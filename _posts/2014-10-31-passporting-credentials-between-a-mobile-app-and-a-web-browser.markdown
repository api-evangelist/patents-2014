---

title: Passporting credentials between a mobile app and a web browser
abstract: Systems and methods for passporting credentials provide a mechanism by which a native app on a client device can invoke a service provider's core web site web addresses (URL) while keeping the existing session active and shared between the two experiences (native app and web flow) so that the end user does not need to re-login at each context switch. The mechanism can include a unique way for the web flow context to communicate conditions and pass control back to the native app context of the shared session. Embodiments may operate by authenticating a device session from a native app executing on a client device producing a device session token; passing the device session token from a native app to an embedded browser to authenticate a user when entering a web flow; and entering the web flow, according to the session token, on an embedded browser driven by the native app so that the user encounters a single shared session (device session and web session) running at least two parallel secure communication interactions with an infrastructure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09438588&OS=09438588&RS=09438588
owner: PAYPAL, INC.
number: 09438588
owner_city: San Jose
owner_country: US
publication_date: 20141031
---
This application is a continuation of and claims the benefit of priority from co pending U.S. patent application Ser. No. 13 162 842 filed Jun. 17 2011 which is hereby incorporated by reference in its entirety.

The present disclosure generally relates to providing secure communications for users of electronic devices running native apps and more particularly for facilitating authenticated communication sessions from a client device using both native applications and web browsers concurrently from the same device.

Consumer mobile devices such as smart phones personal digital assistants note pads web enabled pods and players and other devices such as point of sale POS terminals and ticket kiosks may provide functionality to the user of the device by executing application software known as apps . A native app which may be downloadable or may come pre packaged with hardware or an operating system for example is typically a software application specially designed to execute on a particular device and there are many well known apps for various particular mobile devices. Functionality may also be provided via what may be known as a web app which is not a piece of downloadable software but actually a web site that is optimized for viewing for example on a particular mobile device such as an iPhone . For a software developer creating a true native app e.g. application programming interface API based module may take anywhere from 5 to 20 times more effort to implement and push to production than re using an already built and available web based functionality.

Both native apps and web apps may provide relative advantages however depending on the functionality desired to be obtained. For example use of a native app may be better for situations in which the functionality of the app needs to take advantage of features built into a device such as motion detection voice recording voice recognition camera and global positioning system GPS . A native app may be better if it is desired for the content or service provided by the app to be available offline e.g. in the absence of an Internet connection . On the other hand use of a web app may be better for situations in which a web site and its content already exists and it is desired to provide the same content to many users optimized for viewing by users of many different types of devices.

According to one or more embodiments of the present invention methods and systems for passporting credentials provide a mechanism by which a native app on a device can invoke a service provider s core web site web addresses usually specified using a uniform resource locator or URL while keeping the existing session active and shared between the two experiences native app and web flow so that the end user does not need to re login at each context switch. The mechanism can include a unique way for the web flow context to communicate conditions and pass control back to the native app context of the shared session. Broadly the mechanism provides the user authentication session ID to the embedded browser also referred to as web view control to access a web site s URL for a specific web command view or flow that requires the user s credentials to be used. The unique session identifier may be passed into the browser in place of the user s credentials to allow for the continuation of the authenticated session. The embedded browser is now the primary means of the user s interaction and this keeps the session current e.g. not timed out allowing the user to continue using the web interface. Communication from the browser back to the native app may be accomplished by the native app monitoring URLs requested by the embedded browser with requests for certain URLs indicating particular actions to be taken by the native app. Once the web portion of the flow is done the user returns to the native app and the session keeps going in the native app context of the existing session. Embodiments may allow for better user experience as the users will not need to re authenticate themselves when continuing the same session on the same device.

In one or more embodiments a system includes a client device executing a native app and an embedded web browser in which the native app has a device session token that provides a session authentication with a server for a device session between the native app and the server in which the session authentication is based on credentials for authenticating a user and the native app invokes the embedded web browser providing the embedded web browser with the device session token based on the credentials in which the device session token provides authentication for the session on the embedded web browser.

In another embodiment a computer implemented method includes authenticating a device session from a native app executing on a client device producing a device session token from the authentication passing the device session token to authenticate a user when entering a web flow and entering the web flow on an embedded browser driven by the native app in which a web flow session continues the device session based on the authentication provided from the device session token.

In a further embodiment a computer program product comprises a non transitory computer readable medium having computer readable and executable code for instructing a processor to perform a method that includes authenticating a device session from a native app executing on a client device producing a device session token from the authentication passing the device session token to authenticate a user when entering a web flow and entering the web flow on an embedded browser invoiced by the native app in which a web flow session continues the device session based on the authentication provided from the device session token.

In accordance with embodiments of the present invention passporting credentials is a mechanism by which a native app can invoke core web site uniform resource locators or URLs of an entity while keeping an existing user session active and keeping the session shared between the two user experiences native app and web site so that the user doesn t need to re login at each context switch between native app and web site.

In some situations it may be desirable to try to combine the advantages of both native apps and web apps by accessing a web site from within a native app. When authentication is needed e.g. the user signs in to an account with a user identification ID and then provides a password to access the account security may require that a separate new authenticated session be started for the web app when the user enters the web app from the native app. A best practice for maintaining security is that the newly authenticated session in the web app may entail termination of the authenticated session in the native app to avoid running parallel authenticated sessions. Thus when the user finishes with the web app portion of the functionality the user may be required to log back in from within the native app to continue with the native app portion of the functionality. Such a user experience may be disruptive for the user and may effectively prevent or make impractical the use of many desirable and possible types of functionalities.

The entity providing a web site may be for example a financial service provider FSP such as PayPal Inc. of San Jose Calif. in which a consumer or vendor using the service may have an account with the FSP referred to as an FSP account . The user may log in to the user s account by providing user credentials such as a user name and password that can be used to generate a user authentication session ID. The user authentication session ID may be provided to the embedded web browser also referred to as web view control to access the entity s web site URL for a specific web command view or flow that requires the user s credentials to be used. The unique session identifier is passed into the browser in place of the user s credentials to allow for the continuation of the authenticated session between the native app and the browser. The browser may become the primary means of the user s interaction and the passported session identifier keeps the session current not timed out allowing the user to continue utilizing the web interface. Once the web portion of the flow is done the user may return to native app and the session may keep going in the existing session context that exists in the native app.

Passporting credentials in accordance with one or more embodiments may allow for better user experience as users would not need to re authenticate themselves when continuing the same session from native app to embedded browser or vice versa on the same device. For example an authenticated session may be initiated when the user starts a native app and provides authentication credentials to an application programming interface API for authentication and the authentication API returns a session token back to the native app. That session token is conventionally used as a mechanism by which the native app authenticates itself in all the subsequent API calls. That session token conventionally is refreshed with each and every API call made. If the user then launches a web site the user would need to provide the same set of credentials and a new session would be started for the web browser which is separate from the session started on the app. Conventionally security concerns may then dictate terminating the native app session. One embodiment may instead continue the previously started session and port its credentials into the web browser allowing the user to seamlessly continue with the user interface UI flow without the need for the user to re authenticate. Ideally an average user would not notice a difference in experience when jumping from a native app UI into a web flow and back into the native app s UI.

By providing seamless transitioning to already built and available web based functionality one or more embodiments may allow an entity such as an FSP to provide their apps with a richer feature set for users much earlier than by the more usual means of creating a true native app API based module which may take anywhere from 5 to 20 times more effort to implement and push to production than re using an already built and available web based functionality. For example the way native mobile apps are developed at one FSP may be heavily geared towards replicating functionality that exists on the FSP s main web site and porting it to the new app. As simple as it may seem on the surface the process usually requires new APIs to be created to allow mobile app access to core FSP data and services. This approach generally provides no new functionality albeit there s a new UI and a native app experience and unnecessarily pollutes the API namespace with too many utility functions while accelerating the addition of those new APIs thus further compounding the problem of the API set growing too fast and uncontrollably. The approach enabled by one or more embodiments may re use the existing rich web functionality and allow seamless transitioning between native app s UI and the web site. A critical factor in this experience is that the user does not need to re login when switching between the native app and the web site which provides the desired non disruptive user experience.

Client device may include an application also referred to as app and a web browser which may be embedded in app that execute on client device . Client device may provide an ability to support HTTP protocol in a code which may be for example either running inside the application s memory space or in an external module that is directly controlled driven by the application for example in cases where the operating system OS or device or mobile device platform may support a type of cross application control where the driven app is running outside the driver app s memory space. For example app may drive the execution of embedded browser via execution flow in which a Mobile flow URL and a token are two pieces of data sent into embedded web browser so that embedded browser knows a which URL to request and b what authentication data to provide. Execution flow may be transparent e.g. not noticeable to the user and may include the passing of various foams of information back and forth between app and embedded web browser such as URLs and tokens as shown in .

The entity s or FSP s for example infrastructure may include a server a common gateway interface CGI serving web traffic and a database . Server may enable communication between infrastructure and application also referred to as app executing on client device . The expression native app generally may be used to describe that application may be in some sense optimized to run on client device .

CGI may be a process executing on a computer in the infrastructure belonging to an entity such as an FSP. The CGI may comprise binary code that is proprietary to the entity and may handle web page processing for the entity. CGI may enable communication between infrastructure and embedded web browser executing on client device . For example when a user of client device fills out a form on a web page and sends it in it usually needs to be processed by an application program residing in infrastructure for example . A web server which may be included in infrastructure may pass the form information to the application program that processes the data and which may send back a response message. This method or convention for passing data back and forth between the web server and the infrastructure application may be provided by the CGI .

Both server and CGI may have access to and be in communication with database as shown in and may provide information on and access to for example FSP accounts for users and vendors. Database may be a conventional large volume relational database system RDBMS for example or a low latency in memory data storage system. Database may provide a fast response low latency in memory database access for storing short lived non persistent data e.g. data that may be needed for only a few minutes to a few hours. Database for example may be characterized as a relational database in which a database row may provide access to a relatively large amount of associated information unlocked by a relatively small amount of information specifying a key to the row. A token e.g. a small data object may be used for example to pass information from which such a key ultimately may be determined between various processes such as server CGI application and embedded browser . For example shows a token being passed between application and embedded browser in execution flow . From a security point of view however none of the components of device e.g. app or embedded browser may be able to determine the key from the token passed in execution flow only components of infrastructure e.g. server CGI may have enough knowledge e.g. crypto keys algorithms to be able to determine secure information from the token s internal structure.

At step the device session token may be passed into embedded browser as one of the hypertext transfer protocol or secure hypertext transfer protocol HTTP or HTTPS GET parameters at execution flow and subsequently may be passed to the infrastructure into CGI for processing.

At step the CGI may decode decrypt and unpack the passed in session token and retrieve from database the stored session data that includes among other things an authorization object referred to as a UserAuthToken . Different user auth token objects may have different timestamps permissions and life cycles independently from each other and from the original device session token. Different user auth token objects may be related to one another in that multiple tokens can point to the same user or device session. In this regard a device token and a web token may be two separate objects that may differ quite substantially yet share the same underlying user or device session. For example one token may become invalid expired while the other token and the user session both remain valid.

At step the UserAuthToken authorization object may be used to authenticate the web session on browser effectively achieving a seamless continuation e.g. requiring no user re login at this point of the already active session running from app . For example the user auth token may be re packaged by CGI for example as a web token sharing the same underlying device session as described above. In other words the initial auth token e.g. the passed in session token may be passed into the web flow where it can either be used directly as the web flow s auth token or the initial auth token may be re packaged into a new auth token that is related to the initial auth token and can be used as the web flow s auth token so long as both tokens share the same underlying user or device session. The second token e.g. the web token or web auth token is not required to share the same characteristics as the first token e.g. the device session token or user auth token and may have different and independent access rights lifespan or other properties.

At step while the web flow e.g. the continued session from app to embedded browser is in active use e.g. every new page request is done within the token expiration timeframe the underlying user session e.g. the session on app or device session remains active. For example the native app may keep refreshing its session token the device session token see step by monitoring URL requests from the embedded web browser . Thus if a user is currently logged in with the native app the web flow session on the embedded browser continues the device session without requiring the user to re login so that the user encounters a single shared session running at least two parallel secure communication interactions e.g. communications with the infrastructure .

At step once the flow of execution and user interaction returns back into native app the recently refreshed in app device session token may continue to be valid e.g. the token has not timed out in the web flow itself and may be usable to make API calls into the server . For example to ensure the app s device session token of app is current a call to an appropriate process e.g. a process tracking the account balance of the user associated with the device session token running on server may be made every time the embedded browser requests a new URL. Alternatively a generic keep alive technique may be used in which a call may be made to a low cost or a specialized keep alive API to keep refreshing the token.

In general when a user opens a web app or an interactive web page from a browser and performs some operations such as transferring money between accounts with an FSP the operations may be built in the form of a web flow. In other words when the user moves from one operation to another there is a flow of events and user interaction. The user may sometimes enter sub flows for example when sending money from an FSP account the user may find there is not enough in one account and may decide to add access to another bank account to fund the transaction sending money . So then the user may enter a sub flow for adding access to the bank account and then return to the web flow for sending money and continue with that same web flow. In computer parlance the flows may be kept track of on a stack e.g. a navigation stack and when the user is finished with the adding bank account sub flow that sub flow is popped off the stack so that the user returns to the previous web flow.

Any entity such as an FSP providing a system having an infrastructure may provide a framework for its web flows in which each web page may include multiple pieces e.g. states of a process that can be described using a state transition diagram. A web flow framework may be executed for example by CGI . For example there may be a state or step of a process for a user to enter a send money flow a state that shows whether a user has someone in a contacts list a state that shows this contacts list to select someone to send money to and so forth. Likewise there may also be subsets of states that correspond to various sub flows. There may be many states or steps for each web page some steps may be for displaying or changing the display on the web page for example and some steps may function for example to make a decision what to do next. Such a decision state may be provided by flow entry point step of process shown in .

At step a native app e.g. app may invoke an embedded browser e.g. embedded browser running on client device either inside the app s memory space or directly driven by the app and provide a URL along with one parameter e.g. the encrypted device session token to the web flow entry point e.g. entry point for a web page or service provided by the entity e.g. an FSP of infrastructure . For example the device session token may provide a CGI parameter that includes information for CGI to find the correct flow entry point step for a desired web flow to be continued from a point in the execution of app .

At step labeled flow entry point a CGI e.g. CGI may decide whether the passed in device session token is valid and whether the user s session appears to be still active or whether the session has expired. For example the CGI may decode decrypt and unpack the passed in device session token and retrieve from database the stored session data that includes an authorization object e.g. a user authorization token. Based on all the information the web flow may recognize that the user is logged in and continue on branch . If not the flow may continue on branch as shown.

At branch if the user is logged in e.g. the native app session is still valid and not expired the CGI e.g. CGI may re package the authorization object e.g. the user authorization token to be used as an authorization session token for the web flow. For example the CGI may extract credentials and other information from the authorization object and add other information such as key information for accessing database to find information associated with the current session to re package the authorization object as a web auth token. The re packaged authorization object for example may be passed to web browser via communication shown in . Continuing with branch at step the CGI may continue the execution of the flow for example on browser as if the user is authenticated.

Branch user not logged in may be taken for example if there is a fatal error such as the device session token passed at step was for any reason not good enough e.g. garbled bogus empty or the session had expired to be able to proceed. At branch if the user is not logged in then the web flow may begin to dispatch the user into a web login sub flow at step .

At step the native app e.g. app that s driving the execution of the embedded browser may intercept the URL e.g. the URL passed at execution flow and instead navigate the user into an in app e.g. in application login dialog leaving the embedded browser frame. Once logged in for example via the native app s dialog the user may have an option to re enter the same web flow. Alternatively the driver app may be smarter e.g. include additional logic and first make sure either that the device session token has indeed expired and then direct the user into a login screen or that an unrecoverable fatal error has occurred and then for example display an appropriate message to the user e.g. try again later .

Once the application has invoked the web browser however communication in the direction from web browser to application may be limited. In other words there may be no direct way for the web flow to signal back to a native app that an error has occurred because the web flow may be completely ignorant of whether or not it has even been invoked by an app. For example if there is a fatal error in processing a user s request in a web flow for example the database is down the application would not know that the embedded web page failed to render because the web flow will render something one way or another and the application will not have capability to check the text of what was rendered to make sure the text was correct because for example the text may vary every time . So in one or more embodiments communication back to the driver application e.g. the application that invoked embedded browser may be implemented by the driver application monitoring the URLs being requested by the browser . For example an embedded web flow may signal events such as an error condition or exit from the web flow by requesting pre defined URLs that are being watched by the driver application. Once one or more of these special pre defined URLs is requested the driver application may intercept the pre defined special URL and act accordingly.

There are generally two types of errors system errors that are fatal non recoverable and user errors recoverable . The web flow should handle the user recoverable errors gracefully without help from the driver application.

In case of an unrecoverable fatal error e.g. internal error or system error the web flow should redirect the user into the device login URL to signal the driver application that the web flow has encountered an unrecoverable error and must be closed. The user should be able to navigate into the web flow anew as if it is the first time the flow is being entered as described below at step .

The rationale behind choosing a login URL for this fatal error condition is as follows in case there s a separate bug in the driver app and the URL interception fails there is at least a device specific skinned web page that takes the device s capabilities e.g. screen resolution into account that is being presented to the user. For example on client device a web page optimized for a mobile device may be presented if client device is a mobile device . For another example if client device is a voice terminal for blind people an audio page may be the device specific presentation which might otherwise have been just a regular block of text of the information presented to the user on client device .

Also in case of tampering with the calling parameters or evidence of corrupted data being sent to the server it is a standard security measure to send the user back to the login step if the authenticity cannot be verified.

For exit from the web flow a URL may be registered for an embedded web flow to use that can be recognized by the driver application as an exit signal. Once the web flow requests that URL the driver application may close the embedded web browser moving the user back in the driver application s navigation stack.

Once logged in via the native app s dialog the user may at step have an option to re enter the same web flow for example by passing the same URL and a valid device session token to browser at step .

In implementation of the various embodiments embodiments of the invention may comprise a personal computing device such as a personal computer laptop PDA cellular phone or other personal computing or communication devices. The payment provider system may comprise a network computing device such as a server or a plurality of servers computers or processors combined to define a computer system or network to provide the payment services provided by a payment provider system.

In this regard a computer system may include a bus or other communication mechanism for communicating information which interconnects subsystems and components such as processing component e.g. processor micro controller digital signal processor DSP etc. system memory component e.g. RAM static storage component e.g. ROM disk drive component e.g. magnetic or optical network interface component e.g. modem or Ethernet card display component e.g. CRT or LCD input component e.g. keyboard or keypad and or cursor control component e.g. mouse or trackball . In one embodiment disk drive component may comprise a database having one or more disk drive components.

The computer system may perform specific operations by processor and executing one or more sequences of one or more instructions contained in a system memory component. Such instructions may be read into the system memory component from another computer readable medium such as static storage component or disk drive component. In other embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention.

Logic may be encoded in a computer readable and executable medium which may refer to any medium that participates in providing instructions to the processor for execution. Such a medium may take many forms including but not limited to non volatile media volatile media and transmission media. In one embodiment the computer readable medium is non transitory. In various implementations non volatile media includes optical or magnetic disks such as disk drive component volatile media includes dynamic memory such as system memory component and transmission media includes coaxial cables copper wire and fiber optics including wires that comprise bus. In one example transmission media may take the form of acoustic or light waves such as those generated during radio wave and infrared data communications.

Some common forms of computer readable and executable media include for example floppy disk flexible disk hard disk magnetic tape any other magnetic medium CD ROM any other optical medium punch cards paper tape any other physical medium with patterns of holes RAM ROM E2PROM FLASH EPROM any other memory chip or cartridge carrier wave or any other medium from which a computer is adapted.

In various embodiments execution of instruction sequences for practicing the invention may be performed by a computer system. In various other embodiments a plurality of computer systems coupled by communication link e.g. LAN WLAN PTSN or various other wired or wireless networks may perform instruction sequences to practice the invention in coordination with one another.

Computer system may transmit and receive messages data information and instructions including one or more programs i.e. application code through communication link and communication interface. Received program code may be executed by processor as received and or stored in disk drive component or some other non volatile storage component for execution.

Where applicable various embodiments provided by the present disclosure may be implemented using hardware software or combinations of hardware and software. Also where applicable the various hardware components and or software components set forth herein may be combined into composite components comprising software hardware and or both without departing from the spirit of the present disclosure. Where applicable the various hardware components and or software components set forth herein may be separated into sub components comprising software hardware or both without departing from the scope of the present disclosure. In addition where applicable it is contemplated that software components may be implemented as hardware components and vice versa for example a virtual Secure Element vSE implementation or a logical hardware implementation.

Software in accordance with the present disclosure such as program code and or data may be stored on one or more computer readable and executable mediums. It is also contemplated that software identified herein may be implemented using one or more general purpose or specific purpose computers and or computer systems networked and or otherwise. Where applicable the ordering of various steps described herein may be changed combined into composite steps and or separated into sub steps to provide features described herein.

The foregoing disclosure is not intended to limit the present invention to the precise forms or particular fields of use disclosed. It is contemplated that various alternate embodiments and or modifications to the present invention whether explicitly described or implied herein are possible in light of the disclosure. Having thus described various example embodiments of the disclosure persons of ordinary skill in the art will recognize that changes may be made in form and detail without departing from the scope of the invention. Thus the invention is limited only by the claims.

