---

title: Client-side event logging for heterogeneous client environments
abstract: A testing model for heterogeneous client environments is enabled. A test of a computer system state transition may be specified. The test specification may include elements corresponding to test actions that cause the computer system state transition and elements corresponding to test conditions that are evaluated to generate the test results. A collection of pre-assembled executable components suitable for implementing specified tests at a wide variety of clients may be maintained, and particular test specifications may be mapped to a corresponding and optimal implementation subset of the collection. Test results may be determined based on one or more outputs of the implementation subset of executable components. A vendor and version independent browser driver may include code capable of identifying an operational set of browser capabilities among the superset of considered browser capabilities independent of vendor or version identification by a browser under test.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09336126&OS=09336126&RS=09336126
owner: Amazon Technologies, Inc.
number: 09336126
owner_city: Reno
owner_country: US
publication_date: 20140624
---
This application is related to and incorporates by reference for all purposes the full disclosure of co pending U.S. patent application Ser. No. 14 313 478 filed Jun. 24 2014 entitled TRANSITION TESTING MODEL FOR HETEROGENEOUS CLIENT ENVIRONMENTS U.S. patent application Ser. No. 14 313 624 filed Jun. 24 2014 entitled VENDOR AND VERSION INDEPENDENT BROWSER DRIVER and U.S. patent application Ser. No. 14 313 665 filed Jun. 24 2014 entitled MANAGING BROWSER SECURITY IN A TESTING CONTEXT .

It has become common to develop computing applications for computing environments that include a variety of computing servers and computing clients. In particular it has become common for a particular computing application to be developed to function suitably with a wide variety of computing clients. For example so called Web and or JavaScript applications are commonly expected to operate with a wide variety of hypertext document browser clients including browsers developed by multiple vendors for multiple different hardware platforms and having multiple different versions each with different capabilities. This is a challenging development environment in which application testing can play an even more significant role than usual. Several conventional testing suites have been developed for such environments and particularly for testing Web applications. However each such testing suite has its shortcomings.

For example some conventional test suites are unreliable inconsistent inefficient and or ineffective. Failure to deal properly with ephemeral transitory and or race conditions can result in a high rate of false negative e.g. indications that a test has been failed when a client is actually behaving as desired and or false positive e.g. indications that a test has been passed when the client is actually misbehaving test results. Since this is typically unacceptable test developers may undertake development of compensation code to attempt to correct a conventional test suite s failure to deal properly with certain conditions. However such compensation code tends to be complex and or client specific and can require expert knowledge of each of the plurality of clients. The complexity alone is problematic since it can raise the likelihood that the testing process itself introduces errors sometimes called computer programming bugs .

As another example some conventional test suites delegate test object identification to a client under test. This can open another avenue for unreliability and or inconsistency since the client s object identification mechanism may be flawed and or ambiguous again raising the likelihood of false negative and or false positive test results. In such cases even the stop gap of compensation code may not be available to test developers.

In the following description various embodiments will be described. For purposes of explanation specific configurations and details are set forth in order to provide a thorough understanding of the embodiments. However it will also be apparent to one skilled in the art that the embodiments may be practiced without the specific details. Furthermore well known features may be omitted or simplified in order not to obscure the embodiment being described.

In accordance with at least one embodiment a transition testing model for heterogeneous client environments is enabled. A test of a computer system state transition may be specified with a suitable test description language. The test specification may include multiple element types including elements corresponding to test actions that cause the computer system state transition and elements corresponding to test conditions that are evaluated to generate the test results. A collection of predefined and or pre assembled collectively pre assembled executable components suitable for implementing specified tests at a wide variety of clients may be maintained and or determined and particular test specifications may be mapped to a corresponding implementation subset of the collection for example to an optimal subset. Test results may be determined based on one or more outputs of the implementation subset of executable components and the test results may be provided for presentation to a user.

For example a test developer may specify a test of a Web page state transition with an adapted version of the Java programming language. The Web page may be part of a Web application currently under development. The test specification may include one or more actions to be performed with respect to the Web page and or a hypertext document browser that loads and renders the Web page. For example such actions may correspond to clicking a hyperlink of the Web page making a selection with respect to a field of a form of the Web page or interacting with an interactive element e.g. a button of the Web page. A collection of JavaScript scripts and or snippets may be maintained suitable for implementing tests at a wide variety of browsers and the test specification may be mapped to an optimal e.g. minimized and or non maximal test implementation subset. The test implementation subset may be injected into a sandboxed script execution environment of a target browser and executed to perform the test in accordance with the test specification. Although for clarity examples are described herein with reference to a network document browser any suitable programmatic object and or client collectively client configurable to process information may be substituted for example clients configurable with a suitable programming language and or utilizing suitable programmatic interfaces.

In accordance with at least one embodiment client side event logging for heterogeneous client environments is enabled. The implementation subset of executable components corresponding to a test specification may include a condition evaluation subset of executable components associated with a set of conditions to be evaluated as part of the test and an event capture subset of executable components selected to record an optimal set of events with respect to evaluation of the set of conditions. During a test there may be periods of time when access to the condition evaluation subset of executable components is not available. During these times the event capture subset of executable components may record relevant events so that once access to the condition evaluation subset of executable components becomes available the condition evaluation subset of executable components can be utilized to evaluate the set of conditions based on current state as well as the recorded event history.

For example a hypertext document browser may provide a programmatic interface e.g. an application programming interface or API enabling JavaScript code components to receive a wide variety of events associated with the hypertext document browser and or a Web page loaded and or rendered by the browser. A test specification may be analyzed to determine a relevant subset of such events and the relevant subset may be mapped to a corresponding event capture subset of JavaScript code components. The event capture components may be injected along with the entire set of test implementation components into a sandboxed script execution environment of the browser under test for example with a browser plug in and may record the relevant subset of published events to a data store maintained from the sandboxed script execution environment. The test implementation components may cause a state transition as specified for example with respect to a Web page loaded and or rendered by the browser and then evaluate the specified set of conditions based on a current state of the Web page as well as the relevant subset of published events recorded in the data store.

A browser may be identified by vendor and version. However maintaining a browser driver for each combination of vendor and version can be a substantial task capable of introducing errors into the testing process. Maintaining a single browser driver that varies its behavior based on a particular presentation of vendor and version may not be a substantial improvement. In accordance with at least one embodiment testing with a single vendor and version independent browser driver is enabled. The vendor and version independent browser driver may include executable components capable of identifying an operational set of browser capabilities among the superset of considered browser capabilities when the executable components are injected into an execution environment of a browser under test and used to determine test results. Such browser capabilities may correspond to programmatic interface elements of the browser and the browser driver may select an optimal e.g. minimized and or non maximal subset of the interface elements to instrument to collect data to determine the test results. Where the execution environment is single threaded the browser driver can track objects of the browser under test across thread surrenders including problematic user interface objects such as graphical user interface windows for example by associating unique identifiers with the objects e.g. via naming . Although vendor and version may be sufficient to identify a type of browser at times one or more additional attributes may be required to uniquely identify a type of browser such as a computer operating system OS for which the type of browser is configured. As used herein references to the vendor and or version of a browser may be substituted with a browser type identifier that includes suitable attributes to uniquely distinguish among browser types. Any suitable technique may be utilized to instrument browser interface elements including overriding a browser interface element with a suitable substitute e.g. which hooks or invokes the original interface element subscribing to and or registering for corresponding interface element events and caller side invocation replacement. Such techniques are referred to herein collectively as browser interface element instrumentation and or overriding browser interface elements.

Network document browsers may maintain a variety of security schemes which can interfere with instrumentation and sensing by a browser driver. Nevertheless it is desirable to leave the security schemes enabled since user code interaction with such security schemes can be the subject of testing. In accordance with at least one embodiment management of network document browser security in a testing context is enabled. Browsers under test may associate different network regions with different security contexts. A facility may intercept requests and modify responses to include browser driver code and to appear to originate from a suitable network region e.g. suitable for testing purposes . Browsers under test may be configured to generate secondary security contexts for portions of test code. The potential for the generation of such secondary security contexts may be detected by injected browser driver code and the portions of the test code to be executed in the secondary security context may be modified to enable communication of test data to the primary security context. Browsers under test may resist instrumentation by browser driver code for example by preventing overriding of interface elements activated by test code. In such cases caller side overriding may be implemented by rewriting test code to call corresponding executable components of the browser driver.

Turning now to the figures depicts aspects of an example system architecture in accordance with at least one embodiment. A team of computing application developers may develop a set of network documents in a document development environment . The team may intend that the network documents be presentable and or provide suitable functionality across a target set of network document browsers . The target browser set may include multiple types of network document browser from multiple browser vendors. Each of the types of network document browser may be available in multiple versions. For example network document browser may be available in versions v1 v2 and v3. Network document browser may be available in versions v2 v3 v4 and v5. Network document browser may be available in versions v7.1 and v7.2. Browser vendors may develop network document browsers for multiple computer operating systems. In accordance with at least one embodiment a vendor version operating system 3 tuple may be utilized to identify elements of the target browser set .

To ensure that the network documents behave as expected when rendered by each of the browsers in the target browser set a team of test developers may develop one or more test sets in a test development environment . Although in the document development environment and the test development environment are shown as distinct and independent each embodiment is not so limited. In accordance with at least one embodiment dashed arrow indicates that there is a correspondence between the network documents and the test set s . The correspondence need not be one to one.

The test set s may specify one or more browser state transitions and or network document state transitions with a suitable test description language and may be provided to a transition based test platform . The transition based test platform may manage implementation of tests in accordance with the specified test set s and with respect to at least some of the target browser set . Where a test set references a network document the transition based test platform and or the browsers in the target browser set may access the network document with the document development environment and or an associated document server not shown in .

The network document s may include any suitable document written with any suitable document description language including one or more document markup languages such as a structured generalized markup language e.g. SGML an extensible markup language e.g. XML and a hypertext markup language e.g. HTML and or one or more computer programming languages such as a compiled programming language e.g. C C Java and an interpreted programming language e.g. PHP JavaScript . Although in an embodiment the same holds for the test set s the document description languages utilized for the network document s and the test set s need not be the same. As one non limiting example the network document s may be hypertext documents sometimes called Web pages and the browsers may be hypertext document browsers sometimes called Web browsers while the test set s may be written in an adapted version of the Java programming language. Example test set s are described below in more detail with reference to . The transition based test platform is described below in more detail with reference to . An example browser in accordance with at least one embodiment is described below in more detail with reference to .

Each transition may include one or more test actions one or more pre action test conditions and or one or more post action test conditions . For example transition may include test actions pre action conditions and post action conditions . In accordance with at least one embodiment the pre action conditions are optional. The test actions may specify one or more actions to be performed at a client e.g. a browser of the target browser set of to cause a client state transition. The pre action conditions may specify one or more conditions to be evaluated before performing the actions at the client. The post action conditions may specify one or more conditions to be evaluated once the client state transition has begun during the client state transition and or once the client state transition has finished.

The test actions may include any suitable actions that can be performed and or caused at the client. For example a network document browser may provide a programmatic interface specifying the actions that can be performed and or caused. The pre and post action conditions may include any suitable conditions that can be evaluated with information obtained from the client. For example the programmatic interface of the network document browser may specify a set of events and event parameters available for use in evaluating test conditions. For the example of a hypertext document browser such a programmatic interface may be in accordance with an ECMAScript standard and may include a document object model DOM .

As depicted in the elements of each transition may be arranged in a hierarchy and a nested hierarchy. For example the test may be understood as a root node of the hierarchy having transitions as child nodes. Actions pre action conditions and post action conditions may be child nodes of transition . Actions may be child nodes of actions and so on. Although actions are depicted in as leaf nodes of the hierarchy each embodiment is not so limited. The hierarchies may be of any suitable depth. The structure of the hierarchy may define relationships between the elements of the test including relationships with respect to grouping as a unit and order of execution evaluation. The hierarchy may be defined with any suitable feature or set of features of the test description language. Further relationships that may be defined include that particular groups of actions be performed concurrently or in a specified order that particular groups of conditions be evaluated in a specified order at a specified point in time or with respect to a specified time period e.g. all conditions in the group are expected to evaluate as true at some point during the time period but not necessarily all at the same time .

The test manager may include a test description parser configured to parse provided test set s in accordance with the test description language. The test description parser may create action trees pre action condition trees and post action condition trees in an active test s data store . The trees may correspond to the hierarchies and nest hierarchies specified by the provided test set . A test engine may utilize the browser driver to perform the tests in accordance with the provided test set s . For example the test engine may interact with the browser driver to cause actions to occur at one or more browsers of the target browser set in accordance with the relationships defined by the corresponding action tree s . The test engine may also receive test results and or test result components from the browser driver and evaluate the test results in accordance with the condition relationships as defined by the pre and post action condition trees . In accordance with at least one embodiment explicit condition trees may enable rapid detection of test failure for example in a test that requires multiple conditions to be jointly true in order to pass. Transition networks e.g. including condition trees and or action trees may define path dependent tests which involve fulfilling specified conditions in a particular order and or in response to particular action sequences. A test history module may archive completed tests for later reference by a user of the transition based test platform .

The browser driver may maintain multiple sets of pre assembled executable components utilizable to implement test set s at one or more of the target browser set . For example the browser driver may maintain instrumentation suited to capturing and recording client events that are relevant to a given test set as well as utilities suited to causing test actions and facilitating evaluation of test conditions. Responsive to instructions from the test manager the browser driver may determine an optimal e.g. minimized and or non maximal subset of the pre assembled executable components suitable for implementing a particular test or test set. For example the browser driver may determine a set of evaluation parameters used to evaluate a set of conditions map the set of parameters to a relevant set of client events capable of providing the set of evaluation parameters and further map the relevant set of client events to the pre assembled executable components to determine the optimal subset. Although smaller subsets may be desirable for performance reasons a strictly minimal subset may not be optimal for example due to uncertainties and or ambiguities with respect to browser capabilities including dynamic changes of browser capabilities. The pre assembled executable components may be predefined and or deterministically assembled to achieve the desired functionality. In accordance with at least one embodiment machine learning techniques may be utilized to assemble the executable components for example adapting the assembled executable components with respect to optimality and or adapting the optimal subset of predefined and or pre assembled executable components . Machine learning components may be trained with respect to executable component size number selection and or assembly utilizing observations from tests over a variety of browsers in the browser target set .

The browser driver may interact with one or more of the target browser set utilizing a browser interface including injecting selected executable components into selected browsers to implement tests and keep track of browser state with a browser state tracking module . In accordance with at least one embodiment the browser driver may incorporate a self configuration module capable of probing a browser with a browser capabilities probe to determine the browser s capabilities and of comparing the browser s capabilities with a universal set of browser capabilities documented in a capabilities database . Particular pre assembled executable components may correspond to particular capabilities so that such components become candidates or excluded based on results of the capabilities probe. Alternatively or in addition browser capability probe functionality may be incorporated in and or distributed throughout instrumentation and or utilities such that pre assembled executable components dynamically adapt and or self configure responsive to browser capability detection. The capabilities database may be encoded in the pre assembled executable components for example in the executable instructions of the pre assembled executable components for example including nested sequences of try catch statements.

The browser may also maintain and control a sandboxed script execution environment with a scripting engine capable of executing executable components including statements of a compatible scripting language. The test platform browser plug in may include a script injector module configured to inject selected pre assembled executable components for example as instructed by the browser driver through the browser interface . Alternatively or in addition the selected pre assembled executable components may be injected into the sandboxed script execution environment with any suitable script injection mechanism including with one or more proxy servers and or with one or more programmatic objects under the control of the transition based test platform and acting as a programmatic container of the browser and or the script execution environment . The selected pre assembled executable components may be injected continuously and or at times throughout a test.

Additionally some any or all of the processes may be performed under the control of one or more computer systems configured with executable instructions and may be implemented as code e.g. executable instructions one or more computer programs or one or more applications executing collectively on one or more processors by hardware or combinations thereof. As noted above the code may be stored on a computer readable storage medium for example in the form of a computer program comprising a plurality of instructions executable by one or more processors. The computer readable storage medium may be non transitory.

At a set of executable components to inject may be determined for example by the browser driver responsive to instructions received from the test manager . At the test may be implemented with the determined set of executable components for example by the browser driver . At one or more test results may be determined. For example the test result s may be determined by injected condition evaluation executable components and or by the test engine . At the test result s may be provided for presentation. For example the test manager may provide the test result s to the test development environment for presentation to a test developer.

At conditions may be mapped to executable components. For example the browser driver may map conditions in the condition tree s to a subset of the executable components . As part of one or more client events to intercept may be determined at and one or more executable components corresponding to the client events may be selected at . Similarly actions may be mapped to executable components at . At a target client may be instantiated. For example the browser driver may instantiated one of the target browser set . At executable components may be injected into an execution environment of the client for example by the browser driver . Alternatively or in addition the executable components may include multiple portions and or sub components which are dynamically selected and or mapped collectively dynamically mapped by the executable components during execution. For example the dynamic mapping may be based at least in part on the condition tree s the action tree s the client events of and or dynamic probing of browser capabilities.

At one or more test actions may be triggered. For example injected utility executable components may interact with a programmatic interface of the client to trigger the test actions. At one or more actions with respect to a network document may be processed. For example the action s of may be directed to the network document and having triggered the action s the network document browser may process the network document to cause and or perform the actions. At one or more asynchronous browser events may be published for example by the network document browser as it is processing the network document responsive to the triggered actions. At an instrumented subset of network document browser events may be captured. For example events associated with the event capture executable components injected at may be captured by the injected event capture executable components. Additional events may occur but may not be captured. However if the injected executable component set is optimal with respect to the set of conditions to be evaluated this may enhance efficiency. At the captured events may be recorded in the established data store for example by the injected event capture executable components. Dashed line indicates that these blocks may occur during a time period when condition evaluation executable components are inaccessible e.g. between the observation times Obs Obs Obsand Obsof without loss of relevant event data.

At the optimal set of programmatic interface elements may be overridden with corresponding programmatic interface elements of the set of pre assembled executable components. At a result of the test may be determined with at least one overridden programmatic interface element. In accordance with at least one embodiment determining the result of the test may include generating browser events to emulate user interaction at for example in a case where user interaction with a graphical user interface maintained by the network document browser would trigger a browser event chain but artificial triggering of a browser event e.g. by the set of pre assembled executable components does not trigger each of the browser events in the browser event chain resulting in broken browser event chains without intervention. In accordance with at least one embodiment the set of pre assembled executable components executing in the execution environment of the network document browser may emulate a user input device for example at least in part by maintaining a corresponding virtual user input device and generating one or more browser events of browser event chains based at least in part on a state of the virtual user input device. For example the virtual user input device may be a virtual mouse and emulating the virtual mouse may include determining movement paths of the virtual mouse corresponding to test actions and generating browser events corresponding to the determined movement paths.

Control of a thread of execution in the execution environment of the network document browser may be surrendered at least in part to enable the network document browser to create the user interface object at . For example the execution environment may be single threaded. Upon regaining control of the thread of execution for example at information may be obtained from the user interface object. For example at a programmatic reference to the user interface object may be obtained based at least in part on the unique identifier. Such programmatic references to user interface objects may be maintained in a collection for example by the browser state tracking module of the browser driver . At such a collection may be updated. At a result of the test may be determined based at least in part on information obtained from the user interface object utilizing the unique identifier.

At the portion of the test code may be modified to include one or more of the set of pre assembled executable components configured at least to communicate information from the second security context to the first security context when the one or more of the set of pre assembled executable components are executed in the second security context along with the at least a portion of the test code. For example at the set of pre assembled executable components may replace interface elements utilized by the test code. At information may be collected with the replaced interface elements as they are activated by the test code. At the collected information may be communicated to the first security context. As indicated by dashed line and may execute in the second security context. At a test result may be determined based at least in part on the information communicated from the second security context.

At activations of the interface elements in the test code may be detected with the set of pre assembled executable components executing in the security context of the execution environment. At the activations of the interface elements in the test code may be rewritten with activations of corresponding executable components of the set of pre assembled executable components. At information corresponding to rewritten activations may be collected when the test code is executed in the security context of the execution environment. At corresponding interface elements may be activated by the set of pre assembled executable components. At a test result may be determined based at least in part on the collected information.

The illustrative environment includes at least one application server and a data store . It should be understood that there can be several application servers layers or other elements processes or components which may be chained or otherwise configured which can interact to perform tasks such as obtaining data from an appropriate data store. As used herein the term data store refers to any device or combination of devices capable of storing accessing and retrieving data which may include any combination and number of data servers databases data storage devices and data storage media in any standard distributed or clustered environment. The application server can include any appropriate hardware and software for integrating with the data store as needed to execute aspects of one or more applications for the client device handling a majority of the data access and business logic for an application. The application server provides access control services in cooperation with the data store and is able to generate content such as text graphics audio and or video to be transferred to the user which may be served to the user by the Web server in the form of HyperText Markup Language HTML Extensible Markup Language XML or another appropriate structured language in this example. The handling of all requests and responses as well as the delivery of content between the client device and the application server can be handled by the Web server. It should be understood that the Web and application servers are not required and are merely example components as structured code discussed herein can be executed on any appropriate device or host machine as discussed elsewhere herein.

The data store can include several separate data tables databases or other data storage mechanisms and media for storing data relating to a particular aspect. For example the data store illustrated includes mechanisms for storing production data and user information which can be used to serve content for the production side. The data store also is shown to include a mechanism for storing log data which can be used for reporting analysis or other such purposes. It should be understood that there can be many other aspects that may need to be stored in the data store such as for page image information and to access right information which can be stored in any of the above listed mechanisms as appropriate or in additional mechanisms in the data store . The data store is operable through logic associated therewith to receive instructions from the application server and obtain update or otherwise process data in response thereto. In one example a user might submit a search request for a certain type of item. In this case the data store might access the user information to verify the identity of the user and can access the catalog detail information to obtain information about items of that type. The information then can be returned to the user such as in a results listing on a Web page that the user is able to view via a browser on the user device . Information for a particular item of interest can be viewed in a dedicated page or window of the browser.

Each server typically will include an operating system that provides executable program instructions for the general administration and operation of that server and typically will include a computer readable storage medium e.g. a hard disk random access memory read only memory etc. storing instructions that when executed by a processor of the server allow the server to perform its intended functions. Suitable implementations for the operating system and general functionality of the servers are known or commercially available and are readily implemented by persons having ordinary skill in the art particularly in light of the disclosure herein.

The environment in one embodiment is a distributed computing environment utilizing several computer systems and components that are interconnected via communication links using one or more computer networks or direct connections. However it will be appreciated by those of ordinary skill in the art that such a system could operate equally well in a system having fewer or a greater number of components than are illustrated in . Thus the depiction of the system in should be taken as being illustrative in nature and not limiting to the scope of the disclosure.

The various embodiments further can be implemented in a wide variety of operating environments which in some cases can include one or more user computers computing devices or processing devices which can be used to operate any of a number of applications. User or client devices can include any of a number of general purpose personal computers such as desktop or laptop computers running a standard operating system as well as cellular wireless and handheld devices running mobile software and capable of supporting a number of networking and messaging protocols. Such a system also can include a number of workstations running any of a variety of commercially available operating systems and other known applications for purposes such as development and database management. These devices also can include other electronic devices such as dummy terminals thin clients gaming systems and other devices capable of communicating via a network.

Most embodiments utilize at least one network that would be familiar to those skilled in the art for supporting communications using any of a variety of commercially available protocols such as Transmission Control Protocol Internet Protocol TCP IP Open System Interconnection OSI File Transfer Protocol FTP Universal Plug and Play UpnP Network File System NFS Common Internet File System CIFS and AppleTalk. The network can be for example a local area network a wide area network a virtual private network the Internet an intranet an extranet a public switched telephone network an infrared network a wireless network and any combination thereof.

In embodiments utilizing a Web server the Web server can run any of a variety of server or mid tier applications including Hypertext Transfer Protocol HTTP servers FTP servers Common Gateway Interface CGI servers data servers Java servers and business application servers. The server s also may be capable of executing programs or scripts in response requests from user devices such as by executing one or more Web applications that may be implemented as one or more scripts or programs written in any programming language such as Java C C or C or any scripting language such as Perl Python or TCL as well as combinations thereof. The server s may also include database servers including without limitation those commercially available from Oracle Microsoft Sybase and IBM .

The environment can include a variety of data stores and other memory and storage media as discussed above. These can reside in a variety of locations such as on a storage medium local to and or resident in one or more of the computers or remote from any or all of the computers across the network. In a particular set of embodiments the information may reside in a storage area network SAN familiar to those skilled in the art. Similarly any necessary files for performing the functions attributed to the computers servers or other network devices may be stored locally and or remotely as appropriate. Where a system includes computerized devices each such device can include hardware elements that may be electrically coupled via a bus the elements including for example at least one central processing unit CPU at least one input device e.g. a mouse keyboard controller touch screen or keypad and at least one output device e.g. a display device printer or speaker . Such a system may also include one or more storage devices such as disk drives optical storage devices and solid state storage devices such as random access memory RAM or read only memory ROM as well as removable media devices memory cards flash cards etc.

Such devices also can include a computer readable storage media reader a communications device e.g. a modem a network card wireless or wired an infrared communication device etc. and working memory as described above. The computer readable storage media reader can be connected with or configured to receive a computer readable storage medium representing remote local fixed and or removable storage devices as well as storage media for temporarily and or more permanently containing storing transmitting and retrieving computer readable information. The system and various devices also typically will include a number of software applications modules services or other elements located within at least one working memory device including an operating system and application programs such as a client application or Web browser. It should be appreciated that alternate embodiments may have numerous variations from that described above. For example customized hardware might also be used and or particular elements might be implemented in hardware software including portable software such as applets or both. Further connection to other computing devices such as network input output devices may be employed.

Storage media and computer readable media for containing code or portions of code can include any appropriate media known or used in the art including storage media and communication media such as but not limited to volatile and non volatile removable and non removable media implemented in any method or technology for storage and or transmission of information such as computer readable instructions data structures program modules or other data including RAM ROM Electrically Erasable Programmable Read Only Memory EEPROM flash memory or other memory technology Compact Disc Read Only Memory CD ROM digital versatile disk DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by the a system device. Based on the disclosure and teachings provided herein a person of ordinary skill in the art will appreciate other ways and or methods to implement the various embodiments.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the disclosure as set forth in the claims.

Other variations are within the spirit of the present disclosure. Thus while the disclosed techniques are susceptible to various modifications and alternative constructions certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood however that there is no intention to limit the disclosure to the specific form or forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of the disclosure as defined in the appended claims.

The use of the terms a and an and the and similar referents in the context of describing the disclosed embodiments especially in the context of the following claims are to be construed to cover both the singular and the plural unless otherwise indicated herein or clearly contradicted by context. The terms comprising having including and containing are to be construed as open ended terms i.e. meaning including but not limited to unless otherwise noted. The term connected is to be construed as partly or wholly contained within attached to or joined together even if there is something intervening. Recitation of ranges of values herein are merely intended to serve as a shorthand method of referring individually to each separate value falling within the range unless otherwise indicated herein and each separate value is incorporated into the specification as if it were individually recited herein. All methods described herein can be performed in any suitable order unless otherwise indicated herein or otherwise clearly contradicted by context. The use of any and all examples or exemplary language e.g. such as provided herein is intended merely to better illuminate embodiments of the disclosure and does not pose a limitation on the scope of the disclosure unless otherwise claimed. No language in the specification should be construed as indicating any non claimed element as essential to the practice of the disclosure.

Disjunctive language such as the phrase at least one of X Y or Z unless specifically stated otherwise is intended to be understood within the context as used in general to present that an item term etc. may be either X Y or Z or any combination thereof e.g. X Y and or Z . Thus such disjunctive language is not generally intended to and should not imply that certain embodiments require at least one of X at least one of Y or at least one of Z to each be present.

Preferred embodiments of this disclosure are described herein including the best mode known to the inventors for carrying out the disclosure. Variations of those preferred embodiments may become apparent to those of ordinary skill in the art upon reading the foregoing description. The inventors expect skilled artisans to employ such variations as appropriate and the inventors intend for the disclosure to be practiced otherwise than as specifically described herein. Accordingly this disclosure includes all modifications and equivalents of the subject matter recited in the claims appended hereto as permitted by applicable law. Moreover any combination of the above described elements in all possible variations thereof is encompassed by the disclosure unless otherwise indicated herein or otherwise clearly contradicted by context.

All references including publications patent applications and patents cited herein are hereby incorporated by reference to the same extent as if each reference were individually and specifically indicated to be incorporated by reference and were set forth in its entirety herein.

