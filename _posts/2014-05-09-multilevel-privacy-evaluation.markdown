---

title: Multi-level privacy evaluation
abstract: An multi-level privacy evaluation technology is described for increasing the performance of applications or services that experience high volumes of queries for data with privacy attributes. The multi-level privacy evaluation technology evaluates data using a subset of privacy policy rules and privacy information determined for the data at a backend server and thereby reduces the volume of data that need to be filtered at a frontend server. The multi-level privacy evaluation technology first applies an initial privacy check on a large data set at the backend to authoritatively filter out any data that a viewing user is not permitted to view or access and return as results a smaller data set that the viewing user may be permitted to view or access. A full privacy check is then performed at the frontend on the smaller data set, resulting in reduction in the overall cost of performing privacy checks and reducing latency in displaying data to the viewing user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09460308&OS=09460308&RS=09460308
owner: Facebook, Inc.
number: 09460308
owner_city: Menlo Park
owner_country: US
publication_date: 20140509
---
Various websites and applications enable users to control public or private settings for content. For example a social networking application enables users to set a privacy setting for almost every entity relating to the application including e.g. photos videos statuses timeline wall posts etc. Consider an example where a user Joe of a social networking application attempts to view photos of another user Jane. Jane s photos can have different privacy settings to indicate whether all users can view the photos or only some users e.g. public friends custom and Jane can change those settings at any time. An authorization engine typically aggregates all of Jane s photos and or other data relating to the photos from the backend servers where the photos are persistently stored to the web frontend servers where a set of privacy policies and rules are defined and or evaluated. The authorization engine then evaluates each of the photos based on the set of privacy policies and rules. So if Jane has 1000 photos all of the photos would be fetched from the backend servers and evaluated at the web frontend servers. However if for instance only 10 of the photos turn out to be viewable by the user Joe 90 of the resources may have been wasted in retrieving the photos that could not be viewed by the user Joe.

One way to reduce the resources wasted in retrieving raw data that is eventually discarded is by implementing the authorization engine in the backend servers. However the privacy policies and rules used by the authorization engine can be fairly complex and are typically defined in a computer programming language that is different from the computer programming language used at the backend servers. For example the privacy policies and rules may be coded in PHP while the backend servers may use C . Consequently the backend authorization engine cannot directly leverage the PHP based privacy policies and rules and would require re implementation of the privacy policies and rules in a computer programming language suitable for the backend system. This means that any change to the privacy policies and rules would need to be made twice first at the frontend and then at the backend which results in a waste of resources. Instead of implementing the privacy policies and rules at two locations one solution is to have the backend authorization engine check with the frontend privacy policies and rules for making privacy checks. However such an implementation is also not desirable since the backend calls to the frontend for multiple users can quickly become inefficient and consume additional resources.

A multi level privacy evaluation technology is disclosed for reducing the overall cost of performing complex privacy checks reducing latency in displaying data to viewers and improving the performance of applications or services that experience high volumes of queries per second QPS . In various embodiments the multi level privacy evaluation technology first applies an initial privacy check on a large set of data at one or more database servers backend servers by evaluating the large set of data using a small set of privacy policies and rules. The application of the initial privacy check on the large set of data at the backend server filters out any data that a viewer is definitely not permitted to view or access based on the small set of privacy policies and rules and returns as result a reduced set of data for further evaluation by one or more web servers frontend servers . The multi level privacy evaluation technology then applies a full or accurate privacy check on the reduced set of data by evaluating the reduced set of data using a larger or more complex set of privacy policies and rules. The application of the full privacy check on the reduced set of data at the frontend server provides a decision regarding which data from the reduced set of data are viewable or accessible by the viewer. The data that is authoritatively determined to be viewable or accessible by the viewer is then returned to the viewer. Thus the backend server performs an initial coarse grained evaluation using a subset of rules to remove much of the data that is not relevant before the data is transmitted to the frontend server to perform a fine grained check with a full set of rules.

In some embodiments the multi level privacy evaluation technology periodically validates effectiveness of the initial privacy check by returning a portion of the filtered data as validation data to the frontend server. The frontend server performs a full privacy check on the validation data to identify any data items that were incorrectly filtered out at the backend server and logs such incorrectly filtered data items so that the rules for evaluation at the backend server can be improved.

The multi level privacy evaluation technology is applicable to many high QPS applications or services where each query can involve complex privacy checks on data items. One example of a high QPS service is a newsfeed type service in social networking applications. The newsfeed service identifies recent stories by various users e.g. friends for display on a viewer s landing page and performs a privacy check on each identified story to determine if the story should be included or excluded for viewing by the viewer. Examples of stories include actions such as comments likes etc. and objects such as status photo share checkin etc. When the backend server providing the newsfeed service receives a request the backend server queries various computing nodes where the stories related to the viewer and the viewer s friends are stored. Instead of ranking all the aggregated stories and returning them to the frontend server the multi level privacy evaluation technology applies the initial privacy check on the aggregated stories to filter more of the stories that the viewer is not allowed to view at the backend server. As a result fewer frontend invalidations are needed e.g. for objects such as statuses and shares. This also reduces the CPU resources for ranking the aggregated items both at the frontend server and the backend server.

Another example of a high QPS service is a search engine that indexes data items having different privacy values. Such a search engine can be implemented by applications e.g. social networking applications to accept search queries for data items such as photos posts etc. from users and return as responses data items that are relevant to the search queries and are consistent with the privacy information associated with the data items. When a backend server implementing the search engine receives a search query the multi level privacy evaluation technology automatically filters out stories that do not pass the initial privacy check at the backend server via a query rewriting method. By applying the initial privacy check at the backend server the multi level privacy evaluation technology filters out stories that would not pass the initial privacy check which reduces privacy invalid stories from being returned from the backend server. As a result the frontend invalidation rate is improved which in turn decreases search latency as privacy invalidation is typically a slow process.

Yet another example of a high QPS service is a timeline type service that displays a user s profile comprising a collection of stories e.g. posts shares photos etc. in a chronological order. Any request from a viewer to view data items associated with a user s timeline involves a privacy check of each data item to ensure that the viewer can see only those items that pass the privacy check. For example if a user s photo has a privacy value friends the privacy check can determine whether the viewer is 1 a friend of the user 2 tagged on the photo or 3 friend of the tagged user. If any of these conditions is true the photo passes the privacy check and can be displayed to the viewer. Otherwise the photo may be prevented from being displayed.

In various embodiments the multi level privacy evaluation technology improves the performance of these services or applications by bucketing stories based on their approximate audience. In other words the multi level privacy evaluation technology stores data items suitable for viewers who qualify as public separately from data items suitable for viewers who qualify as friends or less. Consequently when a public viewer requests to see data items associated with a user instead of returning all data items associated with the user to the frontend many of which may be suitable for viewers who qualify as friends the multi level privacy evaluation technology serves data items from the public bucket to the public viewer. This reduces latency for the public viewer as data items that are unsuitable for the public viewer are pre filtered out from the response. Moreover the technology also improves the ranking and CPU efficiency since public data items do not have to compete with friends or less data items which can easily result in the public data items getting outranked and thus never reaching the public viewer.

Various embodiments and implementations of the multi level privacy evaluation technology will now be described. The following description provides specific details for a thorough understanding and an enabling description of these implementations. One skilled in the art will understand however that the disclosed system and methods may be practiced without many of these details. Additionally some well known structures or functions may not be shown or described in detail so as to avoid unnecessarily obscuring the relevant description of the various implementations. The terminology used in the description presented below is intended to be interpreted in its broadest reasonable manner even though it is being used in conjunction with a detailed description of certain specific implementations of the disclosed system and methods.

Consider an example of a viewer submitting a search query for photos relating to the Grand Canyon. The initial data set that includes a set of data items A B C E . . . P Q R can include all the photos relating to the Grand Canyon. Each of these data items can have a privacy setting associated with it providing an indication of who the data item was shared up to by the data item owner. For example data item H may be public indicating that the data item was shared with everyone data item I may be friends indicating that the data item was shared by the data item owner with his or her friends data item J may be only me indicating that the data item was not shared with anyone and data item O can be friends except Joe and Jane indicating that the data item was shared with all the data item owner s friends except Joe and Jane. Instead of storing the actual privacy information which can exceed 100 or 200 bytes per data item the backend server stores a simplified or condensed form of the privacy information privacy information or privacy payload or privacy value that can be much smaller in size e.g. 30 40 bytes but includes enough information to allow the data items to be evaluated using a core set of rules . In the above example the privacy information for each of the data items H I and J remain public friends and only me respectively while the privacy information for data item O can be approximated or condensed from friends except Joe and Jane to friends. 

The multi level privacy evaluation technology performs an initial privacy check by applying a core set of privacy rules on the initial data set to obtain an intermediate data set at the backend server . The intermediate data set includes a set of data items H I J K . . . O that passed the initial privacy check but may or may not be viewable by the viewer. The intermediate data set excludes data items that are positively not viewable by the viewer as determined based on evaluation of the core set of privacy rules. Following are examples of the core set of privacy rules that can be evaluated to obtain the intermediate data set .

Rule 2 A data item is viewable by the viewer if the data item has a privacy value of only me and the viewer is also the data item owner.

Rule 3 A data item is viewable by the viewer if the data item has a privacy value of only me and the viewer is tagged on the data item.

Rule 4 A data item is viewable by the viewer if the data item has a privacy value of friends and the viewer and the data item owner are friends.

Rule 5 A data item is viewable by the viewer if the data item has a privacy value of friends and any one of the viewer s friend is tagged on the data item.

More or less rules may be used in evaluating the initial privacy at the backend. For example one rule can check if a data item is a group post and allow a viewer to view the data item if the viewer is a member of the group post and the group post is private.

The intermediate data set is returned to the frontend server for a full privacy check. The frontend server based on a set of privacy rules filters out data items that should not be viewable by the viewer. The remaining data items in the final data set that passed the full privacy check are returned to the viewer. At the client device the viewer can view the data items that have passed both the initial privacy and full privacy checks.

It should be noted that the term server as used throughout this application refers generally to a computer other device program or combination thereof that processes and responds to the requests e.g. from remote users using client devices across a network from other servers . Servers serve their information to requesting clients. The term client as used herein refers generally to a computer program other device user and or combination thereof that is capable of processing and making requests and obtaining and processing any responses from servers across a network. Client computing devices A D and server computing devices may each act as a server or client to other server client devices. Network can be a local area network LAN or a wide area network WAN but may also be other wired or wireless networks. The client computing devices A D can be connected to network through a network interface such as by a wired or wireless network.

The data flow diagram of illustrates an example writing and updating of a privacy value of a data item in some embodiments of the multi level privacy evaluation technology. In the data flow diagram A a user A using a client device A sends a request that creates a new data item or updates an existing data item. Examples of data items can include but are not limited to objects such as comments statuses shares photos checkins and or the like. A frontend server receives the request and pushes the new updated data item to a backend server . Whenever a data item is created or updated the backend server calculates the privacy value for the new updated data item. The new updated data item and the calculated privacy value for the data item are then stored by the backend server e.g. on a leaf server . Alternately in some embodiments the privacy value for the new updated data item can be calculated at the frontend server and pushed to the backend server along with the new updated data item for storage.

The data flow diagram of illustrates identification of data items for a viewer B in some embodiments of the multi level privacy evaluation technology. Such data items can be identified for example for display on a landing page or a news or data feed associated with a social networking application. The identification of the data items involves performing an initial privacy check at the backend server which ensures that more data items are filtered in the backend thereby enabling the frontend server to perform the more computationally expensive full privacy check on a reduced set of data items.

In the data flow diagram B a client device B sends a request for data items for the viewer B. The frontend server receives the request from the client device and sends a query request for data items for the viewer B to the backend server . The query request can include for example an identifier ID of the viewer B. The backend server receives the query request and in response aggregates data items for the viewer B and the privacy values of the data items. The backend server can query one or more nodes e.g. database where the data items may be stored to aggregate the data items. The backend server then evaluates the privacy of each of the aggregated data items via a process . The backend server can utilize a data item s privacy value the data item s owner ID the viewer ID and the viewer s friends IDs to determine whether the data item should be filtered out. The data items that pass the initial privacy check i.e. the data items that are not filtered out are returned by the backend server to the frontend server . The frontend server then applies a full privacy check on the returned data items via process to filter out any data items that the viewer B cannot view. The data items that are not filtered out i.e. the data items that pass the full privacy check are ranked via a process and the ranked data items are returned as results to the client device B. Each of the processes in the data flow diagram B are described in detail in relation to .

In the data flow diagram a backend server can implement a search engine that queries a search index . The search index can be populated with search migrators or crawlers that regularly crawl and generate the search index. Whenever a data item is created e.g. a photo is uploaded or updated e.g. another user is tagged to the photo the corresponding migrators are called to update the search index . Updating the search index can include for example computing a privacy value for the data item and storing that value in the search index along with the data item. As described above the privacy value can be calculated using one or more functions in the privacy library. In this embodiment input parameters such as privacy information and tagging information can be passed into the privacy library to obtain the privacy value.

In the data flow diagram a search query is received from a client device of a viewer at the frontend server . The frontend server forwards the search query to the backend server. When the search query arrives at the backend the backend server applies an initial privacy check on data items stored in the search index via a process . The backend server rewrites the search query to include as search parameters privacy information and tagging information to effectively filter out any data items based on the privacy information and tagging information. The data items that pass the initial privacy check i.e. the data items matching the rewritten query are returned from the backend server to the frontend server . The frontend server then applies a full privacy check on the returned data items via a process and ranks data items that pass the full privacy check via a process . The ranked data items are then transmitted to the client device as a response to the search query . Each of the processes in the data flow diagram are described in detail in relation to .

Referring to the data flow diagram A illustrates writing and updating of data items in some embodiments of the multi level privacy evaluation technology. In the data flow diagram A a client device A associated with a user A sends a request that creates a data item or updates a data item to a frontend server . The frontend server receives the request and forwards the new updated data item to a backend server for storage. The backend server stores the new updated data item in the database . The backend server e.g. using a wormhole client listens on data items e.g. statuses posts shares checkins videos photos etc. and whenever any new data item or data item update is detected calculates a privacy value for the data item using the privacy library via a process . In this embodiment of the multi level privacy evaluation technology the backend server uses the privacy value of the data item to place the data item in an appropriate viewer bucket. For example data items that have friends as the privacy value can be assigned to the friends or less viewer bucket while data items that have public as the privacy value can be assigned to the approximately public viewer bucket. The backend server then ranks the data items within each viewer bucket and stores the data items along with the ranking information in a memcache under different sets of memcache keys. Each of the processes in the data flow diagram B are described in detail in relation to .

In the data flow diagram B a viewer B submits a request to view data items associated with a user using a client device B. The submitted request is received at a frontend server which then forwards the request to a backend server . The request can include for example the viewer ID and the user ID. If the viewer is a public viewer the backend server retrieves the data items or values stored with approximately public memcache keys from the memcache key value store . If the viewer is a friend the backend server retrieves the data items stored with both approximately public and friends or less memcache keys. The retrieved data items are then sent to the frontend server which then applies the full privacy check on the retrieved data items via a process . The data items that pass the full privacy check are ranked via a process and returned as ranked data items to the client device B. Each of the processes in the data flow diagram B are described in detail in relation to .

The request processor can manage transfer of requests and responses. For example the request processor can receive a request from a client device and redirect the request to the backend server for processing. The full privacy filter includes filter logic for performing a full privacy check of data items that have already passed through an initial privacy filter at the backend server. Performing a full privacy check of data items includes evaluating the data items using a set of privacy policies and rules and determining based on the evaluation whether any of the data items should be provided to a viewer. The full privacy filter automatically filters out data items that do not pass the full privacy check and returns any remaining data items that do to the viewer. The ranking engine can rank the data items that pass the full privacy check and provide the data items with their ranking information to the viewer for display on a client device. The ranking may be performed in embodiments where data is expected to be displayed in an ordered fashion e.g. chronologically according to relevance or the like .

In some embodiments the verification module can detect privacy inconsistencies between the frontend and the backend log those inconsistencies and take a corrective action when triggered. For example the verification module can detect and log all data items that were incorrectly filtered at the backend and can keep track of such data items using a counter. When the number of incorrectly filtered objects reaches a threshold an automatic alert can be triggered. In some embodiments the verification module can trigger the backend server to calculate the privacy values for the incorrectly filtered data items and update the corresponding values on the database if the calculated values do not match the values stored with the data items at the backend. In alternate embodiments the verification module can calculate the verification values for the incorrectly filtered data items and push the new values to the backend server if the new values and the current values do not match.

The request processor can coordinate receiving and sending of requests and responses. For example the request processor can receive requests from the frontend server parse and or route requests to modules aggregate responses from modules and send the responses back to the frontend server. The privacy value write update module detect creation of new data items and updates to data items that change the data items privacy. The module can then trigger the privacy value calculator to calculate or update the privacy values for the new or updated data items. The privacy value write update module and or the privacy value calculator can be implemented at the frontend server in some embodiments.

The privacy value calculator calculates the privacy value of data items using the privacy libraries. In some embodiments the privacy value calculator can take as input an identifier of the data items e.g. status ID photo ID video ID album ID and return a privacy value of only me friends or public which can be encoded using two bits. In other embodiments the privacy value calculator can take as input privacy row and tagging information and output a privacy value of only me friends or public. The privacy value write update module can store the privacy values determined by the privacy value calculator in one or more database tables along with the corresponding data items. For example an privacy value associated with a status object can be stored along with the status object in a status object table as illustrated in Table 1 below.

The initial privacy filter includes filter logic for performing an initial privacy check of data items. Performing an initial privacy check of data items includes evaluating the data items and the privacy values for the data items using a core set of privacy rules and determining based on the evaluation whether any of the data items should be provided to a viewer. The initial privacy filter automatically filters out data items that do not pass the initial privacy check and returns any remaining data items that do to the frontend server for full privacy check.

In some embodiments the initial privacy filter can be implemented as an object filter that examines a data item and determines if the data item should be filtered. The object filter can evaluate a data item s privacy value owner ID viewer ID and or viewer s friends IDs using a small set of privacy rules to determine whether the data item passes or fails the initial privacy check. Any data item that fails the initial privacy check is filtered out. An example implementation of the logic of the object filter can be substantially similar to 

An example of a method for evaluating a data item to determine whether the data item should be filtered using the object filter is described in detail in relation to .

In other embodiments the initial privacy filter can be implemented as a query rewriting module that rewrites search queries to include privacy value and tagging constraints to filter out data item that would not pass initial privacy checks. For example a query relating to posts about Seattle can be re written into the following example form by the query rewriting module 

In the above example query the user is related to the object if the user is the object s owner or the user is tagged in the object. The privacy value and the taggings used in rewriting the query can be stored in a database e.g. the search index . In some embodiments due to performance constraints the query can be limited to a number of friends e.g. top friends of the user. An example method of applying an initial privacy check using the query rewriting module is described in detail in relation to .

In yet other embodiments the initial privacy filter can be implemented as an object categorizer that buckets data items based on their privacy values to serve different traffic types. For example a request from a public stranger to view data items related to a user can be served by data items related to the user stored in the approximately public bucket while a request from a friend to view data items related to the user can be served by data items related to the user stored in the friends or less bucket as well as the approximately public bucket. Example methods of using the object categorizer to bucket data items based on their privacy values and serve data items from the buckets for different traffic types are described in detail in relation to .

The ranking engine like the ranking engine can rank data items based on various criteria. The verification module along with the verification module comprises the verification pipeline for the multi level privacy evaluation technology to detect any incorrectly filtered data items and take a corrective action. In some embodiments the verification module can be periodically triggered to select a portion of the data items filtered by the initial privacy filter and mark the filtered data items using a flag to indicate that the filtered data items would have been filtered at the backend server and is being sent to be validated. In some embodiments the verification module can be triggered by the corresponding verification module of the frontend server to check if the privacy values of the incorrectly filtered data items have changed and if so to update the database to store the updated privacy values with the data items.

At block the backend server receives a request for data items for a viewer. The request can be forwarded to the backend server from a frontend server and can include for example a viewer ID and or viewer s friends IDs. At block the backend server aggregates a set of data items for the viewer e.g. data items related to the viewer ID data items related to the viewer s friends IDs and privacy values associated with each data item in the set. These data items can include user actions e.g. comments likes etc. and objects e.g. statuses shares photos videos checkins etc. . The backend server then evaluates privacy of each data item in the set of data items to determine whether to filter the data item or to include the data item into a result set. This evaluation can be implemented in a loop which begins at block .

At decision block the backend server determines the audience for a data item by checking the privacy value associated with the data item. If the privacy value for the data item is only me i.e. only the owner of the data item can see the data item at decision block the backend server determines if the viewer and the data item owner are the same. If the viewer and the data item owner are the same then the backend server keeps the data item at block otherwise the data item is filtered out at block . If the privacy value for the data item is friends the backend server determines if the viewer and the data item owner are friends at decision block . If so the backend server keeps the data item at block . Conversely if the data item owner and the viewer are not friends the backend server filters out the data item at block . The backend server then evaluates the next data item in the set at block . After evaluating the privacy of all the data items in the set of data items the backend server ranks the remaining data items i.e. the data items that passed the initial privacy check using a ranking algorithm at block . The backend server then returns the data items that passed the initial privacy check along with the ranking information to the frontend server at block .

In some embodiments due to changes in the rules changes in the relationship between users e.g. two users are no longer friends or other reasons the backend server may filter some data items that should have been sent to the frontend server. The multi level privacy evaluation technology can periodically validate the filtering at the backend to detect and track instances of over filtering occurring at the backend server and take a corrective action. is a logic flow diagram illustrating an example method of validating an initial privacy check in some embodiments of the multi level privacy evaluation technology.

In the method a frontend server sends a request for data items associated with a viewer to a backend server at block . The backend server receives the request and can parse the request to extract details of the request e.g. the viewer ID the viewer s friends ID etc. at block . The backend server then aggregates a set of data items for the viewer and the privacy values associated with the data items at block . The backend server evaluates each data item including privacy value and or other information associated with the data item using an initial privacy filter at block . The initial privacy filter can be a logic based a subset of privacy rules to determine if a data item should be filtered out. At block the backend server aggregates and ranks data items that passed the initial privacy filter. In some embodiments at block the backend server flags at least some of the data items that did not pass the initial privacy filter as data items to be validated. At block the backend server returns the data items that passed the initial privacy filter along with the flagged data items to the frontend server . The flagged data items can be used by the frontend server to check the effectiveness of the filtering on the backend server . Filtered data items can be periodically flagged and sent to the frontend server to verify that the backend server is not over filtering data items.

The frontend server receives the data items that passed the initial privacy filter and the flagged data items at block . The frontend server then evaluates each of the received data items using a full privacy filter at block . The full privacy filter can check whether any of the data items should be filtered out based on the privacy information including a set of privacy rules. At block the frontend server aggregates data items that passed the full privacy filter and optionally returns the data items to the viewer at block . For example when the validation method is being implemented as a background process the data items need not be returned to the viewer. At decision block the frontend server examines the data items that passed the full privacy filter to determine if any of those data items include the flagged data items. A flagged data item passing the full privacy check can be an indication that the initial privacy filter incorrectly filtered the data item at the backend. The frontend server logs the incorrectly filtered data items at block . The frontend server then increments a counter to track the number of incorrectly filtered data items at block . At decision block if the counter value is determined to be greater than a threshold the frontend server can trigger an alert at block . In some instances the decision block can also check for other criteria such as increment step size e.g. counter value jumps from 10 to 200 to trigger an alert. The alert can be an indication that some privacy rules have changed elsewhere and the backend server does not have the current information. In some embodiments when the alert is triggered or when one or more incorrectly filtered data items are encountered the frontend server can calculate privacy values for the incorrectly filtered data items. The frontend server can then compare the calculated privacy values with the ones stored in the backend. If there is a mismatch the frontend server can push those values to the backend server to ensure that the backend server has current privacy information for evaluation. Conversely if there are no incorrectly filtered data items or if the counter value is under the threshold the method terminates at block .

Whenever a new data item or an update to a data item is detected the backend server calculates or updates the privacy value for the data item. At block the backend server uses an identifier for the new or updated data item and the privacy libraries to determine an privacy value for the new or updated data item. In some embodiments the backend server can use privacy row and tagging information and the privacy libraries to determine a privacy value of the data item. At block the backend server stores the new updated data item along with the privacy value in a database.

In the method at block a frontend server receives a search query from a viewer. The frontend server forwards the search query to a backend server which can be a search engine. The backend server receives the search query at block and rewrites the search query to include privacy and relevance constraints at block . For example if the search query is for finding any data items related to Grand Canyon the backend server can modify the search query to search for any data items that satisfies the condition of being related to Grand Canyon and any of the following conditions 1 a privacy value of public 2 a privacy value of friends and 3 a privacy of only me where the user is the data item s owner or is tagged in the data item. At block the backend server executes the modified query on a search index or index server to select data items that satisfy the relatedness privacy and tag constraints. The backend server then returns the selected data items as an initial response to the search query at block . The frontend server receives the initial response at block and for each data item in the initial response at block the frontend server evaluates the data item using a full privacy filter at block . At decision block if the data item passes the full privacy filter the frontend server keeps the data item at block . Conversely if the data item fails to pass the full privacy check the frontend server discards the data item at block . At block the frontend server evaluates the next data item in the initial response. Once all the data items in the initial response have been evaluated the frontend server ranks the data items that passed the full privacy filter at block and returns the ranked results as a response to the search query at block .

In the method at block a backend server receives or detects a new data item or an update to a data item. The backend server determines a privacy value for the new updated data item using the privacy libraries at block . At decision block the backend server determines a category in which the data item should be bucketed based on the privacy value. For example if the privacy value is public the backend server buckets the new updated data item in a public category at block . At block the backend server ranks the data items in the public category and stores the data items along with the ranking information in a memcache under a set of public memcache keys.

At decision block if the new updated data item has a privacy value that is only me or friends the backend server buckets the new updated data item in the friends or less category at block . The backend server then ranks the data items in the friends or less category at block and stores those data items along with the ranking information in the memcache under a different set of memcache keys at block .

In some embodiments visibility of some of the data items can be controlled by global settings and such information may not be stored with the data items. As a result the privacy libraries can determine the privacy value of such data items to be custom which is treated as public. Thus even if the data items are less than public e.g. shared with friends the data items are treated as public and would not be filtered at the backend. In some embodiments the backend server can compute the privacy value for the privacy settings using a privacy application programming interface API . This enables data items having less than public global settings to be filtered at the backend.

In the method at block a frontend server receives a request from a viewer to view data items related to a user and sends the request to a backend server . The backend server receives the request at block . The request can include for example a viewer ID and user ID. At decision block the backend server can determine is the request corresponds to an approximately public type or friends or less type. If the request is of approximately public type e.g. the viewer does not have a friend relationship with the user the backend server retrieves data items stored in the approximately public memcache bucket using a set of memcache keys at block . The backend server then returns the retrieved data items along with the ranking information to the frontend server at block .

If at decision block the request type is friends or less e.g. the viewer has a friend relationship with the user or the viewer and the user are the same the backend server retrieves data items from the friends or less bucket using a set of memcache keys at block and data items from the approximately public memcache bucket using a different set of memcache keys at block . The backend server then mixes the retrieved data items and ranks the data items at block . The backend server then returns the retrieved data items along with the ranking information to the frontend server at block .

The frontend server receives the retrieved data items and the ranking information at block . At block for each data item from the retrieved data items the frontend server evaluates the data item using a full privacy filter at block . At decision block if the data item passes the full privacy filter the frontend server keeps the data item at block . Conversely if the data item fails to pass the full privacy filter the frontend server discards the data item at block . At block the frontend server evaluates the next data item from the retrieved data items. Once all the data items retrieved from the backend have been evaluated the frontend server returns the results with their ranking information to the viewer at block .

The computer system generally includes a processor main memory non volatile memory and a network interface device . Various common components e.g. cache memory are omitted for illustrative simplicity. The computer system is intended to illustrate a hardware device on which any of the components depicted in the example of and any other components described in this specification and methods described in the example of can be implemented The computer system be of any applicable known or convenient type. The components of the computer system can be coupled together via a bus or through some other known or convenient device.

The processor may be for example a conventional microprocessor such as an Intel Pentium microprocessor or Motorola power PC microprocessor. One of skill in the relevant art will recognize that the terms machine readable storage medium or computer readable storage medium include any type of device that is accessible by the processor.

The memory is coupled to the processor by for example a bus such as a PCI bus SCSI bus or the like. The memory can include by way of example but not limitation random access memory RAM such as dynamic RAM DRAM and static RAM SRAM . The memory can be local remote or distributed.

The bus also couples the processor to the non volatile memory and drive unit. The non volatile memory is often a magnetic floppy or hard disk a magnetic optical disk an optical disk a read only memory ROM such as a CD ROM EPROM or EEPROM a magnetic or optical card SD card or another form of storage for large amounts of data. Some of this data is often written by a direct memory access process into memory during execution of software in the computer system . The non volatile memory can be local remote or distributed. The non volatile memory can be optional because systems can be created with all applicable data available in memory. A typical computer system will usually include at least a processor memory and a device e.g. a bus coupling the memory to the processor.

Software is typically stored in the non volatile memory and or the drive unit . Indeed for large programs it may not even be possible to store the entire program in the memory. Nevertheless it should be understood that for software to run if necessary it is moved to a computer readable location appropriate for processing and for illustrative purposes that location is referred to as the memory in this disclosure. Even when software is moved to the memory for execution the processor will typically make use of hardware registers to store values associated with the software and local cache. Ideally this serves to speed up execution. As used herein a software program is assumed to be stored at any known or convenient location from non volatile storage to hardware registers when the software program is referred to as implemented in a computer readable medium. A processor is considered to be configured to execute a program when at least one value associated with the program is stored in a register readable by the processor.

The bus also couples the processor to the network interface device . The interface can include one or more of a modem or network interface. It will be appreciated that a modem or network interface can be considered to be part of the computer system . The interface can include an analog modem isdn modem cable modem token ring interface satellite transmission interface e.g. direct PC or other interfaces for coupling a computer system to other computer systems. The interface can include one or more input and or output devices . The I O devices can include by way of example but not limitation a keyboard a mouse or other pointing device disk drives printers a scanner speaker DVD CD ROM drives disk drives and other input and or output devices including a display device. The display device can include by way of example but not limitation a cathode ray tube CRT liquid crystal display LCD LED display a projected display such as a heads up display device a touchscreen or some other applicable known or convenient display device. The display device can be used to display text and graphics. For simplicity it is assumed that controllers of any devices not depicted in the example of reside in the interface.

In operation the computer system can be controlled by operating system software that includes a file management system such as a disk operating system. One example of operating system software with associated file management system software is the family of operating systems known as Windows from Microsoft Corporation of Redmond Wash. and their associated file management systems. Another example of operating system software with its associated file management system software is the Linux operating system and its associated file management system. The file management system is typically stored in the non volatile memory and or drive unit and causes the processor to execute the various acts required by the operating system to input and output data and to store data in the memory including storing files on the non volatile memory and or drive unit .

Some portions of the detailed description may be presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the methods of some embodiments. The required structure for a variety of these systems will appear from the description below. In addition the techniques are not described with reference to any particular programming language and various embodiments may thus be implemented using a variety of programming languages.

In alternative embodiments the machine operates as a standalone device or may be connected e.g. networked to other machines. In a networked deployment the machine may operate in the capacity of a server or a client machine in a client server network environment or as a peer machine in a peer to peer or distributed network environment.

The machine may be a server computer e.g. a database server a client computer a personal computer PC a tablet PC a laptop computer a set top box STB a personal digital assistant PDA a cellular telephone an iPhone a Blackberry a processor a telephone a web appliance a network router switch or bridge or any machine capable of executing a set of instructions sequential or otherwise that specify actions to be taken by that machine.

While the machine readable medium or machine readable storage medium is shown in an exemplary embodiment to be a single medium the term machine readable medium and machine readable storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine readable medium and machine readable storage medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the presently disclosed technique and innovation.

In general the routines executed to implement the embodiments of the disclosure may be implemented as part of an operating system or a specific application component program object module or sequence of instructions referred to as computer programs. The computer programs typically comprise one or more instructions set at various times in various memory and storage devices in a computer and that when read and executed by one or more processing units or processors in a computer cause the computer to perform operations to execute elements involving the various aspects of the disclosure.

Moreover while embodiments have been described in the context of fully functioning computers and computer systems those skilled in the art will appreciate that the various embodiments are capable of being distributed as a program product in a variety of forms and that the disclosure applies equally regardless of the particular type of machine or computer readable media used to actually effect the distribution.

Further examples of machine readable storage media machine readable media or computer readable storage media include but are not limited to recordable type media such as volatile and non volatile memory devices floppy and other removable disks hard disk drives optical disks e.g. Compact Disk Read Only Memory CD ROMS Digital Versatile Disks DVDs etc. SD cards among others.

Unless the context clearly requires otherwise throughout the description and the claims the words comprise comprising and the like are to be construed in an inclusive sense as opposed to an exclusive or exhaustive sense that is to say in the sense of including but not limited to. As used herein the terms connected coupled or any variant thereof means any connection or coupling either direct or indirect between two or more elements the coupling of connection between the elements can be physical logical or a combination thereof. Additionally the words herein above below and words of similar import when used in this application shall refer to this application as a whole and not to any particular portions of this application. Where the context permits words in the above Detailed Description using the singular or plural number may also include the plural or singular number respectively. The word or in reference to a list of two or more items covers all of the following interpretations of the word any of the items in the list all of the items in the list and any combination of the items in the list.

The above detailed description of embodiments of the disclosure is not intended to be exhaustive or to limit the teachings to the precise form disclosed above. While specific embodiments of and examples for the disclosure are described above for illustrative purposes various equivalent modifications are possible within the scope of the disclosure as those skilled in the relevant art will recognize. For example while processes or blocks are presented in a given order alternative embodiments may perform routines having steps or employ systems having blocks in a different order and some processes or blocks may be deleted moved added subdivided combined and or modified to provide alternative or subcombinations. Each of these processes or blocks may be implemented in a variety of different ways. Also while processes or blocks are at times shown as being performed in series these processes or blocks may instead be performed in parallel or may be performed at different times. Further any specific numbers noted herein are only examples alternative implementations may employ differing values or ranges.

The teachings of the disclosure provided herein can be applied to other systems not necessarily the system described above. The elements and acts of the various embodiments described above can be combined to provide further embodiments.

Any patents and applications and other references noted above including any that may be listed in accompanying filing papers are incorporated herein by reference. Aspects of the disclosure can be modified if necessary to employ the systems functions and concepts of the various references described above to provide yet further embodiments of the disclosure.

These and other changes can be made to the disclosure in light of the above Detailed Description. While the above description describes certain embodiments of the disclosure and describes the best mode contemplated no matter how detailed the above appears in text the teachings can be practiced in many ways. Details of the system may vary considerably in its implementation details while still being encompassed by the subject matter disclosed herein. As noted above particular terminology used when describing certain features or aspects of the disclosure should not be taken to imply that the terminology is being redefined herein to be restricted to any specific characteristics features or aspects of the disclosure with which that terminology is associated. In general the terms used in the following claims should not be construed to limit the disclosure to the specific embodiments disclosed in the specification unless the above Detailed Description section explicitly defines such terms. Accordingly the actual scope of the disclosure encompasses not only the disclosed embodiments but also all equivalent ways of practicing or implementing the disclosure under the claims.

From the foregoing it will be appreciated that specific embodiments have been described herein for purposes of illustration but that various modifications may be made. Accordingly the invention is not limited except as by the appended claims.

