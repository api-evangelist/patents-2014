---

title: Managing multiple systems in a computer device
abstract: Resources of multiple systems are managed in a computer device. A first processing system having a set of dedicated resources also has a resource manager to manage at least one of the resources. The first processing system is prevented from directly accessing the resources without authorization. A second processing system, connected to the set of dedicated resources, has a supervisor application to grant control to individual resources to the resource manager of the first processing system. A computer program is executed in the first processing system. The supervisor application grants control of at least one resource to the resource manager of the first processing system in a way that is transparently to the computer program executing in the first processing system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09529627&OS=09529627&RS=09529627
owner: STMICROELECTRONICS ASIA PACIFIC PTE, LTD.
number: 09529627
owner_city: Singapore
owner_country: SG
publication_date: 20140319
---
There are many computer devices available nowadays including for example tablets and smartphones wherein a user can install and launch applications at their selection. Applications are generally launched based on an operating system of the computer device. Computer devices generally support a single operating system although it is in principle possible to load more than one operating system onto a computing device.

Applications can be run directly in an operating system or can be run within downloaded clients for example a browser client.

With multiple applications launched in a single computing device it is necessary to manage resources for each application within the constraints of the computing device.

According to the present disclosure there is provided a computer device comprising a first processing system comprising a resource manager for managing resources when executing a computer program in the first processing system and delivering an output of execution of the program via an output resource a second processing system connected to a set of resources dedicated to the first processing system the second processing system comprising a supervisor application having access to the set of resources and connected to deliver the resources to the resource manager of the first processing system whereby the first processing system has access to the set of resources only via the supervisor application wherein the output resource for use by the first processing system is selected by the supervisor application of the second processing system transparently to the computer program.

Embodiments provide an environment wherein two processing systems are implemented on the same computing device. Each processing system is substantially in principle self contained and can comprise for example an operating system in which applications can be executed. If the first processing system was run in the computing device by itself its resource manager would be capable of accessing the resources of the computer system and managing those resources as between applications launched within the first processing system in an autonomous fashion. That is the first processing system constitutes in itself a framework for executing applications on the computer device. According to the described embodiments of the present disclosure however the first processing system does not have permission to directly access the resources of the computer device. This provides a first level of security of the first processing system when provided as an operating framework in the computer device. This allows a computer device in principle to install an unknown framework e.g. first processing system such that it does not have access to the resources of the computer device. Access to resources required for the execution of applications in the first processing system is provided by the second processing system and particularly by the supervisor application in the second processing system.

Embodiments of the invention are applicable in the context where the output resource is a graphical resource. For example the output resource can comprise a virtual frame buffer for holding graphics data output from the computer program and intended to drive a display. The virtual frame buffer can be managed by the supervisor application in a memory space dedicated to receiving the output of execution of the computer program.

The second processing system can comprise a frame buffer for holding graphics data from one or more applications executed in the second processing system for driving a display. The supervisor application can generate output data for this frame buffer. The supervisor application can be operable to control the display to create an opening on the display wherein the data output from the computer program drives the display within the opening to display said data. In that case the opening can be created by the supervisor application through the frame buffer. The data output from the computer program drives the display via the virtual frame buffer.

That is portions of the display are driven from the frame buffer of the second processing system while a portion of the display is driven from the virtual frame buffer dedicated to the output of the computer program in the first processing system.

The computer program can consider that it is driving a full screen display. In fact however transparently to the computer program the output of the execution of the program is displayed on a portion of a full screen rather than the full screen itself.

In addition the concept underlying embodiments of the present invention can be applied to resources including a general processing unit and an audio video decoder. The advantages can be usefully achieved in the context where the resources are hardware resources.

Embodiments also comprises a method of managing resources in a computer device in which is installed a first processing system comprising a resource manager and a second processing system connected to a set of resources dedicated to the first processing system wherein the first processing system is not authorized to access directly the set of resources the method comprising the supervisor application delivering at least one resource from the set of resources to the resource manager of the first processing system whereby the first processing system has access to the set of resources only via the supervisor application wherein the output resource for use by the first processing system is selected by the supervisor application of the second processing system transparently to a computer program executed in the first processing system.

Embodiments also provide a computer product in the form of a set of computer instructions in a transitory or non transitory e.g. volatile or non volatile media the instructions when executed carrying out the method as herein above.

There is a set of trusted applications and a set of untrusted applications. Among trusted applications there are the supervisor application and also the broadcast middleware. One example of an untrusted application could be a browser because it has access to the web. Each application has its own window which is managed by a window manager described later . The supervisor is the master of the window manager whereas other applications are slave. Each application communicates with the supervisor and window manager using a mechanism based on a unique identifier for each application.

The application manager is responsible for maintaining an application list and providing an interface to access this list to the core . The concept of trusted untrusted will be explained in more detail hereinafter.

A resource manager defines the various shared resources an application can use. These can for example be physical resources such as the communication resource e.g. territorial satellite cable tuner video instances graphics display ports e.g. GDP2 etc. In any physical system access to resources is inherently limited and it is the responsibility of the resource manager to manage the limited resources so that each application can function effectively. Before launching an application will acquire the resources that it needs for its proper operation before it can be launched. This is accomplished through the resource manager. The resource manager maintains the resource list and provides an interface to the core to access this list.

A windows manager is connected to the core and communicates directly with a frame buffer which forms part of the window manager . In the window manager is shown as two separate components a manager and a frame buffer . The window manager and its components can be a known window manager system cooperating with the kernel in a known way to control a display. The windows manager which forms part of the supervisor application provides a special display control function which will be described more fully later. In brief it maintains and draws four separate windows on a display screen via the frame buffer . It also provides an interface to display text for warning messages and displays a CPU status. A user interface module operates under the control of the core and can control the browser environment to draw an application launch bar.

In an alternative embodiment shown in a mechanism creates a hole in a window and handles the display inside the window by some hardware components. A hardware compositor component manages the composition between the output of the frame buffer and those components. Two frame buffers can be mixed together by this hardware compositor. A video plan can also be mixed in. Thus the four separate windows are not necessarily managed only by the frame buffer.

A CPU monitoring module is responsible for grabbing the CPU status periodically and that status can be displayed through the windows manager . A wrapper module is executed on top of the manager of the window manager . It provides a linking interface between code executed in the manager and in the core . This allows different computing environments to be interconnected through the wrapper.

A command module is similarly provided as an interfacing module between the core and applications executing in an application environment as shown in volume . As described in more detail later volume can be considered to comprise containers for untrusted applications.

As mentioned earlier a hardware compositor can drive the display with two frame buffer and two video plans mixed together.

Each application constitutes a program or code sequence which is executed by a CPU forming part of the processor system. The architecture described herein provides a secure run time environment for multiple applications which in particular allow advantage to be taken of a variety of different application frameworks. The architecture does not itself provide a new application framework but provides the infrastructure and tools to facilitate the build of such a framework and or to make it easier to integrate legacy middleware along with an existing application framework. A first concept supported by the architecture described herein is to denote an application as trusted or untrusted. This is determined during installation of an application. On installation the application manager checks the application certificate. If the certificate is valid the application is regarded as trusted else it is regarded as untrusted. Trusted applications are loaded and executed normally that is directly between the supervisor application and the window manager . They have access privileges to directly access resources required for their execution these resources are managed by the resource manager which also manages resources for untrusted applications but through the supervisor application. In contrast untrusted applications are started in a container which provides an environment that is capable of isolating processes from the main system and limiting the resources usage thus providing a certain level of security from malicious programs. The concept of a container is known from the open source environment of Linux where untrusted applications are started in a Linux container as a non root user. Resource usage is provided in the Linux context via the c group mechanism where c group is a control group representing a collection of processes bound by the same criteria . An alternative construction is offered by UNIX in the form of Logical Domains LDOMs .

The processor system described herein uses the concept of containers. A container identifier identifies the container itself. An application identifier identifies the application. By hosting untrusted applications in a respective container a first level of security is provided. The architecture allows a number of different application environments to be hosted. When the manager detects that a user has selected an application to be launched at the display the wrapper intercepts the launch process and advises the core to determine the status of the application that has been selected. All selected applications are considered in the first place to be trusted and so have an identifier which would denote a trusted status. When the core in conjunction with the application manager detects that the application is not trusted it sets a container identifier to a non trusted identifier and allocates an application identifier associated with the container identifier. Moreover the browser executable is not called directly with a start command. There are two possibilities mentioned herein for allowing the application to access resources even though it is untrusted. In a first possibility a script file is called to run a container for the browser noting that the container identifier is untrusted. The script file calls a client before running the browser executable. Although the container is started as untrusted the client needs trusted privileges to obtain resources for example an IP address or dynamic access to hardware resources like audio and video decoders. This can be achieved by setting an application identifier bit for the client beforehand indicating a trusted status for the client even if not for the browser executable or the application which will be run behind the client . This allows the browser executable to be started as untrusted in the container and able to obtain an IP address dynamically using the client. According to the second possibility which is more secure the core can run a check for available IP addresses prior to starting the container. It can then use this IP address and statically configure the container before starting it. In this case it removes the requirement to run the client with trusted privileges within a container and is therefore more secure.

Note that for applications run inside a container process identifiers which are allocated within a container are unique only within the container itself. This can create a difficulty when applications are launched substantially simultaneously. Under usual circumstances if a user launches trusted applications A and B together both applications A and B will start at their own pace in a common environment. The manager will detect that the applications are required to be launched trigger the launch function and the new process identifiers are captured together with a unique application identifier. This identifier is the identifier which is used for applications to communicate with one another. It is also used to identify applications in the frame buffer. As the process identifier is unique in the common environment for each newly captured process identifier it can determine whether the process identifier belongs to application A or application B and update the application manager for future references.

However if a user launches untrusted application A which will launch in a container and untrusted application B which will launch in a container both applications A and B will again start at their own pace. When an application starts to execute it obtains a process identifier from its operating environment in this case a container and supplies it to the manager . However in this case when the launch process is triggered at the manager based on the newly captured process identifier the core is unable to determine whether the new process identifier belongs to application A or application B as the process identifier is unique only within the container itself and not between containers .

This difficulty is overcome in the following way. Applications which are selected more or less simultaneously by a user are sequentially launched by restricting user control in the following manner. If a user launches an application A any application B will not be allowed to start regardless whether it is trusted or untrusted until a launch command for application A implemented at the manager causes a new process identifier value to be captured. As at this time it is sure that the process is for application A the process identifier is updated in the application manager accordingly. A unique application ID is stored as well. So in any future reference in subsequent launch commands the unique ID is used as the identifier.

An application can launch multiple processes each having a process identifier sequentially generated by the application unique within a container for untrusted applications . These process identifiers are held in association with the unique identifier at the superior module.

If no launch command which captures a new process identifier value occurs within ten seconds it is assumed that an error has occurred and application A will be stopped. This will allow the user to launch any application B.

Utilizing the architecture described earlier in the embodiment of the resource manager within system A does not manage the resources applicable for system A. Instead these are managed by the resource manager of system B. Thus system B represents an architecture similar to that described in . A virtual frame buffer is implemented by dedicated memory space which interacts directly with the kernel. The virtual frame buffer has a memory space dedicated to the management of the screen on the display as governed by system A. This memory space is isolated from the rest of the system and is controlled in a dedicated fashion by the supervisor application . The operation of the supervisor module allows the display of system A to be controlled using the hardware resources available to system B. This is accomplished through the resource manager . Using the windows manager and hardware compositor the display output from system A can be drawn into one of the four windows on the display as shown in even though system A considers that it is operating in full screen mode.

The window manager creates a hole in a window. Then the display is managed by the hardware compositor as an overlay solution. The supervisor is responsible to create the window and the hole then to program the hardware compositor through the virtual frame buffer and it is transparent for system A. System A acts as if it is displaying on a single window of a frame buffer.

System A then drives the virtual frame buffer as allocated to it by the supervisor application. The virtual frame buffer FB2 is below FB1 so the final output which drives the display via the kernel is the composite of the contents of FB1 and FB2 as managed by the hardware compositor . The supervisor application allocates the virtual frame buffer resource FB2 to system A when an application is launched in system A that will access to the display as a resource. The supervisor application can also be configured to monitor the application and to detect when the size of the application has changed. The application can then drive the kernel to change the size of the virtual frame buffer.

The above described embodiments of the present disclosure provide a processor system which delivers a toolbox that improves time to market allowing different stack porting for dedicated applications. The toolbox gives the flexibility to run concurrently several applications and interface frameworks for example the different frameworks as shown in volume . The toolbox further provides support for secure content between applications based on the unique application identifier.

It will be appreciate that the embodiments have been described only by way of example. Other variants may be implemented by a person skilled in the art given the disclosure herein. The scope of the invention is not limited by the described embodiments.

The various embodiments described above can be combined to provide further embodiments. These and other changes can be made to the embodiments in light of the above detailed description. In general in the following claims the terms used should not be construed to limit the claims to the specific embodiments disclosed in the specification and the claims but should be construed to include all possible embodiments along with the full scope of equivalents to which such claims are entitled. Accordingly the claims are not limited by the disclosure.

