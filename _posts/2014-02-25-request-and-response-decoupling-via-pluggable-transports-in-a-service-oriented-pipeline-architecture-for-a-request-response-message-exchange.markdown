---

title: Request and response decoupling via pluggable transports in a service oriented pipeline architecture for a request response message exchange
abstract: A method, system, and computer-readable medium are described herein. An embodiment may read a configuration file. The configuration file may specify a first stage that specifies processing of a protocol-agnostic portion of a message. The embodiment may then add, by one or more processors, the first stage to a processing pipeline, where the processing pipeline is configured to process received messages according to the first stage and a second stage. The second stage is a stage of the processing pipeline that specifies processing of a protocol-specific portion of the message. The processing pipeline being further configured to transport the processed message to a service via a transport mechanism.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09264518&OS=09264518&RS=09264518
owner: eBay Inc.
number: 09264518
owner_city: San Jose
owner_country: US
publication_date: 20140225
---
This application is a continuation of U.S. patent application Ser. No. 13 709 800 filed on Dec. 10 2012 which is a continuation of U.S. non provisional application Ser. No. 12 346 742 filed on Dec. 30 2008 which are incorporated herein by reference in their entirety.

A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent files or records but otherwise reserves all copyright rights whatsoever. The following notice applies to the software and data as described below and in the drawings that form a part of this document Copyright 2006 2008 eBay Inc. All Rights Reserved.

This disclosure relates to methods and systems supporting computing and data processing systems. More particularly the disclosure relates to configuring a processing pipeline used to process request and response messages in a service oriented architecture.

In Service Oriented Architecture SOA there are typically many communicating reusable services that are deployed in several machines. In large scale enterprises like eBay eTrade or Google for example there could be thousands of different services deployed in thousands of machines. It is most common and efficient for these services to communicate with each other. Further external access is also typically provided for some of these services. In communicating with each other various different types of communication protocols may be used for efficiently and optimization reasons. Communication between service providers and service consumers can be accomplished using some pre defined protocol. In the web services case this protocol can be the Simple Object Access Protocol SOAP SOAP is a protocol for exchanging Extensible Mark up Language XML based messages over computer networks normally using Hypertext Transport Protocol HTTP HTTPS . SOAP often forms the foundation layer of the web services protocol stack providing a basic messaging framework upon which abstract layers can be built. There are several different types of messaging patterns in SOAP but by far the most common is the Remote Procedure Call RPC pattern in which one network node the client sends a request message to another node the server and the server immediately sends a response message to the client. In a typical SOA implementation Service Consumers communicate with Service Providers using a specific underlying transport protocol HTTP . There are several Message Exchange Patterns MEP for interactions between a service consumer and a service provider. In a Request Response MEP typically the response is sent back using the same transport the request was sent in. This typically requires the client to hold on to the connection until the response arrives which could be inefficient and sometimes inconvenient depending on how long the processing of the request takes. It would be desirable in some cases to have the response come in potentially via a different transport e.g. Simple Mail Transfer Protocol SMTP . Further most conventional SOA framework products require either use of the same transport for requests and responses in a request response MEP or require use of different message exchange patterns such that responses are processed off line and communicated via other means. For these reasons it would be beneficial to decouple request and response processing including their transports for a request response MEP in a SOA. Additionally it is also beneficial to have the system support plugging in custom transports transparently for both requests and responses.

U.S. Patent Application No. 2005 0223109 describes a system wherein services such as product services real time services and common services are deployed in a services oriented architecture. These services may for example be deployed for use in a variety of enterprise data integration functions.

U.S. Patent Application No. 2007 0011126 describes a service oriented architecture SOA and accompanying method. In one embodiment the SOA includes one or more service requesters coupled to one or more service providers via a bus. The bus includes runtime binding functionality to facilitate interaction between the one or more service requesters and the one or more service providers. A registry which stores information pertaining to a service provided by the one or more service providers communicates with one or more service providers and or requesters and the bus. In a more specific embodiment bus includes a Service Integration Bus SIB that includes a Service Factory SF module for facilitating implementing the runtime binding functionality and for selectively invoking the service. Functionality of the SOA is strategically organized into various tiers and layers including a requester tier a provider tier a business process services tier an infrastructure services tier an SIB layer a persistence layer and so on.

U.S. Patent Application No. 2005 0267947 describes a system including a service bus which can act as an intermediary between a client and a service. Messages to the service bus arrive on a transport and can be processed to determine a destination to route and or publish the message to a transformation to perform on the message and or security processing. The message is then sent out on a transport bound for a service or another service bus. A response to the message can follow an inverse path through the service bus.

Thus a computer implemented system and method for decoupling processing of request and response messages supporting different pluggable respective transports in a service oriented pipeline architecture is needed.

In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of some example embodiments. It will be evident however to one of ordinary skill in the art that the present invention may be practiced without these specific details.

As described further below according to various example embodiments of the disclosed subject matter described and claimed herein there is provided a computer implemented system and method for decoupling processing of request and response messages supporting different pluggable respective transports in a service oriented pipeline architecture. Various embodiments are described below in connection with the figures provided herein.

In particular as depicted in the various figures included herewith the SOA message processing model is independent of a specific transport mechanism as transport specific processing is made pluggable e.g. transport processing modules can be added or removed without requiring a significant level of re design or re configuration . The decoupling of request and response processing and the ability to plug in custom transports for either of those allows efficient processing and resource utilization. Additionally new transport protocols can be added to the SOA seamlessly without having to change the SOA processing model.

The various embodiments described herein include a SOA framework on a pipeline based architecture where requests and responses are processed in separate pipelines. At the end of each pipeline whether request or response is a Dispatcher which dispatches the processed message to the destination. This Dispatcher can be either a request dispatcher or a response dispatcher as the case may be. Additionally the pipeline is abstracted such that one of the choices provided for the destination can be a transport mechanism as is the case with client side request dispatcher and server side response dispatcher. Further a transport and a specific interface associated with the transport which each transport can implement is abstracted. These transports are made available for use by specifying them in the service and client configuration files. Thus additional transports can be written and plugged in on to an existing system without knowing anything about the framework or affecting existing services. These transports can be selected for request and responses separately. Further using this de coupled and pluggable transports architecture we can implement efficient local binding of services and consumers in the same Java Virtual Machine JVM at runtime through simple configuration changes. This is achieved through implementing what is called a Local Transport which is yet another transport implementation that follows the same transport interface but actually directly hands off the request to the server side request pipeline without a physical transport being involved. This is a highly desirable thing to have in a large scale distributed computing environment such as eBay.

Referring to a diagram illustrates an example embodiment of a computer implemented system for processing messages in a service oriented pipeline architecture. In the example application server system illustrated synchronous or asynchronous messages are received and sent from system either via a staged event driven architecture SEDA interface or a servlet interface for transferring synchronous data streams. The staged event driven architecture SEDA interface decomposes a complex event driven software application into a set of stages connected by queues. This design avoids the high overhead associated with thread based concurrency models and decouples event and thread scheduling from application logic. By performing admission control on each event queue the service can be well conditioned to load preventing resources from being overcommitted when demand exceeds capacity. SEDA employs dynamic control to automatically tune runtime parameters such as the scheduling parameters of each stage as well as to manage load for example by performing adaptive load shedding. Decomposing services into a set of stages also enables modularity and code reuse as well as the development of debugging tools for complex event driven applications. System can also use a Quality of Service QoS module to provide various levels of priority for the incoming message streams. Messages with higher levels of priority can be dispatched more quickly into the Service Provider Framework SPF described in more detail below.

A Servlet is an object that receives a request and generates a response based on that request. A Servlet container is a specialized web server that supports Servlet execution. The Servlet container combines the basic functionality of a web server with certain Java Servlet specific optimizations and extensions such as an integrated Java runtime environment and the ability to automatically translate specific Uniform Resource Locators URLs into Servlet requests. Individual Servlets are registered with a Son et container providing the container with information about what functionality they provide and what URL or other resource locator they will use to identify themselves. The Servlet container is then able to initialize the Servlet as necessary and deliver requests to the Servlet as they arrive. Many containers have the ability to dynamically add and remove Servlets from the system allowing new Servlets to quickly be deployed or removed without affecting other Servlets running from the same container. Servlet containers are also referred to as web containers or web engines. Servlet interface can be implemented as a servlet container in a particular embodiment. Servlet interface can process incoming synchronous messages and dispatch the processed messages into the Service Provider Framework SPF described in more detail below. SPF can receive messages typically a service request and after processing the messages in the manner described below SPF may dispatch the messages to an appropriate service . Prior to being dispatched to services the incoming message can be initially processed by a number of modules in a pipelined architecture each module performing a particular operation on the received message. These processing modules can include a G11N processing module . The term. G11N as used herein refers to the operations of internationalization and localization. In computing internationalization and localization also spelled internationalisation and localisation are means of adapting computer software for non native environments especially other nations and cultures. Internationalization is the conventional process of designing a software application so that it can be adapted to various languages and regions without engineering changes. Localization is the conventional process of adapting software for a specific region or language by adding locale specific components and translating text. Due to their length the terms are frequently abbreviated to G11N as shown in . Another processing module of SPF can be logging module . Logging module is used to record various items of information related to the received message for tracking debugging and or archiving purposes. Another processing module of SPF can be rate limiting module . Rate limiting module is used to adjust the flow of messages in a stream to a pre defined rate limit or threshold. Application level caching module of SPF provides an ability to temporarily store application level information that may be accessed by the application more than once. Application level caching module can provide a higher level of efficiency because the cached information does not need to be re acquired through a network access. Security module can be provided in SPF to enforce a pre defined security policy with respect to authentication and authorization. Finally monitoring module can be provided in SPF to enable monitoring of the service invocation consumption status and subsequently to enable alerting conditions and monitoring of compliance with service level agreements SLA s . All these are examples of some of the handlers in the pipeline that control the processing of the message. There are a number of other system level handlers. Service implementers can plug in their own service specific handlers as needed. The list and order of handlers in the pipeline can be configured and customized as necessary thus providing a true pluggable pipeline architecture with improved flexibility.

Messages received by system can be configured for a variety of communication protocols. Although many SOA implementations use SOAP as a communications protocol particular embodiments of system can be used with a communication or messaging protocol that is either a proprietary protocol or some other standard messaging protocol other than SOAP. Most communication protocols for use with SOA implementations whether SOAP or another protocol typically use a common basic messaging structure. In general this messaging structure consists of a message header followed by a message payload or message body. In most cases the message header contains most of the protocol specific data. The message payload typically contains data content that is generally common or can be made common for all supported communication protocols. For this reason particular embodiments can isolate protocol specific message processing into a set of relatively compact protocol specific message processors one for each protocol supported by system . As will be described in more detail below the protocol specific message processors can be plugged in or added to the system architecture without a significant level of re design or re configuration of the system. Portions of the incoming message that are common to all supported protocols can be efficiently processed in a message pipeline of SPF as described below. Because the portions of the incoming message processed by the message pipeline of SPF are protocol agnostic i.e. not protocol specific the insertion of a new or different protocol specific message processor does not affect and therefore does not require modification to the message pipeline of SPF . In this manner the embodiments described herein can support a variety of communication protocols in an SOA implementation without causing system re designs or redundancies. These pluggable protocol processors can be registered in a configuration file. In this manner various pluggable protocol processors can be conveniently added i.e. plugged into or removed from the message pipeline of SPF without significant effort.

Referring now to a particular example embodiment of a server side runtime environment or Service Provider Framework SPF is illustrated. SPF can receive incoming messages from a requester server via a framework servlet . The incoming messages can be a server request for a service supported by the SOA. Messages received by SPF can be configured for a variety of different communication protocols. Framework servlet can handle the receipt and queuing of the incoming messages including initialization of appropriate modules. After initial processing the framework servlet forwards the incoming message to a server message processor .

Server Message Processor SMP is the main driver for processing the incoming message. At its initialization time SMP reads all the service configuration files and initializes the appropriate modules service implementation instances and any special handlers etc. Handlers are processing logic components that are plugged into the pipeline in the manner described above. The handlers act on the message typically just the header portion of the message. Examples of these handlers include security logging etc. as shown in and described above. Service configuration files in a particular example embodiment are hierarchical and consist of three levels Global group and instance specific. The global configuration file is used to configure things that are common to all services in the deployed environment. The group level configuration file is used to configure things that are common to a group of services e.g. a specific domain like Search or Trading etc. . The Instance specific configuration file is used to configure things that are specific only to a particular service. The configuration system of SMP allows configuration of much of the functionality provided by system . For example handlers desired data formats and protocol processors can all be configured by SMP . The SMP manages the processing of the received message through several different but symmetric processing steps. These processing steps include processing a request message using the In Pipeline dispatching the processed request message through a request dispatcher processing a response message using the Out Pipeline and dispatching the processed response message through a response dispatcher . At each of these steps the appropriate protocol processor that matches e.g. is compatible with the protocol of the incoming message is also invoked. If any errors occur at any state of processing the processing flow is intercepted by the Server Message Processor SMP and an appropriate error message is returned. The error message can be sent through the Out Pipeline and response dispatcher . Thus SMP is the main driver for the message processing performed in system .

As part of the processing operations performed by the server message processor the message header of the incoming message can be decoded to determine the particular protocol for which the incoming message is coded or compatible with . Once the specific protocol corresponding to the incoming message is determined a corresponding one of the protocol specific processors can be activated to operate upon the header of the incoming message of the same or compatible protocol type. As mentioned above the specific protocol processor is invoked at each of the processing steps performed by the SMP . The specific protocol processor processes the protocol specific headers e.g. SOAP envelope in the case of SOAP and a context is maintained to reflect the processed information. This context is also made available to the pipeline in case any handler wants to took at the context. Once the specific protocol processor returns then the message is passed through the input request pipeline . The protocol agnostic portion of the incoming message e.g. message payload and transport headers is run through the input pipeline for staged processing. In a particular embodiment the pipeline can include several stages. For example a first stage of pipeline can be a logging stage for handling logging of the incoming message. Logging stage can be used to generate a record for the received message. A second stage of pipeline can be an authentication stage for handling authentication operations on the incoming message. Various types and degrees of message authentication can be implemented at this stage. A third stage of pipeline can be a G11N stage for handling the operations of internationalization and localization on the incoming message. As described above internationalization and localization operations can be used to regionalize a message so appropriate results are produced. Other stages can be added to pipeline to enable the insertion of one or more pluggable processors for handling a variety of data formats and for decoding a message payload coded in a particular data format. It will be apparent to those of ordinary skill in the art upon reading this disclosure that other stages can similarly be added to pipeline in which other operations could similarly be performed on the protocol agnostic portions of the incoming message. Further because of the pipeline architecture of the described embodiment various stages of the pipeline can be performed in parallel thereby increasing efficiency of the system .

Once the protocol agnostic portion of the incoming message is processed by each of the stages of pipeline the message can be dispatched to a corresponding service implementation module via a request dispatcher . At the point where the incoming message is passed to the request dispatcher de serialization of the message payload is performed if de serialization has not already been performed by one of the stages in pipeline . It is beneficial to push de serialization of the message payload to the later stages of processing because de serialization can be a time consuming and expensive process. The service implementation module can then perform the requested service based on the service request.

As the service implementation module generates output in response to the request for service server message processor can perform post processing on the protocol agnostic portion of the output data using an output pipeline . In a manner similar to input pipeline output pipeline can be divided into stages each stage performing an operation on the protocol agnostic portion of the output data. Once the protocol agnostic portion of the output data is processed by each of the stages of pipeline the protocol specific portion of the output data is processed by the one of the protocol specific processors . At this point the output message which can either be an output data message generated in response to the service request or an error message can be dispatched to a transport module via the response dispatcher . Transport module can deliver the output message to a service requester via a selected transport. In the case of a synchronous communication the transport module may simply return to the SMP which in turn returns the response to the servlet container.

Referring now to a particular example embodiment of a client side runtime environment or Service Invocation Framework SIF is illustrated. SIF can receive incoming messages from a client application requester via an SIF application programming interface API or through a pre generated proxy. The incoming messages can be a client request for a service supported by the SOA. A client message processor receives the incoming message either way.

The Client Message Processor CMP in a particular example embodiment is the main driver for processing the outgoing request message and for handling the received response. This is very much equivalent to the SMP on the server side. The CMP performs processing operations similar to the SMP however the CMP operates on the client side. These processing operations as described above include running the request message through the request pipeline Out pipeline request dispatcher response pipeline In pipeline and response dispatcher . Similar to the processing performed on the server side an appropriate protocol specific processor is also invoked at each of these processing steps to formulate a request message that contains the selected protocol specific envelope. Similarly an appropriate protocol specific processor is also invoked for processing of the protocol specific envelope in the response message as well. Again similar to the server side the client side also uses a hierarchy of configuration files such as global group and instance specific configurations. As described above the CMP is responsible for managing these configurations.

As part of the processing operations performed by the client message processor the message header of the outgoing message needs to be encoded to reflect the selected protocol. To do this a corresponding one of the protocol specific message processors is activated to encode the header of the outgoing message of the same or compatible protocol type. Once the specific protocol processor returns the outgoing message is run through the request pipeline Out pipeline for staged processing of the protocol agnostic portion of the message. In a particular embodiment the pipeline can include several stages. For example a first stage of pipeline can be a logging stage for handling logging of the incoming message. Logging stage can be used to generate a record for the received message. A second stage of pipeline can be an authentication stage for inserting the security credentials authentication coding and the like. As many stages can be added to pipeline as necessary to enable customization of message processing. In fact every portion of processing logic can be added as a stage also referred to as a Handler in the pipeline . Further because of the pipeline architecture of the described embodiment various stages of the pipeline can be performed in parallel thereby increasing efficiency of the system .

Once the protocol agnostic portion of the outgoing message is processed by each of the stages of pipeline the request message is dispatched to a transport factory module via a request dispatcher . The request dispatcher serializes the outgoing message into the wire data format that is selected configured before handing off the message to the transport factory module . The transport factory module delegates transport of the message via one of a plurality of pluggable transport processors . A particular embodiment can offer support for a plurality of transport modes and protocols such as a local transport useful when the client and server are deployed in the same Java Virtual Machine JVM Hypertext Transport Protocol HTTP Simple Mail Transfer Protocol SMTP and the like. The transport factory module sends the request message to the server via the respective one of the pluggable transport processors . The particular pluggable transport processor chosen for transport of the request message can be configured by the CMP . It will be apparent to those of ordinary skill in the art upon reading this disclosure that other specific transport modes protocols can similarly be added to transport factory to enable transport of the processed request message in a variety of ways.

As the service implementation on the server side generates output in response to the request for service the transport factory module receives this response and passes control to the client message processor . Client message processor then invokes the appropriate protocol specific processor for processing the protocol specific portion of the response message. The CMP then runs the response message through the response pipeline In pipeline . In a manner similar to request pipeline response pipeline is also divided into stages each stage performing an operation on the protocol agnostic portion of the incoming response data. At this point the incoming response message which can be output data in response to a service request is dispatched to a response dispatcher . Additionally the client message processor can send a response to the client application requester via the SIF API .

Thus as described above in connection with both the server side runtime environment and the client side runtime environment can be provided with a transport factory including a plurality of pre configured and selectable transport mechanisms. The information about the desired response transport can be sent with the message over the wire in the request message indicating to the server what transport should be used for response. If such a transport is not available on the server side for sending the response based on the client configuration hard or soft either the request is rejected or the response is sent back on the same transport as the request. If a request goes out via one transport say transport and the response comes back via a different transport say transport then on the client side the equivalent receiving transport needs to be configured and listening for the response as well. Additional pluggable transports can be implemented plugged in and configured without altering the base SOA framework and hence without affecting any existing clients and services. New transports can be added to the client side environment by using a code sample shown in. . Plugging in transports at the server side is similar to that for the client side as shown in . The pluggable transport configuration information can be specified at the client side in a client config.xml file. The pluggable transport configuration information can be specified at the server side in a service config.xml.

The response transport as desired by a client and sent across in the request message is automatically selected for response on the server side assuming the selected transport is available by going through the transport factory as shown. If the selected response transport is HTTP then the response simply amounts to a return to the servlet container which handles the HTTP response. If the client selects LocalTransport as a pluggable transport mechanism then this selected transport mechanism is equivalent to using no physical transport and making an in JVM call i.e. a local java call . In a Local Transport there is provided an option to skip serialization deserialization for optimization purposes.

The example computer system includes a processor e.g. a central processing unit CPU a graphics processing unit GPU or both a main memory and a static memory which communicate with each other via a bus . The computer system may further include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT . The computer system also includes an input device e.g. a keyboard a cursor control device e.g. a mouse a disk drive unit a signal generation device e.g. a speaker and a network interface device .

The disk drive unit includes a machine readable medium on which is stored one or more sets of instructions e.g. software embodying any one or more of the methodologies or functions described herein. The instructions may also reside completely or at least partially within the main memory the static memory and or within the processor during execution thereof by the computer system . The main memory and the processor also may constitute machine readable media. The instructions may further be transmitted or received over a network via the network interface device .

Applications that may include the apparatus and systems of various embodiments broadly include a variety of electronic and computer systems. Some embodiments implement functions in two or more specific interconnected hardware modules or devices with related control and data signals communicated between and through the modules or as portions of an application specific integrated circuit. Thus the example system is applicable to software firmware and hardware implementations. In example embodiments a computer system e.g. a standalone client or server computer system configured by an application may constitute a module that is configured and operates to perform certain operations as described herein. In other embodiments the module may be implemented mechanically or electronically. For example a module may comprise dedicated circuitry or logic that is permanently configured e.g. within a special purpose processor to perform certain operations. A module may also comprise programmable logic or circuitry e.g. as encompassed within a general purpose processor or other programmable processor that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a module mechanically in the dedicated and permanently configured circuitry or in temporarily configured circuitry e.g. configured by software may be driven by cost and time considerations. Accordingly the term module should be understood to encompass a tangible entity be that an entity that is physically constructed permanently configured e.g. hardwired or temporarily configured e.g. programmed to operate in a certain manner and or to perform certain operations described herein. While the machine readable medium is shown in an example embodiment to be a single medium the term machine readable medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine readable medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present description. The term machine readable medium shall accordingly be taken to include but not be limited to solid state memories optical and magnetic media and carrier wave signals. As noted the software may be transmitted over a network using a transmission medium. The term transmission medium shall be taken to include any medium that is capable of storing encoding or carrying instructions for transmission to and execution by the machine and includes digital or analog communications signal or other intangible medium to facilitate transmission and communication of such software.

The illustrations of embodiments described herein are intended to provide a general understanding of the structure of various embodiments and they are not intended to serve as a complete description of all the elements and features of apparatus and systems that might make use of the structures described herein. Many other embodiments will be apparent to those of ordinary skill in the art upon reviewing the above description. Other embodiments may be utilized and derived therefrom such that structural and logical substitutions and changes may be made without departing from the scope of this disclosure. The figures provided herein are merely representational and may not be drawn to scale. Certain proportions thereof may be exaggerated while others may be minimized. Accordingly the specification and drawings are to be regarded in an illustrative rather than a restrictive sense.

Thus a computer implemented system and method for decoupling processing of request and response messages supporting different pluggable respective transports in a service oriented pipeline architecture are disclosed. While the present invention has been described in terms of several example embodiments those of ordinary skill in the art will recognize that the present invention is not limited to the embodiments described but can be practiced with modification and alteration within the spirit and scope of the appended claims. The description herein is thus to be regarded as illustrative instead of limiting.

