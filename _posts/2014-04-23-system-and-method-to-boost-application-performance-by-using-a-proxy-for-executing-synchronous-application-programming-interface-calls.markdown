---

title: System and method to boost application performance by using a proxy for executing synchronous application programming interface calls
abstract: Techniques are described for utilizing synchronous APIs which normally block callers until a result is returned. In particular, the techniques described herein enable an application or other programming construct to boost performance by executing synchronous APIs (e.g., long running time APIs) within a proxy container rather than executing the synchronous APIs in the context of the application itself. Since the proxy is a separate process or thread, the caller application is thereby released from waiting for the synchronous API call and may proceed with other processing instead of waiting for the synchronous API to return. The application may then monitor the proxy to determine whether a result has been received, such as by periodically polling the proxy.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09032425&OS=09032425&RS=09032425
owner: VMware, Inc.
number: 09032425
owner_city: Palo Alto
owner_country: US
publication_date: 20140423
---
Benefit is claimed under 35 U.S.C. 119 a d to Foreign application Serial No. 1314 CHE 2014 filed in India entitled A SYSTEM AND METHOD TO BOOST APPLICATION PERFORMANCE BY USING A PROXY FOR EXECUTING SYNCHRONOUS APPLICATION PROGRAMMING INTERFACE CALLS filed on Mar. 12 2014 by VMware. Inc. which is herein incorporated in its entirety by reference for all purposes.

In the context of computer software an application programming interface API specifies how two or more applications communicate with one another. APIs are very common in today s software allowing otherwise heterogeneous objects or applications to interact utilize each other s functionality and to generally be compatible with each other. In a typical scenario one application invokes the functionality of another application by making a call against that application s API which it exposes.

APIs can generally be divided into synchronous APIs and asynchronous APIs. Synchronous APIs block the caller of the API until a result of the call is returned to the caller. This results in the caller having to wait for the result before proceeding with other processing. Asynchronous APIs on the other hand return immediately and the actual status is returned at the end after the API completion through a callback or can be polled periodically by the caller depending on the API implementation.

Both synchronous and asynchronous APIs can be useful and have applicability in different areas. For example asynchronous APIs can be useful in cases where the task performed takes more time than is required for the caller to wait. The application utilizing asynchronous APIs would typically need to follow certain programming techniques to support asynchronous APIs. Synchronous APIs should generally be faster than asynchronous and the majority of APIs tend to be synchronous. There is no absolute rule to specify which type of API is the most suitable since it often depends on the context and scale of the environment. A thorough analysis should be performed to decide upon which type of API to implement for the particular environment at hand.

There are many cases when developers select the wrong or less optimal types of API in their implementation. For example some developers simply utilize synchronous APIs due to unseen scenarios lack of foresight and the like. Furthermore especially in large scale environments synchronous APIs may block callers due to various factors such as system slowdowns larger than expected data sizes and others. Some applications end up using many third party modules or APIs over which the developer has no control. Some of these third party APIs may be well written to handle all use cases while others may not. If the third party API was not written correctly the calling application may end up waiting indefinitely for the synchronous API and since the calling application has no control over the third party code such problems are often difficult to resolve.

Systems and methods in accordance with various embodiments of the present disclosure provide more efficient ways to utilize synchronous APIs which normally block callers until a result is returned. In particular embodiments described herein enable an application or other programming construct to boost performance by executing synchronous APIs e.g. long running time APIs within a proxy container rather than executing the synchronous APIs in the context of the application itself. Since the proxy is a separate process or thread the caller application is thereby released from waiting for the synchronous API call and may proceed with other processing instead of waiting for the synchronous API to return.

Once the application has initiated the API call in the proxy the application can monitor the proxy for a period of time to determine when the result of the invocation is returned. For example the application may periodically poll the proxy after a designated time interval to check whether a result is available. If the proxy receives the result the result can be provided to the application. If on the other hand the proxy has not received the result from the synchronous API after a maximum number of polls the application may terminate the proxy and consider it having timed out.

Various embodiments can provide a number of advantages. For example the execution of the synchronous API within a proxy can boost the application performance and provide more control over synchronous APIs. One scenario in which the techniques may be particularly useful is when a developer is utilizing a third party library or operating system library whose API is synchronous its types are generated dynamically the synchronous APIs are blocking while fetching properties of some objects and the APIs themselves do not provide any timeout parameters. The embodiments described herein can support terminating threads and running a function as a process due to dynamic types. As such some embodiments would rely on sub process as a proxy in those instances.

In the illustrated embodiment when an application needs to make a call to a synchronous API e.g. a third party API the application first invokes the proxy monitor . In some embodiments the proxy may pass to the proxy monitor a set of parameters to use with the proxy. For example the application may specify the time interval to wait before polling the proxy for a result and also specify the maximum number of monitoring cycles that the monitor should wait before considering the proxy as timed out and terminating the proxy .

Once the application invokes the proxy monitor the proxy monitor instantiates the proxy and obtains a handle to the proxy which it can use to communicate inputs and results with the proxy . The proxy runs concurrently in parallel with the application in a separate thread or process of execution. Once the proxy has been instantiated and is running the application is released to perform any other processing that might be needed. The proxy invokes the synchronous API and is blocked until receiving a result from the synchronous API . As such the proxy waits for a result from the API while the proxy monitor continuously monitors the proxy to check whether the proxy has received a result from the API . For example the proxy monitor may periodically poll the proxy to determine whether the proxy has received a result from the synchronous API . If the proxy has not received the result after a predetermined period of time the proxy can be considered timed out and be terminated by the proxy monitor .

In this particular implementation the monitor proxy algorithm utilizes two parameters 1 Monitor Interval and 2 Monitor Cycles. The Monitor Interval parameter specifies a period of time that the monitor will sleep before polling the proxy. The Monitor Cycles parameter specifies the maximum number of times to poll the proxy before timing out the API. As such the timeout of the API i.e. maximum running time of the synchronous API can be represented by Monitor Interval multiplied by Monitor Cycles.

As illustrated in the normal invocation of the API call is deferred to a proxy which in turn is monitored in the application until the proxy is terminated gracefully i.e. returns a result or until the proxy reaches its timeout period. The application launches a proxy gets a handle to it and uses this handle to communicate inputs and fetch results if any . Proxy runs concurrently or in parallel with the application when it is launched. From this point on the application requests proxy for API execution by passing API information and the required arguments to passed to the API. In the illustration of the API information is comprised of the API function name i.e. apiFuncName and the arguments to the API call i.e. argsToApiFunc . After the API is invoked the application s Monitor call monitors the proxy until its completion. If Monitor determines that the proxy terminated gracefully the return object is collected and assigned to the memory location as if the return object is returned from API. Further if the proxy terminated gracefully the application can use the same proxy for other API execution rather than creating a new proxy for every API execution. If on the other hand the Monitor determines that the proxy has exceeded its timeout period the Monitor terminates the proxy and intimates the application as if the API execution failed. Once proxy timeout occurs new proxy creation can be performed whenever another synchronous API is to be executed.

In various embodiments the term proxy or proxy container are used interchangeably herein and should be broadly interpreted to mean any thread child or sub process depending on the implementation and the programming language being used. For example C C and Java programming languages can use threads as they support thread terminating interfaces whereas the Python language does not provide support for this feature and therefore a sub process can be utilized or multiprocessing with custom Picklers can be used instead.

Various embodiments described herein can be implemented in a wide variety of environments which in some cases can include one or more user computers computing devices or processing devices which can be used to operate any of a number of applications. User or client devices can include any of a number of general purpose personal computers such as desktop or laptop computers running a standard operating system as well as cellular wireless and handheld devices running mobile software and capable of supporting a number of networking and messaging protocols. Such a system also can include a number of workstations running any of a variety of commercially available operating systems and other known applications for purposes such as development and database management. These devices also can include other electronic devices such as dummy terminals thin clients gaming systems and other devices capable of communicating via a network.

Many embodiments utilize at least one network that would be familiar to those skilled in the art for supporting communications using any of a variety of commercially available protocols such as TCP IP FTP UDP HTTP HTTPS or the like. The network can be for example a local area network a wide area network a virtual private network the Internet an intranet an extranet a public switched telephone network an infrared network a wireless network and any combination thereof.

The various environments in which the embodiments can be implemented may include a variety of data stores and other memory and storage media as discussed above. These can reside in a variety of locations such as on a storage medium local to one or more of the computers or remote from any or all of the computers across the network. In some embodiments the information may reside in a storage area network SAN familiar to those skilled in the art. Similarly any necessary files for performing the functions attributed to the computers servers or other network devices may be stored locally and or remotely as appropriate. Where a system includes computerized devices each such device can include hardware elements that may be electrically coupled via a bus the elements including for example at least one central processing unit CPU at least one input device e.g. a mouse keyboard controller touch screen or keypad and at least one output device e.g. a display device printer or speaker . Such a system may also include one or more storage devices such as disk drives optical storage devices and solid state storage devices such as random access memory RAM or read only memory ROM as well as removable media devices memory cards flash cards etc.

Such devices also can include a computer readable storage media reader a communications device e.g. a modem a network card wireless or wired an infrared communication device etc. and working memory as described above. The computer readable storage media reader can be connected with or configured to receive a computer readable storage medium representing remote local fixed and or removable storage devices as well as storage media for temporarily and or more permanently containing storing transmitting and retrieving computer readable information. The system and various devices also typically will include a number of software applications modules services or other elements located within at least one working memory device including an operating system and application programs such as a client application or Web browser. It should be appreciated that alternate embodiments may have numerous variations from that described above. For example customized hardware might also be used and or particular elements might be implemented in hardware software including portable software such as applets or both. Further connection to other computing devices such as network input output devices may be employed.

Storage media and computer readable media for containing code or portions of code can include any appropriate media known or used in the art including storage media and communication media such as but not limited to volatile and non volatile removable and non removable media implemented in any method or technology for storage and or transmission of information such as computer readable instructions data structures program modules or other data including RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disk DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a system device. Based on the disclosure and teachings provided herein a person of ordinary skill in the art will appreciate other ways and or methods to implement the various embodiments.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims.

