---

title: Cache utilization and eviction based on allocated priority tokens
abstract: A system, method, and computer program product are provided for providing prioritized access for multithreaded processing. The method includes the steps of allocating threads to process a workload and assigning a set of priority tokens to at least a portion of the threads. Access to a resource, by each one of the threads, is based on the priority token assigned to the thread and the threads are executed by a multithreaded processor to process the workload.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09477526&OS=09477526&RS=09477526
owner: NVIDIA Corporation
number: 09477526
owner_city: Santa Clara
owner_country: US
publication_date: 20140103
---
This application claims the benefit of U.S. Provisional Application No. 61 873 778 filed Sep. 4 2013 the entire contents of which is incorporated herein by reference.

This invention was made with Government support under LLNS subcontract B599861 awarded by DOE and with Government support under Agreement HR0011 13 3 0001 awarded by DARPA. The Government has certain rights in this invention.

The present invention relates to multithreaded processing and more particularly to providing prioritized access to processor resources.

Some conventional processors leverage massive multithreading as a technique for hiding latency and achieving high performance. Regularly structured compute intensive applications can readily utilize the high peak memory bandwidth and ample computational resources of a graphics processing unit GPU to great effect. In particular regularly structured applications with high spatial and temporal locality can efficiently utilize cache resources. However not all applications can be re factored to exhibit regular control flow and memory access patterns and many emerging GPU applications suffer from inefficient utilization of cache resources. Specifically applications can suffer from cache thrashing due to large thread count small cache sizes and limited cache capacity per thread.

When the massively multithreaded nature of GPUs is combined with irregular memory access patterns little effective cache capacity may be available per thread resulting in high cache miss rates and reducing the amount of temporal locality that can be exploited. Such behavior often results in low reuse of cache blocks both temporally and spatially and may waste memory bandwidth on chip storage and dynamic random access memory DRAM power. Thus there is a need for addressing this issue and or other issues associated with the prior art.

A system method and computer program product are provided for providing prioritized access to processor resources in a multithreaded processing environment. The method includes the steps of allocating threads to process a workload and assigning a set of priority tokens to at least a portion of the threads. Access to a resource by each one of the threads is based on the priority token assigned to the thread and the threads are executed by a multithreaded processor to process the workload.

A priority based resource management technique for massively threaded processors with limited resources may be used to provide prioritized access to the limited resources during multithreaded processing. For example when per thread cache capacity is limited the priority based technique may improve reuse of cache blocks both temporally and spatially. Priority tokens may be assigned to software entities e.g. threads or thread groups that specify a priority for each thread to perform various cache actions including allocation fill and replacement eviction . In addition to influencing caching the priority tokens may also be used to influence other memory system resources and interconnect resources.

In one embodiment mechanisms and policies for assignment transfer and release of the priority tokens may be provided. When using a token priority based approach for implementing resource access policies priority tokens may be allocated assigned transferred and released to influence performance throughput and or power consumption.

At step a set of priority tokens is assigned to at least a portion of the threads. Access to a resource by each one of the threads is based on the priority token assigned to the thread. In the context of the present description the resource may include one or more of cache storage communication or interconnect bandwidth and a scheduler processing pipeline or processing unit. A priority token may specify a single priority for all resources accessed by the thread or a priority for at least one resource accessed by the thread. One or more additional priority tokens may be used to enable access priority for different resources or a different combination of resources that may be accessed by a thread.

At step the threads are executed by a multithreaded processor to process the workload. In one embodiment the priority token assigned to a first thread may be released and or transferred to a second thread during execution of the first thread. The priority tokens are utilized to grant threads priority access to resources during execution of the workload.

More illustrative information will now be set forth regarding various optional architectures and features with which the foregoing framework may or may not be implemented per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

In one embodiment the PPU includes an input output I O unit configured to transmit and receive communications i.e. commands data etc. from a central processing unit CPU not shown over the system bus . The I O unit may implement a Peripheral Component Interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the I O unit may implement other types of well known bus interfaces.

The PPU also includes a host interface unit that decodes the commands and transmits the commands to the grid management unit or other units of the PPU e.g. memory interface as the commands may specify. The host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory e.g. memory or system memory that is accessible i.e. read write by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the grid management unit GMU with pointers to one or more streams. The GMU selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.

A work distribution unit that is coupled between the GMU and the SMs manages a pool of active grids selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the GMU when a pending grid is eligible to execute i.e. has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit and the work distribution unit the GMU also receives grids that are dynamically generated by the SMs during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.

In one embodiment the CPU executes a driver that implements an application programming interface API that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions i.e. API calls that cause the driver to generate one or more grids for execution. In one embodiment the PPU implements a SIMD Single Instruction Multiple Data architecture where each thread block i.e. warp in a grid is concurrently executed on a different data set by different threads in the thread block. The driver defines thread blocks that are comprised of k related threads such that threads in the same thread block may exchange data through shared memory. In one embodiment a thread block comprises 32 related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may exchange data through global memory.

In one embodiment the PPU comprises X SMs X . For example the PPU may include 15 distinct SMs . Each SM is multi threaded and configured to execute a plurality of threads e.g. 32 threads from a particular thread block concurrently. Each of the SMs is connected to a level two L2 cache via a crossbar or other type of interconnect network . The L2 cache is connected to one or more memory interfaces . Memory interfaces implement 16 32 64 128 bit data buses or the like for high speed data transfer. In one embodiment the PPU comprises U memory interfaces U where each memory interface U is connected to a corresponding memory device U . For example PPU may be connected to up to 6 memory devices such as graphics double data rate version 5 synchronous dynamic random access memory GDDR5 SDRAM .

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the PPU . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various SMs . In one embodiment each of the SMs also implements an L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .

In one embodiment the PPU comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes associated with each vertex of the primitive. Attributes may include one of more of position color surface normal vector texture coordinates etc. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display . The driver implements a graphics processing pipeline such as the graphics processing pipeline defined by the OpenGL API.

An application writes model data for a scene i.e. a collection of vertices and attributes to memory. The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver that requests the model data to be rendered and displayed. The driver reads the model data and writes commands to the buffer to perform one or more operations to process the model data. The commands may encode different shader programs including one or more of a vertex shader hull shader geometry shader pixel shader etc. For example the GMU may configure one or more SMs to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the GMU may configure different SMs to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA a digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PPU may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPU may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

As described above the work distribution unit dispatches active grids for execution on one or more SMs of the PPU . The scheduler unit receives the grids from the work distribution unit and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different thread blocks allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units i.e. cores DPUs SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. 192 etc. of distinct processing cores . Each core is a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M DPUs that implement double precision floating point arithmetic N SFUs that perform special functions e.g. copy rectangle pixel blending operations and the like and P LSUs that implement load and store operations between the shared memory and the register file via the J texture unit L1 caches and the interconnect network . The J texture unit L1 caches are coupled between the interconnect network and the shared memory and are also coupled to the crossbar . In one embodiment the SM includes 64 DPUs 32 SFUs and 32 LSUs . In another embodiment the L1 cache is not included within the texture unit and is instead included with the shared memory with a separate direct connection to the crossbar .

Each SM includes an interconnect network that connects each of the functional units to the register file and to the shared memory through the interconnect network . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file to any of the J texture unit L1 caches or the memory locations in shared memory .

In one embodiment the SM is implemented within a GPU. In such an embodiment the SM comprises J texture unit L1 caches . The texture unit L1 caches are configured to access texture maps i.e. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs. The texture unit L1 caches implement texture operations such as anti aliasing operations using mip maps i.e. texture maps of varying levels of detail . In one embodiment the SM includes 16 texture unit L1 caches . As described further herein the texture unit L1 caches are also configured to receive load and store requests from the LSUs and to coalesce the texture accesses and the load and store requests to generate coalesced memory operations that are output to a memory system that includes the shared memory . The memory system may also include the L2 cache memory and a system memory not shown .

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

As previously explained in conjunction with a priority based resource management technique may be used to provide prioritized access to the limited resources during multithreaded processing. Examples of resources that may be accessed using a priority based scheme include the texture unit L1 cache the register file the functional units e.g. cores DPUs SFUs and LSUs the interconnect network the shared memory the crossbar the L2 cache the memory interface and the memory . The scheduler unit may be configured to assign a priority token to each thread that specifies an access priority granted to the thread when accessing one or more of the resources. The scheduler unit may be configured in response to a program instruction software controlled operating mode or circuitry implementing the scheduler unit in order to control the assignment of priority tokens. In one embodiment the priority token may be used to specify a scheduling priority used by the scheduler unit to determine which threads to select for output to the dispatch unit s . Alternatively threads that are assigned a priority token for priority access of a resource may be given scheduling priority by the scheduler unit .

Furthermore although the allocation of the priority tokens is described as being performed by the scheduler unit other units in the PPU may be configured to perform at least a portion of the priority token allocation. For example the work distribution unit may be configured to allocate priority tokens and provide the allocated priority tokens to the SM to assign to particular threads and manage. Distributing the allocation of priority tokens and management of priority tokens in such a manner may be particularly applicable to provide prioritized access to memory system resources having limited capacity such as the L2 cache . The work distribution unit may be configured to determine that a given kernel launch only uses 12 of 15 SMs in a particular embodiment of the PPU so the work distribution unit may allocate 1 12th of the total priority tokens of a type that enables priority access to the L2 cache to each thread group that is sent to one of the 12 SMs . In other words the work distribution unit may be configured to manage the number of priority tokens of one or more types that are allocated to an SM or a thread group while the scheduler unit manages the fine grained assignment of the allocated priority tokens to threads or warps. When a kernel exits the SM the priority tokens assigned to the exiting threads or warps may be returned to the work distribution unit for reallocation.

The scheduler unit includes a thread state storage that is updated as needed to track the state of each thread. For each thread that may be allocated to execute a sequence of instructions the thread state storage stores one or more priority tokens and other state . The other state may indicate whether the thread state is allocated a program counter corresponding to an instruction a flag indicating whether an allocated thread is active or idle and other state associated with a thread that is allocated or available to be allocated.

A priority token may be associated with an individual resource or with a combination of resources so that different priority token types may be used. Examples of the different resources to which access may be controlled via priority tokens individually or in combination include the register file the shared memory the texture unit L1 cache the interconnect network the crossbar the memory interface the memory and the L2 cache .

For example a first type of priority token may be used to enable disable priority access for the texture unit L1 cache and a second type of priority token may be used to enable disable priority access for the L2 cache . In another embodiment a first type of priority token may be used to enable disable priority access for a first portion of the memory system resources e.g. the texture unit L1 cache the register file the shared memory and the interconnect network and a second type of priority token may be used to enable disable priority access for a second portion of the memory system resources e.g. the L2 cache and the memory and interconnect resources e.g. the crossbar and the memory interface . The first and or second type of priority token may be configured to represent two or more levels of priority access.

In one embodiment the quantity of each type of priority token may be limited so that only a portion of the allocated threads may be assigned priority tokens of a particular type. A priority limit may be defined for each type of priority token . Alternatively a priority limit may be defined for an individual resource or for each resource combination. In one embodiment the priority limit is the maximum number of allocated threads for which access priority is enabled. For example a first priority token type may enable disable access priority for an L1 cache and second priority token type may enable disable access priority for an L2 cache. A thread that is assigned a priority token of the first priority token type has priority access enabled for the L1 cache. A thread that is assigned a priority token of the second priority token type has priority access enabled for the L2 cache. A single thread may be assigned priority tokens of the first and second types. In one embodiment each priority token may be implemented using a single bit that is set to TRUE for a thread to which a priority token is assigned. In one embodiment instead of using two separate types of priority tokens a single priority token type is used and threads that are assigned a priority token have the bit set to TRUE and have priority enabled for accessing the L1 cache while threads that are not assigned a priority token have the bit set to FALSE and have priority enabled for accessing the L2 cache. In other embodiments two or more bits may be used to encode the priority token and two or more different priority types e.g. priority levels or combinations of access in terms of access to memory system and or interconnect resources may be supported.

The priority limit for each token type may be the same or different and may be static or may change dynamically. In one embodiment a hill climbing algorithm may be used to dynamically tune the priority limit s for performance. For example the scheduler unit may be configured to successively decrease a first priority limit specified for a priority token that enables access priority for an L1 cache when the number of cache line hits in the L1 cache is less than or equal to a threshold value. In another embodiment priority limit s may be adjusted to optimize for different interleavings of data stored in a memory and specific sequences of program instructions. For example when a number of threads having a particular program counter reaches a threshold value a priority limit may be increased or decreased to modify the number of threads that have priority access to a particular resource for the execution of the specific sequence of program instructions. The priority limits may be determined by software hardware or a combination of software and hardware.

The assignment of a set of priority tokens to threads may be performed using a variety of different policies where each priority token in the set is of the same type and the number of priority tokens in the set does not exceed the priority limit for the type. In one embodiment thread age is used to determine the assignment of priority tokens so that the N oldest allocated threads are assigned N priority tokens in the set. In another embodiment the scheduler unit may be configured to evenly distribute the number of priority tokens in a set between one or more thread groups when assigning tokens to the allocated threads. In one embodiment priority tokens are only assigned to allocated threads that are eligible to be dispatched for execution. In other words priority tokens are only assigned to allocated threads whose execution is not blocked waiting for another event e.g. read or write access to complete . In another embodiment the scheduler unit may be configured to use working set prediction to determine which allocated threads can coexist or access a cache e.g. texture unit L2 cache and or L2 cache with minimal thrashing and the scheduler unit may assign priority tokens to allocated threads that can coexist.

A set of priority tokens may be divided into two or more subsets for assignment to allocated threads. For example a first subset may be allocated to the oldest allocated threads and a second subset may be allocated to the remaining allocated threads. Assuming the priority token type provides access priority for a cache resource the first subset provides guaranteed cache usage permission for the oldest allocated threads. When the access priority is enabled for each oldest allocated thread until the thread exits the access priority provided by the priority tokens may be exchanged between different threads at certain intervals such as when a specified number of cycles or cache access requests have occurred. The second subset provides the remaining allocated threads with some cache access and the priority tokens may be exchanged between different threads at a faster rate because the threads need not exit before the priority token is released and reassigned i.e. exchanged or transferred to another thread.

One or more priority tokens may be used by the scheduler unit to influence scheduling decisions or a selection process when threads are selected for execution. The scheduler unit outputs threads that are selected for execution to the dispatch unit s and the priority token s associated with each thread are provided to the dispatch unit s . In another embodiment the dispatch unit s or the LSUs read the priority tokens associated with each executing thread. The dispatch unit s output threads and associated priority tokens to the processing pipeline that includes the functional units of the SM . The one or more load store unit s in the processing pipeline may output a memory request packet to store processed data that is generated during execution of a thread to the memory system or to load data from the memory system during execution of a thread. The memory system may include one or more of the shared memory the register file the texture unit L1 caches the interconnect network the L2 cache and the memory . The memory system may also include the interconnect resources e.g. the crossbar and the memory interface . The memory request packet also includes an address control and the priority token s assigned to the thread which generated the memory request packet . The control may specify the memory operation e.g. read or write .

When the priority token s specify an access priority e.g. levels enabled or disabled for a cache resource such as the texture unit L1 cache various cache actions may be performed for the thread based on the access priority token s . For example a priority token may be used to specify per thread priority for allocation i.e. fill and replacement i.e. eviction of entries in the cache. The priority token s assigned to the thread may be stored in a cache control unit and may be associated with the cache line in a cache storage unit that is allocated to store the processed data for a write operation or to store data for a read operation.

The cache control unit may be configured to implement an opportunistic caching policy where threads or warps with higher priority i.e. assigned a priority token are allowed to use the texture unit L1 cache as normal filling new data and evicting old data. Threads warps with lower priority may opportunistically use cache space when entries or blocks do not contain higher priority data but the lower priority threads i.e. not assigned a priority token or holding a lower priority token are restricted from evicting other data based on priority. The cache control unit may also be configured to take priority into account when selecting eviction candidates to implement a replacement policy.

In one embodiment different levels of a priority token can be defined to allow more than two priority levels e.g. enabled and disabled priority . For example a first priority token level may indicate guaranteed access to a cache strongly cached . Threads assigned a lower priority token level defer to threads that are assigned the first priority token level and threads that are not assigned a priority token have no cache access privilege. Only threads holding a higher or equivalent priority token may induce eviction of cached data marked with a given priority token level.

The cache control unit may be configured to determine whether a memory request packet generated for a first thread has priority compared with entries in the cache storage unit associated with any other threads. The priority token s may be used by the cache control unit to determine whether to allocate a cache entry to the thread. When no entry is available to be allocated the priority tokens stored in the cache control unit may be used to determine a replacement policy and identify a cache entry to be evicted i.e. victim selection .

At step a memory request packet arrives at the cache control unit . At step the cache control unit determines if the requested data is cached in the cache storage unit i.e. a cache hit . If the data is available at step the priority token associated with the cache entry storing the requested data is updated to reflect the priority of the request when the priority token s in the memory request packet is a higher level than the token priority associated with the cache entry. At step the memory operation specified by the memory request packet is completed. Otherwise at step the cache control unit determines if an entry is available in the cache storage unit to allocate for completing the memory operation specified by the memory request packet .

If an entry is available at step the entry is allocated and at step the priority token s included in the memory request packet are stored in the cache control unit or another unit. Otherwise at step the priority token s are compared with the priority tokens associated with the cache entries that are allocated. In one embodiment a victim with lesser or equal priority compared with the priority token s may be selected for eviction. If there is an entry in the cache storage unit that is not allocated to a high priority thread the entry can be allocated to a lower priority or non token holding thread. Specifically at step if the cache control unit selects an entry for eviction based on the relative access priorities specified by the priority token s then at step the selected cache entry is allocated and the priority token s are stored in the cache control unit .

Otherwise if the cache control unit does not select an entry for eviction i.e. an entry with lower or equal priority based on the relative access priorities specified by the priority token s then the memory request is prevented from allocating space or filling data into the cache so that lower priority threads do not contaminate the cache. At step memory request packet is transmitted through the memory system for completion. At step the memory operation specified by the memory request packet is completed.

By granting only selective group of threads access priority for a resource such as the texture unit L1 cache and or the L2 cache the threads that have access priority enabled operate as if they have exclusive use of the resource enabling reduced memory latency higher memory access bandwidth etc. Threads that do not have access priority enabled have less chance of using the resource. Therefore cache pollution and cache thrashing are reduced. When using a token priority based approach for implementing caching policies scheduling and communication access priority tokens may be allocated assigned transferred and released to optimize resource access for performance throughput and or power consumption.

In one embodiment the priority token s are not stored in the cache control unit and memory request packets having a priority token that disables access priority for the texture unit L1 cache are not allocated an entry in the cache storage unit even when an entry is available. However if data requested by the memory request packet is available in the cache storage unit the data may be provided by the cache storage unit rather than requesting the data from memory. When data that is requested is not available in the cache storage unit the memory request packet is transmitted to the additional memory system units to complete the memory operation.

In addition or assigning priority tokens to threads the scheduler unit may also be configured to reassign or transfer priority tokens from one thread to another during execution of the threads. In one embodiment the scheduler unit may be configured to only transfer priority tokens from threads that have exited i.e. completed execution and a released priority token is transferred to the oldest thread. In other words the oldest N threads are assigned priority tokens and once a priority token is assigned to a thread the thread retains the priority token until the thread exits.

In one embodiment the scheduler unit is configured to release and or transfer priority tokens before a thread exits. The scheduler unit may employ a round robin scheme to rotate priority tokens from the threads in one warp to another as the scheduling priority of the different warps changes after every i cycles transpire after i memory requests occur after every i instructions are executed or in response to a hardware or software defined event.

The scheduler unit may be configured to release a priority token when a thread reaches a token specific instruction such as a  releaseToken directive that may be inserted into a program by a device driver compiler or programmer. Similarly the scheduler unit may be configured to assign a priority token when a thread reaches another token specific instruction such as an  acquireToken directive that may be inserted into a program by a device driver compiler or programmer. When a priority token is not available the thread may wait until a priority token is released. The directive may specify the type of priority token to be acquired or released. In one embodiment the scheduler unit may be configured to release a priority token when a thread reaches a particular software defined location in a program such as at a synchronization barrier instruction i.e. syncthreads where the threads in a warp wait before continuing execution until each thread in the warp has reached the synchronization barrier instruction.

During execution of a thread priority tokens may be assigned to the thread and released. Execution of the thread may be influenced by the priority tokens that are assigned to the thread. At step a thread is allocated to process a workload. At step the scheduler unit determines if a priority token will be assigned to the thread. If not at step the thread state corresponding to the thread is updated to set the priority token as FALSE indicating that the thread access priority is disabled for the thread. The priority token may enable disable access to an individual resource or to a combination of resources.

If the scheduler unit determines that a priority token will be assigned to the thread then at step the thread state corresponding to the thread is updated to set the priority token as TRUE indicating that the thread access priority is enabled for the thread. The steps and step or may be repeated by the scheduler unit for different types of priority tokens. At step the thread is executed for one or more instructions. At step the scheduler unit determines if the thread has completed execution and exited. If the thread has exited then at step the scheduler unit releases the priority token s from the thread by updating the thread state corresponding to the thread so that the priority token is set as FALSE indicating that the thread access priority is disabled for the thread. The scheduler unit may then assign each priority token to another thread thereby transferring one or more priority tokens between threads. The scheduler unit may also allocate the thread to process another workload.

If at step the scheduler unit determines that the thread has not exited then at step the scheduler unit determines if the priority token should be released. When multiple priority tokens are assigned to the thread the scheduler unit may determine if one or more of the multiple priority tokens should be released. In one embodiment the scheduler unit may release the priority token when each instruction is executed for the thread. If the priority token or none of the multiple priority tokens should be released then the thread resumes execution at step . Otherwise at step the scheduler unit releases the priority token s from the thread before returning to step . The scheduler unit releases the priority token s by updating the thread state corresponding to the thread so that each released priority token is set as FALSE indicating that the thread access priority is disabled for the thread. At step the scheduler unit may assign one or more of the released priority tokens to the thread or may assign a different priority token to the thread.

The priority token s that are assigned and released using the method may influence per thread or per warp access for an individual resource or a combination of resources. In addition to a cache memory resources may include other memory system units and interconnect. More generally the overall concept of opportunistic use of idle under utilized hardware resources while guaranteeing priority of use to higher priority entities e.g. entities to which priority tokens are assigned can be applied to other areas in computing such as virtualized server environments. For instance in a cloud computing environment a customer may pay extra for guaranteed compute capacity while leaving resources idle at times which could be opportunistically consumed by other users.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of the present application should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following and later submitted claims and their equivalents.

The system also includes input devices a graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit GPU .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk DVD drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner.

Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. The memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor a chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit board system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant PDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

