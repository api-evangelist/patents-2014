---

title: Secure and efficient authentication using plug-in hardware compatible with desktops, laptops and/or smart mobile communication devices such as iPhonesâ„¢
abstract: A portable apparatus is removably and communicatively connectable to a network device to communicate authentication or authorization credentials of a user in connection with the user logging into or entering into a transaction with a network site. The apparatus includes a communications port to connect and disconnect the apparatus to and from the network device and to establish a communication link with the network device when connected thereto. A processor receives a secure message from the network security server via the port. The message has a PIN for authenticating the user to the network site, and is readable only by the apparatus. The processor either transfers, via the port, the received PIN to an application associated with the network site that is executing on the network device or causes the apparatus to display the received PIN for manual transfer to the application associated with the network site.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09444809&OS=09444809&RS=09444809
owner: AUTHENTIFY, INC.
number: 09444809
owner_city: Chicago
owner_country: US
publication_date: 20140617
---
This application claims priority based on Provisional U.S. Application Ser. No. 61 533 820 filed Sep. 13 2011 and entitled Extending Device Based Authentify 2CHK Functionality . This application is also a continuation in part of pending application Ser. No. 12 938 161 filed Nov. 2 2010 and entitled A NEW METHOD FOR SECURE SITE AND USER AUTHENTICATION which claims priority based on Provisional U.S. Application Ser. No. 61 257 207 filed Nov. 2 2009. This application is also a continuation in part of pending application Ser. No. 13 011 587 filed Jan. 21 2011 and entitled A NEW METHOD FOR SECURE USER AND TRANSACTION AUTHENTICATION AND RISK MANAGEMENT which claims priority based on Provisional U.S. Application Ser. No. 61 298 551 filed Jan. 27 2010. This application is also a continuation in part of application Ser. No. 13 011 739 filed Jan. 21 2011 and entitled A NEW METHOD FOR SECURE USER AND TRANSACTION AUTHENTICATION AND RISK MANAGEMENT which is a continuation in part of pending application Ser. No. 13 011 587. This application is also a continuation in part of pending application Ser. No. 13 081 067 filed Apr. 6 2011 and entitled SECURE AND EFFICIENT LOGIN AND TRANSACTION AUTHENTICATION USING IPHONES AND OTHER SMART MOBILE COMMUNICATION DEVICES which claims priority based on Provisional U.S. Application Ser. No. 61 327 723 filed Apr. 26 2010. This application is also a continuation in part of pending application Ser. No. 13 081 150 filed Apr. 6 2011 and entitled FLEXIBLE QUASI OUT OF BAND AUTHENTICATION ARCHITECTURE which claims priority based on Provisional U.S. Application Ser. No. 61 334 776 filed May 14 2010. This application is also a continuation in part of pending application Ser. No. 13 089 430 filed Apr. 19 2011 and entitled KEY MANAGEMENT USING QUASI OUT OF BAND AUTHENTICATION ARCHITECTURE . This application is also related to pending application Ser. No. 13 006 806 filed Jan. 14 2011 and entitled A NEW METHOD FOR SECURE USER AND SITE AUTHENTICATION which is a continuation of pending application Ser. No. 12 938 161. The contents of the above identified applications are hereby incorporated herein in their entirety by reference.

This invention relates to security and privacy. More particularly it relates to web based login and transaction authentication including web based signatures using hardware plug in devices compatible with desktop and or laptop computers and or smart mobile communication devises such as Apple iPhones .

User authentication using techniques such as passwords one time passwords OTPs hardware or software smartcards etc. have all proven to be either too weak and susceptible to man in the middle MITM or man in the browser MITB attacks or else have proven too cumbersome and expensive. The use of single sign on techniques such as OpenID FaceBook Connect etc. only make the problem worse as once the attacker has compromised the master account they can now break into all other accounts that rely on that initial login. Further the focus of attackers has shifted from trying to break the login process to using sophisticated techniques to come in after the act of login and to attack the transactions being performed. This has made transaction authentication the act of confirming if the transaction seen at the back end web server is identical to that intended by the user even more important.

Out of band authentication OOBA a technique by which a transaction is relayed to the user and confirmation obtained using an alternate form of communication for instance by placing a voice phone call or a text message is a promising alternative but is also to inconvenient and costly to be used very often. It might be useful for the highest value transactions or rare events like password resets but using it for large numbers of transactions is too costly and cumbersome.

In our work we developed innovations that address some of these problems. Specifically we introduce the notion of the establishment of a security server that communicates with an independent pop up window on the user s desktop that is being used to access the website. We determine how this security server can alert the user via communications to the pop up as to the legitimacy of the website the user is browsing via their browser. We also determine how this pop up window can provide a user with a one time password to enable login into the website i.e. authentication of the user to the website based on a secret shared between the website and the security server. Of particular utility is the fact that it provide the security of one time passwords but did not require a per user shared secret which all prior one time password systems have required. We refer to this using various terms such as quasi out of band authentication QOOBA 2CHECK 2CHK authentication and Authentify authentication.

It is common when users browse an eCommerce website such as a merchant bank or broker website for them to see Payment Buttons such as that provided by PayPal. When the user clicks on that payment functionality the user is typically interacting directly with the payment provider. This means the user does not reveal their credentials for authenticating to the payment provider to the eCommerce site. This is an important feature that is no longer available when a user is interacting with the eCommerce site using a smart phone app the site provides.

Thus we extend that work to provide a separate secure client application which has an independent secure communication channel to a back end authentication server. This client application is sometimes referred to as the QOOBA application or the QOOBAA for short 2CHK client . or the Authentify Application or AA for short. This client application can be used to show users transactions either to inform them of the transaction allow the user to confirm deny the transaction and or provide the user with a transaction signature which he she can use in another application such as a merchant or bank website application. Further the client application can also provide the user with an OTP that can be used to login to different websites or other applications. We also develop two distinct methods of generating such OTPs. One in which the OTP is provided by the authentication server and the other in which the client application is seeded during activation so it can then generate OTPs without any connection to the backend authentication server.

Additionally we determine how this client application can be implemented as dedicated software on a computing device or as a browser based application or as an application on a mobile communications device including a smart phone.

The profusion of smart phones has resulted in the coming to market of adjunct pieces of hardware that can attach to the smart phones using various interfaces. Much like one can attach a printer to a computer using a USB port and or cable one can also attach devices to smart phones using for instance the ubiquitous headphone jack.

The innovations described herein also further extend our work to provide for efficient and secure login authentication and transaction authorization using plug in hardware compatible with smart mobile communication devices and Internet connectable personal computing devices.

The present invention is directed to providing improved login authentication and or transaction authorization that is easily implemented on personal computing devices and smart mobile communication devices such as iPhones and iPads using adjunct hardware.

Additional objects advantages novel features of the present invention will become apparent to those skilled in the art from this disclosure including the following detailed description as well as by practice of the invention. While the invention is described below with reference to one or more preferred embodiments it should be understood that the invention is not limited thereto. Those of ordinary skill in the art having access to the teachings herein will recognize additional implementations modifications and embodiments as well as other fields of use which are within the scope of the invention as disclosed and claimed herein and with respect to which the invention could be of significant utility.

According to aspects of the present invention a portable apparatus or hardware device such as a smart card or iPhone plug in device etc. is removably and communicatively connectable to a network device such as a smart phone or other smart mobile communication device in order to communicate authentication credentials of a user in connection with either i the user logging into a network site such as a merchant or bank website or ii the user entering into a transaction such as the purchase of a product or the movement of funds with the network site. The apparatus includes a communications port which can for example be a hardwired port such as a USB port or headphone plug jack or a wireless port such a Bluetooth port. The port is configured so as to be capable of connecting and disconnecting the apparatus to and from the network device and when connected establishing a communication link between the apparatus and the network device to which it is connected. Also included is a processor configured with the logic e.g. software programming to 1 receive from a network security server via the port a secure message that includes a personal identification number PIN for authenticating the user to the network site and is readable only by the processor and not by the network device. The PIN is preferably an OTP. The processor is also configured to i transfer via the port the received PIN to an application associated with the network site and executing on the network device such as a log in web page or a transaction approval web page associated with the network site or ii cause the apparatus to display the received PIN to the user for manual transfer of the PIN to the application associated the network site. The display is typically but not necessarily on a display screen incorporated as part of the apparatus 

Preferably the PIN corresponds to a secret shared only by the security server and the network site and not by the user. The shared secret is also most preferably not associated with any particular user.

According to other preferred aspects of the invention the apparatus may further include a data store. If so the processor is preferably further configured to receive a request of the user to login to the security server and to direct transmission from the port of the request and a user identifier such as a home or cell phone number to the security server via the network device. The processor is also configured to receive a user input including another PIN which is also preferably and OTP and to direct transmission from the port to the security server via the network device of the input other PIN. The port is further configured to receive from the security server via the network device a session cookie and active session information indicating a period of time during which the session with the security server will remain active in response to transmission of the other PIN. The data store is configured to store the session cookie so as to be accessible only to the processor.

According to still other aspects of the invention the port may also or alternatively be configured to receive a seed from the security server via the network device. If so the processor is preferably configured to direct storage of the received seed in a data store which could if desired be the same data store as that referred to above. After the portable device is disconnected from the network device the processor is configured to display the stored seed to the user at the apparatus for entry by the user into a seeding interface of a token and or to enter the stored seed into a seeding interface of the token without user intervention. It should be understood that the received seed could be an intermediate seed for processing by the token to generate the final seed.

If the user is entering into a transaction with the network site the processor is beneficially further configured to receive from a network security server via the port a secure message readable only by the processor and not by the network device including information associated with the transaction typically transaction details. The processor can then cause the apparatus to display for example on a screen that is included in the apparatus the received transaction information to the user.

In an exemplary practical implementation a first application executing on the network device e.g. a smart phone receives a request for authentication of the user in connection with either the user logging into a network site e.g. a merchant or bank or broker website or the user entering into a transaction e.g. a purchase or movement of account funds with the network site. A second application executing on a portable device such as a smart card or other portable hardware capable of being connected to the network device receives a secure message from a network security server via the network device to which it is connected after receipt of the request for authentication by the first application. The secure message includes a PIN which is readable only by the second application for authenticating the user to the network site. That is the PIN is not readable by the network device. The received PIN is transferred to the first application and the first application directs transmission of the transferred PIN from the network device to the network site to authenticate the user or authorize transaction to the network site.

The received PIN may be manually or automatically transferred to the first application. If manual preferably the first application directs a presentation to the user by the network device of a web page associated with the network site that includes the request for authentication. The second application directs a presentation of the received PIN to the user by the portable device connected to the network device. The received PIN can then be manually transferred to the first application by the user inputting the PIN presented by the portable device into the web page presented by the network device.

The second application may if desired store the received PIN in a public data store such as a pasteboard within network device. If so the received PIN can be transferred to the first application by the first application automatically retrieving the stored PIN from the public data store.

If so desired authentication of the user to the security server can also or alternatively be performed. In such a case the second application receives a request of the user to login to the security server and directs transmission of the request and a user identifier e.g. a phone number to the security server via the network device. A third application executing on the network device such as a text message application receives a message including another PIN here again preferably a OTP from the security server in response to the transmitted request. The third application directs a display by the network device of the other PIN to the user. The second application next receives a user input including the displayed other PIN and directs transmission of the input other PIN to the security server via the network device. In response to transmission of the other PIN the second application receives a session cookie and active session information from the security server via the network device. As discussed above the active session information indicates a period of time during which the session between the second application and the security server will remain active. The second application stores the session cookie in a private data store on the portable device that is accessible only to the second application. On the other hand it stores the active session information in a public data store accessible to the first application.

If certain seeding functionality is provided the second application receives a seed from the network security server via the network device. The received seed is stored so that after the portable device is disconnected from the network device the seed is presentable to the user at the portable device for entry by the user into a seeding interface of a token on the portable device and or enterable into the seeding interface of the token without user intervention.

If the received request for authentication is in connection with the user entering into a transaction with the network site the second application may beneficially receive from the network security server via the network device information associated with the transaction and direct a presentation to the user of the transaction information by the portable device.

In initial work we introduce a network based security server with an independent channel to a user pop up that can be used in conjunction with a user s browser and the website being visited to provide both website and user authentication via a single user network device. As noted above we sometimes refer to this as Quasi Out Of Band Authentication QOOBA or 2CHECK 2CHK authentication. It should be understood that the use of the term we should not be construed to imply multiple inventors participated in any particular invention described herein. Rather the term is sometimes used to reflect that others may have been involved in routine programming and other none inventive work relating to the particular invention being described.

A preferred embodiment for an authentication system is shown in . The system includes the following components 

The user will first go through a set up and personalization phase which is a one time process and will then start up or activate the pop up or using a technique such as out of band authentication OOBA . At this point the security server or will have an active communication channel or open to the user which it identifies by some user identifier for instance the phone number used for OOBA. Further the website or at which the user is visiting and the security server or would have previously agreed on a shared secret.

The user using the browser inputs a request to access to certain information that is transmitted by the browser or to the web server or via communication channel or . The web server or transmits this request to the security server or via the user s browser or via communication channels and or and as applicable. The security server or computes a one time login personal identification number PIN i.e. a one time password OTP to authenticate the user to the website as a function of the secret it shares with that particular website or . The security server or then transmits this one time login password to the user s pop up window or via communication channel or . The user cuts and pastes or otherwise copies this one time login password into the web browser or and the login password is transmitted back to the website or via communication channel or . The website or independently computes the login password using the secret it shares with the security server or and compares it with the one received from the user. If the two match then the web server or can be assured that the security server or is authenticating the same user that has requested access i.e. not someone else pretending to be the user who has intercepted the request en route to the security server and since the security server or is showing the user login password in an independent channel or user confirmation of the request is obtained.

Extensions to Transaction Signatures Utilizing Different Form Factors and Maintaining User Event Logs Described in Parent application Ser. No. 13 011 587

We extend this concept i. e. QOOBA to transaction authorization. Specifically when a website receives a transaction from a user browser which it wishes to confirm it sends the transaction information to the security server which forwards the transaction information to the user pop up which we sometimes refer to as the QOOBA Window along with a one time transaction signature which is computed based on a secret shared between the security server and the website server and on the transaction information. We sometimes refer to such as signature as a personal identification number PIN or a one time password OTP . As noted above the shared secret is not associated with any particular user. That is there is no requirement for a per user shared secret. The user transfers this one time transaction signature to the web server via the browser and the web server can recalculate the one time transaction signature and if there is a match can be assured that the user has confirmed the transaction.

We also extend the concept of a browser based pop up to different form factors. For instance the pop up can be implemented as a smart phone app as a dedicated part of a smart phone screen that is used only for this purpose or it could be implemented as a smartcard.

We additionally take advantage of the fact that the pop up or its substitute has a log of every user login and transaction. Traditionally risk engines watch user activity at a given website to determine suspicious behavior. Or in some cases networks of websites share such information. In other words data from the back end systems is analyzed. In our system the pop up s log of a user s login and transaction history provides a user centric front end way to capture this information and augment the capabilities of the risk engines.

In this initial extension of the above to network transactions and referring again to the user using the browser selects a transaction e.g. Pay Alice 100 which is transmitted by the browser or to the web server or via communication channel or . The web server or transmits this transaction to the security server or via the user s browser or over communication channels and or and as applicable. The security server or computes a one time transaction signature i.e. an OTP as a function of i the transaction details and ii the secret it shares with that particular website or . The security server or then transmits this one time transaction signature to the user s pop up window or via communication channel or . The user cuts and pastes or otherwise copies this one time transaction signature into the web browser or and the signature is transmitted back to the website or via communication channel or . The website or independently computes the transaction signature using the i the transaction details and ii the secret it shares with the security server or and compares it with the one received from the user. If the two signature s match then the web server or can be assured that the security server or saw the same transaction it sent i.e. not a transaction manipulated en route to the security server and since the security server or is showing the user the transaction in an independent channel or user confirmation of the transaction is obtained.

In summary the binding between the user the security server or acting as an identity provider and the website or which is the relying party in the case of transactions made over a network such as the purchase of a product by a user at the website is significantly strengthened. The security server or and the website or have a priori agreed on a shared secret the system is easily extended to use public key cryptography . Additionally as shown in the user has used some method for instance the security server communicating with OOBA server via communication channel and OOBA server communicating with the user s cell phone via OOBA communication channel to authenticate the user to the security server . Such authentication of the user to the security server is of course performed prior to the security server providing the user via the pop up window with the credentials required for authenticating to website e.g. for login purposes or for confirming a transaction with the website .

Thus when the user wishes to enter into a transaction at a website or such as the purchase of a product offered at the website or the transfer of funds from a bank account the website or communicated transaction details such as the type and amount of the transaction which were presented both on a web page displayed to the user via the user s browser or and on a pop up window or . Before proceeding with the transaction the website or required authentication and confirmation of the transaction or what is commonly referred to as a signature of the user on the transaction. Therefore the web page additionally displayed a blank for entry of the user s signature. Furthermore the website or also communicated a request for the user s signature on the identified transaction to the security server or . The security server or calculated an OTP for example the above described one time transaction signature as a function of i the secret it shares with the website or and ii the applicable transaction details displayed in the pop up window or and displayed the OTP to the user in the pop up window or . The user entered perhaps by cutting and pasting this OTP onto the web page which served as the user s signature on the transaction. The OTP i.e. the signature was then transmitted to the website or . The website or confirmed the authenticity of the signature by re computing the OTP from the secret it shares with the security server or and the transaction details. Here again this system has all the security properties of OTPs yet has the tremendous advantage that it does not require a shared secret with each user and it is only the security server or and the websites such as website or that need shared secrets for the purpose of generating OTPs used as signatures on transactions. The actual OTP can if desired also be constructed based on a time stamp or a counter based OTP algorithm in the way we use these algorithms the time or counter value needs to be communicated by the security server or to the website or or potentially be computed deterministically using some agreed upon formula.

In either of the above referenced preferred embodiments shown in as a user performs multiple logins and transactions the pop up or its substitute has the ability to store a history or log of these events such as by storing a User Activity Log as shown in . Such data can then be fed to risk management engines which today only have access to patterns of user activity that they observe from one or more websites. More particularly conventional risk analysis relies on data from websites. However because of the flow of information in QOOBA a log of data such as one of the type shown as User Activity Log in to capture the user s activities while the pop up window or is active can be easily maintained. The log could for example be maintained by the security server website or and the user can access this log. If desired the user or the security server or can compute the user s risk profile. Additionally or alternatively the logged data can be forwarded to a third party risk engine not shown where it can be married with data received from websites visited by the user so that the risk engine can provide the user with an augmented risk intelligence analysis.

Furthermore as noted above the pop up can be implemented in one of a variety of different form factors. One variety contemplates the pop up window being on an application on a mobile device another contemplates the window using a dedicated part of the display area of a personal mobile network device such as a smart phone and the last contemplates the pop up window being embodied in dedicated hardware similar to that of a smartcard which has communication capabilities. In all cases all functionality will work in exactly the same fashion except that the user can no longer cut and paste the OTPs used for authentication or authorization such as the one time login PIN or transaction signature described above and would instead have to type them into the web browser operating on a different network device. These form factors provide additional layers of security simply by being independent of the user s desktop computer running the browser. For example implementation on smart phone is easily accomplished because the phone is already personalized and in accordance with the techniques described above OTP generation relies on the use of a secret shared by only the website and security server and therefore the phone does not need to store a special secret or execute OTP software. Rather only the website and the security server need share the necessary secret and only the security server need generate the OTPs required for user authentication and user signature.

Extensions to Utilize Direct Communications Between Websites and the Security Server Described in Parent application Ser. No. 13 011 739

In a still further extension and referring now to another preferred embodiment allows for direct communications of authentication requests and transaction information between the website or and the security server or via communication channel or . More particularly as shown in the user first performs a set up and personalization phase which is a one time process and then starts up or activates the pop up or using a technique such as involving OOBA via OOBA server the user s cell phone and communication channels and as has been described above. At this point the security server or has an active communication channel or session open to the user which it identified by some user identifier for instance the phone number e.g. the user s cell phone number used for OOBA. Further the website or at which the user is transacting and the security server or have a previously agreed on shared secret.

The user uses browser or to select a transaction e.g. Pay Alice 100 which is transmitted by the user s browser or to the web server or . The web server or transmits this transaction to the security server or via a direct link or that has been established between the website or and the security server or rather than via the user s browser or . The security server or computes a one time transaction signature as a function of i the transaction details and ii the secret it shares with that particular website or . The security server or then transmits this one time transaction signature to the user s pop up window or . The user cuts and pastes or otherwise copies this one time transaction signature into the web browser or and the signature is transmitted back to the website or . The website or independently computes the transaction signature using the i the transaction details and ii the secret it shares with the security server or and compares it with the one received from the user. If the two signature s match then the web server or is assured that the security server or saw the same transaction it sent i.e. not a transaction manipulated en route to the security server or and since the security server or showed the user the transaction in an independent channel or session or user confirmation of the transaction is obtained.

Extension to Smart Mobile Communication Devices Including Smart Phones as Described in Parent application Ser. No. 13 081 067

As noted above the pop up can be implemented in one of a variety of different form factors. One variety contemplates the pop up window being on an application on a mobile device another contemplates the window using a dedicated part of the display area of a personal mobile network device such as a smart phone and the last contemplates the pop up window being embodied in dedicated hardware similar to that of a smartcard which has communication capabilities. In all cases all functionality will work in exactly the same fashion except that the user can no longer cut and paste the OTPs e.g. the one time login PINs and transaction signatures used for authentication and would instead have to type them into the web browser operating on a different network device. These form factors provide additional layers of security simply by being independent of the user s desktop computer running the browser.

In another extension of our work an innovative Modified Quasi Out Of Band Authentication MQOOBA protocol is used in lieu of the QOOBA protocol which we have previously described in implementations utilizing smart phones SPs such as iPhones and other sophisticated smart mobile communication devices. In accordance with this protocol a MQOOBA Application which is sometimes referred to the Hawk and Seal application and is referred to most often below as the Authentify Application AA or as the QOOBA application eliminates the need for and hence replaces the pop up window or what is sometimes referred to as the QOOBA pop up described above. The AA can be used 

The AA can be used to provide a secure payment method in conjunction with other SPAs and without the other SPAs learning the user credentials to the payment system. The AA is easily integrated into an on line banking application. In the following example the SP has the AA and a sample application for the eDuckies store. The AA and eDuckies Application EDA are assumed not to multi task in this example. Each has private storage no one else can see. The AA also has public storage any other SPA can see.

The user opens the AA and logs in perhaps once a day. For example either the user can enter his her phone number e.g. the phone number for the SP or the AA can auto fill in this information depending on the user s preference. Behind the scenes the AA talks to i.e. communicates with the authentication server also often referred to as a security server which then issues a login PIN to the user via a short messaging service SMS which is now commonly referred to as a text messaging service.

The user receives the text message with the Login PIN and enters the received Login PIN into the AA. On some SP platforms the AA can be configured if so desired to retrieve the PIN from the incoming SMS stream and auto fill the Login PIN in making it even easier for users. A private equivalent of a session cookie is stored by the AA and will be used by the AA for subsequent authentications to the authentication server to obtain transaction PINs i.e. transaction signatures when available. The AA also communicates with SPAs using the most appropriate method. A unique advantage of this invention is the ability to use public shared storage such as public pasteboards on the operating system of iPhones. The user is now logged in and a MQOOBA session is active.

The user may now start using other SPAs and return to the AA when needed. In this example the user now browses the EDA and eventually wants to place an order. eDuckies would like to get authorization of this order seamlessly. However it would be insecure to let the user provide payment credentials to the EDA.

Accordingly the EDA post the transaction to the authentication server which here serves as the payments system. The EDA also asks the user to authorize the transaction at the AA. This is similar to a user being redirected to a payments website such as PayPal to authorize a transaction. The authentication server will post the transaction to the AA for presentation to the user.

Back at the AA the user sees a transaction waiting gets it and sees that it looks legitimate. Accordingly the user authorizes the transaction. It should be understood that MQOOBA makes it extremely difficult for an attacker even one who somehow has placed a malicious eDuckies App on the user s phone to be able to fake this. The MQOOBA PIN is generated based on a shared secret between authentication server and legitimate merchant site in this case the eDuckies website and transaction information etc. if applicable.

After the user authorizes the transaction at the AA back at the EDA the user sees the PIN auto filled in for them. Behind the scenes the PIN was generated using the transaction information provided by the EDA and the secret shared by the authentication server and eDuckies website by the authentication server and transferred from the authentication server to the AA. The AA then transferred the PIN to the EDA on the user s SP using the shared storage. It should also be understood that if desired the user could be required to manually copy the PIN from the AA to the EDA instead of having the PIN automatically filled in. In either case after the PIN has been filled in on the EDA when the user clicks complete authorization the EDA sends the PIN to the eDuckies website. The eDuckies web service will re compute the PIN and let the AA know if it was valid or not.

As discussed above the AA gives a user dynamic login and transaction authorization PINs for particular merchant sites and for particular transactions. The AA can get these PINs from the authentication server website after having logged into it from within the AA.

Referring now to an SP is shown. The SP includes a CPU and display screen . The SP also has various SPAs executable by the CPU loaded therein including the AA EDA and SMS application SMSA for text messaging. As shown AA uses both public store and private store and EDA uses public store . Referring to the CPU can execute the AA to interact with the security server via communication channel and can execute the EDA to interact with the eDuckies website via communication channel and the security server via communication channel .

As shown in when execution of the AA is started it causes the display of a logo in the area A1 of the display screen . The display in area A1 request a user identifier such as the phone number e.g. a cell phone number associated with SP . Preferably the user has previously been allowed to select between a manual option which if selected would require the identifier to be manually filled in by the user and an automatic option which if selected would serve as a directive to the AA to pre populate the space provided in the display in area A1 with the applicable user identifier e.g. the cell phone number of the SP. See in the case of the iPhone http arstechnica.com apple news 2009 01 iPhone dev user phone numbers.ars .

When the user clicks the arrow in area A1 the AA causes a post via a first application programming interface API message to authentication server . The authentication server returns an acknowledgement indication to the AA and if the message was acknowledged the AA also causes the presentation of that shown in area A2 of the display screen depicted in . As indicated in area A2 if success the authentication server SMSs i.e. text messages a PIN to the user at the user s SMS address. By activating execution of the SMSA by the CPU the user can access his her SMS account and retrieve the PIN from the SMS message sent by the authentication server. The user then enters the PIN in the space provided in area A2 for example by cutting and pasting the PIN from the SMS message. After entering the PIN the user clicks on the arrow in area A2 and the AA sends a second API message to post the PIN.

As shown in the return message from the security server if success is a session cookie a random number we call nonce login and a time to live TTL and the AA causes the display shown in area A3 of the display screen .

It should be noted that rather than a choice just between manual and automatic fill the user could additionally or alternatively be allowed to select or be required to enter a user name in the area A1 and a password in area A2. It should also be understood that the choice between manual and automatic described above is only one such choice described herein. Thus another choice between manual and automatic will be described below in the context of transaction authorization and more particularly with respect to whether a different PIN i.e. a different OTP which is associated with a transaction authorization is conveyed by the AA to the EDA automatically or only after a manual input by the user.

Referring again to the session cookie is stored privately in private store . The nonce login and the TTL are stored publicly on a custom pasteboard the AA public pasteboard which is created within public store See in the case of the iPhone Custom Pasteboard development tool at Apple.com . When the user turns his her focus to the AA the AA always checks the nonce and TTL. If the TTL has timed out the AA causes the display of that shown in area A1 of the display screen of to begin again the log in to the authentication server .

Turning again to when the user is at some other SPA e.g. the EDA or some other website application and has been prompted for a PIN i.e. a OTP either for login or transaction authorization purposes the user is redirected to the AA as will be further discussed with reference to . For purposes of the description below we will assume the user is at the EDA. In conjunction with this redirection the EDA post information to the security server . This information includes whether login authentication or transaction authorization is requested the name of the merchant e.g. eDuckies and if transaction authorization is being requested text of the transaction. If the security server has the ability to PUSH information to the AA the security server causes a post of this information to the AA. The AA causes the display of either the information posted to it by the security server in area A4 of or what is shown in area A1 of if re login to the authentication server is required. For purposes of this discussion we assume area A4 is displayed.

Alternately if the security server has no ability to PUSH we rely on the user to PULL the data. This is the flow that is shown in the figures. When user clicks the arrow in area A3 of the AA causes a post to the security server . The post includes the session cookie described above.

The security server returns a success or failure message. The return message always returns a flag indicating login authentication or transaction authorization the name of the merchant e.g. eDuckies a new nonce login a new TTL and a PIN i.e. a OTP. If it is a transaction authorization it also returns the text of the transaction. If success than the AA causes the display shown in area A4 on the display screen of .

If the user clicks the stop sign the user is directed back to screen shown in . Preferably an alarm is sent to the security server to the EDA and from there to the merchant website and or to some other security related website.

On the other hand if the user clicks the arrow shown in area A4 of the display screen the nonce login and the TTL are written to the AA public pasteboard in public storage . The login or transaction PIN as applicable is also written to the pasteboard using the merchant identifier and PIN combination. The merchantid.PIN is written over any previous merchantid.PIN. The user is now again presented with the display shown in . Alternately if manual PIN transfer is the choice selected then the user will be shown the PIN within the AA and the onus is on the user to copy it from the AA to the EDA.

It is perhaps worthwhile to reemphasize here that as described in greater detail above the login or transaction PIN i.e. the login or transaction OTP is generated by the authentication server based on a secret shared by the authentication server and the website and not shared with or known to the user. Furthermore if transaction authorization is requested the transaction PIN is generated by the authentication server also using transaction information.

It should also be noted that the EDA checks if there is an AA public pasteboard having a login nonce with valid TTL for the user or associated with any particular user. If not it informs the user that he she does not appear to have logged into the AA. Here we have assumed that the user has logged in and that the EDA has determined that the AA public pasteboard has a valid nonce.

We turn now to . For purposes of this description we have also assumed that transaction authorization is involved. The user is at the EDA and is presented with the transaction information shown in area M1 of display screen . When the user clicks the arrow shown in area M1 he she is redirected to the AA and the AA post the information relating to the merchant and transaction to the authentication server . The post includes the login nonce. The security server returns a success or failure. If success then the AA presents the display shown in area M2 of the display screen depicted in to the user. If the user clicks on the arrow shown in area M2 the transaction authorization process described above is performed and the return message includes a string.

When focus returns to the EDA the EDA polls the AA pasteboard to see if there is a new merchantid.PIN. Once the EDA locates it it does a post to the eDuckies website of the string and the transaction authorization PIN. The website will return a success or a failure message after it does its own verification of the PIN. It should be noted here that if the manual PIN transfer option is chosen the user must enter the transaction authorization PIN into the EDA.

Extension to a Flexible Quasi Out of Band Authentication Architecture as Described in Parent application Ser. No. 13 081 150

The QOOBA solution has the following benefits in terms of ease of use total cost of ownership and of particular interest here security.

First with regard to ease of use the user has no new device to carry or password to remember beyond having access to the phone used for out of band authentication. The user does not have to enter any cryptic transaction code into a device and type the result into the browser. Instead the user sees the entire transaction in their QOOBA Window and can copy and paste the transaction signature with a few clicks.

Second with regard to total cost of ownership the QOOBA architecture significantly reduces total lifecycle costs. It requires no new hardware and unlike a soft token does not require per user provisioning and management of secrets. Further as all communications between the web site and the QOOBA server which is also referred to as the security server or authentication server can occur via the browser the integration requirements at the web site are extremely light. The overall costs of the QOOBA solution are designed to be significantly less than an equivalent soft token deployment and far less than that of a physical token.

Finally in terms of security as will be further discussed below the level of assurance depends on the form factor of the QOOBA Window that is used. The smartphone based QOOBA Window i.e. the QOOBA Phone Window provides the highest assurance but even the zero download pop up i.e. the QOOBA Pop up Window significantly raises the bar for an attacker. The software QOOBA window i.e. the QOOBA Software Window is likely to be satisfactory for almost all risk levels.

Further by implementing the QOOBA solution using the flexible architecture described below the web sites in the QOOBA Network are allowed to request or select the form factor appropriate for the transaction. For instance a user can simultaneously have a QOOBA Window on their smartphone as well as on their desktop. While most transactions can be sent to their desktop QOOBA Software Window which is far more convenient the highest risk transactions can be sent to their smartphone QOOBA Phone Window.

The flexible QOOBA architecture will now be described in greater detail and its security properties analyzed.

Referring now to the QOOBA system consists of a desktop personal computing device having the QOOBA Window and a Browser Window executing and displayed thereon a QOOBA Server and websites and each having a QOOBA API operable thereon. Also included in the system as shown is an OOBA Service which is utilized by the QOOBA Server to convey out of band communications e.g. authentication credentials to the user via the user s SP .

As described in more detail in the applications referenced above the user activates the QOOBA Window typically by using OOBA service and establishes a temporary session with the QOOBA Server . Websites participating in the QOOBA Network go through a onetime set up process to establish a shared secret with the QOOBA Server . When the user is at any of the websites he she can use the QOOBA API to request transaction authentication by sending the encrypted transaction to the QOOBA Server via user s Browser Window .

The QOOBA Server will display the transaction to the user in the QOOBA Window and if requested also display in the QOOBA Window a transaction signature derived from the transaction the secret shared between the QOOBA Server and the applicable website or and other information. The user is optionally given the choice of accepting or rejecting the transaction. Acceptance can be signaled passively by taking no action by clicking OK within the QOOBA Window or by copying and pasting the transaction signature from the QOOBA Window into the web application displayed in the Browser Window . If the transaction signature from the QOOBA Window is pasted into the web application displayed in the Browser Window the web site can verify the signature using the transaction the secret shared between the QOOBA Server and the applicable website or and other information as has been described in more detail in the applications referenced above.

The user interface to the QOOBA Server remains largely constant regardless of the browser and or operating system OS being used and the form factor of the QOOBA Window . The only use case in which the user experience deviates is when the user is browsing on a SP where the QOOBA experience is optimized for the device.

As noted above the QOOBA Window can be implemented in one of at least three form factors a browser pop up which we sometimes refer to as the QOOBA Pop up Window a which does not require any software download a small application that is installed on the desktop which we sometimes refer to as the QOOBA Software Window or as a smart phone app which we sometimes refer to as the QOOBA Phone Window.

The same user might well be using different form factors at different times. For instance a user who has the software QOOBA Window installed and uses that most of the time might use the browser pop up QOOBA Window while at some other desktop roaming . For certain high risk transactions the website might require showing the transaction on the SP QOOBA Phone Window while most transactions are shown in the desktop QOOBA Software Window. The look and feel of the QOOBA Window is entirely customizable by the particular QOOBA Network. An implementation for a bank intended solely for its own websites might look and feel very different from an implementation by a payment service that offers authentication into various eCommerce websites . While we are describing numerous elements it should be understood that most of them are optional.

Unlike a soft token the QOOBA Window itself does not contain any user secrets. There is provision to personalize it for the user and perhaps eventually there will be QOOBA Windows with different skins . Depending on the form factor the QOOBA Window can be automatically started for the user at boot up time or must be manually started by the user clicking on an application icon e.g. for the software or SP versions or on a bookmark e.g. for the pop up version.

An example of this is shown in . The user activates the QOOBA Window by performing OOBA for instance by entering a PIN sent via a short messaging service SMS now more commonly referred to as a text messaging service to the user s mobile phone . The user enters the PIN in another not shown QOOBA Window and a keyed hash of it is sent to the QOOBA Server over an encrypted connection.

The encryption is at two levels. First all traffic is run over SSL. Second all traffic is also encrypted at the application level using a key derived from the PIN. We also note that other non OOBA forms of authentication can be used at this step for instance to integrate the QOOBA solution with existing OTP deployments. The analysis here however assumes that OOBA is used.

As shown in at this point in addition to the activation button the QOOBA Window includes multiple other elements. One is a URL Bar showing the address of the QOOBA Server. Another is a personalization image which the user chooses in a one time step during the initial sign up for QOOBA. The primary purpose of this personalization image is to increase the difficulty of attacks where an attacker attempts to mimic a browser pop up based QOOBA Window . Once activated the QOOBA Window will show users their transactions as they are performed on the websites that are part of that QOOBA Network i.e. websites 

It should be noted that as the QOOBA Window and the QOOBA Server will be communicating over SSL it is highly preferred and hence recommended that EV SSL certificates be used. Both SSL and EV SSL certificates are well known and understood by those skilled in the art.

An example of a QOOBA Window displaying a transaction is depicted in . As shown in the QOOBA Window has a number of elements most of which are optional. These elements include the URL Bar showing the address of the QOOBA Server and the personalization image which the user chose during the initial sign up for QOOBA authentication. The elements additionally include a symbol that conveys the impression of flashing green when the user is transacting at a website that is part of the QOOBA Network e.g. website or . The elements also include a space where the name of the website the user is transacting at can appear. This website name can be the domain name as shown or the name of a merchant e.g. Hawk and Seal Bank Ltd. not shown . As shown in the space includes a display of the transaction the user is being asked to sign. The elements further include a comfort word which is a random dictionary word that will be shown to the user both in the QOOBA Window and next to the transaction displayed in the Browser Window . Finally the elements may include a transaction signature . As will be understood if this were an example of a QOOBA Window displaying a login rather than transaction screen the element might be characterized as an authentication PIN rather than transaction signature which likewise serves as a PIN. In any event as has been described above and will be further described below the PIN is computed at the QOOBA Server and sent to the QOOBA Window . The user simply cuts and pastes it from the Window into the part of the web application display in the Browser Window that asks for the signature. As discussed above the space occupied by the PIN can also be used to allow the user to signal to the QOOBA Server that the transaction is valid invalid for example by confirming that he she wishes to proceed with or refuses to confirm the transaction. However it should be recognized that the QOOBA Window can also be used to simply show the user the transaction. Thus the QOOBA Window can take different forms for example in one providing the user with a PIN for logging in to or signing a transaction with a website in another requesting the user s confirmation of a transaction and in still another simply presenting the user with a display of a transaction without the user being required to do anything further.

It should be understood that there are two modes in which the QOOBA Window can operate. A PUSH mode in which the transaction and PIN are simply pushed to the QOOBA Window without any action by the user and a PULL mode in which the user must click on a get transaction button not shown to retrieve the transaction and PIN. While the former is more convenient for the user there are some situations where the PULL mode is more apropos.

For instance in the iPhone implementation of the QOOBA Window the PULL mode is used as SP apps in all except the most recent release of that OS do not permit multi tasking.

Turning now to the QOOBA Server . The QOOBA Server has two primary functions. The first is to interact with the user and OOBA Service to activate QOOBA Window for the user. The other is to interact with pre registered web sites to receive transactions and display them to the user in the QOOBA Window .

The QOOBA Server does not maintain any user information. This means that the QOOBA Server has to be provided the phone number e.g. the number of the SP for the user either by the user or by performing a look up based on a UserID of the user. The QOOBA Server will then interact with the OOBA service to send the user a QOOBA Server PIN not shown that is used to set up a secure session between the QOOBA Server and QOOBA Window .

Websites that are part of the QOOBA Network served by the QOOBA Server such as websites must be pre registered with the QOOBA Server . The QOOBA Server shares a secret key with the server at each of the pre registered websites . While we have not described the use of public key cryptography for key exchange the QOOBA Network is easily adaptable to make use of such cryptography. The QOOBA Server can be implemented as an on premise solution or as a service available through an OOBA partner.

Participating websites execute the QOOBA API to use the QOOBA network. The details of the QOOBA API will be well understood by those skilled in the art from the functional description provided above as well as below and can be easily implemented using well known and routinely used programming techniques. Accordingly the details are not described herein because they are unnecessary to those skilled in the relevant area of art and are therefore considered beyond the scope of this document.

1. Call the qooba transaction request API which returns the encrypted qooba transaction request. In addition to the transaction itself which could simply be a request for a login PIN the website or indicates whether it wishes i to simply display the transaction to the user or ii to ensure the user clicks OK in the QOOBA Window or provide some corresponding indication that he she approves the transaction displayed in the QOOBA Window or iii to obtain a transaction signature. It will be recognized that in the example above the QOOBA Window in makes clear that the website had indicated a desire to obtain a transaction signature. However had the website indicated a desire to ensure the user clicks OK in the QOOBA Window or to provide some corresponding indication that user approves the transaction displayed in the QOOBA Window the term OK or Approved etc. would have been displayed in the QOOBA Window shown in in lieu of the signature PIN . On the other hand had the website indicated a desire to simply display the transaction to the user neither the signature PIN nor a term such as OK or Approved etc. would have appeared in the QOOBA Window shown in .

3. The QOOBA Server decrypts the transaction verifies authenticity and then shows the transaction to the user in the QOOBA Window . As noted above if a transaction signature is requested the QOOBA Server will compute the signature PIN and display it to the user.

4. The QOOBA Server then prepares an encrypted qooba transaction response and sends it back to the Browser in the response to the original POST which is then transmitted back to the website or as applicable.

5. The applicable website or then calls the qooba transaction verify API which will return the result to that website.

In yet another extension of our work we overlay components for key management on the QOOBA architecture. We will describe this extension with reference to . As shown in the QOOBA system here consists of a desktop personal computing device having the QOOBA Window and a Browser Window executing and displayed thereon a QOOBA Server and a Web Service which has the QOOBA API operable thereon. It should be understood that in a practical implementation there would typically be multiple web services at multiple different websites. Also included in the system as shown is an OOBA Service which is utilized by the QOOBA Server to bootstrap authentication of the user using the user s phone which may be a landline cell phone or smart phone.

As has been described above the user activates the QOOBA Window typically by using out of band authentication via OOBA Service and establishes a session with the QOOBA Server . Web Service participates in the QOOBA Network and goes through a onetime set up process to establish a shared secret with the QOOBA Server which is not shared with or known by the user. When the user has an active session with the QOOBA Server via communication channel and is also at the Website via communication channel the Website can use the QOOBA API to request via back end communication channel transaction authorization by sending the transaction directly to the QOOBA Server . The QOOBA Server then displays the transaction to the user in the applicable QOOBA Window which is shown in to be Window .

The QOOBA Server can present various information to the user in the displayed QOOBA Window . For example the QOOBA Server can display a transaction to the user in the QOOBA Window and if requested also display in the QOOBA Window a transaction signature i.e. an electronic signature derived from the transaction the secret shared between the QOOBA Server and the Website and other information. This is accomplished via communication channel . The user is optionally given the choice of accepting or rejecting the transaction. Acceptance can be signaled passively by taking no action by clicking OK within the QOOBA Window and sending a signal via communication channel back to the QOOBA Server or by copying and pasting the transaction signature from the QOOBA Window into the web application displayed in the Browser Window and then sending it back to the Web Service via communication channel . If the transaction signature from the QOOBA Window is copied into the web application displayed in the Browser Window the Website can verify the signature using the transaction the secret shared between the QOOBA Server and the Web Service and other information. It will be recognized that if desired the transaction signature could be shown to the user within a QOOBA Window not shown on the smart phone which is sometimes referred to as the QOOBA Phone Window rather than the QOOBA Window . The user copies this transaction signature into their browser window and sends it to the Web Service . As the transaction signature or PIN is derived from a secret shared between the QOOBA Server and the Web Service and never revealed to the user the Web Service can recalculate the transaction signature independently and thus confirm the transaction. It will be observed that this achieves the same security effect of a transaction authenticator system but there is no per user provisioning of secrets.

Turning to central to the QOOBA system of is the establishment of a secure encrypted and independent channel between the QOOBA Window on a user s desktop or the QOOBA Phone Window not shown on the user s smart phone and the QOOBA security server . As described above the QOOBA Window is used to show the user transactions and provide the user with the opportunity to confirm e.g. approve the transaction.

As shown in the QOOBA concept is extended to include the QOOBA Key Management Logic Client KMLC on the user s desktop the QOOBA Key Management Logic Server KMLS on the QOOBA security server the QOOBA Key Management Logic API KMLAPI on the Web Service and the possibility of non browser desktop or smart phone software e.g. Acrobat Reader . KMLC and KMLS communicate over the secure QOOBA channel between the QOOBA Window and the QOOBA security server . KMLS and KMLAPI communicate over the back end communication channel between the QOOBA security server and the Web Service .

Within the above described framework key generation proceeds as follows. At some point after the QOOBA Window is activated the KMLC generates a private public key pair e.g. Du Pu and stores the private key Du securely typically in memory . KMLC sends the public key Pu to the QOOBA Server where the request is intercepted by the KMLS . A digital certificate Cert which includes the user s public key Pu is prepared by KMLS and one of two things happens.

If KMLS is capable of acting as an intermediate or root certificate authority it signs the certificate and returns the signed certificate to KMLC which maintains it locally preferably in memory . For example KMLS could sign the Cert with the private key Ds of it s private public key pair Ds Ps such that Cert Ds is returned to KMLC .

On the other hand if KMLS acts as a registration authority it forwards the certificate request to an external certificate authority which creates the certificate and returns it to KMLS which in turn forwards the certificate back to KMLC which maintains it locally preferably in memory . In such a case the Cert will be signed by the certificate authority with the private key Dca of it s private public key pair Dca Pca such that Cert Dca is returned to KMLS . KMLS then forwards the received signed Cert i.e. Cert Dca to the KMLC .

It is preferable in either instance for the Cert issued to be relatively short lived i.e. temporary and coincident with the life of the QOOBA session itself. By making it simple to do key generation coincident with activation the need to store digital certificates and private keys locally over an extended period is avoided.

In some situations as will be discussed in more detail below the private key and certificate may be needed by other applications e.g. browser or document processor on the same desktop or mobile device . If the underlying operating system supports standard key stores as MS Windows or Apple MacOS do then the KMLC can be tasked with committing the keys to the key store and deleting them when appropriate.

In addition to the above described generation of keys i.e. asymmetric keys suitable for public key cryptography the key management system can also generate and distribute symmetric keys. Central to this is a function Shared Secret Generator incorporated within KMLS that takes as input such factors as the UserID perhaps the user s hard line or cell phone number a long lived secret known only to the QOOBA Server and other miscellaneous parameters and produces as output the shared secret K. It is important to note that for a given set of inputs the same shared secret will be computed deterministically. Different authenticated entities can request the KMLS to provide them with the appropriate symmetric key by providing the KMLS the applicable input parameters.

Note that depending on the application QOOBA Key Management Logic may make use of one or both of the asymmetric i.e. public key cryptography and symmetric key cryptography capabilities described above.

Having described the key management system including its key generation capabilities we turn our attention to three example applications that make use of these capabilities.

The first example addresses the use of QOOBA for digital signing. For certain applications digital signing using public key cryptography is considered more appropriate than electronic transaction signing. To accomplish digital signing the end user browses in browser window and executes a transaction at a Web Service . The Web Service uses the KMLAPI to make a request for transaction signing with digital signing required. This request is sent over secure back end communication channel to KMLS . The request is then send from KMLS to KMLC via secure channel with an indication that a digital signature is required. The QOOBA transaction signature PIN i.e. a OTP is optionally generated by the QOOBA Server and sent along with the digital signature request. It should be understood that as described above the PIN could if desired be sent by the QOOBA Server to a QOOBA Window similar to QOOBA Window displayed on the user s smart phone not shown via a persistent connection similar to connection rather than to QOOBA Window displayed on the desktop as shown.

The QOOBA Window shows the user the transaction as usual and optionally requires the user to copy the transaction signature PIN i.e. the electronic signature into the browser window . In parallel the KMLC computes a hash on the transaction HashTran and computes a digital signature using the user s private key Du which was previously stored in memory the result being HashTran Du. This process could happen behind the scenes or by asking the user to agree to sign the transaction. In either case the private key Du is applied to the hashed transaction HashTran . The digitally signed hash of the transaction HashTran Du is then sent via secure channel from KMLC to KMLS along with the digital certificate Cert Ds or Cert Dca.

KMLS can optionally perform a validation of the signature by applying the user s public key Pu to the digital signature HashTran Du to obtain HashTran and comparing it to an independently generated HashTran. Whether or not validation is performed the KMLS forwards the signature i.e. HashTran Du and the certificate i.e. Cert Ds or Cert Dca to KMLAPI via secure channel .

KMLAPI can recompute the hash HashTran and verify the signature using the user s public key Pu included in the digital certificate Cert. Thus the KMLAPI applies the KMLS public key Ps to Cert Ds or the Certificate Authority public key Pca to Cert Dca to recover Pu. It then applies the recovered Pu to HashTran Du to recover HashTran and compares it to an independently generated HashTran to verify the signature.

Note that in the above description the hash is created at KMLC . However it could as easily be created at KMLAPI or KMLS though it is likely that each entity would re compute it to be assured of its authenticity.

In this example the entire transaction comes to the QOOBA Window . If on the other hand a document needs to be signed using this approach then it is possible to extend the functionality to have the KMLC commit the private key and public key to the key stores available on the user s desktop which would make the keys available to other applications e.g. browsers or non browser apps . KMLC would be responsible for deleting the user keys from the key store at the appropriate time.

In the second example QOOBA is used for key distribution. It frequently happens that data is encrypted and forwarded to the recipient in a store and forward system such as email. For instance regulations require that documents such as financial statements or health records must be sent encrypted if sent as email attachments. Many applications e.g. WinZip and Acrobat Reader have built in password based encryption capabilities. The question then arises as to how the decryption password is sent to the user. One approach is to a priori agree on a shared password. Drawbacks of this approach are that a compromised password can be used to decrypt many documents and it is also difficult to require complex passwords as the user is likely to forget the password. Described below are three approaches of using the QOOBA Key Management system to solve this problem.

In the first approach a document identified uniquely for instance by a unique DocumentID is encrypted with a key derived from a PIN e.g. an eight character alpha numeric PIN by a Web Service and then sent to a user e.g. via email. For purposes of this discussion a DocumentID is a unique value associated with particular combinations of sender identification recipient identification and document identification. When the user opens the document using some application typically a software application on his her desktop e.g. WinZip and Acrobat Reader the program sends a signal to the Web Service indicating that the user is attempting to read the particular document. Although the application could instead be the browser for purposes of this discussion and as shown in it is assumed to be other desktop software.

The Web Service retrieves the PIN with which that document referenced by DocumentID was initially encrypted and then uses KMLAPI to send the PIN to the QOOBA server . The QOOBA server using KMLS forwards the PIN to KMLC and the PIN is then displayed to the user within the QOOBA Window .

The user copies the PIN into the application and decryption proceeds as normal. It should be observed that in general no changes to the application are required. The ability to trigger a message to the Web Service when opened is functionality that is already built into many applications e.g. Adobe Reader .

One drawback of the above approach is that the Web Service has to maintain a list of DocumentIDs and PINs. One way to solve this problem is to use a second approach and have the key with which each document is encrypted be the result of a function which takes as input the DocumentID and a long term secret known only to the Web Service . This way the key can be generated dynamically after the user attempts to open the document as described in the first approach.

A drawback of the second approach is that there is an assumption that the Web Service is available and on line when the document is opened. As some of the systems that generate and distribute documents are back end batch systems this assumption may not always be applicable. In a third approach QOOBA key management shared secret generation capability can be used to solve the problem as follows.

The Web Service sends the QOOBA Server either one at a time or more likely in a batch file the DocumentIDs it wants to encrypt. For purposes of this discussion it will be assumed that the file contains envelope information such as sender and recipient IDs. KMLS uses the Shared Secret Generator described above to compute encryption keys for each DocumentID. For example key K1 for one DocumentID K2 for another DocumentID K3 for yet another DocumentID etc. These keys are then returned by the KMLS to Web Service . The Web Service then encrypts each respective document with the applicable key and sends the encrypted document e.g. via email to the respective applicable users.

The applicable user uses the other desktop software to open the document which triggers a request for a key directly to the QOOBA Server over a secure web connection which is another communication channel. It should be noted that this is a direct connection from the non browser software to the QOOBA Server and not through QOOBA Window .

This action results in the KMLS using the Shared Secret Generator to re compute the applicable encryption key e.g. K1 K2 K3 etc. The applicable key is then sent to KMLC and shown to the user in QOOBA Window for copying into the Non Browser Window as described earlier.

While we have described the above using a non browser software application e.g. Acrobat Reader as our example the same functionality can be used for browser based web applications.

QOOBA key management can also be used for seeding OTPs and Transaction Authentication Tokens. OTPs and Transaction Authentication token authenticators all require a key which is stored in the token and is also stored at the back end system. Managing these keys which are commonly referred to as seeds introduces costs and complexity. The QOOBA key management system can be used to greatly simplify this process.

For purposes of this discussion it is assumed that a token authenticator not shown is implemented as hardware software or as a mobile phone app. The token starts in an inactive state with no seed present or a seed refresh is required . A request is made either directly within the QOOBA Window by the user or directly from the token to the QOOBA Server or to an external Web Service requesting a seeding event. Some unique identifier identifying the UserID is provided to the QOOBA Server or Web Service as applicable.

The KMLS within the QOOBA Server uses the unique UserID and other information including the long term secret known only to KMLS as inputs into the Shared Secret Generator to generate a unique seed for that user. This seed is sent back to KMLC via the secure channel and then shown to user in the QOOBA Window . The user enters the seed into the software or smart phone app token. We note that the actual seed may be generated by a function that transforms the seed the user enters. It will be recognized that for hardware this will only work if the token has a keypad which most transaction authenticators do indeed have.

As a variant of the above observe that the transaction authenticator can be built directly into the QOOBA Window as part of the functionality. While at first blush the rationale for this may not be obvious compatibility with existing systems such as EMV CAP provides the rationale for this approach. This on demand seeding of the transaction authenticators vastly simplifies the costs of provisioning.

Below are described various examples of how key management can be beneficially layered on top of a QOOBA architecture.

The first example relates to digital signing. In applications that require digital signing a user needs to be provisioned a private key and a digital certificate i.e. a binding of the user s identity and public key as certified by a certificate authority. The use of such a private key which is not known to any 3rd party including the security server provides for strong non repudiation that is necessary for some applications. As discussed above we follow the industry convention of referring to signatures created with public key cryptography as digital signatures . As will be understood by those skilled in the art and is discussed above signatures based on underlying symmetric cryptography with shared secrets like that which the QOOBA system described above already provides are usually referred to as electronic signatures .

The second example relates to encrypted document delivery. When an encrypted file is sent to a user for example a PDF of a brokerage statement the user needs to be provided with the key with which the file was encrypted.

The third example relates to token authenticators. When users are provisioned a token authenticator either for a one time password generator or a transaction authenticator the user s token needs to be provided with a shared secret key. Those skilled in the art will recognize that in this context the shared secret key is often characterized as a seed .

In all these examples key management adds directly to the cost of the system and indirectly affects the security. Keys need to be generated distributed and maintained in sync. As keys can get lost corrupted or stolen key management is usually a significant source of costs and a point of vulnerability in the system.

The recent extensions combine the AA which we have described above as executable on a SP and which we have sometimes referred to as the QOOBA Phone Window application or the 2CHK application or client with a dedicated or non dedicated SP hardware SPH device that can attach to a SP in a manner similar to other adjunct pieces of hardware e.g. a smart card as described earlier the combination of which can provide even higher security. The higher security is typically to protect against attacks on the SP itself. It should be understood that we use the term smart phone broadly to include all wireless network connected devices such as tablet computers etc.

We start by noting that a dedicated SPH device may indeed be a dedicated device but it could itself be an application running on one of the many devices designed to attach we use the term attach broadly as this could include attachment via USB cables near field communications NFC Bluetooth or a headphone jack etc. to smart phones for various other purposes. In either case we refer to both such adjunct devices as SP hardware or SPH below and have sometimes referred to such adjunct devices as 2CHK hardware. It will be recognized that an adjunct device could for example be a secure storage device for the use of the AA a secure display device or a secure source of adjunct identification information e.g. a certificate store or biometric reader or fingerprint protected storage etc. 

When used in this combination the SP is basically acting as a conduit or proxy to ferry messages between the security or authentication server which we have sometimes referred to as the QOOBA or 2CHK server and the SPH attached to the SP. The role previously played by the AA executing on the SP as described above is now played by the AA executing on the SPH. Activation of the AA on the SPH proceeds as usual with the preferred procedure being a voice call to the SP to deliver an activation code with key entry of the activation code happening on the SPH. It should be understood that the SPH now has a secure encrypted connection to the security server via the AA which even the SP conduit proxy cannot read or manipulate. Data passing through the SP acting as a communications conduit is encrypted or encoded in such a manner as to only be readable by the AA on the SPH.

Transactions are now viewed securely by the user on the SPH and other interactions proceed as have been described above. The AA on the SPH can also be seeded to generate OTP tokens using the innovations described above. This means that OTPs can now be securely generated on the SPH even when it is no longer connected to the SP.

As a final aspect of this unique combination while this innovation has been described in terms of SPH connected to a SP the same innovation can be used to connect the security server to an AA running on a SP via an application such as a pop up window or other application running on a personal computer PC and serving as a conduit proxy between the security server and the SP. Thus in such a case the PC functions in substantially the same manner as the SP described above i.e. as a conduit proxy to pass messages between the security server and the AA executing on the SP. This may useful for instance for a user working on a PC connected to the Internet via a wired LAN network but in a shielded room which does not permit cell functionality. It should be noted that instead of a PC any Internet connected device such as a gaming device a TV a DVD player etc. could be the intermediate point serving as the proxy or conduit.

In the following example the SP has a sample application for the eDuckies store. The SPH has the AA. The AA and eDuckies Application EDA are assumed not to multi task in this example. Each have private storage no one else can see. The AA executing on the SPH also has public storage any other Smart Phone Applications SPAs can see and hence access via the proxy conduit.

With the SPH connected to the SP the user opens the AA on the SPH and logs in perhaps once a day. For example either the user can enter his her phone number e.g. the phone number for the SP or the AA can auto fill in this information depending on the user s preference. Behind the scenes the AA executing on the SPH talks via the SP serving as the proxy or conduit to the authentication server also often referred to as a security server or QOOBA server which then issues a login PIN to the user via a short messaging service SMS which is now commonly referred to as a text messaging service.

The user receives the text message with the login PIN on the SP and enters the received Login PIN into the AA on the SPH. On some SPH platforms the AA can be configured if so desired to retrieve the PIN from the incoming SMS stream received by the SP and auto fill the login PIN in on the SPH making it even easier for users. A private equivalent of a session cookie is stored by the AA on the SPH and will be used by the AA for subsequent authentications to the authentication server to obtain transaction PINs when available. The AA on the SPH also communicates via the SP with other SPAs using the most appropriate method. A unique advantage of this invention is the ability to use public shared storage such as public pasteboards on the operating system of iPhones. The user is now logged in and a MQOOBA session is active. The user may now start using other SPAs and return to the AA when needed.

In this example the user now browses the EDA and eventually wants to place an order. eDuckies would like to get authorization of this order seamlessly. However it would be insecure to let the user provide payment credentials to the EDA.

Accordingly the EDA post the transaction via the SP to the authentication server which here serves as the payments system. The EDA also asks the user to authorize the transaction at the AA executing on the SPH. This is similar to a user being redirected to a payments website such as PayPal to authorize a transaction. The authentication server will post the transaction via the SP to the AA on the SPH for presentation to the user.

Back at the AA the user sees a transaction waiting gets it and sees that it looks legitimate. Accordingly the user authorizes the transaction. It should be understood that MQOOBA makes it extremely difficult for an attacker even one who somehow has placed a malicious eDuckies App on the user s phone to be able to fake this. The MQOOBA PIN is generated based on a shared secret between authentication server and legitimate merchant site in this case eDuckies website and transaction information etc. if applicable.

After the user authorizes the transaction at the AA on the SPH back at the EDA the user sees the PIN auto filled in for them. Behind the scenes the PIN was generated using the transaction information provided by the EDA and the secret shared by the authentication server and eDuckies website by the authentication server and transferred via the SP from the authentication server to the AA on the SPH. The AA then transferred via the SP the PIN to the EDA on the user s SP using the shared storage on the SP. It should also be understood that if desired the user could be required to manually copy the PIN from the AA on the SPH to the EDA on the SP instead of having the PIN auto filled in. In either case after the PIN has been filled in on the EDA when the user clicks complete authorization the EDA sends the PIN to the eDuckies website. The eDuckies web service will re compute the PIN and let the AA on the SPH know via the SP if it was valid or not.

As discussed above the AA executing on the SPH gives a user dynamic login and transaction authorization PINs for particular merchant sites and for particular transactions. The AA can get these PINs from the authentication server website via the SP after having logged into it from within the AA on the SPH.

Referring now to an SP is shown. The SP includes a CPU a port such as a USB port earphone jack or Bluetooth connection and a display screen . The SP also has various SPAs executable by the CPU loaded therein including the proxy conduit application EDA and SMS application SMSA for text messaging. As shown EDA uses public store

Removably connected to the SP via the port is SPH . The SPH includes a CPU and display screen . The SPH also has at least AA which is executable by the CPU loaded therein. It should be understood that various other SPH applications SPHAs executable by the CPU could also be loaded on the SPH although such SPHAs would typically not include the EDA or the SMSA . As shown AA executing on the SPH uses both public store and private store

Referring to the CPU can execute the AA to interact with the security server via communication channel the proxy and port . The proxy conduit serves as a communication pipeline between the security server and the AA via communication channel and the port . It also serves as a communication pipeline between the AA and the AA public storage on the SP via the port . Furthermore the CPU can execute the EDA to interact with the eDuckies website via communication channel and the security server via communication channel .

Certain operations have been previously described with reference to for implementations that utilize a SP without an SPH and hence rely on the AA executing on the SP for authentication or transaction approval. Corresponding operations will now be described for implementations that utilize SPH and hence rely on the AA executing on the SPH for authentication or transaction approval. However to avoid unnecessary duplication these operations using the AA on the SPH will be described with reference to as appropriate.

When execution of the AA is started it causes a display similar to that shown in area A1 of the display as depicted in in a first area of the display screen . The display in the first area requests a user identifier such as the phone number e.g. a cell phone number associated with SP . Preferably the user has previously been allowed to select between a manual option which if selected would require the identifier to be manually filled in by the user and an automatic option which if selected would serve as a directive to the AA to pre populate the space provided in the display in the applicable display area with the applicable user identifier e.g. the cell phone number of the SP .

If the SPH is connected to the SP when the user clicks an arrow in the display area see the AA causes a post of a first application programming interface API message via the proxy on the SP to authentication server . The authentication server returns via the proxy an acknowledgement indication to the AA and if the message is acknowledged the AA also causes the presentation of that shown in area A2 of the display screen depicted in in a second area of the display screen . As indicated in area A2 of if success the authentication server SMSs i.e. text messages a PIN which is a OTP to the user at the user s SMS address. By activating execution of the SMSA by the SP CPU the user can access his her SMS account and retrieve the PIN from the SMS message sent by the authentication server. The user then enters the PIN in the space provided in the second display area of display screen for example by typing the PIN from the SMS message onto the display screen see . After entering the PIN the user clicks on an arrow similar to the arrow shown in area A2 of and the AA sends via the proxy a second API message to post the PIN.

The return message from the security server if success returns to the AA via the proxy a session cookie a random number we call nonce login and a time to live TTL and the AA causes a display in a third area of display of the type shown in area A3 of the display screen in .

It should be noted that rather than a choice just between manual and automatic fill the user could additionally or alternatively be allowed to select or be required to enter a user name in the first area and a password in second area of the display . It should also be understood that the choice between manual and automatic described above is only one such choice described herein. Thus another choice between manual and automatic will be described below in the context of transaction authorization and more particularly with respect to whether a different PIN which is associated with a transaction authorization is conveyed by the AA executing on the SPH to EDA executing on the SP automatically or only after a manual input by the user.

The session cookie is stored privately in private store . The nonce login and the TTL are stored publicly on a custom pasteboard the AA public pasteboard which is created within public store See in the case of the iPhone Custom Pasteboard development tool at Apple.com . When the user turns his her focus to the AA the AA always checks the nonce and TTL via port . If the TTL has timed out the AA causes the display on display of that shown in area A1 of the display screen of to begin again the log in to the authentication server .

When the user is at some other SPA e.g. the EDA or website and has been prompted for a PIN either for login or transaction authorization purposes the user is redirected to the AA executing on the SPH as will be further discussed below. For purposes of the description below we will assume the user is at the EDA. In conjunction with this redirection the EDA post information to the security server . This information includes whether a login authentication or transaction authorization is requested the name of the merchant e.g. eDuckies and if transaction authorization is being requested text of the transaction. If the security server has the ability to PUSH information to the AA the security server causes a post of this information to the AA via the proxy and port . The AA causes the display of either the information posted to it by the security server in a fourth area of the display which could for example appear like area A4 of or what is shown in area A1 of if re login to the authentication server is required. For purposes of this discussion we assume that what is shown in area A4 of is caused by the AA to be displayed on the display .

Alternately if the security server has no ability to PUSH we rely on the user to PULL the data. This is the flow that is shown in the figures. When user clicks the arrow in the third area of display which is similar to area A3 of the AA causes a post to the security server via the port and proxy . The post includes the session cookie described above.

The security server returns a success or failure message. The return message always returns a flag indicating login authentication or transaction authorization the name of the merchant e.g. eDuckies a new nonce login a new TTL and a PIN i.e. a OTP. If it is a transaction authorization it also returns the text of the transaction. If success than the AA causes the display in the fourth area of the display screen of that which is shown in area A4 on the display screen of .

If the user clicks the stop sign the user is directed back to what the display screen presented in the third area which is also what is shown displayed on the screen in . Preferably an alarm is sent to the security server to the EDA and from there to the merchant website and or to some other security related website.

On the other hand if the user clicks an arrow similar to that shown in area A4 of presented in the fourth area of the display screen the nonce login and the TTL are written by the AA executing on the SPH to the AA public pasteboard in public storage on the SP via the port and proxy . The login or transaction PIN as applicable is also written to the pasteboard using the merchant identifier and PIN combination. The merchantid.PIN is written over any previous merchantid.PIN. The user is now again presented with the third area display described above which is also shown in area A3 of . Alternately if manual PIN transfer is the choice selected then the user will be shown the PIN within the AA and the onus is on the user to copy it from the AA on the SPH to the EDA on the SP.

It is perhaps worthwhile to reemphasize here that in accordance with our earlier work described in greater detail above the login or transaction PIN is generated by the authentication server based on a secret shared by the authentication server and the website and not shared with or known to the user or associated with any particular user. Furthermore if transaction authorization is requested the transaction PIN is generated by the authentication server also using transaction information.

It should be noted that the EDA checks if there is an AA public pasteboard i.e. public storage on the SP having a login nonce with valid TTL for the user. If not it informs the user that he she does not appear to have logged into the AA on the SPH. Here we have assumed that the user has logged in and that the EDA has determined that the AA public pasteboard which serves as public storage has a valid nonce.

For purposes of this description we will assume that transaction authorization is involved. The user is at the EDA and is presented on the SP display screen with transaction information of the type shown in area M1 of display screen of . When the user clicks an arrow such as the shown in area M1 of he she is redirected via proxy and port to the AA executing on the SPH and the AA post via the port and the proxy the information relating to the merchant and transaction to the authentication server . The post includes the login nonce. The security server returns via the proxy and port a success or failure. If success then the AA presents to the user on the display screen of the SPH the display shown in area M2 of the display screen depicted in . If the user clicks on an arrow displayed on the display screen such as one similar to the arrow shown in area M2 of the transaction authorization process described above is performed and the return message includes a string.

When the focus returns to the EDA the EDA polls the AA pasteboard i.e. public storage to see if there is a new merchantid.PIN. Once the EDA locates it it does a post to the eDuckies website of the string and the transaction authorization PIN. The website will return to the AA via the EDA proxy and port a success or a failure message after it does its own verification of the PIN. It should be noted that if the manual PIN transfer option is chosen the user must enter the transaction authorization PIN displayed at the AA into the EDA .

Referring again to as shown therein the AA can be extended to include the Key Management Logic Client KMLC on the SPH. The Key Management Logic Client KMLC corresponds in functionality to the QOOBA Key Management Logic Client KMLC on the user s desktop which is shown in and described above with reference thereto. As has been described above with reference to Key Management Logic Client KMLC will interact with the Key Management Logic Server KMLS not shown in on the security server the Key Management Logic API KMLAPI not shown in on a Web Service and possibility non browser desktop or smart phone software such as Acrobat Reader or iTunes software also not shown in . KMLC and the KMLS on the security server communicate via the proxy and port over the secure channel between the AA and the security server . KMLS on the security server and KMLAPI on the website communicate over communication channel and communication channel via the eDuckies website or alternatively over the optional back end communication channel between the security server and the Web Service .

Within the above described framework key generation proceeds as follows. At some point after the AA is activated the KMLC generates a private public key pair e.g. Du Pu and stores the private key Du securely typically in memory . KMLC sends the public key Pu to the security server where the request is intercepted by the KMLS not shown executing on the security server. A digital certificate Cert which includes the user s public key Pu is prepared by KMLS and one of two things happens.

If KMLS on the security server is capable of acting as an intermediate or root certificate authority it signs the certificate and returns the signed certificate to KMLC which maintains it locally preferably in memory . For example the KMLS on the security server could sign the Cert with the private key Ds of it s private public key pair Ds Ps such that Cert Ds is returned to KMLC .

On the other hand if the KMLS on the security server acts as a registration authority it forwards the certificate request to an external certificate authority not shown in as described with reference to which creates the certificate and returns it to the KMLS which in turn forwards the certificate back to KMLC which maintains it locally preferably in memory . In such a case the Cert will be signed by the certificate authority with the private key Dca of it s private public key pair Dca Pca such that Cert Dca is returned to KMLS operating on the security server. KMLS then forwards the received signed Cert i.e. Cert Dca to the KMLC .

It is preferable in either instance for the Cert issued to be relatively short lived i.e. temporary and coincident with the life of the session between the security server and AA . By making it simple to do key generation coincident with activation the need to store digital certificates and private keys locally over an extended period is avoided.

In some situations as have been discussed in more detail above with reference to the private key and certificate may be needed by other applications e.g. browsers or document processors on the SP or desktop if the SP serves as the adjunct hardware to which the SPH is connected via the port . If the underlying operating system supports standard key stores as MS Windows or Apple MacOS do then the KMLC can be tasked with committing the keys to the key store and deleting them when appropriate.

In addition to the above described generation of keys i.e. asymmetric keys suitable for public key cryptography the key management system can also generate and distribute symmetric keys. Central to this is a function Shared Secret Generator incorporated within the KMLS executing on the security server that takes as input such factors as the UserID perhaps the user s hard line or cell phone number a long lived secret known only to the security server and other miscellaneous parameters and produces as output the shared secret K. It is important to note that for a given set of inputs the same shared secret will be computed deterministically. Different authenticated entities can request the KMLS on the security server to provide them with the appropriate symmetric key by providing the KMLS the applicable input parameters.

Note that depending on the application Key Management Logic may make use of one or both of asymmetric i.e. public key cryptography and symmetric key cryptography capabilities described above.

The key management system described with reference to including its key generation capabilities can also be applied in the same manner as has been described above with reference to to various applications that make use of these capabilities. These applications include for example digital signatures key distribution and seeding of OTPs and transaction authentication token authenticators. With regard to token authenticators when users are provisioned a token authenticator either for a OTP generator or a transaction authenticator the user s token needs to be provided with a shared secret key. Those skilled in the art will recognize that in this context the shared secret key is often characterized as a seed .

With regards to the seeding of OTPs as pointed out above in the description associated with OTPs and transaction authentication token authenticators e.g. hardware software smart phone apps etc. all require a key which is stored in the token and is also stored at the back end system. Managing these keys which are commonly referred to as seeds introduces costs and complexity. The key management system can be used to greatly simplify this process.

It will be noted that advantageously the SPH can perform certain operations relating to seeding while the SPH is disconnected from the SP . While seeding related operations with the SPH connected to the SP have been covered in detail in the description relating to the following addresses how certain of those operations can be performed with the SPH disconnected from the SP . For purposes of this discussion it is assumed that a token authenticator not shown is implemented as hardware as software or as a SPH app. The token starts in an inactive state with no seed present or a seed refresh is required .

As has been described above with reference to while the SPH is connected to the SP seeds generated by the security server are sent back to KMLC . In the system of the seeds are communicated to the KMLC over the secure channel via proxy and port and can be stored for example in private storage . After the SPH has been disconnected from the SP the stored seeds can if desired be shown to the user by the AA in a display at the SPH . The user can then enter the seed into software or an app token not shown on the SPH similar to the entry of the seed into software or a SPH app token as described with reference to . Again we note that the actual seed may be generated by a function that transforms the seed the user enters. It will also be recognized that for hardware this will only work if the token has a keypad which most transaction authenticators do indeed have.

As a variant of the above it should also be observed that the transaction authenticator can be built directly into the AA as part of the functionality. While at first blush the rationale for this may not be obvious compatibility with existing systems such as EMV CAP provides the rationale for this approach. This on demand seeding of the transaction authenticators vastly simplifies the costs of provisioning.

