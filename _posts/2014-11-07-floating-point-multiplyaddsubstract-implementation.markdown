---

title: Floating point multiply-add-substract implementation
abstract: A floating point multiply and addition/subtraction implementation is provided. Two operands are received in a standard floating point format with a code selecting a mathematic operation from addition, subtraction, and multiplication. Result mantissas and exponents are calculated simultaneously for all operations. The implementation simplifies computation of a result mantissa by dropping the least significant bits of the operands before computing the result. Underflow and overflow errors are shown by two extra bits in the exponent portion of the result. The mantissa result and the exponent result are selected by providing the operation code to a mantissa multiplexer and an exponent multiplexer. The selected mantissa and exponent are combined as output.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09417839&OS=09417839&RS=09417839
owner: The United States of America as represented by the Secretary of the Navy
number: 09417839
owner_city: Washington
owner_country: US
publication_date: 20141107
---
The invention described herein may be manufactured and used by or for the Government of the United States of America for governmental purposes without the payment of any royalties thereon or therefor.

The present invention is directed to an implementation of a floating point multiply add subtract implementation for digital circuitry.

In digital computer processing signed floating point numbers can be utilized in a form having a mantissa multiplied by a base having an exponent. Mathematical functions are carried out on these numbers in semiconductor floating point units or processors in binary format. The floating point unit does addition subtraction multiplication and division operations on floating point numbers. In many implementations the exponent is usually biased which means that a number called the bias is subtracted from the written exponent before computation. This allows implementations to use a positive representation of a negative exponent since the written exponent minus the bias is negative. The examples assume a normalized format which means that the first bit of the mantissa is 1 .

The Institute of Electrical and Electronics Engineers IEEE has standards for floating point representation of numbers. The current standard used by most commercial processors is IEEE 754 2008. The output of this format is a binary floating point number that contains a sign biased exponent and mantissa. A 16 bit IEEE 754 floating point number is given by the following format 

Important resources for floating point unit implementation are its size and its speed. The size of the implementation is the number of gates that are required. Typical commercial 32 bit multiply accumulate floating point units without division take approximately 12 800 gates. This commercial implementation runs at 1 MFlop Mhz or 55 Mhz.

When utilizing field programmable gate arrays and other special purpose semiconductors it is often desirable to reduce the number of gates and chip resources required for processing floating point numbers. It is further desirable to process these numbers as quickly as possible.

The first object of the present invention is to provide an implementation of a floating point unit utilizing fewer gates.

Another object is to provide an implementation of a floating point unit capable of operating at faster speeds than existing units.

Accordingly there is provided a floating point multiply and addition subtraction implementation. Two operands are received in a standard floating point format with a code selecting a mathematic operation from addition subtraction and multiplication. Result mantissas and exponents are calculated simultaneously for all operations. The implementation simplifies computation of a result mantissa by dropping the least significant bits of the operands before computing the result. Underflow and overflow errors are shown by two extra bits in the exponent portion of the result. The mantissa result and the exponent result are selected by providing the operation code to a mantissa multiplexer and an exponent multiplexer. The selected mantissa and exponent are combined as output.

The benefits of the floating point unit implementation contained herein are accomplished via pipelining simplification of exception handling and other hardware techniques. The current implementation calculates NaN underflow and overflow exception conditions by calculating the exponent with two additional bits of precision and using signed two s complement binary format. This eliminates complex error exception detection circuitry because in this format either of the two most significant bits of the exponent will only be 1 when an exception occurs. Underflow occurs when the most significant bit is 1 because the exponent is negative. Overflow occurs when the two most significant bits are 01 because the exponent portion has exceeded its range. NaN is indicated when the exponent bits following the two most significant bits are all 1 s and the mantissa is non zero. In the current implementation post calculation detection of this condition is unnecessary.

The floating point unit implementation receives two floating point numbers Aand B. The floating point number is separated into component parts for processing. For this purpose in the mantissa of Ais identified as A and the mantissa of Bis identified as B. The exponent of Ais identified as A and the exponent of Bis identified as B. The sign of each number is identified as Aand B. This can be performed by segregating the appropriate bits.

Prior to computation error detection module checks for NaNs at the inputs by checking if the exponent of either operand Aor B is all 1s and its mantissa is non zero. This can be performed by conducting an AND operation among all of the exponent bits of the operand conducting an OR operation among all of the mantissa bits of the operand and executing an AND between the two results. Error detection module then asserts signal Aif Ais NaN Bif Bis NaN and a signal NaN if either A B or both is NaN. Next error detection module checks for zeroes at the inputs and then asserts Aif both Ais negated and Ais zero. Likewise Bis asserted if Bis negated and Bis zero. Error detection module then checks for infinities at the inputs and asserts Aif Ais all asserted while Ais all negated. Bis asserted if Bis all asserted and Bis all negated. Next error detection module checks for signaling NaNs at the inputs and Ais asserted when both Ais asserted and the most significant bit of Ais negated. Similarly Bis asserted when Bis asserted and the most significant bit of Bis negated.

Next error detection module checks if invalid operation exceptions signaling NaNs exist at the inputs based upon the opcode. If the opcode indicates addition an invalid operations flag InvOp is asserted when Ais asserted or Bis asserted or both Aand Bare asserted and Aand Bdiffer. If the opcode indicates subtraction then InvOp is asserted when Ais asserted or Bis asserted or both Aand Bare asserted and Aand Bmatch. If the opcode indicates multiplication then InvOp is asserted when Ais asserted or Bis asserted or both Aand Bare asserted and NaN is negated or both Aand Bare asserted and NaN is negated. Next error correction module modifies the diagnostic mantissa output Y to indicate invalid operations and NaN error conditions. Yis set to Aif A is a NaN that is if either Aor Ais asserted. Yis set to Bif B is a NaN. If both A and B are NaNs Yis set to A. The first bit of Ycan be use to indicate a signaling NaN versus a quiet NaN under the IEEE standard.

Further details of the add subtract section will be given in reference to and further details of the multiply section will be given in reference to . The mantissa outputs of the add subtract section Yand Y and the multiply section Y are provided to a mantissa multiplexer . The opcode is further provided to the mantissa multiplexer to select the correct mantissa function input as the mantissa output Y. The exponent outputs of the add subtract section Y and the multiply section Y are provided to an exponent multiplexer . The opcode is further provided to the exponent multiplexer to select the correct exponent function input as the exponent result output Y. An error check module receives the exponent result output Y and Y the input operands Aand Band NaN output from error detection module . Error check module both computes the diagnostic error output and corrects the exponent and mantissa result outputs for the output format as described hereinafter. The mantissa output Yand the exponent output Yare combined in at an output to give the preferred output form. The diagnostic error output of error check module can be a bus which contains the InvOp overflow underflow and inexact error flag signals from error detection module and error check module . A divide by zero flag can be included for compatibility but this flag will never be asserted. In an alternative embodiment error check module can give a diagnostic code that can be used to give these flags.

In order to calculate the sign of the output an XOR gate receives the sign bits of the inputs Aand B and provides the sign of the result Yas the exclusive or of the sign inputs. The sign of the result Yis combined in a combiner with the unsigned mantissa multiplication result Yto give Y.

A preliminary multiplication exponent result Y is calculated from the input exponents Aand B in a multiplication exponent adder . Exponent calculation logic receives the preliminary multiplication exponent result Y and combines this with the exponent correction from the mantissa shift register to give a multiplication exponent result Y.

Mantissa multiplier calculates the mantissa of A Band provides the product M with sufficient precision to store the entire result. This could be the place number precision of Aadded to the place number precision of B or double the precision of Aor Bif both have the same precision. Of course a lower precision result may be acceptable for some applications. This product M will be shifted in operations in a later stage to drop the least significant digits.

A preliminary result exponent Y is determined by adding Ato Bin multiplication exponent adder . Multiplication exponent adder utilizes two extra bits in the most significant places in these exponent calculations. For example in IEEE 764 16 bit the exponents and results would each be five bit values however in this implementation the result is a seven bit value. These extra most significant bits will only be asserted in cases of underflow and overflow. This will be explained below.

The sign of the final output is determined by executing an exclusive or or XOR operation on Aand Bto give Y. This allows use of a simple XOR gate to give the sign for multiplication.

The priority encoder is used to get the order of the multiplication result Mfrom the mantissa multiplier . The order is the position of the most significant bit of M. For example if 0100 4 0011 3 1100 12 the binary order would be 4 because the most significant digit 1xxx is in the fourth position. This is used to determine the number of right shifts of Mthat will be required for the product to fit in the floating point format. In 16 bit implementations 10 bits are allowed. In 8 bit implementations 4 bits are allowed. In a preferred embodiment the priority encoder with shift logic determines the order of the bits beyond the number of bits allowed. This can be used directly as the number of shifts N. In an alternate embodiment the order is the absolute order of the product and this order is converted into a number of shifts N. There are no shifts if the order is less than number of bits allowed. If the order is greater than the number of bits allowed the number of shifts is an adjustment calculated as the order minus the number of bits allowed.

The product of Aand B M is shifted by Nin mantissa shift register so that it fits into the number of bits allowed by dropping the least significant digits. This gives Y the mantissa of the multiplication result. The multiplication exponent Yis calculated in an exponent calculation component by adding the preliminary result exponent Yto the number of shifts required for the mantissa N.

The addition subtraction process is more fully described below. Aand Bare compared using exponent comparator to give the greater of the two exponents as a preliminary addition subtraction result exponent Y. The difference between Aand Bis calculated by exponent subtractor by for example subtracting Bfrom Aas Cusing two s complement addition. Two s complement addition uses less complicated logic to manage the signs and give a difference. Aand Bare scaled in register by shifting the mantissa of the operand having the lower exponent. This shift uses the exponent difference Cto shift the mantissa s bits to less significant places. The operand being shifted is governed by the sign of the difference C. One of ordinary skill in the art would understand this as right shifting the mantissa. For example if Cis positive this means that Ais greater than Band Bis shifted by Cpositions. If Cis negative Bis less than A and Ais shifted by Cpositions. This shift truncates the least significant digits of the smaller operand if one operand is significantly smaller than the other. The register also aligns the mantissas prior to addition so that when the operand and the shifted operand are added the bits will be in the appropriate place value.

The register adds an extra bit of precision to Aand Bwhich have been shifted as described above. A combined adder subtractor receives the shifted mantissa Aand Bhaving the extra exponent bit. The adder subtractor converts these numbers to signed two s complement format by taking the complement of each number and adding one to the complement of each number if the sign bit is 1. While two s complement addition requires the extra bit of precision it greatly simplifies addition and subtraction because the sign can be ignored. The adder subtractor calculates an addition result A Bto give the mantissa of the addition result Yand a subtraction result A Bto give the mantissa of the subtraction result Y. Yand Yare then converted by adder subtractor from two s complement form to signed magnitude form of the result mantissas.

Error check module checks the two most significant bits of Yto determine if an error condition such as an underflow overflow inexact or NaN condition exists. If the opcode indicates addition and Aand Bdiffer or the second most most significant bit of Yis asserted and the AOR Binputs from error detection module are asserted then Yis all asserted. Else if the opcode indicates addition and the Aor Binputs from error detection module are asserted or the most significant bit of Yis asserted then Ychanged to all negated. If the opcode indicates subtraction and Aand Bmatch and the AOR Binputs from error detection module are asserted or the NaN or InvOp inputs from error detection module is asserted or the second most most significant bit of Yis asserted then Yis all asserted. Else if the opcode indicates subtraction and the Aor Binputs from error detection module are asserted or the most significant bit of Yis asserted or the NaN or InvOp inputs from error detection module is asserted then Ychanged to all negated. If the opcode indicates multiplication and the NaN or InvOp inputs from error detection module are asserted or the Aor Binputs from error detection module are asserted and the second most significant bit of Yis negated then Yis changed to all asserted. Else if the opcode indicates multiplication and the Aor Binputs from error detection module are asserted or the most significant bit of Yis asserted then Ychanged to all negated the IEEE 754 convention for indicating these conditions. If the InvOp or NaN inputs from error detection module are asserted then Yis set to the Yinput from error detection module . Else if either of the first two most significant bits of Yare all asserted or the remaining bits after the first two most significant bits of Yare all asserted or all bits of Yare negated then Yis set to all negated the IEEE 754 convention for indicating these conditions. If all remaining bits after the most significant bit of Yare asserted and both NaN and InvOp inputs from error detection module are negated then overflow is asserted. Otherwise if all remaining bits after the most significant bit of Yare negated and both NaN and InvOp inputs from error detection module are negated then underflow is asserted. If the Ainput from error detection module is asserted and Ais not all negated or the Binput from error detection module is asserted and Bis not all negated then the inexact output is asserted the IEEE 754 convention for indicating these conditions. The diagnostic error output of error check module is a bus which contains the InvOp overflow underflow and inexact output signals from error check module . Bus can include a divide by zero line for compatibility but this line will never be asserted because this implementation lacks a divide module.

A mantissa multiplexer selects among Y Yand Ybased on the opcode to provide the result mantissa Y. Yis selected if the opcode indicates subtraction Yis selected if the opcode indicates addition and Yis selected if the opcode indicates multiplication. In final processing Yis composed from Yand Y.

This apparatus can be implemented utilizing many different technologies. These technologies include field programmable gate arrays application specific integrated circuits portions of integrated circuits programmable read only memory programmable logic arrays hard wired electrical circuits or the like.

It will be understood that many additional changes in the details materials steps and arrangement of parts which have been herein described and illustrated in order to explain the nature of the invention may be made by those skilled in the art within the principle and scope of the invention as expressed in the appended claims.

The foregoing description of the preferred embodiments of the invention has been presented for purposes of illustration and description only. It is not intended to be exhaustive nor to limit the invention to the precise form disclosed and obviously many modification and variations are possible in light of the above teaching. Such modifications and variations that may be apparent to a person skilled in the art are intended to be included within the scope of this invention as defined by the accompanying claims.

