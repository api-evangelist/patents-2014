---

title: Limiting the rendering of instances of recursive elements in view output
abstract: Provided are a computer program product, system, and method for limiting the rendering of instances of recursive elements in view output. A schema provides a definition of elements, wherein at least one of the elements comprises a recursive element of a recursive data type, wherein the recursive data type allows for instances of the recursive element to include instances of that same recursive data type at different levels in a hierarchy. A condition is received for terminating recursion for the recursive element. A view is generated for the schema including information on the condition for terminating the recursion, wherein the processing of the view causes a parser to chunk instances of the recursive element in schema data in response to the condition indicating to terminate recursion at the level of the instance of the recursive element being processed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09552381&OS=09552381&RS=09552381
owner: International Business Machines Corporation
number: 09552381
owner_city: Armonk
owner_country: US
publication_date: 20141104
---
This application is a continuation of U.S. patent application Ser. No. 14 148 646 filed Jan. 6 2014 which application is incorporated herein by reference in its entirety.

The present invention relates to a computer program product system and method for limiting the rendering of instances of recursive elements in view output.

An Extensible Markup Language XML schema is a description of elements in a document encoded using the XML language. The XML schema may also be used to define a data model also known as a meta model comprising a definition of a hierarchical representation of nodes that represent the data and relationship of data content for a data model. XML schemas that define more complex data models may have 1000s of nodes arranged in a complex hierarchy of trees of nodes. A large scale schema may be comprised of multiple XML Schema Definition XSD files and provides a definition of large scale trees of nodes and data content.

An XML schema may include a recursive data type. An XML schema is said to be recursive when the type definition allows for elements of the same name and type to appear in their own definition. Recursion may be explicit or implicit such that recursive elements defined with the recursive data type will themselves contain other instances of that same type. The presence of recursive types significantly increases the complexity of specifying transformations between XML datasets as well as between XML datasets and datasets with non hierarchical formats such as relational. The XML schemas which define the structure of XML data represent the recursive data structures via recursive type definitions. Transformations to from and between XML datasets are typically specified as mappings to and from the types defined in the XML schemas. Such mappings serve to document the relationships between datasets and also provide the basis for automated transformation tools that convert one dataset into another. But in the presence of recursive types simple mappings are inherently ambiguous since it can be unclear which and how many levels of recursive structure are being mapped.

Provided are a computer program product system and method for limiting the rendering of instances of recursive elements in view output. A schema provides a definition of elements wherein at least one of the elements comprises a recursive element of a recursive data type wherein the recursive data type allows for instances of the recursive element to include instances of that same recursive data type at different levels in a hierarchy. A condition is received for terminating recursion for the recursive element. A view is generated for the schema including information on the condition for terminating the recursion wherein the processing of the view causes a parser to chunk instances of the recursive element in schema data in response to the condition indicating to terminate recursion at the level of the instance of the recursive element being processed.

Described embodiments provide techniques to generate a view for a schema to limit a number of levels at which recursive elements are expanded in a view by allowing the view to have instances of recursive elements chunked upon satisfying a condition for terminating recursion to allow the user to control the level at which instances of structured recursive elements are generated into the view output. Further embodiments provide techniques for transforming hierarchical recursive type elements to non recursive type elements where hierarchical information is encoded in attributes of the non recursive type elements.

The user accesses the GUI to invoke an XML parser to parse XML data comprising an implementation of the XML schema according to the view to generate XML view output comprising a defined view of the XML elements from the XM data .

The application server client GUI repository and file system may interconnect over a network . The components of may be implemented with suitable computing architectures. In one embodiment the client GUI may be web based invoking the services and using SOAP Simple Object Access Protocol web services or Hypertext Transport Protocol HTTP based Representational State Transfer REST services. In one embodiment the client GUI and the services and may be integrated into one standalone application or distributed in multiple application components. The repository may comprise a relational database or a non relational database.

The repository and file system may be implemented in storage media in one or more storage devices known in the art such as interconnected hard disk drives e.g. configured as a DASD RAID JBOD etc. solid state storage devices e.g. EEPROM Electrically Erasable Programmable Read Only Memory flash memory solid state disks SSDs flash disk storage class memory SCM electronic memory etc. The repository and file system may be implemented in the same or different storage devices. The network may comprise an interconnected network e.g. Intranet Internet Local Area Network LAN Storage Area Network SAN etc. .

In described embodiments the schema comprises an XML schema. In alternative embodiments the schema may be implemented in suitable structured document definition languages other than XML. Further the XML schema may comprise a text based meta language for describing data shared between applications as defined for an industry group.

The views created by the view creation and edit service and stored in the repository include a schema identifying the schema from which the view was generated and nodes corresponding to nodes or elements selected from the schema . Each view node in a view has a matching node in the schema . The view nodes include information on how to render the nodes from the schema corresponding to elements in the schema in the view output i.e. whether to include chunk or generate structured elements for the instances of the elements corresponding to the view nodes.

For instance the GUI in shows a tree representation of the employee elements and manages recursive elements in the XML schema . shows user selectable nodes for the employee and manages recursive element that allows the user to selectively unwind that element by clicking the plus sign adjacent to the manages element once the plus sign is selected the negative sign is displayed as shown in showing that that element has been unwound at that level. When the user selects to unwind the manages recursive element all the attributes for that element are shown. By selecting to unwind a node representing a recursive element the user has selected to include that level of the recursive element as a structured element generated into any view output . The user has indicated in the GUI to include five levels of instances of the recursive element because five levels of the manages recursive element are shown as unwound . The user has also selected to chunk below the fifth level by not unwinding the text attribute below the fifth instance of the manages recursive element to allow expansion beyond the fifth level of the manages recursive element. In this way the user has selected to chunk below the fifth level of instances of the recursive element. Chunking at a level and all levels beyond that chunked level causes the parser to output the recursive elements as text in a string and not as structured elements in the schema language e.g. XML.

The user may use command lines to provide instructions for a level of the recursive element at which instances of the recursive element in the XML schema will be chunked. For instance the user may specify a maximum level up to which instances of the specified recursive element will be generated into the view output such that instances for levels of the recursive element beyond the user specified maximum level are chunked meaning their data is included in a string as text not as nested XML structured elements.

In this way the XML parser will recognize non nested top level instances of the recursive type parse the contents of those instances and emit the XML structure corresponding to those instances. Nested instances of the recursive type will also be parsed and emitted as XML structure as long as the user specified recursion level has not been reached. Once the maximum prescribed recursion level has been reached the parser chunks the nested instances at and below that level and does not parse the nested instance s components. Instead the parser emits a string representation of the nested instance including any additional instances nested within the current one rather than emitting an XML structure.

In a further embodiment to specify the termination condition the user may supply via a GUI or command line interface a predicate for each recursive type and that predicate specifies the condition under which instances of the recursive element are chunked or not outputted as structured element instances XML structures. In one embodiment the predicate may be coded as an annotation in the view schema e.g. predicate . These termination condition annotations may be attached to the type definitions in the view schema definitions so that the predicates can be evaluated at runtime.

When the XML parser recognizes an instance of the recursive type the parser evaluates the predicate. If the predicate evaluates to true then the parser emits the XML structure corresponding to the instance and continues parsing the instance s components. If the predicate evaluates to false then the parser chunks the instance it does not parse the instance s components and the parser emits a string representation of the instance rather than emitting an XML structure.

In a further embodiment the XML parser may be configured to transform hierarchically structured data such as recursive elements to a flat relational dataset where the XML output may be readily transformed to relational data for a relational database.

With the operations of the presence of the ID and parentID attribute values effectively encodes the hierarchical relationships within the data without requiring those relationships to be explicitly reflected in the XML structures.

The described embodiments provide techniques to terminate the number of levels at which instances of recursive elements are generated into view output to allow the user to tailor the schema view output for easier viewing. Further with described embodiments the user may create a view with a modified schema definition for recursive elements that transforms an element having a recursive type into a non recursive type element with hierarchical information encoded in attributes of the structured element generated into the view output.

The described embodiments allow the user to tailor the display and rendering of instances of recursive elements in view output to optimize the viewing options for the user.

The described operations may be implemented as a method apparatus or computer program product using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof. Accordingly aspects of the embodiments may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the embodiments may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described above with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The terms an embodiment embodiment embodiments the embodiment the embodiments one or more embodiments some embodiments and one embodiment mean one or more but not all embodiments of the present invention s unless expressly specified otherwise.

The terms including comprising having and variations thereof mean including but not limited to unless expressly specified otherwise.

The enumerated listing of items does not imply that any or all of the items are mutually exclusive unless expressly specified otherwise.

Devices that are in communication with each other need not be in continuous communication with each other unless expressly specified otherwise. In addition devices that are in communication with each other may communicate directly or indirectly through one or more intermediaries.

A description of an embodiment with several components in communication with each other does not imply that all such components are required. On the contrary a variety of optional components are described to illustrate the wide variety of possible embodiments of the present invention.

Further although process steps method steps algorithms or the like may be described in a sequential order such processes methods and algorithms may be configured to work in alternate orders. In other words any sequence or order of steps that may be described does not necessarily indicate a requirement that the steps be performed in that order. The steps of processes described herein may be performed in any order practical. Further some steps may be performed simultaneously.

When a single device or article is described herein it will be readily apparent that more than one device article whether or not they cooperate may be used in place of a single device article. Similarly where more than one device or article is described herein whether or not they cooperate it will be readily apparent that a single device article may be used in place of the more than one device or article or a different number of devices articles may be used instead of the shown number of devices or programs. The functionality and or the features of a device may be alternatively embodied by one or more other devices which are not explicitly described as having such functionality features. Thus other embodiments of the present invention need not include the device itself.

The illustrated operations of the figures show certain events occurring in a certain order. In alternative embodiments certain operations may be performed in a different order modified or removed. Moreover steps may be added to the above described logic and still conform to the described embodiments. Further operations described herein may occur sequentially or certain operations may be processed in parallel. Yet further operations may be performed by a single processing unit or by distributed processing units.

The elements of the computing environment of including the client GUI application server and components repository and file system may be implemented in one or more computer systems such as the computer system shown in . Computer system server may be described in the general context of computer system executable instructions such as program modules being executed by a computer system. Generally program modules may include routines programs objects components logic data structures and so on that perform particular tasks or implement particular abstract data types. Computer system server may be practiced in distributed cloud computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed cloud computing environment program modules may be located in both local and remote computer system storage media including memory storage devices.

As shown in the computer system server is shown in the form of a general purpose computing device. The components of computer system server may include but are not limited to one or more processors or processing units a system memory and a bus that couples various system components including system memory to processor . Bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnects PCI bus.

Computer system server typically includes a variety of computer system readable media. Such media may be any available media that is accessible by computer system server and it includes both volatile and non volatile media removable and non removable media.

System memory can include computer system readable media in the form of volatile memory such as random access memory RAM and or cache memory . Computer system server may further include other removable non removable volatile non volatile computer system storage media. By way of example only storage system can be provided for reading from and writing to a non removable non volatile magnetic media not shown and typically called a hard drive . Although not shown a magnetic disk drive for reading from and writing to a removable non volatile magnetic disk e.g. a floppy disk and an optical disk drive for reading from or writing to a removable non volatile optical disk such as a CD ROM DVD ROM or other optical media can be provided. In such instances each can be connected to bus by one or more data media interfaces. As will be further depicted and described below memory may include at least one program product having a set e.g. at least one of program modules that are configured to carry out the functions of embodiments of the invention.

Program utility having a set at least one of program modules may be stored in memory by way of example and not limitation as well as an operating system one or more application programs other program modules and program data. Each of the operating system one or more application programs other program modules and program data or some combination thereof may include an implementation of a networking environment. The components of the computer may be implemented as program modules which generally carry out the functions and or methodologies of embodiments of the invention as described herein. The components and of the computing environment may be implemented in one or more computer systems where if they are implemented in multiple computer systems then the computer systems may communicate over a network.

Computer system server may also communicate with one or more external devices such as a keyboard a pointing device a display etc. one or more devices that enable a user to interact with computer system server and or any devices e.g. network card modem etc. that enable computer system server to communicate with one or more other computing devices. Such communication can occur via Input Output I O interfaces . Still yet computer system server can communicate with one or more networks such as a local area network LAN a general wide area network WAN and or a public network e.g. the Internet via network adapter . As depicted network adapter communicates with the other components of computer system server via bus . It should be understood that although not shown other hardware and or software components could be used in conjunction with computer system server . Examples include but are not limited to microcode device drivers redundant processing units external disk drive arrays RAID systems tape drives and data archival storage systems etc.

The foregoing description of various embodiments of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description but rather by the claims appended hereto. The above specification examples and data provide a complete description of the manufacture and use of the composition of the invention. Since many embodiments of the invention can be made without departing from the spirit and scope of the invention the invention resides in the claims herein after appended.

