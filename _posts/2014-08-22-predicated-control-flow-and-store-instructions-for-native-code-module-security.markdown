---

title: Predicated control flow and store instructions for native code module security
abstract: Some embodiments provide a system that executes a native code module. During operation, the system obtains the native code module. Next, the system loads the native code module into a secure runtime environment. Finally, the system safely executes the native code module in the secure runtime environment by using a set of software fault isolation (SFI) mechanisms that use predicated store instructions and predicated control flow instructions, wherein each predicated instruction from the predicated store instructions and the predicated control flow instructions is executed if a mask condition associated with the predicated instruction is met.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09075625&OS=09075625&RS=09075625
owner: Google Inc.
number: 09075625
owner_city: Mountain View
owner_country: US
publication_date: 20140822
---
This application is a continuation in part of U.S. application Ser. No. 12 621 286 entitled Native Code Module Security for ARM Instruction Set Architectures by inventors Robert Muth Karl Schimpf David C. Sehr and Cliff L. Biffle filed 18 Nov. 2009 which claims the benefit of U.S. Provisional Application No. 61 230 530 entitled Native Code Module Security for ARM Instruction Set Architectures by inventors Robert Muth Karl Schimpf David C. Sehr and Cliff L. Biffle filed 31 Jul. 2009.

The subject matter of this application is related to the subject matter in a co pending non provisional application by J. Bradley Chen Matthew T. Harren Matthew Papakipos David C. Sehr and Bennet S. Yee entitled Method for Validating an Untrusted Native Code Module having Ser. No. 12 117 634 and filing date 8 May 2008.

The subject matter of this application is also related to the subject matter in a co pending non provisional application by J. Bradley Chen Matthew T. Harren Matthew Papakipos David C. Sehr Bennet S. Yee and Gregory Dardyk entitled Method for Safely Executing an Untrusted Native Code Module on a Computing Device having Ser. No. 12 117 650 and filing date 8 May 2008.

The present embodiments relate to techniques for safely executing native code modules. More specifically the present embodiments relate to a method and system for safely executing native code modules using predicated control flow and store instructions.

Easy access to computers and plentiful network bandwidth have facilitated sharing of information and applications. For instance a user of a computing device e.g. personal computer mobile phone personal digital assistant etc. may easily install and execute an application downloaded from a website or received from a friend as an email attachment. However installing and executing such applications on a given computing device typically involves a level of trust that is granted on an all or nothing basis by the operating system of the computing device. Furthermore bugs in the operating system may inadvertently allow applications to access resources As a result some e.g. native applications may have full access to the operating system and or resources of the computing device while other e.g. web applications may have little to no direct access to the operating system and or resources of the computing device.

Such coarse grained application of trust may negatively impact the execution of all applications on the computing device. For example native applications may produce unwanted side effects by modifying files on the computing device and or engaging in computation or communication outside of the tasks or features requested by the user. On the other hand web applications may execute one to two orders of magnitude more slowly than native applications and may provide limited functionality to the user.

Hence what is needed is a technique for facilitating finer grained application of trust to software executing on computing devices.

Some embodiments provide a system that executes a native code module. During operation the system obtains the native code module. Next the system loads the native code module into a secure runtime environment. Finally the system safely executes the native code module in the secure runtime environment by using a set of software fault isolation SFI mechanisms that use predicated store instructions and predicated control flow instructions wherein each predicated instruction from the predicated store instructions and the predicated control flow instructions is executed if a mask condition associated with the predicated instruction is met.

In some embodiments the system also validates the native code module using one or more of the SFI mechanisms prior to executing the native code module in the secure runtime environment.

In some embodiments using the predicated store instructions and the predicated control flow instructions involves executing a comparison instruction using the mask condition and a destination address associated with the predicated instruction and executing the predicated instruction based on one or more condition codes modified by the comparison instruction.

In some embodiments the comparison instruction includes a notational and instruction that logically compares a first set of bits from the mask condition with a second set of bits from the destination address.

In some embodiments the one or more condition codes include a zero flag that is set if the notational and instruction returns a set of zero bits.

In some embodiments the predicated instruction is executed if the zero flag is set and the predicated instruction is skipped if the zero flag is cleared.

The following description is presented to enable any person skilled in the art to make and use the embodiments and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present disclosure. Thus the system is not limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features disclosed herein.

The data structures and code described in this detailed description are typically stored on a computer readable storage medium which may be any device or medium that can store code and or data for use by a computer system. The computer readable storage medium includes but is not limited to volatile memory non volatile memory magnetic and optical storage devices such as disk drives magnetic tape CDs compact discs DVDs digital versatile discs or digital video discs or other media capable of storing code and or data now known or later developed.

The methods and processes described in the detailed description section can be embodied as code and or data which can be stored in a computer readable storage medium as described above. When a computer system reads and executes the code and or data stored on the computer readable storage medium the computer system performs the methods and processes embodied as data structures and code and stored within the computer readable storage medium.

Furthermore methods and processes described herein can be included in hardware modules or apparatus. These modules or apparatus may include but are not limited to an application specific integrated circuit ASIC chip a field programmable gate array FPGA a dedicated or shared processor that executes a particular software module or a piece of code at a particular time and or other programmable logic devices now known or later developed. When the hardware modules or apparatus are activated they perform the methods and processes included within them.

Embodiments provide a method and system for safely executing a native code module. The native code module may contain native code that is executed within a secure runtime environment that isolates the native code module from sensitive data and resources on the computing system. The native code module may additionally be validated by a validator prior to execution within the secure runtime environment to ensure that the native code module complies with a set of security constraints. Furthermore the native code module may be used to perform computationally intensive operations for a web application executing within a web browser.

More specifically embodiments provide a method and system for maintaining security for the native code module using predicated control flow and store instructions. Each predicated instruction is executed only if a mask condition associated with the predicated instruction is met. For example a predicated instruction may be preceded by a comparison instruction that performs a bitwise and of a destination address associated with the predicated instruction and a set of mask bits. The comparison instruction may update a set of condition codes based on the result of the bitwise and instead of computing and storing the result of the bitwise and. The predicated instruction may then be executed based on the condition codes. For example the predicated instruction may be executed if a zero flag associated with the comparison instruction is set and skipped if the zero flag is cleared. Such use of comparison instructions and predicated instructions may reduce overhead associated with executing the native code module while ensuring that control flow and store instructions are effectively constrained.

Computing system may correspond to an electronic device that provides one or more services or functions to a user. For example computing system may operate as a mobile phone personal computer PC global positioning system GPS receiver portable media player personal digital assistant PDA and or graphing calculator. In addition computing system may include an operating system not shown that coordinates the use of hardware and software resources on computing system as well as one or more applications e.g. web browser web application that perform specialized tasks for the user. For example computing system may include applications such as an email client address book document editor web browser and or media player. To perform tasks for the user applications may obtain the use of hardware resources e.g. ARM processor memory I O components network interface card graphics processing unit GPU etc. on computing system from the operating system as well as interact with the user through a hardware and or software framework provided by the operating system as described below.

In one or more embodiments computing system includes functionality to obtain and or execute applications using a network connection. In particular computing system may obtain web application from one or more servers e.g. server 1 server x using a network connection with the server s and load web application in web browser . For example web application may be downloaded from an application server over the Internet by web browser .

Once loaded web application may provide features and user interactivity comparable to that of native applications on computing system . For example web application may function as an email client document editor media player computer aided design CAD system and or computer game. Web application may also include dynamic user interface elements such as menus buttons windows sub windows icons animations and or other graphical objects that emulate analogous user interface elements in native applications. In other words web application may correspond to a rich Internet application RIA .

Furthermore web application may execute on computing system regardless of the type of platform e.g. operating system drivers hardware etc. associated with computing system . Though platform independent applications such as web application may be more portable and secure than native applications such cross platform applications may lack certain performance capabilities of native applications.

More specifically non native applications such as web application may be written using scripting languages that are interpreted rather than compiled such as JavaScript JavaScript is a registered trademark of Sun Microsystems Inc. . The interpreted nature of web application and or other non native applications may result in significantly slower execution times for the non native applications than those of compiled native applications. Non native applications may also be unable to utilize low level libraries and or application programming interfaces API that are available for use by native applications. Consequently non native applications may provide limited functionality in certain tasks.

To enable native performance for web applications computing system may obtain and execute a native code module within plugin . Like web application native code module may be obtained from one or more servers e.g. server 1 server x by web browser . For example web application may provide a hyperlink to native code module on the Internet. Web browser may then download native code module from the Uniform Resource Locator URL specified in the hyperlink. Alternatively native code module may be specified by the user or by an external source such as another web application and or a native application. Furthermore native code module may be obtained from local storage e.g. a browser cache on computing system instead of from a server.

More specifically native code module may correspond to a software module containing native code that runs directly on hardware provided by computing system such as a CPU e.g. ARM processor . As a result native code module may be used to perform tasks that require substantial access to CPU resources on computing system . For example native code module may be used by web application to provide computationally intensive features associated with physics simulation signal processing artificial intelligence modeling flexible high throughput cryptography and or multimedia editing and analysis.

In one or more embodiments plugin includes a variety of mechanisms to ensure the safe execution of native code module . In particular native code module may be validated by a validator provided by plugin prior to execution. Native code module validation is described in a co pending non provisional application by inventors J. Bradley Chen Matthew T. Harren Matthew Papakipos David C. Sehr and Bennet S. Yee entitled Method for Validating an Untrusted Native Code Module having Ser. No. 12 117 634 and filing date 8 May 2008 which is incorporated herein by reference.

Once native code module is validated native code module may be loaded into a secure runtime environment provided by plugin . Native code execution in a secure runtime environment is described in a co pending non provisional application by inventors J. Bradley Chen Matthew T. Harren Matthew Papakipos David C. Sehr Bennet S. Yee and Gregory Dardyk entitled Method for Safely Executing an Untrusted Native Code Module on a Computing Device having Ser. No. 12 117 650 and filing date 8 May 2008 which is incorporated herein by reference. Secure runtime environment may also be provided by a web browser extension to web browser and or secure runtime environment may be built into web browser .

Furthermore because native code module may include binary code that runs directly on hardware native code module may be platform independent with respect to the operating system web browser and or other software components on computing system . As described in the above referenced applications plugin and or native code module may also include mechanisms for executing on a variety of instruction set architectures including the use of fat binaries and binary translators.

However native code module may not be platform independent with respect to the instruction set architecture ISA of one or more processors e.g. ARM processor in computing system . In particular different ISAs may implement data types instructions registers addressing modes memory architecture interrupt and exception handling and or external input output I O differently. Accordingly instructions and mechanisms for executing software modules e.g. web browser native code module plugin etc. directly on hardware may vary between different ISAs. Moreover execution of the same software module within multiple ISAs may require that the software module be recompiled into a different binary executable for each ISA. For example an x86 64 bit implementation of native code module may utilize 64 bit addresses a flat segmentation model of memory and 64 bit general purpose registers GPRs while an x86 32 bit implementation of native code module may utilize 32 bit addresses a multi segment model of memory and 32 bit GPRs.

Differences in ISA implementations may additionally affect security mechanisms used to validate and execute native code module . More specifically the security mechanisms described in the above referenced applications for executing native code modules within x86 ISAs may not pertain to mechanisms for safely executing native code modules within x86 64 bit or ARM ISAs. Consequently the functionality of validator and or secure runtime environment may require adaptation for use within a variety of ISAs.

In one or more embodiments the system of includes functionality to safely execute native code module within an ARM ISA. In other words plugin and web browser may correspond to software modules that execute directly on ARM processor using the ARM ISA. Moreover native code module may correspond to a set of ARM instructions and data that is loaded into the address space of ARM processor and used to facilitate the execution of web application .

As with native code modules in x86 environments the secure execution of native code module on ARM processor may be facilitated by validator and or secure runtime environment . In particular validator and secure runtime environment may enable safe execution of native code module on ARM processor using a set of software fault isolation SFI mechanisms in lieu of hardware segmented memory support available in x86 ISAs. Such SFI mechanisms may maintain control flow integrity for native code module and or constrain store instructions in native code module .

Validator and secure runtime environment may also be configured to maintain security for native code modules within x86 64 bit ISAs. Native code module security within x86 64 bit ISAs is described in a co pending non provisional application by David C. Sehr Bennet S. Yee and J. Bradley Chen and filed on the same day as the instant application entitled Native Code Module Security for 64 bit Instruction Set Architectures having serial number TO BE ASSIGNED and filing date TO BE ASSIGNED which is incorporated herein by reference.

In one or more embodiments native code module is loaded into memory of computing system for inspection by validator . Once loaded into memory page table protection provided by the operating system of computing system may prevent native code module from being modified. As discussed below with respect to page table protection may additionally provide SFI mechanisms for restricting instruction execution in native code module to a code region in the address space and data accesses to the code region or a data region in the address space.

In one or more embodiments validator performs static binary analysis on native code module to ensure that native code module conforms to a set of security constraints. If native code module does not conform to the security constraints validator may discard native code module prior to loading native code module into secure runtime environment .

During analysis of native code module validator may ensure that native code module is statically linked at a start address of zero e.g. providing a zero based address range for native code module with the first byte of text at 128 Kbytes after the start address. Validator may then sequentially disassemble and or decode all executable instructions within native code module beginning with the first byte of text at 128 Kbytes after the start address. During disassembly validator may verify that native code module does not contain any unsafe or otherwise restricted instructions such as instructions that directly invoke the operating system hardware performance instructions and or complex addressing modes. As discussed below validator may also verify that data blocks within a code region associated with native code module begin with illegal instructions.

Once native code module is validated native code module is executed in secure runtime environment . As described in the above referenced applications secure runtime environment may load and launch native code module from memory provide an execution environment that includes communications threads memory management and debugging support for native code module moderate access to system resources according to an access policy for native code module and or support the isolated execution of multiple native code modules on computing system . Consequently secure runtime environment may provide additional SFI mechanisms for ensuring the secure execution of native code module on computing system . In particular secure runtime environment may restrict access from native code module to registers memory and or other resources associated with the ARM ISA.

As discussed in the above referenced applications validator and or secure runtime environment may enforce security for native code module by providing pseudo instructions that mask certain instructions within native code module . In one or more embodiments pseudo instructions are used to constrain both control flow instructions and store instructions within the ARM ISA. Furthermore the SFI mechanisms provided by validator and or secure runtime environment may ensure that all instructions within each pseudo instruction are executed sequentially or not at all.

In one or more embodiments validator and or secure runtime environment provide SFI mechanisms that enforce control flow integrity by restricting the execution of certain instructions ensuring that data blocks are never executed validating direct control flow instructions and or masking destination addresses associated with indirect control flow instructions. More specifically validator may ensure that control flow instructions in native code module are restricted to branch and link e.g. bl instructions and branch and exchange e.g. bx instructions. In other words validator may disable program counter e.g. R15 register updates using general register move instructions or load multiple e.g. ldm instructions. Alternatively program counter updates may be used to mask indirect control flow instructions. Furthermore validator and or secure runtime environment may disable the use of Thumb instructions in native code module . Such restrictions may simplify control flow analysis by validator with little to no performance impact during execution of native code module .

In addition validator and or secure runtime environment may ensure that data blocks within the code region associated with native code module are never executed. As mentioned previously page table protection may restrict instruction execution in native code module to a code region of the address space. However the ARM ISA may store both executable instructions and data e.g. constant pools within the code region. To prevent data from being executed the SFI mechanisms may divide the code region into equally sized aligned 16 byte blocks containing either code e.g. code blocks or data e.g. data blocks start each data block in the code region with an illegal instruction and ensure that each indirect control flow instruction targets the beginning of an aligned 16 byte code block.

To validate direct control flow instructions validator may statically compute direct control flow targets and confirm that the targets correspond to valid instructions. To validate indirect control flow instructions e.g. instructions with targets computed at runtime validator may verify that each indirect control flow instruction is part of a multi instruction sequence e.g. pseudo instruction with appropriate address masking operations during loading of native code module into memory.

In one or more embodiments validator ensures that a set of upper bits and a set of lower bits in each destination address associated with each indirect control flow instruction and or store instruction are cleared. The cleared bits may prevent the instructions from accessing restricted portions of the address space. For example validator may use a masking instruction to ensure that the first bit of each store instruction s destination address is cleared which in turn keeps the destination address in the first 2 Gbytes of the address space.

More specifically validator may use pseudo instructions that contain predicated control flow and store instructions. Each pseudo instruction may additionally include a comparison instruction that precedes a predicated instruction. The comparison instruction may examine a destination address of the predicated instruction to ensure that the destination address meets a mask condition associated with the predicated instruction. For example the comparison instruction may correspond to a notational and instruction e.g. tst that performs a bitwise and of a first set of bits from the mask condition with a second set of bits from the destination address. Furthermore the comparison instruction may modify one or more condition codes. For example instead of computing and storing a result associated with the bitwise and the notational and instruction may modify a zero flag based on the result of the bitwise and the zero flag may be set if the result is a set of zero bits or the zero flag may be cleared if the result contains one or more nonzero bits.

The predicated instruction may then be executed based on the condition codes. For example the predicated instruction may be executed if the zero flag is set which indicates that the destination address meets the mask condition. On the other hand the predicated instruction may be skipped if the zero flag is cleared which indicates that the destination address does not meet the mask condition. Comparison instructions mask conditions and predicated control flow and store instructions are discussed in further detail below with respect to .

Because pseudo instructions that use comparison and predicated instructions do not store the results of masking destination addresses the use of such pseudo instructions may be more efficient than the use of pseudo instructions that contain masking instructions. For example a pseudo instruction that contains a tst instruction followed by a streq instruction may require two fewer clock cycles than a pseudo instruction that contains a bic instruction followed by an str instruction. A similar increase in efficiency may be enabled for native code modules associated with other ISAs if such ISAs provide predicated control flow and or store instructions. Consequently overhead associated with executing native code modules in a variety of ISAs may be reduced by using predicated control flow and store instructions in lieu of masking instructions in pseudo instructions within the native code modules.

As discussed above the pseudo instruction may include a predicated store instruction e.g. streq r1 r0 corresponding to the store instruction that is executed if a mask condition associated with the store is met. As shown in a comparison instruction e.g. tst r0 0x80000000 may be executed immediately before instruction to determine if the mask condition is met. In particular instruction may correspond to a notational and instruction that performs a bitwise and using a destination address of instruction e.g. the contents of the r0 register and a mask value e.g. 0x80000000 corresponding to the mask condition.

Instruction may additionally update one or more condition codes. The condition codes may be stored in a Current Program Status Register CPSR provided by the ARM ISA and may correspond to the Negative Zero Carry and or Overflow e.g. N Z C V bits of the CPSR. Instruction may update the Z bit of the CPSR based on the bitwise and of the destination address and mask value. If the bitwise and produces all zero bits the Z bit is set. On the other hand if the bitwise and produces one or more nonzero bits the Z bit is cleared.

Because instruction includes the eq suffix instruction is executed only if the Z bit is set by instruction . Conversely instruction is skipped if the Z bit is cleared by instruction . In other words the pseudo instruction may constrain stores to the destination address stored in the r0 register by executing instruction only if the destination address conforms to the mask condition e.g. a cleared first bit for stores in the native code module instead of directly masking the contents of the r0 register.

As with the pseudo instruction of includes two instructions at offsets of e108 and e10c in the last two sections of an aligned 16 byte block. Moreover instruction corresponds to a notational and instruction that sets a Z bit of the CPSR if the destination address of instruction e.g. the contents of the r0 register meets the mask condition represented by the mask value of 0x8000000F. The mask condition may be used to ensure that the target of the branch and exchange instruction is aligned along a 16 byte alignment boundary and remains within a code region in the first 2 Gbytes in the address space.

Instruction may then be executed based on the setting or clearing of the Z bit by instruction . If the Z bit is set e.g. the destination address meets the mask condition instruction is permitted to branch to the destination address. If the Z bit is cleared e.g. the destination address does not meet the mask condition instruction is skipped to prevent code execution from reaching a restricted region of the address space.

Because the branching instruction to be constrained already contains a predicate that requires the Z bit to be set the predicate is also applied to a comparison instruction preceding instruction in the pseudo instruction so that instruction does not inadvertently set the Z bit if the Z bit was cleared prior to instruction . In other words the predicated execution of instruction may prevent instruction from interfering with the intended execution or skipping of instruction based on the value of the Z bit prior to modification by instruction . The pseudo instruction of may also be adapted to other branching instructions with the eq suffix such as bleq instructions and or blxeq instructions.

First the native code module is obtained operation . The native code module may be obtained from one or more servers and or compiled from source code. In addition the native code module may be used to facilitate the execution of a web application such as a JavaScript application. For example the native code module may be used to perform computationally intensive operations for the web application.

Next the native code module is loaded into a secure runtime environment operation . For example the native code module may be loaded into a secure runtime environment for an ARM ISA and or another ISA that contains predicated control flow and or store instructions. The loaded native code module is then validated operation using one or more SFI mechanisms prior to executing the native code module. During validation the native code module may be inspected for conformity to a set of security constraints. In particular the native code module may be inspected to detect defects that do not conform to the security constraints operation . If the native code module does not conform to the security constraints e.g. the validator detects defects in the native code the native code module is discarded without having been executed.

If the validator does not detect defects in the native code module the native code module is executed in the secure runtime environment using the SFI mechanisms operation . The secure runtime environment may be provided by a plugin associated with the web browser a browser extension to the web browser and or a component within the web browser. The SFI mechanisms may use predicated store instructions and predicated control flow instructions to constrain stores and control flow in the native code module. Each predicated instruction from the predicated store and or predicated control flow instructions may be executed if a mask condition associated with the predicated instruction is met. In particular the predicated instruction may be preceded by a comparison instruction that determines if a destination address associated with the predicated instruction meets the mask condition. The comparison instruction may modify one or more condition codes which are then used to execute or skip the predicated instruction.

Consequently the SFI mechanisms used to validate and execute the native code module may enable secure execution of the native code module directly on hardware with low performance overhead while maintaining portability and platform independence across different web browsers and operating systems. In particular the SFI mechanisms may provide per thread protection that constrains threads used to execute untrusted code in the native code module while allowing trusted code used to validate and execute the native code module to execute without constraints. Furthermore the SFI mechanisms may improve performance by minimizing overhead associated with enforcing mask conditions for control flow and store instructions. Finally the direct execution of the native code module on hardware may allow the native code module to execute on a variety of processors and operating systems without modification.

The foregoing descriptions of various embodiments have been presented only for purposes of illustration and description. They are not intended to be exhaustive or to limit the present embodiments to the forms disclosed. Accordingly many modifications and variations will be apparent to practitioners skilled in the art. Additionally the above disclosure is not intended to limit the present embodiments.

