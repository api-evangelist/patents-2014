---

title: Dynamic generation of policy enforcement rules and actions from policy attachment semantics
abstract: At least one defined service policy to be enforced by a policy enforcement point (PEP) is obtained. The obtained at least one defined service policy is parsed to identify at least one set of enforceable policy provisions and the at least one set of enforceable policy provisions is identified. Each set of enforceable policy provisions includes a policy subject, a policy domain, and at least one assertion as the enforceable policy provisions within the at least one defined service policy. At least one runtime processing rule including at least one processing action usable by the PEP is created to enforce the policy subject, the policy domain, and the at least one assertion of each identified at least one set of enforceable policy provisions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09270541&OS=09270541&RS=09270541
owner: INTERNATIONAL BUSINESS MACHINES CORPORATION
number: 09270541
owner_city: Armonk
owner_country: US
publication_date: 20140325
---
This application is a continuation of and claims priority to and claims the benefit of U.S. patent application Ser. No. 13 764 828 titled DYNAMIC GENERATION OF POLICY ENFORCEMENT RULES AND ACTIONS FROM POLICY ATTACHMENT SEMANTICS which was filed in the United States Patent and Trademark Office on Feb. 12 2013 and which is incorporated herein by reference in its entirety.

This application is further related to U.S. patent application Ser. No. 13 764 847 titled APPLYING POLICY ATTACHMENT SERVICE LEVEL MANAGEMENT SLM SEMANTICS WITHIN A PEERED POLICY ENFORCEMENT DEPLOYMENT which was filed in the United States Patent and Trademark Office on Feb. 12 2013 to U.S. patent application Ser. No. 13 764 864 titled POLICY ASSERTION LINKING TO PROCESSING RULE CONTEXTS FOR POLICY ENFORCEMENT which was filed in the United States Patent and Trademark Office on Feb. 12 2013 and to U.S. patent application Ser. No. 13 764 895 titled INSTRUMENTATION AND MONITORING OF SERVICE LEVEL AGREEMENT SLA AND SERVICE POLICY ENFORCEMENT which was filed in the United States Patent and Trademark Office on Feb. 12 2013 each of which is hereby incorporated by reference as if fully set forth herein.

The present invention relates to service level agreement SLA policy enforcement. More particularly the present invention relates to dynamic generation of policy enforcement rules and actions from policy attachment semantics.

Service level agreements SLAs are contracts for services formed between consumers and service providers. For example a consumer may enter into a service level agreement with a service provider to send and or receive an agreed number of messages e.g. text messages per month for a contracted set fee. The SLA may further specify that if the consumer exceeds the agreed number of messages per month associated with the contracted set fee an additional per message fee will be charged for each additional message.

A method includes obtaining by a processor at least one defined service policy to be enforced by a policy enforcement point PEP parsing the obtained at least one defined service policy to identify at least one set of enforceable policy provisions identifying the at least one set of enforceable policy provisions where each set of enforceable policy provisions comprises a policy subject a policy domain and at least one assertion as the enforceable policy provisions within the at least one defined service policy and creating at least one runtime processing rule comprising at least one processing action usable by the PEP to enforce the policy subject the policy domain and the at least one assertion of each identified at least one set of enforceable policy provisions.

A system includes a memory and a processor programmed to obtain at least one defined service policy to be enforced by a policy enforcement point PEP parse the obtained at least one defined service policy to identify at least one set of enforceable policy provisions identify the at least one set of enforceable policy provisions where each set of enforceable policy provisions comprises a policy subject a policy domain and at least one assertion as the enforceable policy provisions within the at least one defined service policy and create within the memory at least one runtime processing rule comprising at least one processing action usable by the PEP to enforce the policy subject the policy domain and the at least one assertion of each identified at least one set of enforceable policy provisions.

A computer program product includes a computer readable storage medium having computer readable program code embodied therewith where the computer readable program code when executed on a computer causes the computer to obtain at least one defined service policy to be enforced by a policy enforcement point PEP parse the obtained at least one defined service policy to identify at least one set of enforceable policy provisions identify the at least one set of enforceable policy provisions where each set of enforceable policy provisions comprises a policy subject a policy domain and at least one assertion as the enforceable policy provisions within the at least one defined service policy and create at least one runtime processing rule comprising at least one processing action usable by the PEP to enforce the policy subject the policy domain and the at least one assertion of each identified at least one set of enforceable policy provisions.

The examples set forth below represent the necessary information to enable those skilled in the art to practice the invention and illustrate the best mode of practicing the invention. Upon reading the following description in light of the accompanying drawing figures those skilled in the art will understand the concepts of the invention and will recognize applications of these concepts not particularly addressed herein. It should be understood that these concepts and applications fall within the scope of the disclosure and the accompanying claims.

The subject matter described herein provides dynamic generation of policy enforcement rules and actions from policy attachment semantics. The present technology involves automated policy transformation and runtime enforcement to allow policies within a policy domain e.g. service provider policy domain etc. to be associated with any runtime object e.g. objects representing specific consumers organizations service resources etc. that needs to be controlled or regulated by that policy. Those policies may be enforced against the runtime object s at policy enforcement points PEPs that operate to provide proxy service offerings including policy enforcement. Examples of runtime objects against which policies may be enforced include transactions web requests database requests representational state transfer REST services and web applications. The control or regulation of the runtime object by policy may be further determined based upon the content of that object at runtime such as user credentials. Policies may be attached at an object level for an object thereby enhancing the specificity of policy enforcement based upon the granularity of the respective objects e.g. at the level of specific consumers organizations service resources etc. and based upon the content of those objects at runtime.

To implement the present technology a device such as a PEP programmatically and dynamically transforms defined service policies which are defined using policy attachment semantics into runtime processing rules that encapsulate runtime processing actions collectively runtime policy enforcement rules that are to be executed against runtime objects to enforce the provisions e.g. defined via the policy attachment semantics of the defined policies. To transform the defined service policies the device obtains one or more defined service policies to be enforced by the PEP. The defined service policies that are obtained are parsed to identify enforceable policy provisions such as policy constraints e.g. number of messages per agreement . A policy subject a policy domain and one or more assertions are identified as the enforceable policy provisions within each defined service policy. Additionally an optional policy schedule and policy effective dates may be included in policy attachments. One or more runtime processing rules that include at least one processing action usable by the PEP to enforce the identified policy subject policy domain and the assertion s of each defined service policy are defined. The PEP may then apply the defined processing rules and the encapsulated processing actions against runtime objects to enforce the original service policy definitions.

To transform the defined service policies into the runtime processing rules and processing actions intermediate proxy policy objects are created that operate as intermediate effective policies. The proxy policy objects support the proxy service offerings and constraints for policy enforcement provided by PEPs as described herein. The creation of policy enforcement rules that include runtime processing rules and processing actions to support the runtime enforcement of defined policies involves the creation of these intermediate policy proxy objects that include information from the original policy that is under transformation. These intermediate policy proxy objects provide a framework and foundation for creation of the actual runtime policy enforcement rules including the processing rules and processing actions.

The present technology may be applied for example to implement service level agreements SLAs within a service oriented architecture SOA network appliance engine. The present technology may be implemented for example using higher level gateway platform actions rather than low level code. As such implementation may be performed at a layer of abstraction above the encoding level for the respective appliance engines. It should be noted that the present technology may be implemented with a variety of policy constructs and is not limited to particular variations of how policies are constructed. Accordingly the present technology may be flexibly applied across a variety of service platforms.

It should be noted that conception of the present subject matter resulted from recognition of certain limitations associated with policy administration and enforcement. For example it was observed that policy administrators are tasked with implementing and maintaining policies to support service level definitions SLDs and service level agreements SLAs and that the domain of policy enforcement has become increasingly complex as systems have increased in size and feature sets. This process of having administrators manually implement and maintain policies was observed to be a time consuming task that is prone to errors particularly due to the increased size and complexity of the systems and feature sets available within these systems. For example it was observed that where multiple SLAs are attached to a service subsequent changes that affect multiple consumers may require the identification and editing of multiple configured policy enforcement rules and actions associated with those policy enforcement rules but that identification of all applicable policy enforcement rules and actions was difficult. It was further observed that manual updating of the applicable policy enforcement rules that were able to be identified may require extensive efforts and that this processing is again prone to errors. It was further determined that there are several issues that have arisen with the increased size and complexity of policy administration and enforcement systems. For example it was determined that scalability cost maintainability agility and operational stability are all factors to be addressed within policy administration and enforcement for such system implementations. As such in view of the observations and determinations described above the present subject matter improves policy administration and enforcement by providing for dynamic generation of policy enforcement rules and actions from policy attachment semantics as described above and in more detail below.

Several definitions are utilized within the following description and some are repeated and further defined below. The term service policy or policy as utilized herein represents any mediation enforcement provision routing provision security provision or any other custom policy provision that is written to a specification that a policy enforcement system may implement. As such a service policy may be implemented as a web service e.g. web services description language WSDL as a representational state transfer REST implementation or service as a web application e.g. plain old XML PDX implementation as a database request or otherwise as appropriate for the given implementation.

Regarding service policies a service level agreement SLA is a service policy that represents an agreement e.g. a contract for services between a service provider and a consumer where a level of service is formally defined and agreed between the parties to the SLA. The SLA records a common understanding about services priorities responsibilities guarantees warranties and any other particulars of the agreement. Examples of SLAs include business services such as a web service a REST service and a web application. The SLA may specify for example the levels of availability serviceability performance operation or other attributes of the service to be provided by the service provider to the consumer. As a further example an SLA may represent a processing agreement such as a transaction rate a processor utilization level a disk utilization level and a memory utilization level for the business service.

A service level definition SLD represents a service policy that protects the service provider infrastructure access and utilization constraints such as for example from accesses by non contracting entities for which an SLA has not been established or to limit a maximum resource utilization to prevent service degradation e.g. maximum number of messages per minute . An SLD when attached to a policy subject is enforced by a policy enforcement point PEP . A policy subject represents an entity with which a policy e.g. an SLA or SLD may be associated such as for example an endpoint of a transaction a message a resource an operation or other entity.

A policy administration point PAP represents a location e.g. repository registry etc. where policies such as SLAs and SLDs may be created stored accessed and modified. A WebSphere service registry and repository WSRR represents one possible example of a PAP. A policy enforcement point PEP represents an intermediary system that operates to enforce defined policies. The PEP provides proxy service offerings including policy enforcement. A policy framework represents the infrastructure used to convert supported policy vocabularies into processing actions and processing rules.

Regarding transformation of service policies as a first phase of policy transformation a service policy is transformed into one or more intermediate or local policy entities. The intermediate policy entities are termed herein in the alternative as a proxy policy a proxy policy object and an effective policy. Each of these terms represents an intermediate policy entity created based upon information within the original service policy e.g. SLD or SLA etc. that may be used to create runtime enforcement logic to enforce the respective service policies.

As a second phase of policy transformation the intermediate proxy policy entities are transformed into one or more processing actions that represents an atomic unit of behavior defined based upon a policy to be implemented by a PEP. A processing rule or policy enforcement processing rule as described herein represents an ordered sequence of processing actions defined based upon a policy to be implemented by a PEP. One or more processing rules may be collected into a policy enforcement rule. As such the term policy enforcement rule as used herein represents one or more processing rules to be enforced to perform policy enforcement. An SLA check represents a gateway operation at a PEP that is used to determine the SLA policy enforcement rules created from defined policies that are to be implemented during runtime by that PEP and applied to a particular transaction e.g. to a message .

For example a policy may be specified as an SLA between a service provider and a consumer. Each consumer may have its own selected service options. As such for purposes of the present example it is assumed that two consumers have selected different service plans for a particular service. Within this example one consumer has selected a default service level defined within the service provider domain for this particular service offering at a level of one hundred 100 allowed requests per hour. Similarly another consumer has selected a higher tier service level identified within the present example as a gold service level with a service offering of five hundred 500 allowed requests per hour. As such enforcement of this SLA by a PEP would involve identification of the respective consumers correlation of the respective consumers with their selected service plans levels and monitoring of request rates e.g. message rates transaction rates etc. for each consumer based upon their respective selected plans. If a threshold number of requests per hour associated with a selected plan is reached the PEP would then invoke processing to identify any additional service requests as overages relative to the plan or prevent the service requests as appropriate for a given implementation. Similarly if a consumer issues a request that is authorized based upon the selected service plan the PEP is responsible for ensuring that the request is satisfied for the consumer by the service provider.

The present technology enhances policy enforcement point PEP functionality to transform defined service policies e.g. SLAs and SLDs associated with a policy administration point PAP into policy enforcement rules and actions that are enforced by the PEP. The automated transformation of the defined policies involves transformation from the defined policy definitions semantics to policy enforcement rules and actions that are operable by the PEP platform to enforce the defined policies. The policy enforcement rules and actions are dynamically implemented and enforced on a transactional basis during runtime as transactions associated with the defined policies occur e.g. as messages are received .

Example transformations include transformation of a defined service policy into one or more processing actions in a normalized and interchangeable format. The normalized and interchangeable format may include for example a language such as extensible markup language XML XML stylesheet language for transformations XSLT object oriented languages such as Java and C programming languages relational database management RDBM languages such as structured query language SQL and scripting languages implementations such as PHP Hypertext Preprocessor PHP and Perl.

It should be noted that the PEP processing technology described herein operates as a proxy for both the service providers and the consumers to enforce the various provisions of defined SLAs and SLDs. As such the PEP represents a proxy component entity for both the service provider s and for the consumer s . Within this proxy context for policy enforcement the PEP operates to protect the interests of the service providers to ensure that no unauthorized consumers access the respective services provided by the service providers and to ensure that consumers that are authorized do not exceed the defined SLDs associated with the services and service providers. Similarly the PEP operates to protect the interests of consumers and service providers to ensure that the SLA s for which the consumers and service providers have contracted are upheld enforced. To fulfill this dual proxy role the PEP operates as a proxy intermediary for both of the respective entities to analyze messages communicated between the respective entities and to enforce policy enforcement rules that are defined in association with the PEP based upon policies associated with the respective services and agreements.

As described above the present technology provides for the programmatic creation of policy enforcement rules populated with processing actions from policies defined in association with the respective services and agreements. The following pseudo syntax policy example represents one possible implementation of a defined service policy for which policy enforcement rules populated with processing actions may be programmatically created and that may be enforced by a PEP.

Based upon the pseudo syntax policy example above a UserNameToken 1.0 is defined with an ExactlyOne constraint represented via a tag pair such that only one user name token may be present in any message proxied by a PEP. Additionally the pseudo syntax policy example above further specifies that the user name token must always be present within any message by specifying the IncludeToken Always constraint represented via an additional tag pair . A policy of sp WssUsernameToken10 represents a policy to be enforced for all messages also represented within an additional tag pair that identify the username token version one 1.0 Basic Auth is required.

Attaching the UserNameToken 1.0 policy to a service that is proxied by a PEP results in a filter action being programmatically created. The filter action may be implemented to analyze incoming messages and to determine whether the specified components are part of the incoming message. If the specified components are not present within a particular incoming message the message is rejected. If the specified components are present the message is allowed to continue. As such it is by the creation and implementation of the message filtering action from the original policy that the UserNameToken 1.0 policy is enforced by the PEP.

The following pseudo syntax policy enforcement rule example may be programmatically created from the pseudo syntax policy example above for enforcement within a PEP.

As can be seen from the pseudo syntax policy enforcement rule example above the policy enforcement rule is enabled within the mAdminState field a Type of filter is specified and the filtering action is applied to the INPUT stream specified in the Input field. The Transform field specifies a stylesheet to execute as part of policy action. The Output field specifies the name of a stream where the output of the action is to be stored.

As such a policy framework as described in more detail below consumes policies such as the pseudo syntax policy example above for enforcement by a PEP. To enforce the respective policies the policy framework generates policy enforcement rules that include processing actions such as the example filtering action described above for messages to enforce the associated policy. It should be noted that consumption of defined service policies and transformation of those service policies to enforceable processing rules and processing actions may be repeated with consistency of results. As such one device such as a PEP may be configured to consume and transform policies to create processing rules and to distribute the created processing rules to other PEPs for enforcement along with enforcement by the PEP that performed the transformation which provides one possible option for consistent policy enforcement results across multiple of PEPs. Alternatively each PEP of a multiple PEP environment may be configured to consume and transform service policies into processing rules with consistent transformation results across a set of PEPs which may also result in consistent policy enforcement results. As such a variety of policy transformation processing options may be available and utilized based upon implementation details as appropriate for the respective implementation.

Further as policies change over time the associated policy enforcement rules and processing actions may be modified added deleted or otherwise changed to implement any changes to the respective policies that have changed. As such the present technology may provide for repeatability of implementation. The present technology may further improve scalability of costs maintainability agility and operational stability.

The dynamic generation of policy enforcement rules and actions from policy attachment semantics described herein may be performed in real time to allow prompt creation of policy enforcement rules and run time actions from registered SLA policy attachment semantics. For purposes of the present description real time shall include any time frame of sufficiently short duration as to provide reasonable response time for information processing acceptable to a user of the subject matter described. Additionally the term real time shall include what is commonly termed near real time generally meaning any time frame of sufficiently short duration as to provide reasonable response time for on demand information processing acceptable to a user of the subject matter described e.g. within a portion of a second or within a few seconds . These terms while difficult to precisely define are well understood by those skilled in the art.

The service provider server  through the service provider server M represent service capable devices e.g. messaging devices for text messages etc. . The service provider server  through the service provider server M also represent administrative devices that may be utilized by service provider administrators for policy creation such as creation of SLDs and SLAs.

As described above policies implemented by service provider administrators via devices such as the service provider server  through the service provider server M may be stored within the policy registry for enforcement by PEPs such as the policy enforcement server  through the policy enforcement server T . The policy enforcement server  through the policy enforcement server T each implement a policy framework as described above and in more detail below for transformation of defined service policies stored in the policy registry into policy enforcement rules that include processing rules and processing actions that are to be enforced during runtime against objects. The objects may be of varying granularity e.g. at the level of specific consumers organizations service resources etc. as described above based upon the particular scope and configuration of the respective policies to be enforced for the respective service providers and consumers.

A PEP may be implemented via each of the policy enforcement server  through the policy enforcement server T . The PEP has the role of enforcing policies defined outside or within the PEP. The PEPs operate as gateways that provide virtual services that proxy policy enforcement operations for the real backend services. The PEPs protect and optimize transactions flowing through the respective network s on behalf of the backend services. As such the policy enforcement server  through the policy enforcement server T each represent proxy gateways that provide proxy services for the service providers represented by the service provider server  through the service provider server M and for consumers represented by the computing device  through the computing device N .

It should be noted that there may be a many to one relationship of PEPs to service providers. Each PEP may create its own policy enforcement rules based upon policies to be enforced for a given service provider. By use of the present technology the policy enforcement rule creation from defined policies may be consistently repeated across the set of PEPs that are designated to enforce the respective policies.

As will be described in more detail below in association with through the policy enforcement server  through the policy enforcement server T may each provide automated dynamic generation of policy enforcement rules and actions from policy attachment semantics. The automated dynamic generation of policy enforcement rules and actions from policy attachment semantics is based upon creation of the policy enforcement rules and actions to be enforced during runtime to fulfill the respective SLDs and SLAs established for messaging management within the system . A variety of possibilities exist for implementation of the present subject matter and all such possibilities are considered within the scope of the present subject matter.

It should be noted that any of the respective computing devices described in association with may be portable computing devices either by a user s ability to move the respective computing devices to different locations or by the respective computing device s association with a portable platform such as a plane train automobile or other moving vehicle. It should also be noted that the respective computing devices may be any computing devices capable of processing information as described above and in more detail below. For example the respective computing devices may include devices such as a personal computer e.g. desktop laptop etc. or a handheld device e.g. cellular telephone personal digital assistant PDA email device music recording or playback device tablet computing device e book reading device etc. a service provider messaging server a web server application server or other data server device or any other device capable of processing information as described above and in more detail below.

The network and the network may include any form of interconnection suitable for the intended purpose including a private or public network such as an intranet or the Internet respectively direct inter module interconnection dial up wireless or any other interconnection mechanism capable of interconnecting the respective devices.

Further the core processing module may provide different and complementary processing of policy enforcement rule creation and policy enforcement via the created policy enforcement rules in association with each implementation. As such for any of the examples below it is understood that any aspect of functionality described with respect to any one device that is described in conjunction with another device e.g. sends sending etc. is to be understood to concurrently describe the functionality of the other respective device e.g. receives receiving etc. .

A central processing unit CPU provides computer instruction execution computation and other capabilities within the core processing module . A display provides visual information to a user of the core processing module and an input device provides input capabilities for the user.

The display may include any display device such as a cathode ray tube CRT liquid crystal display LCD light emitting diode LED electronic ink displays projection touchscreen or other display element or panel. The input device may include a computer keyboard a keypad a mouse a pen a joystick touchscreen or any other type of input device by which the user may interact with and respond to information on the display .

It should be noted that the display and the input device may be optional components for the core processing module for certain implementations devices. Accordingly the core processing module may operate as a completely automated embedded device without direct user configurability or feedback. However the core processing module may also provide user feedback and configurability via the display and the input device respectively as appropriate for a given implementation.

A communication module provides interconnection capabilities that allow the core processing module to communicate with other modules within the system . The communication module may include any electrical protocol and protocol conversion capabilities useable to provide interconnection capabilities appropriate for a given implementation.

A memory includes a policy processing storage area that provides memory space for the creation of policies e.g. SLAs and SLDs in association with the core processing module when implemented for example in association with one or more of the service provider server  through the service provider server M . Additionally the policy processing storage area provides memory space for the creation of policy enforcement rules and associated runtime processing actions to support the runtime enforcement of defined policies e.g. SLAs and SLDs in association with the core processing module when implemented for example in association with one or more of the policy enforcement server  through the policy enforcement server T .

The policy processing storage area also provides storage for policy proxy objects that operate as intermediate effective policies that encapsulate policy information from repository service policies that is usable for runtime policy enforcement. As described above creation of policy enforcement rules that include runtime processing rules and processing actions to support the runtime enforcement of defined policies involves the creation of intermediate policy proxy objects that include information from the original policy that is under transformation. These intermediate policy proxy objects provide a framework and foundation for creation of the actual runtime policy enforcement rules including the processing rules and processing actions.

The memory also includes a policy enforcement processing rule and action storage area that provides storage space for created policy enforcement rules and associated runtime processing actions. As described above the created policy enforcement rules and associated runtime processing actions may be utilized for runtime enforcement of defined policies e.g. SLAs and SLDs in association with the core processing module when implemented for example in association with one or more of the policy enforcement server  through the policy enforcement server T .

It is understood that the memory may include any combination of volatile and non volatile memory suitable for the intended purpose distributed or localized as appropriate and may include other memory segments not illustrated within the present example for ease of illustration purposes. For example the memory may include a code storage area an operating system storage area a code execution area and a data area without departure from the scope of the present subject matter.

A policy framework module is also illustrated. The policy framework module provides policy enforcement rule creation and runtime enforcement of processing actions for the core processing module as described above and in more detail below. The policy framework module implements the dynamic generation of policy enforcement rules and actions from policy attachment semantics of the core processing module .

The policy framework module includes several sub components or sub modules. A policy parser parses policy definitions for SLDs and SLAs to identify policy constraints to be implemented during runtime processing of messages. A processing rule generator PRG generates policy enforcement rules from the runtime constraints associated with policies parsed by the policy parser . A policy domain assertion to policy action mapper provides policy mapping to policy enforcement rules within the policy framework module . Given a policy domain and a list of assertions the policy domain assertion to policy action mapper maps or converts each policy domain assertion identified within the runtime constraints parsed by the policy parser to corresponding runtime processing actions to be enforced for messages processed by the policy framework module . The processing rule generator PRG then populates the respective created policy enforcement rule with the created runtime processing actions. The created policy enforcement rules and processing actions may be stored within the policy enforcement processing rule and action storage area of the memory . A policy enforcement module implements the created policy enforcement rules and runtime processing actions created from the original policy definitions.

It should also be noted that the policy framework module may form a portion of other circuitry described without departure from the scope of the present subject matter. Further the policy framework module may alternatively be implemented as an application stored within the memory . In such an implementation the policy framework module may include instructions executed by the CPU for performing the functionality described herein. The CPU may execute these instructions to provide the processing capabilities described above and in more detail below for the core processing module . The policy framework module may form a portion of an interrupt service routine ISR a portion of an operating system a portion of a browser application or a portion of a separate application without departure from the scope of the present subject matter.

The policy registry is also shown associated with the core processing module within to show that the policy registry may be coupled to the core processing module without requiring external connectivity such as via the network or the network .

The CPU the display the input device the communication module the memory the policy framework module and the policy registry are interconnected via an interconnection . The interconnection may include a system bus a network or any other interconnection capable of providing the respective components with suitable interconnection for the respective purpose.

Though the different modules illustrated within are illustrated as component level modules for ease of illustration and description purposes it should be noted that these modules may include any hardware programmed processor s and memory used to carry out the functions of the respective modules as described above and in more detail below. For example the modules may include additional controller circuitry in the form of application specific integrated circuits ASICs processors antennas and or discrete integrated circuits and components for performing communication and electrical control activities associated with the respective modules. Additionally the modules may include interrupt level stack level and application level modules as appropriate. Furthermore the modules may include any memory components used for storage execution and data processing for performing processing activities associated with the respective modules. The modules may also form a portion of other circuitry described or may be combined without departure from the scope of the present subject matter.

Additionally while the core processing module is illustrated with and has certain components described other modules and components may be associated with the core processing module without departure from the scope of the present subject matter. Additionally it should be noted that while the core processing module is described as a single device for ease of illustration purposes the components within the core processing module may be co located or distributed and interconnected via a network without departure from the scope of the present subject matter. For a distributed arrangement the display and the input device may be located at a point of sale device kiosk or other location while the CPU and memory may be located at a local or remote server. Many other possible arrangements for components of the core processing module are possible and all are considered within the scope of the present subject matter. It should also be understood that though the policy registry is illustrated as a separate component for purposes of example the information stored within the policy registry may also alternatively be stored within the memory without departure from the scope of the present subject matter. Accordingly the core processing module may take many forms and may be associated with many platforms.

A policy B represents an SLD of a service provider that is to be enforced by a PEP. The policy parser consumes the original representation of the policy B and generates creates a number of policy proxy objects from the original policy B . The generated policy proxy objects within the present example include proxy policy1 through policy proxy N . Each of the proxy policy1 through the proxy policy N contains similar information based upon information within the original policy B . The effective policies represent locally created processing entities that specify policy enforcement constraints e.g. such as policy subjects credentials assertions etc. to be enforced by a PEP based upon policy information and enforceable policy provisions within the policy B . As such the effective policies map the policy information and enforceable policy provisions within the policy B to policy enforcement constraints from which processing rules and processing actions may be created.

A policy subject is shown within the proxy policy  to be attached to a service policy subject. In the proxy policy N the policy subject is shown to be attached to an operation policy subject. As such the respective effective policies have been created from information within the policy B and have been attached to different policy subjects for eventual enforcement.

A policy domain within the proxy policy  identifies a uniform resource locator URL that represents for purposes of example a location of a policy domain to be enforced. It should be noted that other forms of identification of policy domains are possible and all such possibilities are considered to be within the scope of the present subject matter. Within the present example the URL is illustrated with ellipsis dots for convenience to represent an accessible storage location that references a security policy domain of 2432039. A policy domain within the proxy policy N references the same policy domain as the policy domain within the proxy policy  .

The proxy policy  also includes an SLD assertions identifier with a value of USERNAME TOKEN 1.0 that maps for example to a sp WssUsernameToken10 policy constraint associated within the policy B . An example of such a policy was described in association with the pseudo syntax policy example above. An SLD assertions identifier within the proxy policy N includes a value of USERNAME TOKEN 2.0. As such each of the respective SLD assertion identifiers may include different assertions as specified by the SLD policy B .

Each of the effective policies parsed and generated from the policy B may then be processed one by one by the processing rule generator PRG to create a processing rule for each proxy policy object. The collection set of processing rules that result are represented as a policy enforcement rule . To generate the policy enforcement rule with its set of processing rules that include the respective processing actions the PRG calls invokes the policy domain assertion to policy action mapper sub component to process each proxy policy through as represented for each of the proxy policy through by the single arrow . The PRG passes the policy domain and list of assertions for that particular domain to the policy domain assertion to policy action mapper .

In response to being invoked with the policy domain and list of assertions for that particular domain the policy domain assertion to policy action mapper maps or converts e.g. transforms each of those assertions to create corresponding processing actions . The policy domain assertion to policy action mapper returns the created processing actions to the PRG as represented by the arrow . The PRG then populates the processing rule with the created processing actions . The PRG iteratively processes each proxy policy through and creates a corresponding processing rule within the policy enforcement rule . The PRG outputs the created policy enforcement rule to each PEP that is tasked with policy enforcement for the particular SLD s associated with the policy B . As such the policy framework module generates policy enforcement rules processing rules for each proxy policy object that include processing actions to be performed from the runtime constraints associated with policies and distributes the created policy enforcement rules to the respective PEPs to enforce. This processing may be performed for each policy and for each SLD.

Additional complexities exist with respect to enforcement of SLAs. For example with SLAs the task of the policy framework module described above is more complicated. A policy subject may contain a number of SLAs. These SLAs are determined at runtime based upon the contents e.g. user credentials etc. of the respective objects being processed to determine which if any policy enforcement rules are to be enforced.

Additionally an SLA policy S an SLA policy S and an SLA policy S are illustrated. The policy framework consumes the SLA policies through . Within this example the SLAs would be attached at a service policy subject. The policy framework module creates a parent processing rule for the service policy subject. The parent processing rule includes an SLA check action and for each match and enforce operation loop logic used to select processing rules to be applied during runtime to enforce the respective SLA policies through .

The SLA check action includes requirements specified in the SLA policies through to match against during runtime along with the corresponding processing rule that contains the respective policy implementation. During runtime the SLA check action outputs a list of zero 0 or more processing rules that match content e.g. user credentials etc. within the particular message being processed. The for each match and enforce operation loop logic may then take the list of matching processing rules and make a call to apply each of the matching processing rules one by one. The processing actions from the SLD policy B if any may then be enforced after the matching SLA processing rules .

A proxy policy  is illustrated. It is understood that many effective policies may be created based upon a set of policies represented by the SLD policy B and the SLA policies through . However because of the detail illustrated within the proxy policy  in only this one proxy policy object is illustrated. The ellipsis dots below the proxy policy  represent the continuation of the created effective policies to include the additional effective policies that may be created.

Within this example the policy parser annotates each proxy policy object with additional information along with the associated SLD policy assertion s from the Policy B the credentials that are to be matched for each SLA and the corresponding assertions that are to be used to enforce the respective policies. As can be seen from an SLD proxy policy portion represents a similar effective policy as the proxy policy  of . As such additional description of this portion of the proxy policy  may be obtained with reference to as described above.

Additionally an effective proxy policy object for each of the SLA policy S SLA policy S and SLA policy S is represented in association with the proxy policy  . The policy parser creates an effective SLA proxy policy  from the SLA policy S creates an effective SLA proxy policy  from the SLA policy S and creates an effective SLA proxy policy  from the SLA policy S . As can be seen within the effective SLA proxy policy  each of the effective SLA proxy policy  the effective SLA proxy policy  and the effective SLA proxy policy  form a portion of the proxy policy  .

Each of the effective SLA proxy policy  the effective SLA proxy policy  and the effective SLA proxy policy  includes a credentials field and an assertions field . Within the effective SLA proxy policy  the value of the credentials field is USERID JOHN DOE. As such messages that are processed during runtime with a user identifier of JOHN DOE will be identified and the effective SLA proxy policy  selected for processing those messages. The value of the assertions field within the effective SLA proxy policy  is set to ROUTE MESSAGE which indicates that messages associated with this user identifier are to be routed without any additional transformation or encoding. Additionally it should be noted that the inclusion of the user identifier for JOHN DOE and only that user identifier also satisfies the ExactlyOne policy provision to be enforced for the SLD policy B .

Within the effective SLA proxy policy  the value of the credentials field is USERID JANE DOE. As such messages that are processed during runtime with a user identifier of JANE DOE will be identified and the effective SLA proxy policy  selected for processing those messages. The value of the assertions field within the effective SLA proxy policy  is set to TRANSFORM MESSAGE which indicates that messages associated with this user identifier are to be transformed. Any transformation appropriate for a given SLA and implementation may be utilized. Additionally it should be noted that the inclusion of the user identifier for JANE DOE and only that user identifier also satisfies the ExactlyOne policy provision to be enforced for the SLD policy B .

Within the effective SLA proxy policy  the value of the credentials field is USERID JOHN SMITH. As such messages that are processed during runtime with a user identifier of JOHN SMITH will be identified and the effective SLA proxy policy  selected for processing those messages. The value of the assertions field within the effective SLA proxy policy  is set to ENCRYPT MESSAGE which indicates that messages associated with this user identifier are to be encrypted. Any encryption protocol technique appropriate for a given SLA and implementation may be utilized. For example a message may be encrypted using RSA AES or 3DES or other encryption protocols as appropriate for a given implementation. Additionally it should be noted that the inclusion of the user identifier for JOHN SMITH and only that user identifier also satisfies the ExactlyOne policy provision to be enforced for the SLD proxy policy B .

As described above in association with the processing rule generator PRG again interacts with the policy domain assertion to policy action mapper . Each of the effective proxy policies generated from the policy B and the SLA policies through e.g. the SLA proxy policy  and others may then be processed one by one by the processing rule generator PRG to create a processing rule for each proxy policy object e.g. effective policy . The collection set of processing rules that result are represented as a policy enforcement rule . To generate the policy enforcement rule with its set of processing rules that include the respective processing actions the PRG calls invokes the policy domain assertion to policy action mapper sub component to process each proxy policy object as represented for each proxy policy object by the single arrow . The PRG passes the policy domain and list of assertions for that particular domain to the policy domain assertion to policy action mapper .

In response to being invoked with the policy domain and list of assertions for that particular domain the policy domain assertion to policy action mapper maps or converts e.g. transforms each of those assertions to create corresponding processing actions . The policy domain assertion to policy action mapper returns the created processing actions to the PRG as represented by the arrow . The PRG then populates the processing rule with the created processing actions . The PRG iteratively processes each proxy policy object e.g. the SLA proxy policy  and others and creates a corresponding processing rule within the policy enforcement rule . The PRG outputs the created policy enforcement rule to each PEP that is tasked with policy enforcement for the particular SLD s associated with the policy B and the SLA policies through . As such the policy framework module generates policy enforcement rules processing rules for each proxy policy object that include processing actions to be performed from the runtime constraints associated with policies and distributes the created policy enforcement rules to the respective PEPs to enforce. This processing may be performed for each policy for each SLD and for each SLA.

Regarding additional details of the created policy enforcement rule the PRG may again create the parent rule represented within the first row of the policy enforcement rule . The PRG may populate the parent rule with an SLA Check action represented by the S within the first row first element of the policy enforcement rule . Then for each SLA policy the PRG may append the credentials match to the SLA check action create another empty rule and append the rule name to the SLA check action. This new processing rule may then be populated with the processing actions that result from the assertions of the respective SLA policy through represented by the additional rows of the policy enforcement rule .

Once processing to transform all the SLA policies to SLA processing rules and processing actions has been completed the for each and enforce operation represented by the F within the first row second element of the policy enforcement rule may be added to the parent processing rule. The SLA processing rules may be added appended to the parent processing rule as child processing rules to form a completed policy enforcement rule usable to enforce the provision of the original policy.

During runtime enforcement the loop construct associated with the for each and enforce operation takes in as input the list of processing rule names for SLA processing rules generated by the SLA check action. For each rule name the process iteratively calls or enforces the respective processing rules and thereby enforces the processing actions contained within the respective processing rules. The SLD processing rule s generated from the SLD assertions may also be appended to the parent processing rule represented by the remainder of the first row of the policy enforcement rule . The SLD processing rule s may be applied after the SLA processing rules have been applied.

As such the policy framework provides dynamic rule creation and processing. As any change to a policy is made the processing rules and actions associated with the respective policy may be recreated by the policy framework the previous processing rules and processing actions may be removed and replaced by the newly created processing rules and processing actions. Accordingly policy implementation and enforcement policy maintenance and policy adaptation to changes may be improved by use of the present technology.

In response to determining at decision point that a request to define processing rules and processing actions collectively policy enforcement rules for one or more defined service policies has been detected the process selects obtains a defined service policy to process at block . The selected service policy may be for example a service level definition SLD that protects service provider infrastructure access and utilization constraints or may be a service level agreement SLA that represents an agreement for services and a level of service between a service provider and a consumer.

At block the process parses the selected service policy to identify enforceable policy provisions. At block the process identifies enforceable policy provisions within the parsed service policy. It should be noted that the identified enforceable policy provisions may include a policy subject a policy domain and at least one assertion. It should further be noted that there may be one or more sets of enforceable policy provisions within the parsed service policy as described above. At block the process generates at least one local proxy policy object that includes policy enforcement constraints based upon the identified policy subject policy domain and at least one assertion of the at least one defined service policy that represent the enforceable policy provisions. At block the process populates each proxy policy object with the identified enforceable policy provisions.

At block the process begins iterative processing of the generated proxy policy objects to map the generated proxy policy objects to runtime executable processing rules and processing actions and selects a proxy policy object to map. At block the process defines creates at least one runtime processing rule that includes at least one processing action usable by the PEP to enforce the identified policy subject policy domain and at least one assertion of the defined service policy represented by the selected policy proxy object.

At decision point the process makes a determination as to whether mapping of the generated proxy policy objects to processing rules and processing actions is completed. In response to determining that at least one additional proxy policy object is available to map to runtime executable processing rules and processing actions i.e. the mapping is not completed the process returns to block and iterates as described above.

In response to determining at decision point that all generated proxy policy objects have been mapped to runtime executable processing rules and processing actions the process makes a determination at decision point as to whether the mapped proxy policy objects represent one or more SLD policies only or whether the mapped proxy policy objects additionally represent one or more SLAs. In response to determining that the mapped proxy policy objects represent one or more SLD policies only the process forms an SLD policy enforcement rule from the mapped processing rules and processing actions at block .

Returning to the description of decision point in response to determining that the mapped proxy policy objects additionally represent one or more SLAs at block the process creates one or more service level agreement SLA check actions usable to select SLA processing rules during runtime based upon the contents of the objects under processing during runtime. At block the process generates runtime SLA processing logic to identify matching SLA processing rules to be applied to objects during runtime for SLA policy enforcement. As described above the generated runtime SLA processing logic may include a for each match loop that processes and enforces each appropriate SLA processing rule based upon the contents of the object under processing during runtime. At block the process forms a policy enforcement rule populated with the SLA check action and the runtime SLA processing logic and designates the SLA processing rule as a parent processing rule within the policy enforcement rule. At block the process appends one or more processing rules that include one or more processing actions mapped from the respective SLA policy proxy objects. As described above the processing rules and processing actions mapped from the SLA policy proxy objects are useable during runtime to enforce the defined SLA policies.

In response to appending the SLA processing rules to the policy enforcement rule at block or in response to forming the SLD policy enforcement rule at block the process distributes the generated policy enforcement rule to one or more policy enforcement points PEPs at block . Where the process is executed by a policy enforcement point distribution of the generated policy enforcement rule may include locally implementing the generated policy enforcement rule and may also include distribution of the generated policy enforcement rule to one or more other PEPs. The process returns to decision point and iterates as described above.

As such the process obtains defined service policies reinforced by one or more PEPs generates proxy policy objects based upon the contents of the defined service policies maps generated proxy policy objects to processing rules and processing actions and generates policy enforcement rules. The generated policy enforcement rules are usable during runtime to enforce the original defined service policies at one or more PEPs. The process distributes the generated policy enforcement rules for enforcement to one or more PEPs to deploy the generated policy enforcement rules. It should be noted that the process is dynamic and may be triggered at any time to update deployed policy enforcement rules based upon changes to service policy definitions and or the addition or deletion of defined service policies. Accordingly the process provides a flexible and manageable platform by which to deploy and maintain enforcement logic for defined service policies.

In response to determining that one or more policy enforcement rules have not been received the process makes a determination at decision point as to whether an object for which runtime enforcement of policy enforcement rules has been received. The respective object may be received from a service provider or from a customer. As described above the object may include a service request selected such as a transaction a web request a database request a representational state transfer REST service and a web application a message or any other object for which policy enforcement may be enforced. As also described above a PEP that executes a process such as the process acts as a proxy for both a service provider and a customer between which the object is communicated. In response to determining at decision point that an object for which runtime enforcement of policy enforcement rules has not been received the process returns to decision point and iterates as described above.

In response to determining at decision point that one or more policy enforcement rules has been received or created locally based upon defined service policies the process stores the respective policy enforcement rule s at block . At block the process configures enforcement of the respective policy enforcement rule s . As such the respective policy enforcement rules may be enforced by the PEP. Returning to the description of decision point in response to determining that an object for which runtime enforcement of policy enforcement rules has been received the process identifies a defined policy enforcement rule that includes the defined runtime processing rule s applicable to enforce the defined service policy for which the policy enforcement rule was created against the object during runtime at block .

As described above processing rules may include SLD processing rules and may also include SLA processing rules. Where both an SLD processing rule and one or more SLA processing rules are included in the same policy enforcement rule the SLD processing rule is considered a parent processing rule and is configured to be executed after any child SLA processing rules. As such at decision point the process makes a determination as to whether the defined policy enforcement rule includes one or more SLD processing rules for enforcement of a defined SLD policy only or whether the defined policy enforcement rule includes processing rules for enforcement of one or more SLAs in addition to an SLD.

In response to determining at decision point that the defined policy enforcement rule additionally includes at least one processing rule for enforcement of one or more SLAs the process performs an SLA check action on the object to identify the appropriate SLA processing rule s at block . As also described above the processing for SLA enforcement is dynamic and is based upon the contents of the object at runtime. As such the process may for example determine a first SLA processing rule associated with a first user credential for one object and may determine a second different SLA processing rule associated with a second user credential for another object. Accordingly the process may dynamically adjust the processing actions of the defined processing rules according to the first SLA processing rule of the first user credential and according to the second SLA processing rule for the second user credential. Many other variations on dynamic SLA processing rule selection and enforcement are possible and all are considered to be within the scope of the present subject matter.

At decision point the process makes a determination as to whether the SLA check action identified any matching SLA processing rules to be enforced against the object. In response to determining that at least one matching SLA processing rule has been identified to be enforced against the object the process performs iterative processing for each matching SLA processing rule to process the object using the respective matching SLA processing rule s at block .

In response to determining at decision point that no matching SLA processing rules have been identified to be enforced against the object or in response to processing the object using each matching SLA processing rule at block or in response to determining at decision point that the defined policy enforcement rule only includes one or more SLD processing rules for enforcement of a defined SLD policy the process proceeds to process the object using the SLD policy enforcement rule at block . As described above in the case of a policy enforcement rule that includes both SLD and SLA processing rules the SLD policy enforcement rule is considered the parent processing rule and is configured to be executed after any child SLA processing rules. As such the process enforces the respective SLD processing rule s last after processing each matching SLA processing rule on the object where appropriate.

At decision point the process makes a determination as to whether the object is authorized to be forwarded to the destination based upon the applied policy enforcement rule. In response to determining that the object is authorized to be forwarded to the destination based upon the applied policy enforcement rule the process forwards the object to the destination at block . In response to determining that the object is not authorized to be forwarded to the destination based upon the applied policy enforcement rule the process generates a notification e.g. error notification log entry etc. at block and does not forward the object to the destination. In response to either forwarding the object to the destination at block or in response to generating the notification at block the process returns to decision point and iterates as described above.

As such policy enforcement within a policy enforcement point PEP may be implemented using a process such as the process to dynamically process objects based upon content of the objects during runtime. This processing may be based upon defined runtime processing rules that include runtime processing actions that enforce defined service policies for service providers and contractual agreements between service providers and customers.

As described above in association with through the example systems and processes provide dynamic generation of policy enforcement rules and actions from policy attachment semantics. Many other variations and additional activities associated with dynamic generation of policy enforcement rules and actions from policy attachment semantics are possible and all are considered within the scope of the present subject matter.

Those skilled in the art will recognize upon consideration of the above teachings that certain of the above examples are based upon use of a programmed processor such as the CPU . However the invention is not limited to such example embodiments since other embodiments could be implemented using hardware component equivalents such as special purpose hardware and or dedicated processors. Similarly general purpose computers microprocessor based computers micro controllers optical computers analog computers dedicated processors application specific circuits and or dedicated hard wired logic may be used to construct alternative equivalent embodiments.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as JAVA Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention have been described with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable storage medium that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable storage medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modems and Ethernet cards are just a few of the currently available types of network adapters.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

