---

title: Systems and methods for managing authority designation and event handling for hierarchical graphical user interfaces
abstract: Prior art attempts to manage authority designation in GUI-based computer systems have set up various “handshaking” schemes between a graphics management system, such as a window server, and the various processes that are attempting to offer and accept access to each other. However, these schemes have certain limitations. In particular, when windows are used as the “fundamental basis” for implementing authority designation, events that should treat all content within a window identically can't do so because, even though all content in the window may appear to be “owned” by the window, there may be some other process that is actually rendering the content to some portion of the window. Thus, described herein are systems and methods to manage authority designation and event handling within “hierarchical” GUIs using “handshaking” schemes that are secure, sub-window granular, and that generalize recursively when applied to the various graphical layers used to construct the windows.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09633226&OS=09633226&RS=09633226
owner: Apple Inc.
number: 09633226
owner_city: Cupertino
owner_country: US
publication_date: 20140530
---
Embodiments of the invention relate generally to the field of secure computing and more particularly to managing access of graphical user interface GUI elements and responding to events in a hierarchical graphical user interface environment.

Security concerns for all types of processor based electronic devices and particularly for computing devices have become significant. While some concerns may relate to detrimental actions which may be undertaken by defective code implemented by such devices the greater concerns relate to the ramifications of various types of attacks made upon such devices through malicious code including code conventionally known in the field by a number of names such as viruses worms Trojan horses spyware malware and others. Many of these attacks are directed at computing devices such as workstations servers desktop computers notebook and handheld computers and other similar devices. Many of these computing devices can run one or more application programs which a user may operate to perform any number of desired functions.

A number of methodologies have been used in an attempt to reduce or eliminate both the attacks and influence of malicious or defective code. Generally these methodologies include detection prevention and mitigation. Specifically these methodologies range from attempts to scan identify isolate and possibly delete malicious code before it is introduced to the system or before it does harm such as is the objective of anti virus software and the like to restricting or containing the actions which may be taken by processes affected by malicious or defective code.

Most modern computer systems employ operating systems that support graphical user interfaces or GUIs . Central to these operating systems is the use of a low level application referred to as a window server. One function of a window server is to receive annotate and route signals from external devices e.g. human interface devices such as keyboards pointer devices and tablets to the appropriate application e.g. an audio video or multimedia application . Typically the window server manages all windows accessed by programs running within a data processing system including granting accesses to the programs. As more and more programs are running in the system and more and more GUIs are utilized by the programs the process for granting and managing the access of GUIs becomes more complicated and inefficient.

Prior art attempts to manage authority designation in GUI based computer systems such as those described in U.S. Pat. No. 8 365 192 published Jan. 29 2013and entitled Methods for Managing Authority Designation of Graphical User Interfaces which is hereby incorporated by reference as if reproduced in its entirety have attempted to set up handshaking schemes between a graphics management system such as a window server and the various processes that are attempting to offer and accept access to and from one another. However these schemes have certain limitations. In particular because windows were used as the fundamental basis of implementing authority designation in such window server based management schemes actions that should have treated all content and or state spanning multiple windows in a self consistent interface couldn t do so because if there was an out of process window being presented as part of what the user thought was his or her application there would potentially be lag in communication when certain user changes had to be rectified.

For example in the case of a user request to resize a window normally an application would respond to the resize request in a very controlled manner so that the user is not shown a half drawn window i.e. so as to avoid the phenomenon known as window tearing . This could be achieved by e.g. recognizing the window resize up to a certain point redrawing everything in the window flushing that content to the screen and then if the window has been resized further since the screen flush realizing the new resize request so that when the window content reflows to the screen it feels fluid and tearing is avoided. However if the window being resized is pretending that some particular content is part of itself e.g. by relying on position and sizing of content in a higher z order window but some other process is actually rendering that particular content then the window can reflow all of its content but it won t all necessarily update in the same time frame resulting in windows that appear to be lagging behind and bouncing along as the user dragged or resized a different window.

Another limitation with prior art attempts to manage authority designation in GUI based computer systems that use windows as their fundamental basis is the fact that the service window i.e. the window that is being hosted into the application cannot turn around and re grant the hosting application permissions. For example if the service process needed to ask for help to perform a particular task it couldn t allow a second service to present a window as the host application even if the intended use were to simply place another window over the service provided content because it couldn t grant rights on behalf of a process that it wasn t. Thus this form of authority management could not be applied recursively while maintaining security.

Thus there is a need for systems and methods to manage authority designation and event handling among isolated designated actors within hierarchical GUIs that are both secure and that generalize recursively when applied to the various graphical layers used to construct the windows within the hierarchical GUIs. There is also a need for simple rules that provide per window granularity regarding content ownership and access as well as the associated processes for managing them.

According to some embodiments disclosed herein rather than hosting content as windows content is hosted in graphics contexts such as CORE ANIMATION contexts. CORE ANIMATION is a registered trademark of Apple Inc. CORE ANIMATION is a graphics rendering and animation infrastructure available on both APPLE S iOS and OS X that developers may use to animate the views and other visual elements of their applications. By hosting content in CORE ANIMATION contexts rather than in windows the level at which the handshaking occurs is entirely within CORE ANIMATION . So an application may request of a particular service Create a context that I can host to do something. Then CORE ANIMATION will create the requested context as what will be referred to herein as a window server hosted context. 

A window server hosted context as used herein refers to a GUI element wherein the rendering doesn t happen in the client process space rather it happens in the window server. This means that any time a particular window needs to do a redraw it has to synchronize the two or more processes i.e. the host and the service that would be being redrawn. So with the systems described herein utilizing window server hosted contexts the window manager is dealing with pre synchronized data because the CORE ANIMATION content is committed in transactions and will always have the last committed transaction available to draw.

The handshaking process that is done according to embodiments described herein stores a record of what contexts are allowed to host which content remotely so that when CORE ANIMATION attempts to perform the requested rendering it can determine whether the current context i.e. the context that is currently drawing is owned by the hosting process and whether it is expecting the hosted process. Thus the window server will look at the two context records in its records database and verify whether the requested context was the correct context and whether it was requested by the correct hosting context. As may now be more fully understood this process may be generalized and applied recursively to additional hierarchical layers of GUI elements hosted inside one another within windows.

For example according to some embodiments of the improved windows management systems described herein a given window no longer needs to request to the window server I m going to present as this user level application. Instead the context for window can simply report to the window server that I m hosting context X i.e. a referencing layer and context X will contain validating data indicating that the window context is allowed to host it . So for example if Host Application A requests information to be put into a region of a window that will behave as a dialog box e.g. Save Dialog B but it also needs to provide thumbnail images C that the Save Dialog B service wouldn t know how to draw then the process providing the Save Dialog B would want to host an additional remote context that could generate that data. At this point a three tiered hierarchical GUI structure will have been created wherein a window in a hosting application e.g. Host Application A has some content that is remote to it e.g. Save Dialog B and unknown to the host within that remote context there s some other content that s remote e.g. thumbnail images C .

In the Save Dialog example described above the high level window is owned by Host Application A the first level remote content is Save Dialog B and the detail information is from thumbnail image context C. In this example contexts B and C will have done their handshaking independently of application A. In fact application A never even needed to know about the handshaking between contexts B and C. However within the window server the event system i.e. the system level process that receives incoming user level events and routes them to the correct windows contexts for handling does have to know about the handshaking between B and C so that when everything in Host Application A get drawn the graphic rendering infrastructure e.g. CORE ANIMATION that does the drawing and figures out where the various graphical elements are located may hand a series of shapes representing the various graphical contexts in the window s hierarchy over to the event system. These shapes passed to the event system may have information attached to them that specifies the equivalent of This context routes to this process and has this shape on a given window. Further included in this information handed over to the event system may be a tree height property i.e. a z ordering of what contains what with respect to the hierarchical window that is being rendered. The reason this information is important is because if a given shape is calculated to be located outside of its enclosing shape that is a potentially valid outcome in theory but an event would never reach such a shape on the window because by the time the event system has resolved what areas of the window have events routed to them and in what way all such shapes would be clipped to within some parent layer context s boundaries.

Other features of the present invention will be apparent from the accompanying drawings and from the detailed description which follows.

In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the inventive concept. As part of this description some of this disclosure s drawings represent structures and devices in block diagram form in order to avoid obscuring the invention. In the interest of clarity not all features of an actual implementation are described in this specification. Moreover the language used in this disclosure has been principally selected for readability and instructional purposes and may not have been selected to delineate or circumscribe the inventive subject matter resort to the claims being necessary to determine such inventive subject matter. Reference in this disclosure to one embodiment or to an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one implementation of the invention and multiple references to one embodiment or an embodiment should not be understood as necessarily all referring to the same embodiment.

It will be appreciated that in the development of any actual implementation as in any development project numerous decisions must be made to achieve the developers specific goals e.g. compliance with system and business related constraints and that these goals may vary from one implementation to another. It will also be appreciated that such development efforts might be complex and time consuming but would nevertheless be a routine undertaking for those of ordinary skill in the design of an implementation of image processing systems having the benefit of this disclosure.

According to some embodiments a mechanism is employed by a window server to allow a first process e.g. trusted process as an owner of a window or other graphics context to grant one or more access rights also simply referred to as rights of the window or other graphics context to a second process e.g. untrusted process as a grantee that requests to access the window or other graphics context. The window server operates as a mediator to allow the first process and second process to negotiate the access rights to allow the second process to access a window or other graphics context owned possessed or created by the first process. Once the access rights have been negotiated between the first and second processes the window server also operates as an enforcer to enforce the agreed upon access rights which may limit access of the first process and or second process to the window or other graphics context based on the negotiated access rights.

As a result by delegating the granting authority to a process that owns the window or other graphics context the window server does not have to handle the specific details of granting the access on behalf of an owner where the owner is in a better position and knows the specific details of the window or other graphics context. In addition the first process may trust the window server as the window server may be part of an operating system while the first process may be a certified application. However the first process may not trust the second process where the second process may be a third party application installed in the system. By invoking the window server to mediate the granting of the access rights and to enforce the access rights the security concerns between the first and second processes have been greatly reduced.

In prior art windows management systems wherein access was only window based the so called handshaking process of granting and accepting rights between processes wouldn t generalize to more granular levels of control because a given window couldn t grant new rights for a new sub window. The present disclosure which describes windows management systems and methods for managing authority designation and event handling for hierarchical graphical user interfaces including both windows and nested graphics contexts e.g. CORE ANIMATION layers allows for more complex shapes within windows and more specialized event routing.

Window server also referred to as a window manager window management system or a graphics management system is system software e.g. a system component of an operating system that controls the placement and appearance of windows also referred to as graphical user interface elements within a windowing system. Window server is designed to help provide an operating environment and it works in conjunction with the underlying graphical system e.g. display device driver and display hardware which provides required functionality such as support for graphics hardware pointing devices and a keyboard. Typically window server controls access by the operating system and other applications e.g. processes to a display via device driver and display hardware e.g. a display controller and or frame buffers . For example drawing may be clipped to an application s visible window. Window server presents an interface to each client application that enables each client application to run without direct interaction with other applications on the machine.

In one embodiment the window system as shown in may be a buffered window system. In a buffered window system application programs e.g. processes do not draw directly into a video memory but to off screen window buffers in system memory that are then composed together by compositor of window server to render the final screen. That is instead of outputting directly to a common screen application programs each output data first to a separate and independent window buffer e.g. window buffers where the data can be manipulated before they are transferred to a frame buffer not shown to be shown on a screen of a display device. The output from these separate window buffers is then processed and combined in the frame buffer to display onto a common screen of the display device.

A frame buffer is typically under control of graphics hardware e.g. a display controller which controls the display of the windows on the screen of the display device using the data in the frame buffer. Thus in a buffered window system operations for creating the content in windows are separated from operations for composing a screen image from images of windows for different applications. Processes create or update images of the windows content for the windows in window buffers and compositor of window server composes a screen image from images of the windows in window buffers . Window buffers are independent from the frame buffer. Content in the corresponding window buffers can be copied by window server and or display device driver to the corresponding locations in the frame buffer to display the windows in these locations on the common screen of the display device. The window buffers are independent from the frame buffer.

According to one embodiment of a prior art handshake process a mechanism is employed by window server to allow a first process e.g. process as an owner of a window to grant or assign one or more access rights of the window to a second process e.g. process as a grantee or assignee that requests to access the window. Typically the second process does not have privilege to access a window and the second process has to rely on the first process to obtain the access rights to the window owned by the first process. For example the first process may be a trusted process that is responsible for display a dialog box to allow a user to select a file from a file system. The second process may be a network related application that only has privilege to access a network but it does not have privilege to access the file system. However the first process may not trust the second process for the purpose of granting one or more access rights to a window owned by the first process. In this situation the first process can only trust the window server.

In one embodiment window server operates as a mediator or bridge to allow the first process and second process to negotiate the access rights to allow the second process to access a window owned by the first process. Once the access rights have been negotiated between the first and second processes window server also operates as an enforcer to enforce the agreed upon access rights which may limit access of the second process to the window based on the negotiated access rights. Window server may also comprise an event system for receiving incoming user level events e.g. mouse related events and routing them to the correct windows for handling.

According to one embodiment for each window created by a process window server creates and maintains a window rights record as part of window records . A window rights record includes detailed information concerning the respective window including certain access rights that are currently assigned to certain processes. Some of the accesses rights may be exclusive rights e.g. owner event receiver presentation rights which can only be assigned to a single process at a given time. Other accesses rights e.g. back store rights may be non exclusive rights that can be substantially concurrently assigned to multiple processes. Window server is configured to oversee the granting of the access rights from one process to another process or processes. For example window server may reject granting of any exclusive access rights to multiple processes.

In addition when a first process attempts to grant an access right to a second process window server may also authenticate the first process to determine whether the first process has the authority to grant the access right. In one embodiment only an owner of a window can grant an access right to another process that is not an owner of the window. In this example if the second process obtains an access right from the first process and the second process attempts to grant the same access right to a third process window server may reject such an attempt. In one embodiment window server may maintain a list of ownerships of all windows managed by window server . Such information can be used to determine the ownership of a particular window which can be used to determine whether a particular process has the authority to grant or assign an access right to another process.

Once the access rights have been granted and accepted window server is configured to enforce the access rights of a window according to its associated window record. That is window server may restrict a particular process to access only a portion of a window or a certain function of the window based on the access rights currently owned by that particular process. For example if a process obtains an access right of a window to receive a mouse up event e.g. releasing a mouse button without obtaining an access right to receive a mouse down event e.g. pressing a mouse button window server may allow the process to receive a notification when a mouse up event occurs. However the process would not receive a notification when a mouse down event occurs. Thus the access rights serve as an entitlement to access certain areas or functions of a window and at the same time restrict a process from accessing other areas or functions of the window. This literally put a particular process in a restricted operating environment e.g. a sandboxed environment enforced by window server .

Referring back to for the purpose of illustration in response to a request received from process for granting one or more access rights to process window server is configured to authenticate process to ensure that process has the authority to grant an access right. Window server is further configured to examine the access rights to be granted to create a window record reflecting the current states of the window. In one embodiment a window record includes information identifying all or most of the access rights and the processes that hold the access rights. Thereafter window server transmits the information representing the window record to process offering the access rights to be granted by process . Based on the information received from window server process can either accept or reject the offer. In one embodiment process can only accept or reject the entire offer. The offer may expire and become invalid after a predetermined period of time within which an acceptance has not been received by window server . Once the offer has been accepted by process window server is configured to enforce the access of the window by process based on the accepted terms specified in the window record. In addition if one or more exclusive rights have been granted to the process access of process associated with the exclusive rights may also be restricted by window server since process no longer has those exclusive rights .

As a result by delegating the granting authority to process that owns the window window server does not have to handle the specific details of granting the access on behalf of an owner. In this situation process as an owner is in the best position to grant the access rights as typically the owner knows the specific details of the window. In addition process may trust window server as window server may be part of an operating system while process may be a certified application. However process may not trust process where process may be a third party application installed in system . By involving window server to mediate the granting of the access rights and to enforce the access rights process does not have to worry about the authenticity of process .

According to some embodiments an access right of a window includes one of an ownership right presentation right event receiving right back store read right back store write right and some other rights. In one embodiment an ownership right is an exclusive right granting the sole ability to destroy the window create right grants and currently to change the nature of backing resources such as the format of the backing store . All exclusive rights not explicitly held are implicitly held by the owner. A presentation right is an exclusive right granting the ability to display a window visually as part of a process and manipulate the display characteristics shape position on screen etc. . An event recipient right is an exclusive right granting the ability to receive user events on the window. Mouse clicks and keyboard events routed to the window go to the holder of an event recipient right. Backing store access rights are both non exclusive rights granting the ability to read or write the memory backing the window s content. The ability to overwrite content has security implications as fake content can guide a user to perform actions they otherwise would not and the ability to inspect content has security implications as it enables gathering of user information which a process would otherwise not have access to.

Referring to initially during transaction when process requests accessing a window owned by process process transmits a first message to process for example via an inter process call IPC or an application programming interface API . The request may include information describing the window to be accessed including for example a window identifier ID identifying the window a location or coordinates of at least a portion of the window being accessed and one or more interactions with the window e.g. event notifications to be received etc. In addition the request may further include a token or process or thread ID that uniquely identifies process under window server . For the IPC between two processes prior to contacting the window server a message or sequence of messages may be communicated between two processes. In one embodiment a token to be passed to window server to identify process indicating what is being requested. This could be a window identifier or it could be a description of a behavior function e.g. I want window vs. I want a save panel . In addition a requested set of rights can be optional in this scenario especially in the case of a description of behavior.

In response to the first message during transaction process transmits for example via an API a second message to window server . The second message includes one or more access rights to be offered to process for accessing the window and a token or process ID associated with process . The one or more access rights may represent at least some of the interactions that process can or cannot do with respect to the window. For example an access right may determine whether a notification of a particular event e.g. mouse up or mouse down event will be sent and received by process . Some of these access rights may be exclusive rights that can only be possessed or held by a single process at a time or non exclusive rights that can be shared by multiple processes. In addition the second message may further include other access rights that are currently held by or assigned to other processes.

In response to the second message received from process window server authenticates process to ensure that process has the authority to grant the rights. In one embodiment only an owner of a window can grant an access right of the window to another process. Window server also authenticates process based on the token or process ID of process . In addition window server generates a window record corresponding to the window ID obtained from the second message. The window record includes detailed information concerning at least some access rights of the window including the access rights being offered to process . During transaction window server transmits a third message to process where the third message includes at least the one or more access rights being offered. In one embodiment if some of the access rights being offered include a non exclusive right the third message may further identify one or more other processes that share the non exclusive right. In one embodiment the third message may further include other access rights held by other processes but not held by process . As a result process has an entire picture or full description of all the access rights associated with the window in determining whether to accept or reject the offer. In one embodiment the offer may be good for a predetermined period of time which may be set up by window server e.g. via a timer . When there is no acceptance received from process the offer may expire and become invalid.

Based on the offer during transaction process transmits a fourth message back to window server either accepting the offer or rejecting the offer. During transaction window server transmits a fifth message to process indicating whether the offer has been accepted rejected or expired. In one embodiment window server also sets up a timer with a predetermined timeout period and when the timeout period lapses the offer may become invalid. When the offer has been rejected by process or the offer becomes invalid the corresponding window record may be updated e.g. rolled back or destroyed by window server and without the corresponding window record window server prevents process from accessing the window.

If the offer has been accepted by process during transaction window sever is configured to enforce the accepted access rights when process accesses the window. For example process may request to receive certain event notifications e.g. mouse up mouse down resize and or focus events . Based on the request process may grant those access rights to receive such event notifications. During operations when the associated interactions occur on the window the corresponding event notifications will be transmitted e.g. via a callback interface from window server to process provided the corresponding window record indicates that such access rights are currently possessed by process . In addition if an exclusive right has been granted from process to process the access of process associated with the exclusive right may also be restricted by window server as process has given up that exclusive right.

Referring now to a block diagram illustrating an exemplary graphics rendering and animation infrastructure is shown. As shown in the graphics rendering and animation infrastructure includes a UIKit AppKit a CORE ANIMATION an OPENGL ES OPENGL Core graphics and graphics hardware. Such a graphics rendering and animation infrastructure may be utilized to manage process external reference able content in an efficient fashion. The exemplary graphics rendering and animation infrastructure CORE ANIMATION provided by Apple Inc. is a general purpose system for animating views and other visual elements of applications. As used herein a view refers to an NSView object which defines the basic drawing event handling and printing architecture of an application. CORE ANIMATION is a technology that integrates with views to provide better performance and support for animating view content. CORE ANIMATION achieves this behavior by capturing content e.g. by caching the contents of views into bitmaps that can be manipulated directly by the graphics hardware. In some cases this caching behavior might require programmers to rethink how an application s content is presented and managed but most of the time the use of CORE ANIMATION appears seamless to the programmer. In addition to caching view content CORE ANIMATION also defines a way to specify arbitrary visual content integrate that content within views and animate it along with everything else.

CORE ANIMATION is not a drawing system itself. Instead it is an infrastructure for compositing and manipulating an application s content in hardware. At the heart of this infrastructure are layer objects which are used to manage and manipulate an application s content. A layer captures an application s content e.g. in the form of a bitmap that may be manipulated easily by the graphics hardware. In most applications layers are used as a way to manage the content of views but standalone layers may also be created depending on the needs of a particular application.

Layer objects are 2D surfaces organized in a 3D space and are the elemental units of the CORE ANIMATION infrastructure. Like views layers manage information about the geometry content and visual attributes of their surfaces. Unlike views layers do not define their own appearance. A layer merely manages the state information surrounding a bitmap or other content. The content itself can be the result of a view drawing itself or a fixed image that is specified. For this reason the main layers used in an application are considered to be model objects because they primarily manage data. This notion is important for programmers to keep in mind because it affects the behavior of animations.

Most layers do not do any actual drawing in an application. Instead a layer captures the content an application provides via drawing instructions which may be cached in a bitmap or other format sometimes referred to as the backing store. When a property of the layer is subsequently changed the corresponding state information associated with the layer object is changed. When a change triggers an animation CORE ANIMATION passes the layer s content and state information to the graphics hardware which does the work of rendering the content using the new information.

Layers can be arranged hierarchically to create parent child relationships. The arrangement of layers affects the visual content that they manage in a way that is similar to views. The hierarchy of a set of layers that are attached to views mirrors the corresponding view hierarchy. Standalone layers may also be added into a layer hierarchy to extend the visual content of an application beyond just the created views.

Referring now to an embodiment of a rendering process is shown in accordance with the prior art. In the rendering process an application inputs graphical user interface GUI information into a backing store not shown and a CORE ANIMATION framework sometimes referred to herein simply as CORE ANIMATION is used to process the GUI information in the backing store. Once the framework has processed the GUI information a render engine renders the processed information into a frame buffer . Although not shown in the render engine typically renders processed information into an assembly buffer that is then composited into the appropriate location of the frame buffer . When compositing is completed scan out hardware outputs the rendered information in the frame buffer to a display using a frame rate of the display .

The processing performed by the CORE ANIMATION framework includes graphics animation and compositing operations for the application . To perform the operations the CORE ANIMATION framework divides the processing into a layer tree and a render tree . A layer tree is simply a description of the content within a context so a layer and especially a layer hierarchy specifies content while a context represents ownership and drawing of this content. In this two tree approach the layer tree is exposed to the application and is used for implicit animation and implicit layout of graphics objects also referred to herein as layers . On the other hand the render tree is manipulated and is traversed by the render engine .

The layer tree includes a data structure that interfaces with the application . The data structure of the layer tree is configured to hold a hierarchy of layers. The layers are objects having various properties and attributes and are used to build the GUI of the application . The terms property and attribute may be used interchangeably in the present disclosure . In general for example the layers can include content windows views video images text media etc. The data structure of the layer tree is preferably as small and compact as possible. Therefore many of the attributes of the layers preferably have default values kept in an extended property dictionary such as NSDictionary of Apple s Cocoa application environment.

During operation the application interacts with the layer tree of the framework to manipulate the hierarchy of layers in the layer tree . The application can be any computer application or client process that manipulates or changes the layers being displayed. When the application commits an event or change to the layer tree the framework determines what events or changes are made at each layer by the application . These events or changes in the layer tree are then committed to an animation and compositing process of the framework . This process determines one or more implicit animation functions of the framework to use on the layer tree based on the committed events or changes for each layer of the layer tree .

The animation and compositing process then performs explicit animation of the events or changes and configures the layout of the layers in the render tree . The animation and layout of the render tree is then rendered by the render engine and output to the frame buffer . Any manipulations of layers made by the application to the layer tree are not evaluated at the frame rate of the display . Instead changes in the render tree are traversed and updated at the frame rate .

As alluded to above the framework separates the animation and compositing of layers from the application . For example when the application makes changes the affected layers in the layer tree are instantly changed from one state to another. State changes reflected in the layers of the layer tree are then percolated to the physical display by animating the changes and compositing the layers of the render tree from the initial state of the layers to their final or end state. This form of animation and composition is referred to herein as implicit animation and is part of the animation and compositing process of .

By using implicit animation in the framework the application does not have to include code for animating changes e.g. movement resizing etc. of layers to be displayed. Accordingly any code required for animating layers can be minimized in the application . As shown in simplified form in for example the application may not require an embedded loop for animating changes to the layers. Instead the application includes code that indicates a change in the state of a layer e.g. indicates a change in position of a layer . The framework determines from the changes made to the layers in the layer tree what implicit animation to perform on the layers and then the framework explicitly performs that animation on the layers using the render tree . Accordingly animations can be abstracted in such a way that the code of the application does not need to run at the frame rate . This allows the animation for objects layers to be decoupled from the logic of the application and allows the application and the animations to run on separate threads in the rendering process .

The animation and compositing process can perform a number of different types of animation on layers or objects. For example if the application operates on the layer tree to change a layer from start point A to end point B in the GUI for the application the animation and compositing process automatically manipulates i.e. without application input the representation of that layer in the render tree to animate its movement from point A to point B on the display . In another example if the application operates on the layer tree to add a new layer to the layer tree the animation and compositing process may automatically manipulate the render tree to fade in the new layer. In yet another example if the application operates on the layer tree to replace an existing layer with a new layer the animation and compositing process automatically manipulates the render tree to animate a transition from the existing layer to the new layer.

In for example the relationships for three example layers D E and F are shown where layer D is the superlayer of E and where layer E is the superlayer of F. Each layer D E and F is defined by a corresponding frame rectangle D E and F having its own coordinate system D E and F. The bounds attribute of the layers defines its coordinate system . In general the frame rectangle of each layer is positioned within the coordinate system of its superlayer. Thus the frame rectangle E for layer E is positioned within the coordinate system D of layer D and the frame rectangle F for layer F is positioned within the coordinate system E of layer E. When a given layer is moved or its coordinate system is transformed e.g. rotated flipped etc. all of its sublayers are moved or transformed along with it. Yet because each layer has its own coordinate system the drawing instructions for that layer can be consistent no matter where the layer is or where its superlayer moves to on a screen.

The frame rectangles essentially define the area of the layers i.e. the tablet on which the layers can draw. The frame rectangle of a given layer can lie within the frame rectangle of its superlayer. In addition the frame rectangle of a given layer can extend outside its superlayer s frame rectangle . For example the frame rectangle F lies entirely within the frame rectangle E of its superlayer E but the frame rectangle E for superlayer E extends outside the frame rectangle D of its superlayer D. In contrast to views in NSView the layers can place content outside the frame of their parent layers.

Referring now to a block diagram is shown illustrating a system architecture having a window and content server. Unlike the prior art system architecture shown in depicts a system wherein window server has been replaced by Window Content Server . As explained above according to some embodiments by hosting content in CORE ANIMATION contexts rather than in windows the level at which the handshaking occurs is entirely within CORE ANIMATION . So an application may request a particular service to create a context for it to host at which point CORE ANIMATION will create the requested window server hosted context for the application.

As mentioned above window server hosted context refers to a GUI content element wherein the rendering doesn t happen in the client context rather it happens in the Window Content Server . As such any time a particular window needs to do a redraw it has to synchronize the two or more processes that would need to be redrawn. Thus by utilizing window server hosted contexts the window manager may deal only with pre synchronized data since the CORE ANIMATION content is committed in transactions and will always have the last committed transaction available to draw.

According to some embodiments the handshaking process that takes place between contexts in CORE ANIMATION may be stored in the form of a record specifying what contexts are allowed to host which content remotely. Thus when CORE ANIMATION attempts to perform the requested rendering it can determine whether the current context is owned by the hosting process and whether it is expecting the hosted process. To this end a window record may contain a Window Event Routing Region Record i.e. the root of the Event Routing Region Tree for that window. A Window Event Routing Region Record may include additional detailed information concerning the respective window or hosted context i.e. information in addition to the information stored within window records described with reference to such as an event mask as will be discussed in further detail below shape specifying information owner ID and information specifying zero or more Event Routing Region children. Thus the Window Content Server will look at the two context records in its records database and verify whether the requested context was the correct context and whether it was requested by the correct hosting context.

The handshaking process between remote contexts is dissimilar conceptually to the handshaking process described above with respect to windows in that no intermediary extends an offer of rights. For example first a request has to be made by a first process for access to a particular context. With respect to the Save Dialog context example described above and with reference to there will be a request from an application that gets communicated in to the Window Content Server . This transaction may take the following form Step 1 The process that serves up the Save Dialog context receives a message specifying the following My Process ID is XYZ and I want a Save Dialog context that I can host. Step 2 The process that serves up the Save Dialog context would then create a CORE ANIMATION context and attach information about what process is expected to host it and potentially other incidental info about how events should route The created Save Dialog context is referred to herein as a hosted context because it lives in the Window Content Server and the Window Content Server does the actual rendering of its content. Step 3 The process that serves up the Save Dialog will get an identifier for the created Save Dialog context that it can use to then craft the layout of the context put content in it etc. and it will turn around and hand that identifier back to the context that requested it initially.

In the example presented above the requesting process was Host Application A with Process ID XYZ the process that created the context was Save Dialog B and the CORE ANIMATION component in the Window Content Server knows that the Save Dialog context with some given identifier is owned by process B and is restricted to being remotely added to process A. Then when process A places a reference to this Save Dialog context in its Layer Tree e.g. in the CORE ANIMATION component of Window Content Server the context will be validated i.e. the Window Content Server will confirm that the process that asked to put the reference to this particular context in its Layer Tree is the process that is allowed to do so. At that point the handshaking process between remote contexts is complete. Thus when the CORE ANIMATION component in the Window Content Server renders the window from A it would traverse A s the Layer Tree see the remote context reference from B validate whether B may be hosted in A and then draw that content. As part of drawing that content the Window Content Server would also see the remote context reference from C and validate that the current context i.e. B was really from B and render C and then turn around and report both shapes i.e. both the B shape in the A window and the C shape within the B shape . The process generalizes and would be repeated recursively for each hierarchical level of content in A s Layer Tree.

As may now be more clearly appreciated when the content from B is added to the Layer Tree by A A can restrict the area that B is allowed to be drawn in and move it around within the A s window. However when a redraw happens that realizes a change in geometry in A the shape of any area receiving an event also gets updated. In this manner the way GUI elements are drawn and the way events are routed remain in sync with one another. Thus even if the content and shape of B are drawn differently relative to window A s coordinate system they remain in sync. When the window A redraws with a resizing change for example the event routing information gets updated at the same time so that the window and its sub region components behave as expected.

Referring now to is a process diagram is shown illustrating a method for granting access rights of a window or hosted context. reflects several improvements over the process diagram of stemming from the use of CORE ANIMATION contexts that are hosted within the Window Content Server . In particular the offer to grant one or more rights of access now takes place at the context level rather than the window level. First at Step Process may make a request for hostable content from Process . Process may then communicate with the Window Content Server to make a request for a new context drawn by Window Content Server Step . Upon receiving the response with the context identifier provided by the Window Content Server Step Process may then instruct the Window Content Server to restrict the hosting of the context to Process Step . Process may also pass along the relevant event mask for the created context as will be explained in further detail below . Process may then return an identifier for the referencing context to Process Step . Once Process has received the context identifier it may inform Window Content Server of the addition of the hosted context referencing layer to its context Step . Finally the Window Content Server may proceed to draw and update the various contexts within the hierarchical GUI according to the Event Routing Regions Step while continuing to route events according to the Event Routing Regions step .

As mentioned above when the authority designation process was purely window based the rights enforcement process couldn t generalize because windows couldn t grant new rights for a new sub window. The new hosted context model described herein allows for more complex shapes and more specialized event routing.

According to some embodiments event routing is implemented by using data structures referred to herein as event masks. An event mask is a bit mask where the different bits represent event types. E.g. event type 1 may be left mouse down and event type 2 may be left mouse up. Various event types may be represented by increasing binary values created by performing left shift operations on the preceding binary value. In this way complex bit maps may be created with information specifying whether a particular window or context receives a particular type of event and then such bit masks may be combined in a computationally efficient manner e.g. using a logical OR operation to determine whether any component within the hierarchy of a particular window receives an event of a particular type.

According to some embodiments at a high level the process for handling incoming events begins by determining whether a window located under the position of the incoming event is interested in the event. Compared with prior art solutions this determination now also considers potential sub window routing of events within the shapes hosted inside the window. This results in a situation wherein a window may receive an event even if it has not declared interest in it. For example if an event is clearly meant for the window performing the event routing analysis and no other window is overriding the current window s interest in the receipt of the event then the current window may receive the event. One example of such an event may be a scroll event which should go to the window under the mouse whether or not the window has declared an interest in scroll events.

The search for interested windows may now be generalized through the region hierarchy that gets attached to the windows. As explained above when hosted contexts having particular shapes and locations also referred to herein as structural regions are added to a window s Layer Tree each structural region is treated as a node in the Layer Tree having an arbitrary number of children listed in z order a parent identifier and a shape. At the top level of the hierarchy is the window itself. The window will have its own event mask which may be augmented with one or more structural region event masks to create an effective event mask i.e. an aggregation of the event masks of all the structural regions hosted within the window with the event mask of the window itself. In one embodiment augmenting the window s event mask with the structural region event masks comprises performing a set union operation e.g. a bitwise OR operation on all the structural regions hosted within that window. In the Save Dialog example discussed throughout the window s effective event mask would thus be The event mask that A set on the window bitwise OR d with the masks for B and C. With the construction of the effective event mask the Window Content Server may now determine what event types any component of the window is interested in.

Event routing for windows may now be generalized into three groups 1 Explicit Routing the window under an event has explicitly declared interest in the event type 2 Implicit Routing the window under the event implicitly gets the event because of that event s type if the events gets routed there and 3 Opaque Window Routing the widow does not get the event type and if there are any windows under the current window the event is not routed to them either. If none of the above conditions apply the event is given to the first interested window i.e. a window asking for the event and that can handle the event below the current window. As may now be understood some events may drop for a given window e.g. if neither the window nor any of its component structural regions are interested in receiving the particular event type and there is no other interested window below the window.

If an event is explicitly routed into a window the algorithm will attempt to determine the deepest member of the tree i.e. the object with highest z order that explicitly wanted this event. To make this determination at each level the algorithm will evaluate whether the context wants the event and if the event is within its geometry. If so it will check to see whether that context also has children that might want the event. In some implementations the algorithm may actually operate by finding the deepest structural region at the location first and then walk back up the hierarchy towards the window until finding the first structural region that explicitly wants the event. In other words if a host window tries to put content over something that s provided remotely the algorithm will continue routing to the remote context. This eliminates a potential security hole because if the host window process could draw on top of what the remote content is it could guide the user to send events that did something the user wasn t actually trying to do. Similarly if the malicious process could receive the events it could get information the user was trying to give to a process that was trusted. Thus as may now be seen more clearly it is a matter of security that event routing and visual content remain in sync at all times.

Even if there s a structural region that requested explicitly to get a particular event type if the region is not in the linear list of deepest region at the location of the event through its parents to the window then nothing at that location has actually explicitly requested that event. Thus the event should be routed implicitly. According to some embodiments the event is routed implicitly based on the same rules for whether it went to the window i.e. once it is known that a window is getting event then the algorithm may do the search starting at the deepest structural region walking back up the hierarchy and finding the first structural region that wants the event. If that search comes back with no interested region then the event may just be sent to the deepest structural region because this is directly equivalent to the idea of sending the event to the window that is on top. 

For windows that are opaque to a given event type i.e. the widow does not get the event type and if there are any windows under the current window the event is not routed to them either the algorithm may simply be generalized by finding the first window that may possibly be able to receive the event type and then applying the rules for the cases discussed above. In other words because the first step of determining whether a window wants an event has had consideration of the structural regions locations folded into it the algorithm may simply proceed from there. Once it has been determined which window if any the event will go to the correct region of the window is located using the rules described above.

As discussed above two new types of event routing have been introduced Implicit Routing and Opaque Window Routing. Because of these new routing types certain new routing rules have been developed to deal with particular event routing scenarios as will be discussed further herein. For example if a window is opaque for an event and that event routes implicitly the event is always sent to the top most window that handles the event type. If the window is opaque but the event doesn t route implicitly the event will be dropped i.e. no window under this window can get the event and this window is not interested . A final interesting case involves the scenario wherein the window is not opaque for the event but there s no window that actually requested the event type although the event can implicitly route . In such a scenario the event may still be routed to the top most window since it can route to it implicitly .

As also discussed above the concept of effective event masks have been introduced to aggregate the event masks of all the structural regions hosted within the window with the event mask of the window itself. Certain considerations must be taken into consideration in the construction of the effective event mask. In particular the event masks of the window s sub regions must be included in the effective event mask but they must be included conditionally at first. This is because when first attempting to determine whether a window is interested in a particular event a first pass of the algorithm will ask Is there a chance anything in this window wants the event If the window s native mask and the aggregated mask of all the structural regions don t match on the incoming event type then it is safe to assume that the window doesn t want the particular event type. If the window does match on the event type however and the particular event type is within the native mask then the window does want the event. However if the event type is only in the aggregated mask of the structural regions then the algorithm has to begin searching by location and determine whether the structural region matching the position of the incoming event wants this event. As may now be understood if only a structural region within the window wants a particular event type then when determining if the window wants a given event of that type the algorithm process has to check if the location of the event is within that structural region. This process then generalizes hierarchically for the entire window. For example if C is the only structural region asking for a certain event type then the aggregated structural region event mask at both A s level and B s level will reflect that something wants the event but the algorithm will have to intersect the geometry of the structural region from B and C to determine which structural region was the one that actually wanted the event.

Referring now to a diagram is shown illustrating a method for handling event routing in accordance with one embodiment. The exemplary scenario of uses the same Save Dialog window example discussed previously and with reference to . In this exemplary scenario the different windows and component structural regions are requesting to receive events for different subsets of the possible events that the system is capable of responding to . In particular Host Application A is requesting to receive event types E E E and E Save Dialog B is requesting to receive event types Eand E and Thumbnails C are requesting to receive event types E E E E and E.

The event masks for each of the components A B and C of the window are shown in Event Mask table . In particular the effective event mask for the window is shown on the bottom row with the label A B C to reflect the fact that this effective bit mask represents a bit wise OR operation on the event masks for window A and structural regions B and C. As may be seen at the location of structural regions of type C each of the event types E Eare requested by the window other than event type E as reflected by the 0 at index position in the effective event mask . Event Table provides an exemplary cross reference table showing what events the various indices in the effective event mask correspond to. For example event type Ecorresponds to a left mouse down event event type Ecorresponds to a left mouse up event etc.

Shaded window represents a window that is behind the window of Host Application A in z ordering. As discussed above with reference to Opaque Window Routing if the window for Host Application A was opaque to event type E an event of type Elocated within the extent of the window for Host Application A would not be passed to shaded window even if shaded window or some structural region within it had declared an explicit interest in events of type E. If on the other hand Host Application A was not opaque to event type E an event of type Elocated within the extent of the window for Host Application A would be passed to shaded window and the event would be given to appropriate structural region of the first window below the window for Host Application A that was both asking for events of type Eand which could handle events of type E.

Referring now to a diagram is shown illustrating a method for handling event routing in accordance with one embodiment. specifically shows how the window in the exemplary scenario of would handle incoming events of two types Eand E. In this example the location of the user s mouse is represented by mouse pointer which is shown as being located over structural region C.

First the behavior of the event routing algorithm will be examined with respect to an incoming event of type Eat the location of mouse pointer . As represented by the dashed arrow lines the algorithm will first determine if window A is interested in receiving events of type E. As may be seen the event mask for window A has a 0 in its event mask at the index position corresponding to event E so the process may proceed to evaluate structural region B s interest in receiving events of type E. As may be seen the event mask for region B also has a 0 in its event mask at the index position corresponding to event E so the process may proceed to evaluate structural region C s interest in receiving events of type E. The event mask for structural region C has a 1 in its event mask at the index position corresponding to event E so the process may proceed to give the incoming Eevent in this case a left mouse down event to the structural region at the location of mouse pointer . In this case that corresponds to the thumbnail image C. Passing of this left mouse down event to the thumbnail image Cmay then trigger the appropriate response in the process that owns the thumbnail image C such as giving Save Dialog process B the File ID of the file that the user wishes to overwrite by saving the current file.

Next the behavior of the event routing algorithm will be examined with respect to an incoming event of type Eat the location of mouse pointer . As represented by the solid arrow lines the algorithm will first determine if window A is interested in receiving events of type E. As may be seen the event mask for window A has a 0 in its event mask at the index position corresponding to event E so the process may proceed to evaluate structural region B s interest in receiving events of type E. As may be seen the event mask for region B also has a 0 in its event mask at the index position corresponding to event E so the process may proceed to evaluate structural region C s interest in receiving events of type E. The event mask for structural region C also has a in its event mask at the index position corresponding to event E. Because there are no deeper layers in the hierarchical representation of window A assuming that events of type Edo not route implicitly the process may proceed to give the incoming Eevent in this case a scroll down event to the first interested window i.e. a window asking for the event and that can handle the event below the window A. As mentioned above assuming window A is opaque to events of type E the event will simply be dropped and not passed to windows located underneath window A even if they may have had interest in events of type E.

Each of the exemplary modules shown in e.g. Notifications Calendar Social Feed Stocks Weather may be provided by to the Notification Center but instead of being provided as plug ins that are loaded into Notification Center directly in which case each plug in would have access to everything in the Notification Center process according to some embodiments described herein the various modules may instead be a services that are requested by the Notification Center. For example the Notification Center may simply ask for a graphics context to be placed at a particular location within its extent that shows Stock information. This means that e.g. if the user receives a Stock notification that needs to update the share prices of one of the stocks being monitored by the user the event for that notification can be routed without the Notification Center having to know about it and a preview of the updated stock price could be drawn without anything in the Notification Center s address space needing to know anything special about the Stocks client module. From the user s perspective however the relevant information will still be drawn at the correct location inside of the Notification Center.

In this instance the service modules providing the content would be more sandboxed and less trusted. However they are still able to draw their desired UI updates in the appropriate regions on the screen when they receive notifications. By using the techniques described herein the service modules are nicely sandboxed without the Notification Center application having to extend any extra trust to the service modules. In prior art implementations plug in modules such as the service modules described above have to be especially trusted. Further the use of widgets requires the use of very restricted content e.g. certain widgets may have to be web based or use a restricted subset of JavaScript to limit what they can do etc. and requires the content to be carefully extracted from the widgets before being presented to the user. Moreover events may not be routed directly to widgets. Thus widgets and plug ins are examples of instances where the hosting application needs to know everything about the events that the widget and plug ins receive and where the events will need to be routed. In some instances plug ins are actually loaded directly into a host process s address space. With the techniques described herein the hosting application now no longer needs to know those details because event routing will be handled in a secure fashion by the improved Window Content Server e.g. following the event handling rules for windows and hierarchical structural regions outlined above.

Turning now to a flowchart is shown illustrating a process for performing authority designation and event handling in a hierarchical GUI system in accordance with one embodiment. First the computer implemented method begins by receiving at a graphics management system a window comprising one or more structural regions wherein each of the one or more structural regions comprises a parent context zero or more child contexts and an ordering and wherein each of the window and the one or more structural regions comprises an event mask Step . Next the process proceeds by receiving at the graphics management system a first message from a first process for granting one or more rights to a second process for accessing a GUI element Step . Next the process proceeds by receiving at the graphics management system an incoming event Step and determining based at least in part on the event masks of the window and the one or more structural regions a location where the incoming event should be routed wherein the determination comprises at least one of the following routing to the window routing to one of the one or more structural regions routing to a different window or dropping the incoming event Step . Finally the process concludes by routing the incoming event to the determined location Step .

Turning now to illustrative computer system within which the disclosed window manager may be implemented is shown. Computer system includes one or more client applications and that communicate with Window Content Manager through one or more application programming interface API libraries . Applications and may for example include media players web browsers games office software databases system utilities etc. In one embodiment applications and communicate with Window Content Manager through an OpenGL API. As described above Window Content Manager may also communicate with a second application such as for example CORE ANIMATION . Both Window Content Manager and CORE ANIMATION may communicate with operating system and graphics hardware through one or more APIs such as OpenGL or Direct3D not shown . DIRECT3D is a registered trademark of the Microsoft Corporation. Graphics hardware typically includes both working or buffer memory and texture memory . Texture memory may be used to store texture maps so that they may be applied to the surfaces of graphical objects. Scan out hardware takes the content of memory buffers e.g. assembly or frame buffer memory and sends it to display device e.g. a standard computer screen or a touch screen .

System is also shown to include one or more CPUs one or more output devices one or more input devices memory and storage . CPUs may include any programmable control device including without limitation one or more members from the Intel Core Intel Atom Pentium and Celeron processor families. INTEL CORE INTEL ATOM PENTIUM and CELERON are registered trademarks of the Intel Corporation. CPUs may also be implemented as a custom designed circuit that may be embodied in hardware devices such as application specific integrated circuits ASICs and field programmable gate arrays FPGAs . Output devices and input devices may provide audio and or visual and or tactile based interfaces. Memory may include one or more different types of media typically solid state . For example memory may include memory cache read only memory ROM and or random access memory RAM . Storage may store media e.g. audio image and video files computer program instructions or software preference information device profile information and any other suitable data. Storage may include one more non transitory storage mediums including for example magnetic disks fixed floppy and removable and tape optical media such as CD ROMs and digital video disks DVDs and semiconductor memory devices such as Electrically Programmable Read Only Memory EPROM and Electrically Erasable Programmable Read Only Memory EEPROM . Memory and storage may be used to tangibly retain computer program instructions organized into one or more modules and written in any desired computer programming language. When executed by CPUs and or graphics hardware such computer program code may implement one or more of the methods described herein.

While not shown it will be understood that system may also include communication interfaces to enable communicate with other equipment via one or more networks e.g. local networks such as a USB network a business local area network or a wide area network such as the Internet . System may represent any number of computational platforms such as without limitation personal desktop computers notebook computers workstation computer systems server computer systems pad computer systems and other mobile platforms such as personal music and video devices and mobile telephones.

It is to be understood that the above description is intended to be illustrative and not restrictive. The material has been presented to enable any person skilled in the art to make and use the invention as claimed and is provided in the context of particular embodiments variations of which will be readily apparent to those skilled in the art e.g. some of the disclosed embodiments may be used in combination with each other . In addition it will be understood that some of the operations identified herein may be performed in different orders. The scope of the invention therefore should be determined with reference to the appended claims along with the full scope of equivalents to which such claims are entitled. In the appended claims the terms including and in which are used as the plain English equivalents of the respective terms comprising and wherein. 

