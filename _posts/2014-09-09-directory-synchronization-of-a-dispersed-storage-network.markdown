---

title: Directory synchronization of a dispersed storage network
abstract: A method begins by independently executing a first write transaction in a dispersed storage network (DSN) to a particular write verification step of a multiple step write process, wherein the first write transaction has a first transaction identifier. The method continues by independently executing a second write transaction in the DSN to the particular write verification step, wherein the second write transaction has a second transaction identifier, and wherein subject matter of the first write transaction is related to subject matter of the second write transaction. The method continues by dependently finalizing the multiple step write process for each of the first and second write transactions utilizing the first and second transaction identifiers when each of the first and second write transactions have reached the particular write verification step.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09501341&OS=09501341&RS=09501341
owner: INTERNATIONAL BUSINESS MACHINES CORPORATION
number: 09501341
owner_city: Armonk
owner_country: US
publication_date: 20140909
---
The present U.S. Utility patent application claims priority pursuant to 35 U.S.C. 120 as a continuation of U.S. Utility application Ser. No. 12 903 205 entitled DIRECTORY SYNCHRONIZATION OF A DISPERSED STORAGE NETWORK filed Oct. 13 2010 which is incorporated herein by reference in its entirety and made part of the present U.S. Utility patent application for all purposes.

U.S. Utility patent application Ser. No. 12 903 205 claims priority pursuant to 35 U.S.C. 119 e to U.S. Provisional Application No. 61 290 775 entitled DISTRIBUTED STORAGE DATA SYNCHRONIZATION filed Dec. 29 2009 and claims priority pursuant to 35 U.S.C. 120 as a continuation in part of U.S. Utility application Ser. No. 12 080 042 entitled REBUILDING DATA ON A DISPERSED STORAGE NETWORK filed Mar. 31 2008.

This invention relates generally to computing systems and more particularly to data storage solutions within such computing systems.

Computers are known to communicate process and store data. Such computers range from wireless smart phones to data centers that support millions of web searches stock trades or on line purchases every day. In general a computing system generates data and or manipulates data from one form into another. For instance an image sensor of the computing system generates raw picture data and using an image compression program e.g. JPEG MPEG etc. the computing system manipulates the raw picture data into a standardized compressed image.

With continued advances in processing speed and communication speed computers are capable of processing real time multimedia data for applications ranging from simple voice communications to streaming high definition video. As such general purpose information appliances are replacing purpose built communications devices e.g. a telephone . For example smart phones can support telephony communications but they are also capable of text messaging and accessing the internet to perform functions including email web browsing remote applications access and media communications e.g. telephony voice image transfer music files video files real time video streaming. etc. .

Each type of computer is constructed and operates in accordance with one or more communication processing and storage standards. As a result of standardization and with advances in technology more and more information content is being converted into digital formats. For example more digital cameras are now being sold than film cameras thus producing more digital pictures. As another example web based programming is becoming an alternative to over the air television broadcasts and or cable broadcasts. As further examples papers books video entertainment home video etc. are now being stored digitally which increases the demand on the storage function of computers.

A typical computer storage system includes one or more memory devices aligned with the needs of the various operational aspects of the computer s processing and communication functions. Generally the immediacy of access dictates what type of memory device is used. For example random access memory RAM memory can be accessed in any random order with a constant response time thus it is typically used for cache memory and main memory. By contrast memory device technologies that require physical movement such as magnetic disks tapes and optical discs have a variable response time as the physical movement can take longer than the data transfer thus they are typically used for secondary memory e.g. hard drive backup memory etc. .

A computer s storage system will be compliant with one or more computer storage standards that include but are not limited to network file system NFS flash file system FFS disk file system DFS small computer system interface SCSI internet small computer system interface iSCSI file transfer protocol FTP and web based distributed authoring and versioning WebDAV . These standards specify the data storage format e.g. files data objects data blocks directories etc. and interfacing between the computer s processing function and its storage system which is a primary function of the computer s memory controller.

Despite the standardization of the computer and its storage system memory devices fail especially commercial grade memory devices that utilize technologies incorporating physical movement e.g. a disc drive . For example it is fairly common for a disc drive to routinely suffer from bit level corruption and to completely fail after three years of use. One solution is to utilize a higher grade disc drive which adds significant cost to a computer.

Another solution is to utilize multiple levels of redundant disc drives to replicate the data into two or more copies. One such redundant drive approach is called redundant array of independent discs RAID . In a RAID device a RAID controller adds parity data to the original data before storing it across the array. The parity data is calculated from the original data such that the failure of a disc will not result in the loss of the original data. For example RAID 5 uses three discs to protect data from the failure of a single disc. The parity data and associated redundancy overhead data reduces the storage capacity of three independent discs by one third e.g. n 1 capacity . RAID 6 can recover from a loss of two discs and requires a minimum of four discs with a storage capacity of n 2.

While RAID addresses the memory device failure issue it is not without its own failure issues that affect its effectiveness efficiency and security. For instance as more discs are added to the array the probability of a disc failure increases which increases the demand for maintenance. For example when a disc fails it needs to be manually replaced before another disc fails and the data stored in the RAID device is lost. To reduce the risk of data loss data on a RAID device is typically copied on to one or more other RAID devices. While this addresses the loss of data issue it raises a security issue since multiple copies of data are available which increases the chances of unauthorized access. Further as the amount of data being stored grows the overhead of RAID devices becomes a non trivial efficiency issue.

The DSN memory includes a plurality of distributed storage DS units for storing data of the system. Each of the DS units includes a processing module and memory and may be located at a geographically different site than the other DS units e.g. one in Chicago one in Milwaukee etc. . The processing module may be a single processing device or a plurality of processing devices. Such a processing device may be a microprocessor micro controller digital signal processor microcomputer central processing unit field programmable gate array programmable logic device state machine logic circuitry analog circuitry digital circuitry and or any device that manipulates signals analog and or digital based on hard coding of the circuitry and or operational instructions. The processing module may have an associated memory and or memory element which may be a single memory device a plurality of memory devices and or embedded circuitry of the processing module. Such a memory device may be a read only memory random access memory volatile memory non volatile memory static memory dynamic memory flash memory cache memory and or any device that stores digital information. Note that if the processing module includes more than one processing device the processing devices may be centrally located e.g. directly coupled together via a wired and or wireless bus structure or may be distributedly located e.g. cloud computing via indirect coupling via a local area network and or a wide area network . Further note that when the processing module implements one or more of its functions via a state machine analog circuitry digital circuitry and or logic circuitry the memory and or memory element storing the corresponding operational instructions may be embedded within or external to the circuitry comprising the state machine analog circuitry digital circuitry and or logic circuitry. Still further note that the memory element stores and the processing module executes hard coded and or operational instructions corresponding to at least some of the steps and or functions illustrated in .

Each of the user devices the DS processing unit the DS managing unit and the storage integrity processing unit may be a portable computing device e.g. a social networking device a gaming device a cell phone a smart phone a personal digital assistant a digital music player a digital video player a laptop computer a handheld computer a video game controller and or any other portable device that includes a computing core and or a fixed computing device e.g. a personal computer a computer server a cable set top box a satellite receiver a television set a printer a fax machine home entertainment equipment a video game console and or any type of home or office computing equipment . Such a portable or fixed computing device includes a computing core and one or more interfaces and or . An embodiment of the computing core will be described with reference to .

With respect to the interfaces each of the interfaces and includes software and or hardware to support one or more communication links via the network and or directly. For example interfaces support a communication link wired wireless direct via a LAN via the network etc. between the first type of user device and the DS processing unit . As another example DSN interface supports a plurality of communication links via the network between the DSN memory and the DS processing unit the first type of user device and or the storage integrity processing unit . As yet another example interface supports a communication link between the DS managing unit and any one of the other devices and or units and or via the network .

In general and with respect to data storage the system supports three primary functions distributed network data storage management distributed data storage and retrieval and data storage integrity verification. In accordance with these three primary functions data can be distributedly stored in a plurality of physically different locations and subsequently retrieved in a reliable and secure manner regardless of failures of individual storage devices failures of network equipment the duration of storage the amount of data being stored attempts at hacking the data etc.

The DS managing unit performs distributed network data storage management functions which include establishing distributed data storage parameters performing network operations performing network administration and or performing network maintenance. The DS managing unit establishes the distributed data storage parameters e.g. allocation of virtual DSN memory space distributed storage parameters security parameters billing information user profile information etc. for one or more of the user devices e.g. established for individual devices established for a user group of devices established for public access by the user devices etc. . For example the DS managing unit coordinates the creation of a vault e.g. a virtual memory block within the DSN memory for a user device for a group of devices or for public access . The DS managing unit also determines the distributed data storage parameters for the vault. In particular the DS managing unit determines a number of slices e.g. the number that a data segment of a data file and or data block is partitioned into for distributed storage and a read threshold value e.g. the minimum number of slices required to reconstruct the data segment .

As another example the DS managing module creates and stores locally or within the DSN memory user profile information. The user profile information includes one or more of authentication information permissions and or the security parameters. The security parameters may include one or more of encryption decryption scheme one or more encryption keys key generation scheme and data encoding decoding scheme.

As yet another example the DS managing unit creates billing information for a particular user user group vault access public vault access etc. For instance the DS managing unit tracks the number of times user accesses a private vault and or public vaults which can be used to generate a per access bill. In another instance the DS managing unit tracks the amount of data stored and or retrieved by a user device and or a user group which can be used to generate a per data amount bill.

The DS managing unit also performs network operations network administration and or network maintenance. As at least part of performing the network operations and or administration the DS managing unit monitors performance of the devices and or units of the system for potential failures determines the devices and or units activation status determines the devices and or units loading and any other system level operation that affects the performance level of the system . For example the DS managing unit receives and aggregates network management alarms alerts errors status information performance information and messages from the devices and or the units . For example the DS managing unit receives a simple network management protocol SNMP message regarding the status of the DS processing unit .

The DS managing unit performs the network maintenance by identifying equipment within the system that needs replacing upgrading repairing and or expanding. For example the DS managing unit determines that the DSN memory needs more DS units or that one or more of the DS units needs updating.

The second primary function i.e. distributed data storage and retrieval begins and ends with a user device . For instance if a second type of user device has a data file and or data block to store in the DSN memory it sends the data file and or data block to the DS processing unit via its interface . As will be described in greater detail with reference to the interface functions to mimic a conventional operating system OS file system interface e.g. network file system NFS flash file system FFS disk file system DFS file transfer protocol FTP web based distributed authoring and versioning WebDAV etc. and or a block memory interface e.g. small computer system interface SCSI internet small computer system interface iSCSI etc. . In addition the interface may attach a user identification code ID to the data file and or data block .

The DS processing unit receives the data file and or data block via its interface and performs a distributed storage DS process thereon e.g. an error coding dispersal storage function . The DS processing begins by partitioning the data file and or data block into one or more data segments which is represented as Y data segments. For example the DS processing may partition the data file and or data block into a fixed byte size segment e.g. 2to 2bytes where n 2 or a variable byte size e.g. change byte size from segment to segment or from groups of segments to groups of segments etc. .

For each of the Y data segments the DS processing error encodes e.g. forward error correction FEC information dispersal algorithm or error correction coding and slices or slices then error encodes the data segment into a plurality of error coded EC data slices which is represented as X slices per data segment. The number of slices X per segment which corresponds to a number of pillars n is set in accordance with the distributed data storage parameters and the error coding scheme. For example if a Reed Solomon or other FEC scheme is used in an n k system then a data segment is divided into n slices where k number of slices is needed to reconstruct the original data i.e. k is the threshold . As a few specific examples the n k factor may be 5 3 6 4 8 6 8 5 16 10.

For each EC slice the DS processing unit creates a unique slice name and appends it to the corresponding EC slice . The slice name includes universal DSN memory addressing routing information e.g. virtual memory addresses in the DSN memory and user specific information e.g. user ID file name data block identifier etc. .

The DS processing unit transmits the plurality of EC slices to a plurality of DS units of the DSN memory via the DSN interface and the network . The DSN interface formats each of the slices for transmission via the network . For example the DSN interface may utilize an internet protocol e.g. TCP IP etc. to packetize the EC slices for transmission via the network .

The number of DS units receiving the EC slices is dependent on the distributed data storage parameters established by the DS managing unit . For example the DS managing unit may indicate that each slice is to be stored in a different DS unit . As another example the DS managing unit may indicate that like slice numbers of different data segments are to be stored in the same DS unit . For example the first slice of each of the data segments is to be stored in a first DS unit the second slice of each of the data segments is to be stored in a second DS unit etc. In this manner the data is encoded and distributedly stored at physically diverse locations to improve data storage integrity and security. Further examples of encoding the data segments will be provided with reference to one or more of .

Each DS unit that receives an EC slice for storage translates the virtual DSN memory address of the slice into a local physical address for storage. Accordingly each DS unit maintains a virtual to physical memory mapping to assist in the storage and retrieval of data.

The first type of user device performs a similar function to store data in the DSN memory with the exception that it includes the DS processing. As such the device encodes and slices the data file and or data block it has to store. The device then transmits the slices to the DSN memory via its DSN interface and the network .

For a second type of user device to retrieve a data file or data block from memory it issues a read command via its interface to the DS processing unit . The DS processing unit performs the DS processing to identify the DS units storing the slices of the data file and or data block based on the read command. The DS processing unit may also communicate with the DS managing unit to verify that the user device is authorized to access the requested data.

Assuming that the user device is authorized to access the requested data the DS processing unit issues slice read commands to at least a threshold number of the DS units storing the requested data e.g. to at least 10 DS units for a 16 10 error coding scheme . Each of the DS units receiving the slice read command verifies the command accesses its virtual to physical memory mapping retrieves the requested slice or slices and transmits it to the DS processing unit .

Once the DS processing unit has received a read threshold number of slices for a data segment it performs an error decoding function and de slicing to reconstruct the data segment. When Y number of data segments has been reconstructed the DS processing unit provides the data file and or data block to the user device . Note that the first type of user device performs a similar process to retrieve a data file and or data block.

The storage integrity processing unit performs the third primary function of data storage integrity verification. In general the storage integrity processing unit periodically retrieves slices and or slice names of a data file or data block of a user device to verify that one or more slices have not been corrupted or lost e.g. the DS unit failed . The retrieval process mimics the read process previously described.

If the storage integrity processing unit determines that one or more slices is corrupted or lost it rebuilds the corrupted or lost slice s in accordance with the error coding scheme. The storage integrity processing unit stores the rebuild slice or slices in the appropriate DS unit s in a manner that mimics the write process previously described.

The processing module may be a single processing device or a plurality of processing devices. Such a processing device may be a microprocessor micro controller digital signal processor microcomputer central processing unit field programmable gate array programmable logic device state machine logic circuitry analog circuitry digital circuitry and or any device that manipulates signals analog and or digital based on hard coding of the circuitry and or operational instructions. The processing module may have an associated memory and or memory element which may be a single memory device a plurality of memory devices and or embedded circuitry of the processing module . Such a memory device may be a read only memory random access memory volatile memory non volatile memory static memory dynamic memory flash memory cache memory and or any device that stores digital information. Note that if the processing module includes more than one processing device the processing devices may be centrally located e.g. directly coupled together via a wired and or wireless bus structure or may be distributedly located e.g. cloud computing via indirect coupling via a local area network and or a wide area network . Further note that when the processing module implements one or more of its functions via a state machine analog circuitry digital circuitry and or logic circuitry the memory and or memory element storing the corresponding operational instructions may be embedded within or external to the circuitry comprising the state machine analog circuitry digital circuitry and or logic circuitry. Still further note that the memory element stores and the processing module executes hard coded and or operational instructions corresponding to at least some of the steps and or functions illustrated in .

In an example of storing data the gateway module receives an incoming data object that includes a user ID field an object name field and the data object field and may also receive corresponding information that includes a process identifier e.g. an internal process application ID metadata a file system directory a block number a transaction message a user device identity ID a data object identifier a source name and or user information. The gateway module authenticates the user associated with the data object by verifying the user ID with the managing unit and or another authenticating unit.

When the user is authenticated the gateway module obtains user information from the management unit the user device and or the other authenticating unit. The user information includes a vault identifier operational parameters and user attributes e.g. user data billing information etc. . A vault identifier identifies a vault which is a virtual memory space that maps to a set of DS storage units . For example vault i.e. user 1 s DSN memory space includes eight DS storage units X 8 wide and vault i.e. user 2 s DSN memory space includes sixteen DS storage units X 16 wide . The operational parameters may include an error coding algorithm the width n number of pillars X or slices per segment for this vault a read threshold T a write threshold an encryption algorithm a slicing parameter a compression algorithm an integrity check method caching settings parallelism settings and or other parameters that may be used to access the DSN memory layer.

The gateway module uses the user information to assign a source name to the data. For instance the gateway module determines the source name of the data object based on the vault identifier and the data object. For example the source name may contain a file identifier ID a vault generation number a reserved field and a vault identifier ID . As another example the gateway module may generate the file ID based on a hash function of the data object . Note that the gateway module may also perform message conversion protocol conversion electrical conversion optical conversion access control user identification user information retrieval traffic monitoring statistics generation configuration management and or source name determination.

The access module receives the data object and creates a series of data segments through Y in accordance with a data storage protocol e.g. file storage system a block storage system and or an aggregated block storage system . The number of segments Y may be chosen or randomly assigned based on a selected segment size and the size of the data object. For example if the number of segments is chosen to be a fixed number then the size of the segments varies as a function of the size of the data object. For instance if the data object is an image file of 4 194 304 eight bit bytes e.g. 33 554 432 bits and the number of segments Y 131 072 then each segment is 256 bits or 32 bytes. As another example if segment sized is fixed then the number of segments Y varies based on the size of data object. For instance if the data object is an image file of 4 194 304 bytes and the fixed size of each segment is 4 096 bytes the then number of segments Y 1 024. Note that each segment is associated with the same source name.

The grid module receives the data segments and may manipulate e.g. compression encryption cyclic redundancy check CRC etc. each of the data segments before performing an error coding function of the error coding dispersal storage function to produce a pre manipulated data segment. After manipulating a data segment if applicable the grid module error encodes e.g. Reed Solomon Convolution encoding Trellis encoding etc. the data segment or manipulated data segment into X error coded data slices .

The value X or the number of pillars e.g. X 16 is chosen as a parameter of the error coding dispersal storage function. Other parameters of the error coding dispersal function include a read threshold T a write threshold W etc. The read threshold e.g. T 10 when X 16 corresponds to the minimum number of error free error coded data slices required to reconstruct the data segment. In other words the DS processing module can compensate for X T e.g. 16 10 6 missing error coded data slices per data segment. The write threshold W corresponds to a minimum number of DS storage units that acknowledge proper storage of their respective data slices before the DS processing module indicates proper storage of the encoded data segment. Note that the write threshold is greater than or equal to the read threshold for a given number of pillars X .

For each data slice of a data segment the grid module generates a unique slice name and attaches it thereto. The slice name includes a universal routing information field and a vault specific field and may be 48 bytes e.g. 24 bytes for each of the universal routing information field and the vault specific field . As illustrated the universal routing information field includes a slice index a vault ID a vault generation and a reserved field. The slice index is based on the pillar number and the vault ID and as such is unique for each pillar e.g. slices of the same pillar for the same vault for any segment will share the same slice index . The vault specific field includes a data name which includes a file ID and a segment number e.g. a sequential numbering of data segments Y of a simple data object or a data block number .

Prior to outputting the error coded data slices of a data segment the grid module may perform post slice manipulation on the slices. If enabled the manipulation includes slice level compression encryption CRC addressing tagging and or other manipulation to improve the effectiveness of the computing system.

When the error coded data slices of a data segment are ready to be outputted the grid module determines which of the DS storage units will store the EC data slices based on a dispersed storage memory mapping associated with the user s vault and or DS storage unit attributes. The DS storage unit attributes may include availability self selection performance history link speed link latency ownership available DSN memory domain cost a prioritization scheme a centralized selection message from another source a lookup table data ownership and or any other factor to optimize the operation of the computing system. Note that the number of DS storage units is equal to or greater than the number of pillars e.g. X so that no more than one error coded data slice of the same data segment is stored on the same DS storage unit . Further note that EC data slices of the same pillar number but of different segments e.g. EC data slice of data segment and EC data slice of data segment may be stored on the same or different DS storage units .

The storage module performs an integrity check on the outbound encoded data slices and when successful identifies a plurality of DS storage units based on information provided by the grid module . The storage module then outputs the encoded data slices through X of each segment through Y to the DS storage units . Each of the DS storage units stores its EC data slice s and maintains a local virtual DSN address to physical location table to convert the virtual DSN address of the EC data slice s into physical storage addresses.

In an example of a read operation the user device and or sends a read request to the DS processing unit which authenticates the request. When the request is authentic the DS processing unit sends a read message to each of the DS storage units storing slices of the data object being read. The slices are received via the DSnet interface and processed by the storage module which performs a parity check and provides the slices to the grid module when the parity check was successful. The grid module decodes the slices in accordance with the error coding dispersal storage function to reconstruct the data segment. The access module reconstructs the data object from the data segments and the gateway module formats the data object for transmission to the user device.

In an example of write operation the pre slice manipulator receives a data segment and a write instruction from an authorized user device. The pre slice manipulator determines if pre manipulation of the data segment is required and if so what type. The pre slice manipulator may make the determination independently or based on instructions from the control unit where the determination is based on a computing system wide predetermination a table lookup vault parameters associated with the user identification the type of data security requirements available DSN memory performance requirements and or other metadata.

Once a positive determination is made the pre slice manipulator manipulates the data segment in accordance with the type of manipulation. For example the type of manipulation may be compression e.g. Lempel Ziv Welch Huffman Golomb fractal wavelet etc. signatures e.g. Digital Signature Algorithm DSA Elliptic Curve DSA Secure Hash Algorithm etc. watermarking tagging encryption e.g. Data Encryption Standard Advanced Encryption Standard etc. adding metadata e.g. time date stamping user information file type etc. cyclic redundancy check e.g. CRC32 and or other data manipulations to produce the pre manipulated data segment.

The encoder encodes the pre manipulated data segment using a forward error correction FEC encoder and or other type of erasure coding and or error coding to produce an encoded data segment . The encoder determines which forward error correction algorithm to use based on a predetermination associated with the user s vault a time based algorithm user direction DS managing unit direction control unit direction as a function of the data type as a function of the data segment metadata and or any other factor to determine algorithm type. The forward error correction algorithm may be Golay Multidimensional parity Reed Solomon Hamming Bose Ray Chauduri Hocquenghem BCH Cauchy Reed Solomon or any other FEC encoder. Note that the encoder may use a different encoding algorithm for each data segment the same encoding algorithm for the data segments of a data object or a combination thereof.

The encoded data segment is of greater size than the data segment by the overhead rate of the encoding algorithm by a factor of X T where X is the width or number of slices and T is the read threshold. In this regard the corresponding decoding process can accommodate at most X T missing EC data slices and still recreate the data segment . For example if X 16 and T 10 then the data segment will be recoverable as long as 10 or more EC data slices per segment are not corrupted.

The slicer transforms the encoded data segment into EC data slices in accordance with the slicing parameter from the vault for this user and or data segment . For example if the slicing parameter is X 16 then the slicer slices each encoded data segment into 16 encoded slices.

The post slice manipulator performs if enabled post manipulation on the encoded slices to produce the EC data slices. If enabled the post slice manipulator determines the type of post manipulation which may be based on a computing system wide predetermination parameters in the vault for this user a table lookup the user identification the type of data security requirements available DSN memory performance requirements control unit directed and or other metadata. Note that the type of post slice manipulation may include slice level compression signatures encryption CRC addressing watermarking tagging adding metadata and or other manipulation to improve the effectiveness of the computing system.

In an example of a read operation the post slice de manipulator receives at least a read threshold number of EC data slices and performs the inverse function of the post slice manipulator to produce a plurality of encoded slices. The de slicer de slices the encoded slices to produce an encoded data segment . The decoder performs the inverse function of the encoder to recapture the data segment . The pre slice de manipulator performs the inverse function of the pre slice manipulator to recapture the data segment .

As illustrated there are at least two primary methods to interface the plurality of user devices to the DS processing . A first primary method is an object method and a second primary method is a block method. In the object method data is interchanged in the form of an object that may have variable size name s directory links and metadata. Object storage includes a sequence of bytes of a varying length to help abstract the physical storage e.g. object names rather than just disk drive locations . User devices can add delete bytes of an object. The object may have attached metadata describing the data. This layer looks like an object storage device to the above layers. For example different size files and or data associated with a client server application. In the block method data is interchanged in the form of fixed length blocks. Block storage utilizes a sequence of bytes of a nominal length to help abstract the physical storage e.g. block numbers rather than just disk drive locations . Files may be converted to blocks such that files typically fill multiple blocks. The block storage system can be abstracted by a file system for the user device.

Within the object method there are at least two secondary interfacing methods. A first secondary method is a simple object method and a second secondary method is a file system method. In the simple object method data is interchanged that may not conform to a typical computer file and directory system. Simple objects include data without a file structure such as bytes exchanged in an embedded client with a server application. Simple objects may be communicated in messages via HTTP. Simple objects may utilize simple object access protocol SOAP procedures to exchange extensible markup language XML style documents. For example location data exchanged between a global positioning system GPS equipped user device and a location services application server. In the file system method an approach is provided for storing and organizing data where the data is interchanged conforming to a typical computer file and directory system. In the file system file names are assigned to files and organized in a directory. File name may be an index into a file allocation table FAT of location information. For example a user device sends a Windows formatted file to the DSN system.

As illustrated the DS processing unit interfaces the DSN memory to the plurality of user devices through either an object layer and or a block layer . The object layer interfaces with either a simple object layer and or a file system layer . As illustrated the simple object layer interfaces with either a Java SDK software developer kit layer and or a web service layer . In an example the Java SDK layer may utilize a loader to interpret Java class files generated by a Java compiler. For instance a Java archiver may manage Java Archive JAR files. In an example the web service layer utilizes a protocol for machine to machine interaction over a network. For instance the protocol includes a simple object access protocol SOAP standard over hypertext protocol HTTP or representational state transfer REST . The web service layer interfaces with a HTTP REST API layer . In example the REST API layer on utilizes a client server approach with discrete states without a continuous server load e.g. a request followed by a response with no state maintained by a server . Note that REST may run over HTTP.

As illustrated the file system layer interfaces with either a FTP file transfer protocol layer an AFP Apple Filing Protocol layer and or a Web DAV web based distributed authoring and versioning layer . In example the FTP layer is utilized to exchange files over transport control protocol internet protocol TCP IP such as the internet via ports. For instance FTP utilizes a client server approach. For instance FTP may utilize separate control and data streams and applications may be command line or graphical. Note that a secure sockets layer SSL and or transport layer security TLS may be added for improved security. In an example the AFP layer provides a network protocol of file services for the Macintosh operating system OS family over TCP IP. In an example the Web DAV layer provides extensions to HTTP to allow the plurality of user devices to create change and or move files on a web server. For instance Windows OS provides directory web folders.

As illustrated the block layer of interfaces with a SCSI small computer system interface layer . In an example the SCSI layer provides a bus approach physical connection and data transfer between computers and peripheral devices. For instance SCSI enables initiators e.g. in user device to send commands to targets e.g. in DS processing unit and or DS memory . The SCSI layer interfaces with an iSCSI internet small computer system interface layer . In an example the iSCSI layer transfers SCSI commands over the internet and or the network via TCP IP enabling remote initiators e.g. in user device to send commands to targets e.g. in DS processing unit and or DS unit .

As illustrated the iSCSI layer interfaces with a NFS network file system layer a FTP layer an AFP layer a CIFS common internet file system layer and or directly with the user device . In example the NFS layer enables user devices access over a network where the DS processing unit implements a NFS daemon process to make data available to a plurality of user devices . For instance directories are communicated as user device requests a mount. In an example the CIFS layer provides a client server application layer network protocol to provide shared access to files printers serial ports e.g. common in Windows OS . The FTP layer and AFP layer function as previously discussed.

In an example of operation the user device utilizes an embedded interface to store data in the DSN memory . A user device data application communicates REST transfers via HTTP over the network to the HTTP REST API interface layer . The web service layer may host the server side of the REST transfers. The object layer interfaces the data to the DS processing where the data is segmented encoded and sliced in accordance with an error coded dispersal storage function to produce encoded data slices . The DS processing sends the encoded data slices to the DSN memory for storage therein.

In another example of operation the user device utilizes a URL interface uniform resource locator to store a file in the DSN memory . A user device file application communicates Web DAV transfers via HTTP over the network to the Web DAV interface layer . The Web DAV interface may provide web folders to the user device such that the user device may drop the file to be stored in the DSN memory into the folder. The file system layer and the object layer interfaces data of the file to the DS processing where the data is segmented encoded and sliced in accordance with an error coded dispersal storage function to produce encoded data slices . The DS processing sends the encoded data slices to the DSN memory for storage therein.

In another example of operation the user device utilizes a hard drive style interface to store data blocks in the DSN memory . A user device block application communicates CIFS transfers over the network to the CIFS interface layer . The CIFS interface layer may provide shared access to the user device such that the user device when looks at the DSN memory as an iSCI device to store data blocks in the DSN memory . The iSCSI and SCSI layer interfaces data of the data blocks to the DS processing where the data is segmented encoded and sliced in accordance with an error coded dispersal storage function to produce encoded data slices . The DS processing sends the encoded data slices to the DSN memory for storage therein.

There are at least two primary interfacing methods from the DS processing to the applications . A first primary method is an object method and a second primary method is a block method as previously discussed with reference to . As illustrated a data application interfaces with the Java SDK layer and or HTTP REST API layer interfacing functions. As illustrated a file application interfaces with a FTP layer an AFP layer and or a Web DAV layer interfacing functions. As illustrated a block application interfaces with a NFS layer a FTP layer an AFP layer a CIFS layer and or directly with an iSCSI layer . In another example the applications may interface directly with one or more of a web service layer a simple object layer a file system layer the iSCSI layer an object layer and a block layer .

The applications may utilize protocols e.g. above the physical layer of the interfacing functions to access the DSN memory . The data application communicates data with the DS processing to access the DSN memory . The file application communicates files with the DS processing to access the DSN memory . The block application communicates data blocks with the DS processing to access the DSN memory . The DS processing sends slices through the network to the DSN memory for storage therein. The DS processing retrieves slices from the DSN memory through the network .

In another example of operation the user device may determine a DS processing unit to utilize based on a predetermination and or initially on a predetermination followed by a potential subsequent modification based in part on actual performance. In another example user device determines to initially utilize DS processing unit when DS processing unit is listed in a predetermined table. Next user device determines to subsequently utilize DS processing unit when DS processing unit does not perform to a required level and DS processing unit is the second choice.

In an example of operation user device provides DSN memory access authorization credentials when accessing the DSN memory via DS processing unit . Next the DS processing unit verifies the authorization credentials. The DS processing unit forwards a DSN memory access request to the DSN memory when the authorization credential verification is favorable e.g. on a list of authorized users for the particular item in the DSN memory . The DS processing unit does not forward a DSN memory access request to the DSN memory when the authorization credential verification is not favorable e.g. not on a list of authorized users for the particular item in the DSN memory . The method of operation of the user device to determine the DS processing unit is discussed in greater detail with reference to .

In another sample DS processing unit forwards the authorization credentials to the DSN memory with the DSN memory access request e.g. without verification by the DS processing unit . The DSN memory verifies the authorization credentials. The DSN memory processes the memory access request when the authorization credential verification is favorable. The DSN memory does not process the memory access request when the authorization credential verification is not favorable.

The method continues at step where the processing module determines candidate DS processing units based on one or more of a virtual DSN address to physical location table a query a message from one or more DS processing units a data type a data size a security indicator a performance indicator a status indicator a command a predetermination and a lookup. The method continues at step where the processing module determines candidate DS processing units attributes where the attributes may include one or more of current capacity current loading uptime history performance history data types supported data types not supported security restrictions and encryption algorithms supported. Such a determination may be based on one or more of a virtual DSN address to physical location table a query a message from one or more DS processing units a data type a data size a security indicator a performance indicator a command a predetermination and a lookup. In an example the processing module determines that DS processing unit has an attribute of capacity above a threshold based on the performance indicator. In another example the processing module determines that DS processing unit has an attribute of a particular encryption algorithm based on the security indicator from a query.

The method continues at step where the processing module determines a DS processing unit to utilize based on one or more of the DSN access requirements the candidate DS processing units the candidate processing units attributes a comparison of the candidate processing units attributes to the DSN access requirements a virtual DSN address to physical location table a query a message from one or more DS processing units a data type a data size a security indicator a performance indicator a command a predetermination and a lookup. In an example the processing module determines the DS processing unit such that substantially all of the requirements are met or exceeded. For instance the processing module determines the DS processing unit that meets or exceeds the most requirements. The method continues at step where the processing module utilizes the determined DS processing unit for the DSN access e.g. store retrieve delete check status .

In an example of operation the DS processing unit determines if memory utilization of DSN memory storage set is above a threshold e.g. when the memory utilization is greater than or equal to 70 utilized . Such a determination may be based on one or more of a query of one or more of the DS units of the DSN memory storage set a message from a DS managing unit and or a message from the DSN memory storage set . Next the DS processing unit sends a memory utilization alert to the DS managing unit when the DS processing unit determines that the memory utilization is above the threshold. In addition the DS processing unit may activate a dormant DSN memory storage set as DSN memory storage set to provide more storage capacity for at least one vault that is utilizing DSN memory storage set .

In another example of operation the DS processing unit determines which of the two storage sets to utilize when the DS processing unit has new data to send to the DSN memory for storage. As illustrated in DSN memory storage set has the same number of DS units as DSN memory storage set . In another example DSN memory storage set may include two or more DS units for each pillar.

In another example of operation the DS processing unit determines to send pillar slices to DS unit of DSN memory storage set . In another example the DS processing unit determines to send pillar slices to DS unit of DSN memory storage set . Note that DSN memory storage set may be nearly full while DSN memory storage set may be nearly empty. In another example of operation the DS processing unit balances distribution of new data between the two DSN memory storage sets to achieve a balancing objective. For instance the balancing objective may include completely filling DSN memory storage set followed by sending subsequent data to DSN memory storage set . In another instance the balancing objective may include alternating sending new data to the DSN memory storage sets such that DSN memory storage set fills up to capacity first. In yet another instance the balancing objective may include alternating sending new data to the DSN memory storage sets such that the DSN memory storage sets fill up to capacity substantially simultaneously. The DS processing method to balance the utilization is discussed in greater detail with reference to .

The method continues at step where the processing module determines operational parameters based on one or more of the data object a vault lookup a query of dispersed storage network DSN memory storage set memory utilization a command a user ID a data object name a data type a data size a priority indicator a security indicator a performance indicator and other metadata. For example the processing module determines that the pillar width is four based on the user ID. The method continues at step where the processing module determines available DSN memory storage set s based on one or more of a query the operational parameters a vault lookup a predetermination a query of DSN memory storage set memory utilization a command a user ID a data object name a data type a data size a priority indicator a security indicator a performance indicator and other metadata. For example the processing module determines that DSN memory storage sets and are available based on a query.

The method continues at step where the processing module determines a DSN memory storage set to utilize based on one or more of the available storage set s a balancing objective a query the operational parameters a vault lookup a predetermination a random number a query of DSN memory storage set memory utilization a command a user ID a data object name a data type a data size a priority indicator a security indicator a performance indicator and other metadata. In an example the processing module determines that the balancing objective is to alternate sending new data to the available DSN memory storage sets such that the DSN memory storage sets fill up to capacity substantially simultaneously and that available DSN memory storage set has 30 capacity remaining and DSN memory storage set has 95 capacity remaining. For instance the processing module determines a random number from 1 to 125 e.g. 30 95 125 . Next the processing module encodes the data object in accordance with an error coding dispersal storage function to produce encoded data slices. The processing module sends the encoded data slices to DSN memory storage set for storage therein when the random number is less than or equal to 30. The processing module sends the encoded data slices to DSN memory storage set for storage therein when the random number is greater than 30. Note that this weighted method balances the utilization to meet the balancing objective.

As illustrated in the DSN memory includes the DS unit at site and a DS unit at site at a time subsequent to that of . As illustrated DS unit includes the storage and control module and memories . As illustrated DS unit includes the storage unit control module and memories . Note that memories are transportable such that memories were transferred to DS unit while memories remain in DS unit .

As illustrated the storage unit control module is operably coupled to the computing system via the network . The storage unit control module may include DS processing and may receive via the network a store command metadata and a data object to store. Note that the DS unit access may be via a WebDAV sequence e.g. via an IP address such as http 21.8.44 vault1 to facilitate easy DS unit access. The data object may include a simple object file a block file and or EC data slices. In an example the storage unit control module stores the data object in one or more of the memories substantially as received e.g. a slice is stored as a slice a block file is stored as a block file etc. . In another example the storage unit control module encodes the data object utilizing an error coding dispersal storage function to produce encoded data slices and stores the encoded data slices in one or more of the memories . Note that the storage unit control module unit may determine to utilize only the memories of the DS unit when the capabilities of memories substantially meet the requirements. In another example the storage unit control module determines to utilize some combination of the memories of the DS unit and memory of at least one other DS unit when the capabilities of memories alone substantially do not meet the requirements.

In an example of operation the storage unit control module determines where e.g. which address of one or more of the memories to store the received data object as encoded data slices. Such a determination may be based on one or more of metadata a command e.g. from the DS processing unit indicating which memory or memory type to use a type of data indicator a local virtual DSN address to physical location table lookup a priority indicator a security indicator available memory memory performance data memory status memory cost data and any other parameter to facilitate desired levels of efficiency and performance. For instance the storage unit control module may select memories e.g. magnetic hard disk drives to store the encoded data slices since the performance and efficiency is good enough for the requirements e.g. availability cost response time . In another instance the storage unit control module distributes the slices to memories when memories and are not available. In another instance the storage unit control module distributes the slices at various addresses across one memory. In another instance the storage unit control module distributes a read threshold k 8 of the encoded data slices across memories for fast retrieval and the other 4 n k encoded data slices to other DS units. In yet another instance the storage unit control module distributes the encoded data slices across the DS unit memories and at least one other DS unit at the same site as the DS unit . In yet another instance the storage unit control module distributes the encoded data slices across the DS unit memories and at least one other DS unit at a different site as the DS unit .

In a further example of operation the storage unit control module creates and maintains a local virtual DSN address to physical memory table. The storage unit control module determines where previously stored encoded data slices are located based on the local virtual DSN address to physical memory table upon receiving a retrieve request via the network . Note that a DS processing unit operably coupled to the DS unit via the network maintains a virtual DSN address to physical memory table for the system tracking where the pillars are located for each vault.

In the example of operation the storage unit control module determines when a change has occurred to the memory configuration of the DS unit and updates the local virtual DSN address to physical memory table e.g. DS unit level and sends a configuration update message to the DS processing unit to update the virtual DSN address to physical memory table e.g. system level based on the memory configuration change. The storage unit control module determines when a change has occurred to the memory configuration of the DS unit based on one or more of a configuration message from the DS managing unit a memory query a test an error message a configuration indicator a command a vault lookup a command a predetermination and a DS unit message. For instance the storage unit control module of DS unit in determines that a change e.g. memory has been removed which is utilized to store pillars of vault has occurred based on a query of the memories .

In another instance any number of pillars may be moved e.g. via memory transport from one DS unit to another. In another instance the storage unit control module of DS unit in determines that a change e.g. memory has been added which holds slices from pillars of vault has occurred based on a query of the memories and a DS managing unit configuration message. Next storage unit control module of DS unit in updates its associated local DSN address to physical location table and send a configuration update message to the DS processing unit where the message includes an indication that pillars e.g. of a vault are stored in DS unit and or pillars are not stored in DS unit . The storage unit control module of DS unit in updates its associated local DSN address to physical location table and send a configuration update message to the DS processing unit where the message includes an indication that pillars e.g. of vault are stored in DS unit . The DS processing unit utilizes the DS units to access the pillars of the new configuration. The DS units provide slice access for the pillars of the new configuration.

The processing module may be part of the computing core of and may include memory to run a file application and store a working copy of a file. The processing module may host a file application which during a first timeframe manipulates a first portion of the file. In an example the manipulation may include one or more of reading editing deleting moving inserting replicating and checking status. The file application may manipulate a second portion of the file during a second timeframe etc.

The data object cache may comprise memory to temporarily store at least a portion of the file. The contents of the data object cache may change frequently as the file is manipulated. The file may be deleted from the data object cache once the manipulation sequences conclude. Portions of the file may be stored as slices in the DSN memory from time to time.

In an example of operation DS processing stores and or retrieves slices of the file in the DSN memory . For instance the DS processing determines to select at least a portion of the file segment the portion encode and slice the portion to produce encoded data slices in accordance with an error coding dispersal storage function. Next the DS processing send the encoded data slices to the DSN memory for storage therein. In another instance the DS processing moves the portion of the file from the processing module to the data object cache . The determination to save the portion in DSN memory may be based on one or more of an action policy e.g. when the file has changed a query for change a message from the processing module file application and a timer expiration since the last save sequence. The method to determine if the data object has changed and what action to take when it has changed is described in greater detail with reference to .

In another example the processing module determines that the data object has changed when a comparison of the file to the file previously stored in the data object cache e.g. as a result of the last save sequence reveals that more than a threshold of characters are different and the timer from the last save sequence has expired. In another example the processing module determines that the data object has changed when the processing module receives a message that the file has been closed e.g. ending the file manipulation . The method repeats back to step when the processing module determines that the data object has not changed. The method continues to step when the processing module determines that the data object has changed.

The method continues at step where the processing module determines operational parameters including pillar width n read threshold k and an action policy e.g. what to do when change is determined . Such a determination may be based on one or more of a vault lookup a command a predetermination and a message. The method continues at step where the processing module determines an action where the action may include storing a new copy of the file in the data object cache e.g. in the file format and or as encoded data slices and or storing a new copy revision or portion of the file in a dispersed storage network DSN memory as encoded data slices. Such a determination may be based on one or more of the action policy the operational parameters a data size indicator a system activity level indicator a vault lookup a command a message from the processing module a predetermination and a message. For example the processing module determines the action to be store in the data object cache when the action policy indicates to store the file in the cache when the data size is below a threshold.

In another example the processing module determines the action to be store in the DSN memory when the action policy indicates to store the file in the DSN memory when the system level activity level indicator is below a threshold. The method branches to step when the processing module determines the action to be store in the DSN memory. The method continues to step when the processing module determines the action to be store in the data object cache. The method continues at step where the processing module saves the file in the data object cache in the file format. For instance the processing module saves the entire file. In another instance the processing module saves a portion of the file that has changed since the last save sequence. Note that the processing module may create encoded data slices from the file in accordance with the operational parameters and store the slices in the data object cache. The method continues at step where the processing module encodes a portion of the file in accordance with an error coding dispersal storage function to produce encoded data slices. The processing module sends the encoded data slices to the DSN memory with an updated revision number and a store command for storage in the DSN memory.

The method continues at step where the processing module determines operational parameters which may include one or more of pillar width n read threshold k and a cache list e.g. which data object may be where in the data object cache . Such a determination may be based on one or more of a vault lookup a command a predetermination a data object name data object size data type a priority indicator a security indicator a performance indicator a command and a message.

The method continues at step where the processing module determines a location of the data object which may include a data object cache and or a dispersed storage network DSN memory. Such a determination may be based on one or more of the operational parameters a cache list a vault lookup a command a predetermination a data object name data object size data type a priority indicator a security indicator a performance indicator a command and a message. The method branches to step when the processing module determines the location of the data object to be not in the cache. The method continues to step when the processing module determines the location of the data object to be in the cache.

The method continues at step where the processing module retrieves the data object from the cache memory in accordance with a cache list. In an example the data object is stored as encoded data slices. The processing module de slices and decodes the encoded data slices in accordance with an error coding dispersal storage function to produce the data object in accordance with the operational parameters when the data object is stored as encoded data slices. The method continues at step where the processing module sends the data object to the requester. The method branches to step .

The method continues at step where the processing module retrieves encoded data slices from the DSN memory in accordance with the operational parameters and or location determination when the processing module determines the location of the data object to be not in the cache. The method continues at step where the processing module de slices and decodes the slices utilizing the error coding dispersal storage function and in accordance with the operational parameters to produce the data object. The method continues at step where the processing module stores the data object in data object cache memory and modifies the cache list to indicate that the data object is stored in the cache. Note that this may provide an improvement to the system such that the subsequent retrievals may be from the cache e.g. faster . The method continues at step where the processing module sends the data object to the requester. The method branches to step .

The method continues at step where the processing module determines a read ahead which may include an amount of the data object to retrieve next e.g. which may be similar to the last retrieval if the consumption pace is steady or it may be none . Such a determination may be based on one or more of the amount of the data object retrieved for consumption so far the current position pointer a history of reading ahead time since the last retrieval the operational parameters a cache list a vault lookup a command a predetermination a data object name data object size data type a priority indicator a security indicator a performance indicator a command a system activity level indicator and a message. For example the processing module determines the read ahead to be 10 megabytes when the history of reading ahead indicates that the last five read ahead retrievals where 10 mega bytes and the average time between retrievals was 5 minutes. The method repeats back to step .

The method continues at step where the processing module dispersed storage error encodes the data in accordance with the operational parameters to produce a set of encoded data slices. The method continues at step where the processing module generates a first transaction identifier regarding storage of the set of encoded data slices. Note that the first transaction identifier may include a transaction number and or a request number. Such a generation of the first transaction identifier may include at least one of utilizing a coordinated universal time utilizing a random number generator output performing a function e.g. increment decrement multiply times 2 etc. based on at least one of a previous first transaction identifier and a previous second transaction identifier performing a second function on the first transaction identifier to generate the second transaction identifier.

The processing module outputs a plurality of write request messages to a plurality of dispersed storage DS units wherein each of the plurality of write request messages includes the first transaction identifier and a corresponding one of the set of encoded data slices. One or more of the DS units may send a write response message e.g. an acknowledgement to the processing module in response to receiving the write request message. The processing module receives write response messages from the DS units. Note that the processing module may not receive an acknowledgement due to many potential errors and failures e.g. DS unit failure network failure etc. .

The method continues at step where the processing module receives write response messages from at least some of the DS units wherein each of the write response messages includes a reference to the first transaction identifier. Note that a write response message of the write response messages comprises at least one of an operation succeeded status code a transaction conflict status code e.g. slice is locked by another transaction an addressing error status code e.g. slice is not assigned to a responding DS unit a check condition status code e.g. an expected revision does not match what is currently stored and an unauthorized status code e.g. a requester is not authorized to write the slice .

The processing module determines whether a write threshold number of favorable e.g. with the operation succeeded status code write response messages have been received within a time period. The method branches to step when the processing module determines that the write threshold number of favorable write response messages have been received within the time period. The method continues to step when the processing module determines that the write threshold number of favorable write response messages have not been received within the time period. Alternatively the processing module determines that the write threshold number of favorable write response messages have not been received within the time period when the processing module receives at least one of the write response messages having an unfavorable response and when a number of write response messages having the unfavorable response exceeds a second threshold. The method continues at step where the processing module outputs a plurality of rollback transaction request messages to the plurality of DS units wherein each of the plurality of rollback transaction request messages includes the first transaction identifier. Note that the DS unit deletes the encoded data slice slice names and first transaction identifier in response to receiving the rollback transaction request message. Next the method branches back to step where the processing module re attempts to store the set of encoded data slices.

The method continues at step where the processing module reads directory information associated with the data. Such directory information may link a data identifier and revision identifier to a virtual DSN address of the location where the encoded data slices are stored in the DS units of the dispersed storage network memory. In an example the processing module retrieves encoded directory slices from the plurality of DS units and decodes the encoded directory slices utilizing an error coding dispersal stored function to produce the directory information. The processing module updates directory information regarding storage of the data to produce updated directory information. For example the processing module modifies the revision identifier to indicate a newer revision has been stored for the corresponding data identifier.

The method continues at step where the processing module determines if the directory information is as expected by one of more of comparing a transaction number of the last directory addition to an expected next transaction number e.g. from the transaction number list and by comparing the last entered data object name to the current data object name. Note that it is possible that another processing module is concurrently writing slices of a data object where the data object is targeted for the same directory position e.g. a write collision . The method branches to step when the processing module determines that the directory information is as expected. The method continues to step when the processing module determines that the directory information is not as expected. The method continues at step where the processing module sends an error message e.g. to a dispersed storage managing unit and may send a rollback request message to the plurality of DS units and may branch back to step to re create and re store encoded data slices to avoid a potential write conflict.

The method continues at step where the processing module dispersed storage error encodes the updated directory information to produce a set of encoded directory slices next. Next the processing module generates a second transaction identifier regarding storage of the set of encoded directory slices wherein generating the second transaction identifier includes at least one of utilizing a coordinated universal time utilizing a random number generator output performing a function based on at least one of a previous transaction identifier a previous second transaction identifier performing a second function on the first transaction identifier to generate the second transaction identifier. The processing module outputs a second plurality of write request messages to a second plurality of DS units wherein each of the second plurality of write request messages includes the second transaction identifier and a corresponding one of the set of encoded directory slices. Alternatively the processing module outputs the second plurality of write request messages to the plurality of DS units.

Alternatively the processing module outputs a plurality of read request messages that includes a plurality of slice names corresponding to the updated directory information. Next the processing module receives a plurality of read response messages that include a slice revision. Next the processing module establishes the expected slice revision as the slice revision. Next the processing module outputs the second plurality of write request messages to the plurality of DS units wherein each of the second plurality of write request messages further includes the expected slice revision. The DS units may send an acknowledgement to the DS processing in response to receiving the data object name and second transaction number.

The processing module receives second write response messages e.g. acknowledgements from at least some of the plurality of DS units. Alternatively the processing module interprets the second write response messages for confirmation of the expected slice revision. Note that the second write response message of the second write response messages comprises at least one of an operation succeeded status code a transaction conflict status code an addressing error status code a check condition status code e.g. the expected slice revision does not equal a current slice revision and an unauthorized status code. Note that the processing module may not receive a second write response message due to many potential errors and failures e.g. DS unit failure network failure .

The method continues at step where the processing module determines whether at least a second write threshold number of favorable e.g. operation succeeded without error second write response messages have been received from the DS units within a time period. The method branches back to step where the processing module re updates e.g. re reads and updates the directory information regarding storage of the data re disperse error encodes the directory information to re produce the set of encoded directory slices and outputs at least some of the second plurality of write request messages regarding the reproduced set of encoded directory slices at step to try again when the processing module determines that at least the second write threshold number of favorable second write response messages have not been received within a time period. The method continues to step when the processing module determines that at least the second write threshold number of favorable second write response messages have been received.

The method continues at step where the processing module outputs a plurality of data commit request messages regarding the set of encoded data slices to the plurality of DS units wherein each of the plurality of data commit request messages includes the first transaction identifier. Next the processing module outputs the plurality of directory commit request messages regarding the set of encoded directory slices to the second plurality of DS units wherein each of the plurality of directory commit request messages includes the second transaction identifier. Alternatively the processing module outputs a plurality of commit request messages regarding the set of encoded data slices and the set of encoded directory slices to the plurality of DS units wherein each of the plurality of commit request messages includes the first and second transaction identifiers. Alternatively the processing module outputs the plurality of commit request messages regarding the set of encoded data slices and the set of encoded directory slices to the plurality of DS units. The method of operation of the DS unit is discussed in greater detail with reference to .

The method continues at step where the processing module obtains a DS unit most recent slice revision from local memory based on the slice name. The method continues at step where the processing module determines whether the DS unit most recent slice revision compares favorably to the DS processing module most recent slice revision from the request. The processing module determines that the DS unit most recent slice revision compares favorably to the DS processing module most recent slice revision when the DS unit most recent slice revision is substantially the same as the DS processing module most recent slice revision. In addition the processing module may check for other possible error conditions. In an example the processing module verifies that the slice name is within a range that is assigned to the processing module e.g. the DS unit . The processing module sends a write response message that includes an addressing error status code when the processing module determines that the slice name is not within the range. In another example the processing module verifies that a requester that initiated the write request is authenticated and has an appropriate permissions level. The processing module sends a write response message that includes an unauthorized status code when the processing module determines that requester is not authenticated or does not have the appropriate permissions level.

The method branches to step when the processing module determines that the DS unit most recent slice revision compares favorably to the DS processing module most recent slice revision. The method continues to step when the processing module determines that the DS unit most recent slice revision compares unfavorably to the DS processing module most recent slice revision. The method continues at step where the processing module generates a write response message to include a condition status code e.g. a check condition status code indicating the unfavorable comparison. Next the processing module sends the write response message to the DS processing module.

The method continues at step where the processing module stores the encoded directory slice. In addition the processing module may generate a write response message that includes an operation succeeded status code. Next the processing module sends the write response message to the DS processing module. The method continues at step where the processing module stores the new slice revision as the DS unit most recent slice revision when the transaction identifier is null. The processing module stores the new slice revision as the DS unit most recent slice revision when the transaction identifier is not null and a commit transaction message is subsequently received as discussed below.

Alternatively or in addition to the processing module receives the write request message wherein the write request message further includes a DS processing module transaction identifier. Next the processing module determines whether the slice name has a locked state based on a local state indicator. The processing module generates a write response message that includes a transaction conflict status code and sends the write response message to the DS processing module when the slice name has the locked state and a DS unit transaction indicator associated with the encoded directory slice compares unfavorably to the DS processing module transaction identifier. The processing module updates the local state indicator to indicate that the slice name has the locked state and stores the DS processing module transaction identifier as the DS unit transaction identifier when the slice name does not have a locked state.

In addition the processing module may receive a commit transaction request message regarding storage of at least one of an encoded data slice and an encoded directory slice wherein the commit transaction request message includes at least one transaction identifier. Next the processing module identifies one or more slice names based on the at least one transaction identifier and for each of the one or more slices names updates a slice status indicator to indicate the at least one of the encoded data slice and the encoded directory slice is visible. In addition the processing module may update a current revision indicator associated with the slice name and transaction identifier to indicate a revision associated with the slice name. In addition the processing module may update the slice status indicator to indicate that the slice name has an unlocked state subsequent to indicating that the at least one of the encoded data slice and the encoded directory slice is visible.

Alternatively the processing module receives a commit transaction request message regarding storage of at least one of an encoded data slice and an encoded directory slice wherein the commit transaction request message includes first and second transaction identifiers of the at least one transaction identifier wherein the first transaction identifier is associated with the encoded data slice and the second transaction identifier is associated with the encoded directory slice. Next the processing module updates a first slice status indicator to indicate that the encoded data slice is visible and re updates the first slice status indicator to indicate that the encoded data slice is not visible when a DS unit memory error exists. The processing module updates a second slice status indicator to indicate that the encoded directory slice is visible and re updates the second slice status indicator to indicate that the encoded directory slice is not visible when the DS unit memory error exists.

As may be used herein the terms substantially and approximately provides an industry accepted tolerance for its corresponding term and or relativity between items. Such an industry accepted tolerance ranges from less than one percent to fifty percent and corresponds to but is not limited to component values integrated circuit process variations temperature variations rise and fall times and or thermal noise. Such relativity between items ranges from a difference of a few percent to magnitude differences. As may also be used herein the term s operably coupled to coupled to and or coupling includes direct coupling between items and or indirect coupling between items via an intervening item e.g. an item includes but is not limited to a component an element a circuit and or a module where for indirect coupling the intervening item does not modify the information of a signal but may adjust its current level voltage level and or power level. As may further be used herein inferred coupling i.e. where one element is coupled to another element by inference includes direct and indirect coupling between two items in the same manner as coupled to . As may even further be used herein the term operable to or operably coupled to indicates that an item includes one or more of power connections input s output s etc. to perform when activated one or more its corresponding functions and may further include inferred coupling to one or more other items. As may still further be used herein the term associated with includes direct and or indirect coupling of separate items and or one item being embedded within another item. As may be used herein the term compares favorably indicates that a comparison between two or more items signals etc. provides a desired relationship. For example when the desired relationship is that signal has a greater magnitude than signal a favorable comparison may be achieved when the magnitude of signal is greater than that of signal or when the magnitude of signal is less than that of signal .

While the transistors in the above described figure s is are shown as field effect transistors FETs as one of ordinary skill in the art will appreciate the transistors may be implemented using any type of transistor structure including but not limited to bipolar metal oxide semiconductor field effect transistors MOSFET N well transistors P well transistors enhancement mode depletion mode and zero voltage threshold VT transistors.

The present invention has also been described above with the aid of method steps illustrating the performance of specified functions and relationships thereof. The boundaries and sequence of these functional building blocks and method steps have been arbitrarily defined herein for convenience of description. Alternate boundaries and sequences can be defined so long as the specified functions and relationships are appropriately performed. Any such alternate boundaries or sequences are thus within the scope and spirit of the claimed invention.

The present invention has been described at least in part in terms of one or more embodiments. An embodiment of the present invention is used herein to illustrate the present invention an aspect thereof a feature thereof a concept thereof and or an example thereof. A physical embodiment of an apparatus an article of manufacture a machine and or of a process that embodies the present invention may include one or more of the aspects features concepts examples etc. described with reference to one or more of the embodiments discussed herein.

The present invention has been described above with the aid of functional building blocks illustrating the performance of certain significant functions. The boundaries of these functional building blocks have been arbitrarily defined for convenience of description. Alternate boundaries could be defined as long as the certain significant functions are appropriately performed. Similarly flow diagram blocks may also have been arbitrarily defined herein to illustrate certain significant functionality. To the extent used the flow diagram block boundaries and sequence could have been defined otherwise and still perform the certain significant functionality. Such alternate definitions of both functional building blocks and flow diagram blocks and sequences are thus within the scope and spirit of the claimed invention. One of average skill in the art will also recognize that the functional building blocks and other illustrative blocks modules and components herein can be implemented as illustrated or by discrete components application specific integrated circuits processors executing appropriate software and the like or any combination thereof.

