---

title: Generation of simulated errors for high-level system validation
abstract: A device, integrated circuit and method for generating simulated errors are disclosed. In the disclosed device, integrated circuit and method, an original data value is read from a memory. The original data value is intercepted by the integrated circuit. The integrated circuit is operable to virtualize an error in the original data value to generate a modified data value. The integrated circuit is also operable to generate an interrupt according to the virtualization. This disclosure may be particularly useful for high-level memory validation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09110879&OS=09110879&RS=09110879
owner: EMULEX CORPORATION
number: 09110879
owner_city: Costa Mesa
owner_country: US
publication_date: 20140324
---
This is a continuation of U.S. patent application Ser. No. 14 010 468 filed Aug. 26 2013 which is a continuation of U.S. patent application Ser. No. 12 054 323 filed Mar. 24 2008 now U.S. Pat. No. 8 522 080. The above referenced United States patent applications are all hereby incorporated by reference in their entirety.

This invention relates to high level system validation and more particularly to generating simulated errors for system validation to verify system behavior.

After building a computer system a system designer or software programmer will usually test the system to determine whether it responds appropriately. Generally a designer may generate errors within the system to test the software and verify that all of the fault cases are covered and that the system handles exceptions correctly. As software and electronic systems continue to become more complex however it becomes more difficult to test the system and software for errors and the system s responses to those errors.

As an example illustrates a representative system of a conventional enclosure . A host bus adapter HBA or IOC may be connected to a disk enclosure by Fibre Channel FC link or SAS or other communication protocol. A series of drives may be attached to the enclosure . Within the enclosure a microprocessor generally controls a switch to connect the various attached devices other HBAs and drives . The microprocessor may include flash memory and RAM and a management interface . The management interface may be for example Ethernet RS 232 SCSI Enclosure Services SES over FC or SAS or a virtual port.

In operation the microprocessor controls the switch to make the correct connections. When an error occurs at the lowest level a message may be sent up the chain of command from the switch to the microprocessor to the management interface and to the controlling device. That controlling device then determines the next action and sends the appropriate signals back down the chain of command. For example the microprocessor may report to a redundant array of independent disks RAID controller that a disk has failed. The RAID controller then sends the appropriate controls to rebuild the RAID set to recover from the failed disk. The higher controlling device may be an end user such as the programmer a RAID head or a mainframe computer. A system designer attempts to simulate all possible errors the system may encounter during actual run time in order to verify that the system responds correctly.

A large system may include dozens of enclosures multiple RAID heads and different computers all interacting together. These systems can become very complex. To validate the system a system designer should ideally attempt to simulate any error that could possibly happen. If an error is not simulated then that error may cause unanticipated or unexpected results when it occurs in actual performance.

Generally a software programmer or system designer may wish to test the responses of the upper management system or the entire system to determine how the system responds to various errors. To physically cause the errors within a system would be costly and therefore a programmer may wish to simulate the errors to determine if the system responds appropriately. There are currently two major mechanisms implemented to simulate errors in systems 1 insertion of test circuitry into the hardware such as an application specific integrated circuit ASIC and 2 firmware interception and modification of hardware or ASIC responses.

One option available to a system designer is to connect test devices to the drive ports of the system enclosure. These test devices simulate typical traffic across the system and can also introduce certain errors into the traffic. However this requires additional hardware. The test equipment would have to be able to trigger the desired errors and be fast enough to simulate the actual run time errors encountered during the actual performance of the system. The test equipment is generally expensive and bulky and may not be available to some companies. The time to test each possible error for each possible device drive by physically attaching test equipment can be time and cost prohibitive. Therefore this option is generally not available to most designers.

The system designer may alternatively design the ASIC to generate faults and corrupt data under test. The ASIC can be designed with additional hardware and software to generate test errors. However given the constantly increasing complexity of ASICs insertion of test circuitry to force a significant amount of error cases to be covered can become a major design effort rivaling the complexity of the original design. Since the design is within the ASIC the errors that can be generated are limited to those that were designed into the chip. Therefore the test designer must be extremely knowledgeable about the details of the design and the impact that any low level error has on the larger system to foresee and incorporate any desired test errors into the ASIC design. Using this methodology a significant portion of the design implementation may be fault insertion circuitry. Not only does the additional circuitry increase die size and associated cost but the additional logic increases the probability of soft errors and increase power consumption required of the device.

The final alternative is to provide software within the upper management system such as the microprocessor to simulate error reads. Software is used to modify the data read from the chip and the microprocessor sends the modified data to the upper levels of management. The system is run in a test mode alerting the microprocessor that the modified data should be used instead of the actual data read from the ASIC. However the additional software requires processing time which slows the performance of the entire system even when it is not being tested. Modifying the status information read from the ASIC in firmware modifies the behavior of the code being tested and or introduces overhead into all operations performed by the firmware. The firmware must read the status from the ASIC determine if it is in test mode and then branch either fetching data to modify the original status or performing the normal operation on the data. In real time systems the overhead servicing test modes could result in significant differences from normal run time operations possibly causing abnormal behavior that does not exist in the real code or masking issues that do exist. Additionally it is difficult to isolate the effects of the function initiating the test and the run time firmware s response.

Embodiments of the present invention are directed to enabling error simulation for system validation. Embodiments of the invention provides a flexible mechanism to aid in validating software responses from the application programming interface level enclosure management level to the system level. It may allow any response or sequence of responses from an ASIC to be easily generated supporting the test and debug of system firmware and software. By modifying readback statuses and interrupt behavior at the processor interface the test circuit may be easy to implement with low risk of adversely impacting the ASIC design.

Errors can be simulated by modifying data presented to the processor as well as generating interrupts consistent with the modified data in the ASIC hardware. According to embodiments of the present invention the ASIC includes logic and hardware to simulate errors to test the software responses of the higher management system above the ASIC. Modify logic may be added to the ASIC so when the microprocessor attempts to read a specific address the modify logic may modify the data depending on the test configuration and the requested address. In a test mode the original read values may be intercepted and modified by the modify logic before it is sent to the microprocessor based on the configuration of registers. The modify logic may force values to be set or cleared depending on the address accessed by the microprocessor matching a value programmed into a register set. The ASIC may also include selection logic to determine whether data from the modify logic or the unmodified value from a device should be sent to the ASIC interface and on to the microprocessor. The ASIC then sends the information up to the microprocessor and up to the management interface where software can determine the appropriate course of action.

The ASIC logic may also include interrupt logic and a timer. The interrupt logic can send an appropriate interrupt signal to the microprocessor to alert the system of an event occurrence. The interrupt logic may be connected to a timer and the timer may be configured to activate the interrupt logic after a delay so that the system may return to a steady state before an error signal is generated. Therefore the programming of the desired modifications within the modify logic may be separated in time from the occurrence of the error event so as to not interfere with the actual error detection and error handling code paths of the system. Embodiments of the present invention therefore allow an extensive range of firmware software system code paths to be exercised.

Embodiments of the invention may allow simulated errors to be generated to validate the firmware s handling as well as system level software handling of errors that may not easily be recreated by manipulation of the system under test. Virtualizing the errors at the processor interface may provide a non intrusive methodology that may give a significant amount of flexibility in testing without burdening the ASIC with large amounts of test circuitry.

In the following description of preferred embodiments reference is made to the accompanying drawings which form a part hereof and in which it is shown by way of illustration specific embodiments in which the invention may be practiced. It is to be understood that other embodiments may be utilized and structural changes may be made without departing from the scope of the preferred embodiments of the present invention.

Embodiments of the present invention are directed to enabling error simulation for system validation. Embodiments of the invention provides a flexible mechanism to aid in validating software responses from the application programming interface level enclosure management level redundant arrays of independent disks RAID controller to the system level. It can allow any response or sequence of responses from an ASIC to be easily generated supporting the test and debug of system firmware and software. By modifying only the readback statuses and interrupt behavior at the processor interface the test circuit can be easy to implement with low risk of adversely impacting the ASIC design.

Errors can be simulated by modifying data presented to the processor as well as generating interrupts consistent with the modified data in the ASIC hardware. The normal traffic flow of the system may not be interrupted. Also timers may be used to delay error activation permitting the test injection calls to be completed and permitting the system to return to steady state operation before generating the test error. The system s behavior response may not be modified due to the test code injecting the error the system software implementation and run time operation is only affected by the simulated error. A detailed evaluation of the ASIC before construction is not required. The only consideration that may need to be taken into account is the number of register reads that need to be modified for a single error to support the maximum decision tree depth the processor would need to access. Embodiments of the present invention therefore allow an extensive range of firmware software system code paths to be exercised.

Although embodiments of the invention may be described herein primarily in terms of ASIC designs within a switch of an enclosure it should be understood that embodiments of the invention are not so limited but extend to other compatible devices and can be implemented with any system using a microprocessor interface. Embodiments of this invention may be used with any closed system including any device not easily changed after it is incorporated into a product such as for example a FPGA a circuit board an ASIC a switch enclosure or a computer within an enclosure. Embodiments of the invention may be used with any system utilizing a microprocessor interface including for example a storage area network.

The selection logic configured from gates or a state machine determines whether data from the modify logic or the unmodified value on datapath should be sent to the ASIC interface and on to the microprocessor. If the information associated with the requested address should be modified the selection logic may send the modified error information to the ASIC interface . However if the selection logic determines that the address is not to be modified the actual information from the switch logic available on datapath may be sent to the ASIC interface . The ASIC then sends the information up to the microprocessor and potentially up to the HBA and or up to the management interface where software can determine the appropriate course of action.

The ASIC logic may also include interrupt logic and a timer . The interrupt logic can send an appropriate interrupt signal to the microprocessor to alert the system of an event occurrence. The interrupt logic may be a state machine to generate a signal to the processor to alert the processor that an event has occurred. The interrupt logic may be connected to a timer and the timer may be configured to activate the interrupt logic after a delay so that the system may return to a steady state before an error signal is generated. Therefore the programming of the desired modifications within the modify logic may be separated in time from the occurrence of the error event so as to not interfere with the actual error detection and error handling code paths of the system. The modify logic may alternatively be programmed through an alternate path such as an RS 232.

As an example of one embodiment of the invention a user may program a test configuration which includes providing the addresses of the registers to be modified along with the modifications to simulate the desired error. The interrupt logic then waits a specified amount of time using the timer before an interrupt signal is sent alerting the microprocessor of an error. When the microprocessor reads the status of the ASIC to determine the reason for the interrupt if a requested address matches that of the user input then the modify logic sends the data from the device modified by the user s test configuration. The modified data is then sent to the microprocessor from the ASIC the system may detect and process the simulated error and the user may then determine if the system reacted appropriately. If the requested address from the microprocessor does not match the test device address inputted by the user then the unmodified data retrieved from the switch logic may be sent to the microprocessor . Therefore a user can simulate any error reportable through the ASIC s processor interface such as a bad clock a detached device etc. after the ASIC has been designed and implemented.

The registers are externally programmable. Therefore a system or user outside the ASIC may program the entries of the registers with a desired address location to simulate a desired error and the bit mask and forced value to simulate the desired error. These registers may be programmed at any time after the design of the ASIC. Therefore the initial design of the ASIC does not have to be altered depending on the desired error to be generated the error data and desired address need only be externally programmed into the registers. The registers configured for storing address data and error data including the bit mask and force values are devices externally programmable to store the desired information to be retrieved at a later time by the system.

Once these values are stored in the appropriate registers the microprocessor according to its decision tree logic checks for the event by sending address requests and receiving information concerning the location and nature of the event.

Comparison logic then may compare the values contained in the match address register set against the address of any read request from the microprocessor . The comparison logic such as gates or a state machine may be configured to compare the entries of the address register set with the read request address from the microprocessor and may determine whether there is a match or not and if necessary the entry location of the register of the matching address.

In the case of an address match the output multiplexer feeding the processor s bus may output the modified data instead of passing through the original read values . The bit mask register allows bit level control of the values of the bits to be modified. This fine level of control permits the test to run in a background mode reacting to normal status bits or to arbitrarily modify any or all bits ignoring real time behavior. Only unmasked bits may be modified by the test circuit. The data value register contains the forced value to apply to the original data. Bits allowed by the mask register may be forced onto the original status read. The remaining bits may be unchanged.

The ASIC includes logic and hardware to compare the read address by the microprocessor with the inputted addresses in the match address register . This comparison controls the multiplexer selection to return an original value read or a modified value altered by the modify logic . Therefore if the address requested by the microprocessor is not in the match address register then the microprocessor may receive the unmodified data from the ASIC register set . Since the address does not match an address in the register set the multiplexer may send data to the microprocessor from the original read datapath from the register set module . If however the microprocessor is requesting information from an address in the match address register then the modify logic may use the modify bit mask register and the forced value register to modify the received data from the register set module . The multiplexer may then select the modified data and send it to the microprocessor simulating an error.

For example in if a user wants to test the system s response to a failure at port 0 resulting from a non responsive disk three sets of modification registers can be configured 1 a port level error detect register can be configured with the low level error status 2 a port level interrupt status register can be configured with the second level decision on error type and 3 the router level interrupt status register can be configured with the first level decision on the module causing the interrupt. These may be stored as three separate entries in the register sets for the address bit mask and force value. Therefore if a user inputs addresses 4000 18 and 32 for example those values would be entered into the match address register at entry 0 1 and 2 to represent the router level interrupt status located at address 4000 the associated port level interrupt status register located at address 18 and the cause of the interrupt located at address 32 . The user may then choose to modify bit of address 4000 bit of address 18 and bit of address 32 so the values 01 10 and 80 would be entered into entries 0 1 and 2 of the modify bit mask registry . These values represent the bit location to be masked by the modification logic. Finally the user can input the values the masked bits are to be changed to corresponding to the desired error. So for example if a user wants to modify bit of address 4000 to a 1 indicating an event occurrence at port 0 bit of address 18 to 10 indicating an error address and bit of address 32 to 80 indicating that the error is a non responsive disk these values would be entered into the forced value registry in the 0 1 and 2 entries.

Therefore if the microprocessor requests information from address 4000 the modify logic would mask bit with the force value 1 as read from entry 0 of the register . This modification may indicate to the microprocessor that the error occurred at port 0. The microprocessor then requests information from port 0 which in this example would be address 18. The test address match logic would recognize the address in the match address register and the modify logic would mask bit with force value 1 which for this example may indicate the error registry as 32. Finally the microprocessor would send a read request to address 32 and again the test address match logic and the modify logic would mask bit to the value of 80 non responsive disk . The microprocessor would then determine that port 0 had an error of a non responsive disk. The microprocessor would then respond and the rest of the system software up the control chain would react to that error. The user could then determine whether the system responded appropriately for the given error. The entire software of the system may be verified from the ASIC interface all the way to the highest control a command head or mainframe computer.

Enable and mode registers may also be used to enable the data modification and to control the test or system behavior. The ASIC may include various functions to permit a subset of possible behavior modes. A Global Test Enable function may be included as a master enable for the test circuit to ensure that non atomic setup of the test registers does not occur unintentionally. Therefore regardless of the address or information in the registers the test mode could be turned off and original read datapath values would be sent to the microprocessor . An Address Set Enable function may be included as an enable for each set of address mask and data registers controlling how many different address match registers are actively used at a given time. The function keeps track of all the valid entries in the register so that if data had not been cleared in a register it does not generate an unwanted error. For example this function would enable entries 0 1 and 2 in the above example associated with and the other register entries would be deselected so retained data in register N would not generate an unwanted error. A One shot or Continuous function may be used as a register modification to apply the test mode only once per test or apply the test mode persistently lasting until an explicit disable is given or the error is determined. A Generate Interrupt function may be included as an enable for the generation of an interrupt to initiate a sequence of processing. A Clear Interrupt Control function may control which address read clears the interrupt. Therefore the interrupt signal may be cleared after the first address is read if there is a transient problem being simulated or it may be cleared after multiple address reads and the problem is fixed as if there is a more persistent error being simulated. This allows actual ASIC behavior to be closely modeled. Also a Delay Timer function may delay activation of the test to allow test setup to be decoupled from the actual test this delay controls a timer to determine when the interrupt may be sent to the microprocessor. Any of these functions may be used singularly or in combination.

Using the Clear Interrupt Control function if the error is just a notification the test circuitry may be configured to clear the interupt on the read of the router level interrupt status register. If an action needs to be taken to resolve the error the interrupt could be configured to be cleared on the read of the port s low level status register.

After the modification registers have been configured and the interrupt strategy set using the Generate Interrupt function the enables for the required register groups may be set using the Address Set Enable function. Additionally the delay timer may be set indicating the time delay before readback modification logic is activated and the interrupt is generated using the Delay Timer function.

After the delay expires determined by a timer the interrupt may be generated at causing the firmware s normal interrupt processing routines to execute. The firmware and software will then react as if the actual error occurred. After each modified register is read the modification circuit for that register may be disabled automatically by hardware assuming one shot configuration eliminating the need to disable the test modifications after the simulated error injection has occurred. A user may utilize either the One shot or Continuous function to disable a register after it is read or may use the Clear Interrupt Control function after the simulated error injection has finished.

The invention adds hardware to modify the status information received from the switch logic in order to simulate a desired error. When a user wants to simulate an error a command can be sent from the upper management interface such as for example a laptop. The user can send four types of commands 1 the address port or device where the error is simulated stored in register 2 the bit within the data stored at the address to modify to indicate an error stored in register 3 the desired data for that bit location the error status stored in register and 4 a time lapse before the error simulation is executed. The information may be sent over a write bus and stored in registers within the ASIC . The timer then waits the appropriate time determined by the fourth input command utilizing the Delay Timer function. A test interrupt signal may then be sent to the microprocessor . The microprocessor or the higher management system then runs its system response the item under test . The system then uses varying logic to determine the nature and location of the error.

The microprocessor may read various register addresses to determine what the simulated error may be sending requests to addresses to retrieve information in a systematic fashion. The request may be compared to the changed addresses previously written by the user . If the address is not one to be tested by the user and is not in the register the test address match selection line to the multiplexer may be set to retrieve information directly from the switch logic and physical connections . However if one of the registers does contain the address then the selection changes so the multiplexer retrieves the modified status information from the modify logic and register information instead of directly from the switch logic . The modify logic may modify only the bits per the mask in register passing the non masked bits from the switch logic .

This permits any chip to be tested for any error as it may be determined after the chip has been created. Design time may be utilized at the time of testing to determine the desired address bit location and mask value to use to simulate various errors. However that can be determined at any time after creating the chip and little need be known about the chip ahead of time.

Also by using the timer before the test interrupt is sent the system may be permitted to re enter a steady state. Therefore the request and programming to initiate the error does not interfere with the response to the error. The system simulates a real life occurrence of an error that can occur at any time. The program requests to simulate the error may not mask or create actual problems.

Although the present invention has been fully described in connection with embodiments thereof with reference to the accompanying drawings it is to be noted that various changes and modifications will become apparent to those skilled in the art. Such changes and modifications are to be understood as being included within the scope of the present invention as defined by the appended claims.

