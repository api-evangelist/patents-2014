---

title: Enabling IP execution on a simulation execution platform
abstract: In a system and method that simulates a design including a third party IP component, a driver for the IP component is compiled and executed in a workstation implementing the simulation platform for the design. The source code for the driver is modified to allow the simulation to reroute certain functions that would cause the simulator to hang until an event occurs that would unlock the simulation. The rerouting includes storing instruction location, state information, and any other context information needed to restore a paused function. The saved information is stored in a stack that is traversed upon detection of the event.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09208282&OS=09208282&RS=09208282
owner: Cadence Design Systems, Inc.
number: 09208282
owner_city: San Jose
owner_country: US
publication_date: 20140730
---
Aspects of the present invention relate generally to integrated circuit designs and in particular to techniques for simulation and test of such designs.

Hardware designers for example integrated circuit IC designers do not always design every component of a new hardware device. While designers may design one or more components of a particular device they often employ component designs also known as intellectual property or IP from one or more third party IP providers. Using components from third party IP providers can facilitate the design by avoiding the need for the designer to design every aspect of the device s functionality.

Hardware designers may employ a hardware based verification platform to perform certain operations on a design. Hardware verification platforms can enable testing of the various components of the design which facilitates design analysis and debugging. Multiple aspects of the hardware design typically may be tested. For example a hardware design may undergo architectural simulation and analysis and debugging where the functionality of each of the components being implemented in the design is tested for example with transaction level modeling TLM or bus functional modeling. The hardware design may additionally undergo circuit simulation and analysis where the signals between components are tested for example using register transition level RTL analysis. Other steps may include system simulation for example to model the components of a system together and system and software emulation for example to model execution of software elements executing on a modeled system. Once a design is completed one or more components of the device may be tested and verified. Such testing may require a device specific driver to verify that the inputs and outputs over a communication medium conform to a standard or predefined protocol.

A simulation platform conventionally models the hardware components at various levels of abstraction. Processor models implementing Instruction Set Simulators ISS in combination with hardware simulators can be used to simulate cross compiled embedded software for example an operating system OS . A collection of hardware models running such embedded software is known as a Virtual Platform VP . When simulating a driver for design IP with a conventional VP due to timing programming language and interface limitations of the driver the modeled processors and operating systems are not practical for simulating execution of the driver. However if the driver is executed in the workstation or other execution platform hardware components modeled on the VP will be cut off from communication with the workstation processor and consequently with the driver. Timing differences may also exist between the driver running on the workstation processor or other execution platform with reference to a standard clock wall time and the design IP objects running on the simulator with reference to the executed simulation simulator or design time . Due to such different and independent time domains and execution processors cross domain communications can cause dead loop or hanging during the simulation either in the driver code execution on the workstation or in the design IP component execution on the simulator . Additionally the simulation of some design IP components in this configuration may cause the simulation to hang where the simulated objects encounter a loop in the simulation. Thus additional modules and interfaces as well as entirely new drivers are often developed to simulate a driver and interface associated with the design IP of a device under test. However driver development is error prone and time consuming.

Therefore there is a need in the art for more efficient systems and methods to simulate design IP interface drivers.

A system and method that simulates a design including a third party IP component is provided. In order to avoid the necessity of building additional interfaces that allow for the interaction of a driver with the associated IP component interface the driver for the IP component is compiled and executed in a workstation implementing the simulation platform for the design. Additionally for a driver compiled at the workstation the driver will have access to the kernel OS services at the workstation. The source code for the driver may be modified to allow the simulation to reroute certain functions that would cause the simulator to hang until an event occurs that would unlock the simulation. The modification may be signaled by the driver designer to indicate the existence of a potential hang point. A search through the source code will recognize the identified points and the appropriate modifications will be inserted to handle the rerouting of the functions. The rerouting includes storing instruction location state information and any other context information needed to restore a paused function. The saved information is stored in a context stack or link list that is strictly arranged in the order of detection of the event. Upon completion of the event the stack is accessed and the paused function s restored in strict reverse order of detection of the event. Then execution of the simulation can continue as if the function was never paused.

The driver that is successfully tested with the simulation can be used by the IP developer to start firmware development software verification SOC firmware development and firmware driver debugging using the tested driver even if the associated design and IP hardware is not yet available.

While some of the IP components mentioned above may be proprietary a number of them may be developed according to a standard be it wired or wireless communications audio video memory or others. Different IP providers can and will have different ways of implementing a particular standard. It should be noted that there may be portions of a standard for which compliance is mandatory and other portions for which compliance is optional. The hardware designer may have a particular feature set in mind in which compliance either with only mandatory portions of the standard or with mandatory and certain optional portions of the standard would be necessary.

Where a standard such as Bluetooth Wi Fi other communications memory management display or other functionality in a device is implicated verification of the design may include showing compliance with the standard. Where the functionality in question is the result of proprietary third party IP which does not necessarily follow a particular standard the IP provider may disclose an interface definition or custom protocol without the IP provider revealing its proprietary information. The standards or provided definitions may then be utilized by a simulation platform to show that the components of the design execute properly or to otherwise identify errors.

In the case of IP that is designed to provide particular functionality but in accordance with a proprietary design or feature set rather than a standard outputs of the design will be a proprietary function of the inputs. An IP provider may be able to provide a custom protocol consisting of design based sets of inputs and corresponding outputs making it possible to exercise the design through a selection of various combinations of inputs without revealing proprietary aspects of the IP design component. An object oriented definition of the IP component may then be created based on the custom protocol.

Returning to according to an exemplary embodiment an IP model . .may be provided that uses the verification and protocol knowledge developed and utilized during earlier design and verification phases of the system and device IP to execute an IP model that simulates an abstract version of the hardware IP.

The verification and protocol knowledge may include an object oriented definition of one or more standards or other protocols implemented by the design. Objects for a protocol standard may be defined and utilized during any stage of the design verification process. For example the object oriented definition of the standard may be used during architectural development to confirm the component interconnections represented by associations between objects conform to the standard. Similarly the object oriented definition of the standard may be used during component simulation system emulation debugging or post silicon analysis to confirm that the components of the design conform to the standard during execution. Additionally the object oriented definition of the standard may be used to develop the driver and abstract IP model of the design IP to test the design before the design IP is itself ready to undergo testing. Then the driver and interface may be used to facilitate simulation of the design IP.

In a simulator interface may be implemented to provide control and observability for the components of the platform . The simulator interface may be executed on a control thread within an execution platform such as a computer processor or workstation on which the simulator is executed. The simulator interface runs in a control thread separate from the modeled components of the virtual platform. State information and other simulation related information for the modeled components including verification IP and design IP objects may then be made available via simulation commands executed by the control thread when control of the simulation returns to the control thread .

In modeled components are executed on individual simulator threads but the simulation and modeling information is all stored in a memory storage device of the workstation .

A modeled component as described herein may refer to either a hardware component a bare metal software program or OS running within the context of a processor hardware component or a process running on an OS running within the context of a processor hardware component. According to an embodiment of the present invention the simulation platform may run multiple hardware component models in sequence with each modeled hardware component using separate host platform resources.

The simulation platform may use a processor model ISS to access state information for the modeled components via an application programming interface API . For example function calls to the API allow the system to display the embedded software view of the memory and the registers of the modeled system. An OS may be simulated with reference to an ISS modeling a processor instruction set running on a modeled hardware component. Then each software application or application process running on the OS will be executed as an OS process as necessary.

The design IP may also be modeled as a hardware model and during simulation interface with the provided driver. As previously noted testing an IP driver for the design IP objects modeled with the platform illustrated in is not desirable. Therefore the driver will be executed at the workstation . However when simulating a component that interfaces with a driver implemented on the workstation certain functions may hang the simulator while waiting for some event to occur. To avoid the described hang up the source code for the driver will be modified to create a stack of context information that is saved when a potential waiting loop is encountered in the driver source code. Device and or driver designers may insert keywords into the code to signal the beginning of a potential waiting loop. Then at each such identified point the source code will be modified to perform additional routing as described further herein.

According to an embodiment the waiting loop may be implemented in a function or sub function of the driver source code. When the driver reaches source code during the execution of the function that causes the driver to wait for example when the source code initiates a loop until a variable written to a register equals a specific value additional code may be added directing the driver to save the context for the current function and return. The saved context information may include at least the location of the next instruction in the function and the state information required to return the function to the same state as when the information was stored.

An exemplary illustration of the routing process is described with reference to . As shown in multiple functions may be nested in the driver source code. Preliminarily function f calls function f which calls function f . Then if function has a source code block that causes the driver to wait for an event rather than waiting on the event the context for function will be saved in a stack as context L including a pointer to the known return point for function. Function will then return to function and if at function it is known that function was unable to complete for example because a context was saved for function then a context will also be saved for function as context L in the stack. Similarly when function returns to function incomplete context L will be saved in stack.

When an event occurs that potentially closes the waiting loop for example a specific value is written to a register the stack for the driver may be traversed to find the appropriate saved context and continue execution of that function. The testbench or workstation will maintain a list of the events that would close a waiting loop and will access the appropriate stack when such an event occurs in the order that such events are detected.

When a stack is accessed each accessed link will restore the saved context remove the associated link from the list and call the next link in the reverse order that the contexts were detected and saved. For example when the stack illustrated in is accessed the saved context L will be restored for function and the context L link will be removed from the list. Then function will call link L which will restore the saved context in function and remove the link L from the list. Then the context saved in L will be restored and the stack deleted. The functionality to execute this restoring and routing is inserted into the source code as part of the previously described modification. When the context in L is restored function will continue as if it were never stopped. At this point because the event that triggered the stack was the event that will close the waiting loop in function function will execute to completion and return to function as normal.

An exemplary process to complete the verification of the design and associated driver is shown in . During execution of a simulation for a hardware design containing design IP block the process may encounter either a hanging loop as in block or an awaited event that would close a hanging loop as in block . If an awaited event is detected block the workstation executing the simulation will access a stored stack associated with the event block . Then the stored contexts in the stack will be restored block until a hanging loop that is closed by the detected event is restored. Then the simulation will continue executing as if it was never paused block .

A user may access a simulation or emulation platform in a standalone client system client server environment or a networked environment. is a simple block diagram illustrating components of an exemplary system according to an embodiment of the present invention. As shown in a system may comprise a workstation or client executing a simulation platform and having a memory storage . The client may be any computing system that executes a simulation platform or otherwise facilitates access to memory storage for example a personal computer. The client may include a processor that performs a method in accordance with the disclosed embodiments. Such a client would be part of an overall simulation system in accordance with the disclosed embodiments.

Hardware designs instruction sets software packages instances of modeled components interface definitions and other objects used by the simulation platform may be stored in memory storage . A user may access the objects stored in memory storage with the client via the simulation platform where the simulation platform is capable of accessing memory storage and displaying the objects and the data associated with the simulation. The simulation platform may include a user interface for example a program application or middleware that acts as a frontend to and facilitates access to objects in memory storage . The simulation platform may facilitate verification of the components in a hardware design using the display and edit tools and procedures described herein. The user may interact with the simulation platform through a number of input devices such as by inputting a selection as with a mouse or inputting a request as with a keyboard. The user may observe the simulation results on an output device or display. The simulation platform may run in an application window controlled by the user.

Memory storage may include a file system hard drive database or any other method of storing data. According to an embodiment multiple memory storage devices may be implemented not shown . For example design storage may contain the hardware design and related information and a separate simulation database may contain interface definitions and other objects used to run simulation tests on a hardware design.

As shown in a client may be a stand alone system as may be of particular interest where the design being simulated is confidential. Additionally according to an aspect of an embodiment as shown in a client may be part of a networked environment.

A user may access a simulation platform at the server via the client having a user interface capable of accessing and displaying the components implemented as part of a hardware design and the results of the simulation of those components. The client may be any computing system that facilitates the user accessing storage device for example a personal computer. The network may be a wired or wireless network that may include a local area network LAN a wireless area network WAN the Internet or any other network available for accessing storage device from the client .

The server may be a network server accessible to the client via the network that may manage access to storage device . The user interface may receive instructions regarding simulation of a design from the user and utilizing the objects stored in memory storage facilitate a display of the simulation or the information gathered during the simulation. Multiple different clients not shown may access storage device via the network and request access to the objects stored therein.

In another networked environment the simulation platform may be executed on a network capable client and access the designs packages and other objects stored in one or more storage devices via a network and communications server.

As shown in a client may be a stand alone system as may be of particular interest where the components being simulated are confidential. Additionally according to an aspect of an embodiment as shown in a client may be part of a networked environment.

Although primarily described with reference to a driver the described embodiments may be utilized with any software stack including firmware developed to operate with an IP component. Any driver or software stack used during the simulation of a hardware design containing design IP may be used in the verification and simulation procedures described herein.

In some applications the modules described hereinabove may be provided as elements of an integrated software system in which the blocks may be provided as separate elements of a computer program. Some embodiments may be implemented for example using a non transitory computer readable storage medium or article which may store an instruction or a set of instructions that if executed by a processor may cause the processor to perform a method in accordance with the embodiments. Other applications of the present invention may be embodied as a hybrid system of dedicated hardware and software components. Moreover not all of the modules described herein need be provided as separate units. Additionally it is noted that the arrangement of the blocks in does not necessarily imply a particular order or sequence of events nor are they intended to exclude other possibilities. Such implementation details are immaterial to the operation of the present invention unless otherwise noted above.

The exemplary methods and computer program instructions may be embodied on a non transitory computer readable storage medium that may include any medium that can store information. Examples of a computer readable storage medium include electronic circuits semiconductor memory devices ROM flash memory erasable ROM EROM floppy diskette CD ROM optical disk hard disk fiber optic medium or any electromagnetic or optical storage device. In addition a server or database server may include computer readable media configured to store executable program instructions. The features of the embodiments of the present invention may be implemented in hardware software firmware or a combination thereof and utilized in systems subsystems components or subcomponents thereof.

While the invention has been described in detail above with reference to some embodiments variations within the scope and spirit of the invention will be apparent to those of ordinary skill in the art. Thus the invention should be considered as limited only by the scope of the appended claims.

