---

title: Native code module security for arm instruction set architectures
abstract: Some embodiments provide a system that executes a native code module. During operation, the system obtains the native code module. Next, the system loads the native code module into a secure runtime environment. Finally, the system safely executes the native code module in the secure runtime environment by using a set of software fault isolation (SFI) mechanisms that constrain store instructions in the native code module. The SFI mechanisms also maintain control flow integrity for the native code module by dividing a code region associated with the native code module into equally sized code blocks and data blocks and starting each of the data blocks with an illegal instruction.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08966628&OS=08966628&RS=08966628
owner: Google Inc.
number: 08966628
owner_city: Mountain View
owner_country: US
publication_date: 20140821
---
This application is a continuation of U.S. application Ser. No. 14 022 882 filed Sep. 10 2013 which is a continuation of U.S. application Ser. No. 12 621 286 filed Nov. 18 2009 which claims the benefit of U.S. Provisional Application No. 61 230 530 filed Jul. 31 2009 the contents of which are incorporated by references. This application is also related to U.S. application Ser. No. 12 117 634 filed May 8 2008 U.S. application Ser. No. 12 117 650 filed May 8 2008 and U.S. application Ser. No. 12 621 266 filed Nov. 18 2009.

The present embodiments relate to techniques for safely executing native code modules. More specifically the present embodiments relate to a method and system for safely executing native code modules within ARM instruction set architectures.

Easy access to computers and plentiful network bandwidth have facilitated sharing of information and applications. For instance a user of a computing device e.g. personal computer mobile phone personal digital assistant etc. may easily install and execute an application downloaded from a web site or received from a friend as an email attachment. However installing and executing such applications on a given computing device typically involves a level of trust that is granted on an all or nothing basis by the operating system of the computing device. Furthermore bugs in the operating system may inadvertently allow applications to access resources As a result some e.g. native applications may have full access to the operating system and or resources of the computing device while other e.g. web applications may have little to no direct access to the operating system and or resources of the computing device.

Such coarse application of trust may negatively impact the execution of all applications on the computing device. For example native applications may produce unwanted side effects by modifying files on the computing device and or engaging in computation or communication outside of the tasks or features requested by the user. On the other hand web applications may execute one to two orders of magnitude slower than native applications and may provide limited functionality to the user.

Hence what is needed is a finer grained application of trust to software executing on computing devices.

Some embodiments provide a system that executes a native code module. During operation the system obtains the native code module. Next the system loads the native code module into a secure runtime environment. Finally the system safely executes the native code module in the secure runtime environment by using a set of software fault isolation SFI mechanisms that constrain store instructions in the native code module. The SFI mechanisms also maintain control flow integrity for the native code module by dividing a code region associated with the native code module into equally sized code blocks and data blocks and starting each of the data blocks with an illegal instruction.

In some embodiments the system also validates the native code module using one or more of the SFI mechanisms prior to executing the native code module in the secure runtime environment.

In some embodiments maintaining control flow integrity for the native code module further involves at least one of 

In some embodiments masking destination addresses associated with indirect control flow instructions involves clearing a set of upper bits and a set of lower bits in each of the destination addresses.

In some embodiments a transfer of control flow to the illegal instruction causes the native code module to discontinue execution.

In some embodiments enforcing storage of valid data addresses in the stack pointer involves enabling store instructions that increment or decrement the stack pointer without masking and masking direct updates to the stack pointer to keep a value of the stack pointer within the call stack.

In some embodiments the unmapped pages enable stack relative store instructions without masking if the immediate offset is smaller than a size of one or more of the unmapped pages.

In some embodiments the SFI mechanisms are configured to mask instructions in the native code module by 

The following description is presented to enable any person skilled in the art to make and use the embodiments and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present embodiments. Thus the system is not limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features disclosed herein.

The data structures and code described in this detailed description are typically stored on a computer readable storage medium which may be any device or medium that can store code and or data for use by a computer system. The computer readable storage medium includes but is not limited to volatile memory non volatile memory magnetic and optical storage devices such as disk drives magnetic tape CDs compact discs DVDs digital versatile discs or digital video discs or other media capable of storing code and or data now known or later developed.

The methods and processes described in the detailed description section can be embodied as code and or data which can be stored in a computer readable storage medium as described above. When a computer system reads and executes the code and or data stored on the computer readable storage medium the computer system performs the methods and processes embodied as data structures and code and stored within the computer readable storage medium.

Furthermore the methods and processes described below can be included in hardware modules. For example the hardware modules can include but are not limited to application specific integrated circuit ASIC chips field programmable gate arrays FPGAs and other programmable logic devices now known or later developed. When the hardware modules are activated the hardware modules perform the methods and processes included within the hardware modules.

Embodiments provide a method and system for safely executing a native code module. The native code module may contain native code that is executed within a secure runtime environment that isolates the native code module from sensitive data and resources on the computing system. The native code module may additionally be validated by a validator prior to execution within the secure runtime environment to ensure that the native code module complies with a set of security constraints. Furthermore the native code module may be used to perform computationally intensive operations for a web application executing within a web browser.

More specifically embodiments provide a method and system for maintaining security for the native code module within an ARM instruction set architecture ISA . To maintain security the validator and or secure runtime environment may provide a set of software fault isolation SFI mechanisms that maintain control flow integrity and constrain store instructions in the native code module in lieu of x86 hardware memory segments. Control flow integrity may be maintained by dividing a code region associated with the native code module into equally sized code blocks and data blocks starting the data blocks with illegal instructions restricting control flow instructions to branch and link instructions and branch and exchange instructions validating direct control flow instructions disabling Thumb instructions and or masking destination addresses associated with indirect control flow instructions. Store instructions may be constrained by bounding an address space and a call stack of the native code module with a set of unmapped pages enforcing storage of valid data addresses in a stack pointer computing a store address by combining a valid base register with an immediate offset and or masking non stack relative store instructions. Consequently embodiments may provide per thread protection with low performance overhead during execution of native code modules while maintaining platform independence and portability across different web browsers and operating systems.

Computing system may correspond to an electronic device that provides one or more services or functions to a user. For example computing system may operate as a mobile phone personal computer PC global positioning system GPS receiver portable media player personal digital assistant PDA and or graphing calculator. In addition computing system may include an operating system not shown that coordinates the use of hardware and software resources on computing system as well as one or more applications e.g. web browser web application that perform specialized tasks for the user. For example computing system may include applications such as an email client address book document editor web browser and or media player. To perform tasks for the user applications may obtain the use of hardware resources e.g. ARM processor memory I O components network interface card graphics processing unit GPU etc. on computing system from the operating system as well as interact with the user through a hardware and or software framework provided by the operating system as described below.

In one or more embodiments computing system includes functionality to obtain and or execute applications using a network connection. In particular computing system may obtain web application from one or more servers e.g. server server x using a network connection with the server s and load web application in web browser . For example web application may be downloaded from an application server over the Internet by web browser .

Once loaded web application may provide features and user interactivity comparable to that of native applications on computing system . For example web application may function as an email client document editor media player computer aided design CAD system and or computer game. Web application may also include dynamic user interface elements such as menus buttons windows sub windows icons animations and or other graphical objects that emulate analogous user interface elements in native applications. In other words web application may correspond to a rich Internet application RIA .

Furthermore web application may execute on computing system regardless of the type of platform e.g. operating system drivers hardware etc. associated with computing system . Though platform independent applications such as web application may be more portable and secure than native applications such cross platform applications may lack certain performance capabilities of native applications.

More specifically non native applications such as web application may be written using scripting languages that are interpreted rather than compiled such as JavaScript JavaScript is a registered trademark of Sun Microsystems Inc. . The interpreted nature of web application and or other non native applications may result in significantly slower execution times for the non native applications than those of compiled native applications. Non native applications may also be unable to utilize low level libraries and or application programming interfaces API that are available for use by native applications. Consequently non native applications may provide limited functionality in certain tasks.

To enable native performance for web applications computing system may obtain and execute a native code module within plugin . Like web application native code module may be obtained from one or more servers e.g. server server x by web browser . For example web application may provide a hyperlink to native code module on the Internet. Web browser may then download native code module from the Uniform Resource Locator URL specified in the hyperlink. Alternatively native code module may be specified by the user or by an external source such as another web application and or a native application. Furthermore native code module may be obtained from local storage e.g. a browser cache on computing system instead of from a server.

More specifically native code module may correspond to a software module containing native code that runs directly on hardware provided by computing system such as a CPU e.g. ARM processor . As a result native code module may be used to perform tasks that require substantial access to CPU resources on computing system . For example native code module may be used by web application to provide computationally intensive features associated with physics simulation signal processing artificial intelligence modeling flexible high throughput cryptography and or multimedia editing and analysis.

In one or more embodiments plugin includes a variety of mechanisms to ensure the safe execution of native code module . In particular native code module may be validated by a validator provided by plugin prior to execution. Native code module validation is described in a co pending non provisional application by inventors J. Bradley Chen Matthew T. Harren Matthew Papakipos David C. Sehr and Bennet S. Yee entitled Method for Validating an Untrusted Native Code Module having Ser. No. 12 117 634 and filing date 8 May 2008 which is incorporated herein by reference.

Once native code module is validated native code module may be loaded into a secure runtime environment provided by plugin . Native code execution in a secure runtime environment is described in a co pending non provisional application by inventors J. Bradley Chen Matthew T. Harren Matthew Papakipos David C. Sehr Bennet S. Yee and Gregory Dardyk entitled Method for Safely Executing an Untrusted Native Code Module on a Computing Device having Ser. No. 12 117 650 and filing date 8 May 2008 which is incorporated herein by reference. Secure runtime environment may also be provided by a web browser extension to web browser and or secure runtime environment may be built into web browser .

Furthermore because native code module may include binary code that runs directly on hardware native code module may be platform independent with respect to the operating system web browser and or other software components on computing system . As described in the above referenced applications plugin and or native code module may also include mechanisms for executing on a variety of instruction set architectures including the use of fat binaries and binary translators.

However native code module may not be platform independent with respect to the instruction set architecture ISA of one or more processors e.g. ARM processor in computing system . In particular different ISAs may implement data types instructions registers addressing modes memory architecture interrupt and exception handling and or external input output I O differently. Accordingly instructions and mechanisms for executing software modules e.g. web browser native code module plugin etc. directly on hardware may vary between different ISAs. Moreover execution of the same software module within multiple ISAs may require that the software module be recompiled into a different binary executable for each ISA. For example an x86 64 bit implementation of native code module may utilize 64 bit addresses a flat segmentation model of memory and 64 bit general purpose registers GPRs while an x86 implementation of native code module may utilize 32 bit addresses a multi segment model of memory and 32 bit GPRs.

Differences in ISA implementations may additionally affect security mechanisms used to validate and execute native code module . More specifically the security mechanisms described in the above referenced applications for executing native code modules within x86 ISAs may not pertain to mechanisms for safely executing native code modules within x86 64 bit or ARM ISAs. Consequently the functionality of validator and or secure runtime environment may require adaptation for use within a variety of ISAs.

In one or more embodiments the system of includes functionality to safely execute native code module within an ARM ISA. In other words plugin and web browser may correspond to software modules that execute directly on ARM processor using the ARM ISA. Moreover native code module may correspond to a set of ARM instructions and data that is loaded into the address space of ARM processor and used to facilitate the execution of web application .

As with native code modules in x86 environments the secure execution of native code module on ARM processor may be facilitated by validator and or secure runtime environment . In particular validator and secure runtime environment may enable safe execution of native code module on ARM processor using a set of software fault isolation SFI mechanisms in lieu of hardware segmented memory support available in x86 ISAs. Such SFI mechanisms may maintain control flow integrity for native code module and or constrain store instructions in native code module .

Validator and secure runtime environment may also be configured to maintain security for native code modules within x86 64 bit ISAs. Native code module security within x86 64 bit ISAs is described in a co pending non provisional application by David C. Sehr Bennet S. Yee and J. Bradley Chen and filed on the same day as the instant application entitled Native Code Module Security for 64 bit Instruction Set Architectures having Ser. No. 12 621 266 and filing date Nov. 18 2009 which is incorporated herein by reference.

In one or more embodiments native code module is loaded into memory of computing system for inspection by validator . Once loaded into memory page table protection provided by the operating system of computing system may prevent native code module from being modified. As discussed below with respect to page table protection may additionally provide SFI mechanisms for restricting instruction execution in native code module to a code region in the address space and data accesses to the code region or a data region in the address space.

In one or more embodiments validator performs static binary analysis on native code module to ensure that native code module conforms to a set of security constraints. If native code module does not conform to the security constraints validator may discard native code module prior to loading native code module into secure runtime environment .

During analysis of native code module validator may ensure that native code module is statically linked at a start address of zero e.g. providing a zero based address range for native code module with the first byte of text at 128 Kbytes after the start address. Validator may then sequentially disassemble and or decode all executable instructions within native code module beginning with the first byte of text at 128 Kbytes after the start address. During disassembly validator may verify that native code module does not contain any unsafe or otherwise restricted instructions such as instructions that directly invoke the operating system hardware performance instructions and or complex addressing modes. As discussed below validator may also verify that data blocks within a code region associated with native code module begin with illegal instructions.

Once native code module is validated native code module is executed in secure runtime environment . As described in the above referenced applications secure runtime environment may load and launch native code module from memory provide an execution environment that includes communications threads memory management and debugging support for native code module moderate access to system resources according to an access policy for native code module and or support the isolated execution of multiple native code modules on computing system . Consequently secure runtime environment may provide additional SFI mechanisms for ensuring the secure execution of native code module on computing system . In particular secure runtime environment may restrict access from native code module to registers memory and or other resources associated with the ARM ISA.

As discussed in the above referenced applications validator and or secure runtime environment may enforce security for native code module by providing pseudo instructions that mask certain instructions within native code module . In one or more embodiments pseudo instructions are used to constrain both control flow instructions and store instructions within the ARM ISA. Furthermore the SFI mechanisms provided by validator and or secure runtime environment may ensure that all instructions within each pseudo instruction are executed sequentially or not at all. Execution of pseudo instructions within ARM ISAs is discussed in further detail below with respect to .

In one or more embodiments validator and or secure runtime environment provide SFI mechanisms that enforce control flow integrity by restricting the execution of certain instructions ensuring that data blocks are never executed validating direct control flow instructions and or masking destination addresses associated with indirect control flow instructions. More specifically validator may ensure that control flow instructions in native code module are restricted to branch and link e.g. bl instructions and branch and exchange e.g. bx instructions. In other words validator may disable program counter e.g. R15 register updates using general register move instructions or load multiple e.g. ldm instructions. Alternatively as discussed below program counter updates may be used to mask indirect control flow instructions. Furthermore validator and or secure runtime environment may disable the use of Thumb instructions in native code module . Such restrictions may simplify control flow analysis by validator with little to no performance impact during execution of native code module .

In addition validator and or secure runtime environment may ensure that data blocks within the code region associated with native code module are never executed. As mentioned previously page table protection may restrict instruction execution in native code module to a code region of the address space. However the ARM ISA may store both executable instructions and data e.g. constant pools within the code region. To prevent data from being executed the SFI mechanisms may divide the code region into equally sized aligned 16 byte blocks containing either code e.g. code blocks or data e.g. data blocks start each data block in the code region with an illegal instruction and ensure that each indirect control flow instruction targets the beginning of an aligned 16 byte code block. Data blocks within code regions are discussed below with respect to . Code blocks within code regions are discussed below with respect to .

To validate direct control flow instructions validator may statically compute direct control flow targets and confirm that the targets correspond to valid instructions. To validate indirect control flow instructions e.g. instructions with targets computed at runtime validator may verify that each indirect control flow instruction is part of a multi instruction sequence e.g. pseudo instruction with appropriate address masking operations during loading of native code module into memory.

In one or more embodiments destination addresses associated with indirect control flow instructions are masked by clearing a set of upper bits and a set of lower bits in each of the destination addresses. In one or more embodiments the code region begins at address 0 and continues to an address that is a power of 2 in the address space. As a result an exemplary indirect control flow pseudo instruction that masks a branch and exchange instruction involving the r3 register may include the following instructions 

The first instruction of the pseudo instruction may correspond to a masking e.g. bit clearing instruction that clears the four highest and lowest bits in the r3 register. The masking instruction may ensure that the target of the branch and exchange instruction is aligned along a 16 byte alignment boundary and remains within a code region in the range of 0 256 megabytes in the address space. Alternatively the indirect control flow pseudo instruction above may be implemented using a single instruction 

In other words the pseudo instruction may directly update the program counter with the masked destination address instead of preceding a branch and link or branch and exchange instruction with a masking instruction.

Those skilled in the art will appreciate that the size and position of the code region may allow for a more efficient implementation of SFI than unaligned memory regions and or memory regions of other sizes. More specifically the creation of a code region between address 0 and a power of 2 within the address space may allow masking to be accomplished using a single instruction and a variety of instructions and operands. For example the indirect control flow pseudo instruction above may utilize any arithmetic or logical instruction s that clear the four highest and lowest bits in the r3 register. Similarly the same masking instructions may be used with modified operands to accommodate code regions of different sizes as long as the sizes are powers of 2.

Such instructions and or operands may further be selected for use in pseudo instructions to minimize performance overhead during execution of native code module . In particular the use of a logical and operation to mask addresses may introduce an overhead of about one instruction per masking operation if the size of the code region is a power of two. In other words base 2 modular arithmetic may be used to efficiently implement masking in most 32 bit and 64 bit ISAs while code regions of arbitrary sizes may preclude the use of base 2 modular arithmetic and require additional overhead in masking operations e.g. from division operations . However efficient implementations of non base 2 arithmetic operations may allow masking operations to use such arithmetic operations. For example an efficient implementation of base 10 modular arithmetic may allow the size of the code region to be a power of 10 and may introduce the use of base 10 arithmetic operations in masking operations.

Validator and or secure runtime environment may additionally include SFI mechanisms for constraining load and or store instructions in native code module . Such SFI mechanisms may include the verification of pseudo instructions and or specific addressing modes within native code module as well as the use of unmapped pages to bound a valid memory region and or call stack of native code module . Constraining of store instructions is discussed in further detail below with respect to .

In one or more embodiments code region begins at address 0 and extends to an address that is a power of two e.g. the first 256 megabytes of the address space . Data region begins where code region ends and extends to an address that is a higher power of two e.g. the first 2 Gbytes of the address space . Finally trusted region occupies the remainder of the address space e.g. the last 2 Gbytes . Code region may contain both code and data blocks while data region may contain a call stack data and a set of unmapped pages and . Trusted region may contain a different set of unmapped pages and . Unmapped pages and may bound trusted code and data used to facilitate the execution of the native code module such as code and data for a validator e.g. validator of secure runtime environment e.g. secure runtime environment of and or trusted services associated with the native code module.

As described in the above referenced applications trampoline instructions may be used by the native code module to access resources and or services associated with trusted region . However a number of SFI mechanisms associated with code region data region trusted region and or a stack pointer within data region may prevent the native code module from inappropriately accessing trusted region and or other portions of the address space. The SFI mechanisms may be provided by the validator and or secure runtime environment and constrain both control flow instructions and stores within the native code module.

First the SFI mechanisms may include page table protection in lieu of hardware memory segments provided by x86 ISAs. Page table protection may be provided by the ARM processor and or an operating system associated with the address space and may restrict the native code module s access to various parts of the address space. First page table protection may restrict access to code region and data region . As described above code region may begin at address 0 with the first byte of text at 128 Kbytes. Moreover after the native code module is loaded into code region page table protection may prevent code region from subsequent modification.

Page table protection may also prevent the native code module from executing portions of the address space outside of code region . For example the use of execute never e.g. XN bits in ARM page table entries may prevent the native code module from executing pages in data region . Bits in page table entries may also be set to restrict portions of data region to read only access and or read write access by the native code module. For example string constants associated with the native code module may be stored in a read only section of data region that is enforced using page table protection. As discussed below page table protection associated with unmapped pages and may effectively constrain the native code module s memory references and stack pointer updates to code region and or data region while minimizing performance overhead.

Next the SFI mechanisms may enforce storage of valid data addresses e.g. within data region in stack pointer e.g. the R13 register used to reference call stack . Stack pointer may be initialized with an address within call stack . To constrain stack pointer within call stack the SFI mechanisms may bound call stack with unmapped pages and enable store instructions that increment or decrement stack pointer without masking and or mask direct updates to stack pointer to keep a value of stack pointer within call stack .

More specifically unmapped pages and may enable stack relative store instructions without masking if the immediate offset plus the largest store is smaller than a size of one or more of the unmapped pages e.g. 4 Kbytes . As a result store instructions e.g. stm ldm etc. that increment or decrement stack pointer may be executed without masking. Because such instructions make relatively small adjustments to stack pointer the adjustments either keep stack pointer within call stack or cause segmentation violations if stack pointer exceeds the bounds of call stack and references an instruction in an unmapped page or . The SFI mechanisms may then respond to the segmentation violations by terminating the execution of the native code module and or triggering traps that handle the segmentation violations.

In addition direct updates to stack pointer may be made using the add sub and or mov instructions using immediate offsets while instructions such as ldr and ldm may be disallowed in direct updates to stack pointer . Direct updates with offsets larger than the size of unmapped pages and may be followed immediately by a masking instruction that keeps stack pointer within call stack and or unmapped pages and . For example a pseudo instruction for a direct update to stack pointer may correspond to the following 

To constrain non stack relative store instructions the SFI mechanisms may allow addressing modes that calculate store addresses by combining a valid base register with an immediate offset while disabling addressing modes that calculate store addresses by adding two registers together. Because immediate offsets may correspond to 12 bit numbers addressing modes that use immediate offsets may cause displacements of at most 4 Kbytes. Consequently immediate offsets of register values within the address range of code region and or data region may remain either within code region or data region or generate illegal memory references into unmapped pages and that cause segmentation violations.

Furthermore non stack relative store instructions may be masked to ensure that register values used in the non stack relative store instructions fall within code region or data region . For example a store pseudo instruction that executes a mask instruction prior to a non stack relative store instruction may include the following instructions 

Those skilled in the art will also appreciate that the same SFI mechanisms described above may be used to constrain load instructions in the native code module. In particular page table protection unmapped pages and restrictions on modifications to stack pointer masking and or register immediate offset addressing modes may also be used to constrain load addresses to code region or data region . For example load addresses may be computed by combining a valid base register with an immediate offset and or by masking values in the base register. As a result the validator and or secure runtime environment may also include functionality to constrain some or all load instructions in the native code module.

Furthermore the validator and or secure runtime environment may use a variety of SFI mechanisms to constrain any combination of non stack relative loads non stack relative stores stack relative loads and stack relative stores. Such selective constraining of loads and or stores may be based on security and or performance considerations associated with executing the native code module. For example stack pointer may be restricted to code region and data region e.g. the lower 2 Gbytes of the address space instead of to call stack to reduce the amount of masking used in stack relative loads and or stores.

In one or more embodiments illegal instruction corresponds to a breakpoint that prevents the data block from being executed. Because direct control flow instructions are validated to not target data blocks and indirect control flow instructions are masked to target the beginnings of aligned 16 byte blocks data and is effectively never targeted by any control flow instruction. Along the same lines indirect control flow instructions that target illegal instruction may cause an exception that discontinues execution of the native code module and prevents subsequent execution of data and . Consequently the use of data blocks within the code region may enable conformity to the ARM compilation model while maintaining control flow integrity in the native code module.

In one or more embodiments a number of SFI mechanisms may ensure that instructions and within the pseudo instruction are executed from beginning to end. First SFI mechanisms associated with control flow integrity may force control flow instructions to target the beginning of the code block. In addition padding within the native code module may align instructions such that the pseudo instruction takes up the entire 16 byte code block. For example instruction may correspond to a nop instruction that aligns the last instruction of the pseudo instruction with the end of the code block. In other words nop instructions may be used to place indirect control flow instructions e.g. instruction in the last sections of aligned 16 byte code blocks which may ensure that each code block contains at most one and only one pseudo instruction. Consequently control flow instructions targeting the code block of and or other code blocks containing pseudo instructions may only reach the beginnings of the pseudo instructions and may not bypass masking instructions within the pseudo instructions.

Sequential execution of instructions may further be facilitated by storing the same execution condition in condition fields and of instructions and . Each condition field and may correspond to four bits in the corresponding instruction and that specifies the execution condition required to execute the instruction. In particular the execution condition may be obtained from instruction that is masked by other instructions and in the pseudo instruction. If the execution condition is met instructions and are executed and if the execution condition is not met the pseudo instruction is bypassed as a whole. In other words instructions and may utilize predication such that instructions and within the pseudo instruction are executed in an all or none fashion.

In one or more embodiments the execution condition is based on a set of condition codes stored in a Current Program Status Register CPSR provided by the ARM ISA. More specifically the condition codes may correspond to the Negative Zero Carry and or Overflow e.g. N Z C V bits of the CPSR register. As shown in the execution condition in condition fields and is set as 0000 indicating that instruction is intended to execute only if the Z bit of the CPSR register is set. Moreover instructions and may not change the condition codes. As a result the condition codes and condition fields and in instructions and may further ensure that instructions within the pseudo instruction are executed sequentially e.g. if the condition codes satisfy the condition or not at all e.g. if the condition codes do not satisfy the condition .

First the native code module is obtained operation . The native code module may be obtained from one or more servers and or compiled from source code. In addition the native code module may be used to facilitate the execution of a web application such as a JavaScript application. For example the native code module may be used to perform computationally intensive operations for the web application.

Next the native code module is loaded into a secure runtime environment for an ARM ISA operation . In particular the native code module may be loaded into a valid memory region e.g. code region and data region of in the 32 bit address space of the ARM ISA. The loaded native code module is then validated operation using one or more SFI mechanisms prior to executing the native code module. During validation the native code module may be inspected for conformity to a set of security constraints. In particular the native code module may be inspected to detect defects that do not conform to the security constraints operation . If the native code module does not conform to the security constraints e.g. the validator detects defects in the native code the native code module is discarded without having been executed.

If the validator does not detect defects in the native code module the native code module is executed in the secure runtime environment using the SFI mechanisms operation . The secure runtime environment may be provided by a plugin associated with the web browser a browser extension to the web browser and or a component within the web browser. The SFI mechanisms may maintain control flow integrity for the native code module and or constrain store instructions in the native code module. To maintain control flow integrity the SFI mechanisms may divide the code region into equally sized e.g. aligned 16 byte code blocks and data blocks start data blocks in the code region with illegal instructions restrict control flow instructions to branch and link instructions and branch and exchange instructions validate direct control flow instructions disable Thumb instructions and or mask destination addresses associated with indirect control flow instructions. Similarly the SFI mechanisms may constrain store instructions by bounding an address space and a call stack of the native code module with a set of unmapped pages enforcing storage of valid data addresses in a stack pointer computing a store address by combining a valid base register with an immediate offset and or masking non stack relative store instructions.

Consequently the SFI mechanisms used to validate and execute the native code module may enable secure execution of the native code module on ARM hardware with low performance overhead while maintaining portability and platform independence across different web browsers and operating systems. In particular the SFI mechanisms may provide per thread protection that constrains threads used to execute untrusted code in the native code module while allowing trusted code used to validate and execute the native code module to execute without constraints. Furthermore the SFI mechanisms may improve performance by minimizing overhead associated with masking store instructions. Finally the direct execution of the native code module on ARM hardware may allow the native code module to execute on a variety of ARM processors and operating systems without modification.

The foregoing descriptions of embodiments have been presented only for purposes of illustration and description. They are not intended to be exhaustive or to limit the embodiments to the forms disclosed. Accordingly many modifications and variations will be apparent to practitioners skilled in the art. Additionally the above disclosure is not intended to limit the present embodiments. The scope of the embodiments is defined by the appended claims.

