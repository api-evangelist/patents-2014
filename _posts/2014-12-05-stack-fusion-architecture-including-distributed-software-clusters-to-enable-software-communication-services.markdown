---

title: Stack fusion architecture including distributed software clusters to enable software communication services
abstract: A stack fusion architecture enables a cloud provider to provide Software-as-a-Service (SaaS) offerings to multiple organizations. Each organization operates a Infrastructure-as-a-Service (IaaS) platform and is associated with an organization domain. A cluster of software/communication services is deployed to each platform. Users registered to an organization domain have access limited to the cluster uniquely associated with that domain. The architecture includes a globally accessible domain-to-cluster map used to map each cluster to the associated domain. A locally accessible user-to-cluster map is stored in each cluster to map that cluster to each user registered to the domain uniquely associated with that cluster. The architecture enables communication between users provisioned on different clusters and registered to different domains without exposing private information to the cloud provider.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09430672&OS=09430672&RS=09430672
owner: Cisco Technology, Inc.
number: 09430672
owner_city: San Jose
owner_country: US
publication_date: 20141205
---
The present disclosure relates to cloud based real time communications also known as software as a service SaaS .

Real time communications services for business are available in two deployment models. One model called on premise is a model wherein the Information Technology IT department of a company obtains software for providing communications services to their users. Premise based deployment models have drawbacks. They require costly up front licenses and IT projects to install and deploy. They have very slow upgrade cycles with businesses often being many years behind the current release. They also typically struggle in providing business to business b2b communications.

In an alternative deployment model referred to as cloud or software as a service SaaS a third party the SaaS provider builds and operates the server software. The SaaS model introduces difficulties too. The communications software might run in a data center far away from the business customer introducing latency. Another issue is that of data sovereignty. Communications services typically include storage and maintenance of personally identifiable information including user accounts. Many businesses would prefer that personally identifiable user information and company corporate information reside in the corporate data center not in the data centers of a third party that cannot perhaps be trusted as much.

Techniques presented herein facilitate a communications service that can be provided as a cloud service amongst a number of organizations. According to a first technique a cloud provider is configured to provide Software as a Service SaaS offerings to multiple organizations. Each of the organizations operates a distinct Infrastructure as a Service IaaS platform and is associated with at least one distinct organization domain associated with the organization. A cluster of software services including communication services is deployed to each IaaS platform. Each cluster is uniquely associated with the organization that operates that IaaS platform. Users that belong to each organization are provisioned on the cluster associated with that organization. The provisioning includes storing user information for each user only on the associated cluster. Users provisioned on different clusters are enabled to communicate with each other as if the users were part of a centralized cloud communication service without sharing respective user information with the cloud provider.

According to a second technique that supports operations in the first technique a globally accessible domain to cluster map is established and used to map each cluster to the organization domain associated therewith. A locally accessible user to cluster map is stored in each cluster to map that cluster to each user registered to the organization domain associated with that cluster so as to have access thereto. A user request for access to a software service offered by the cloud provider is received wherein the user request includes a user email address which may include a domain name and a user identifier identity . The user request is directed to the requested software service in a cluster associated with the organization domain to with the user is registered based on the user email address the domain to cluster map and one of the user to cluster maps.

Historically real time communications services for business have been available in two deployment models. One model called on premise is a model wherein the Information Technology IT department of a company obtains software for providing communications services to their users. The IT department then installs the software on servers residing in their data centers and then operates this software. This is the traditional deployment model for enterprise Internet Protocol IP communications services also known as IP PBX or Unified Communications for the past 15 years . However premise based deployment models have drawbacks. They require costly up front licenses and IT projects to install and deploy. They have very slow upgrade cycles with businesses often being many years behind the current release. They also typically struggle in providing b2b communications.

More recently an alternative deployment model has arisen. In this model referred to as cloud or software as a service SaaS the IT department does not need to install or manage the software. Rather a third party the SaaS provider builds and operates the server software. The IT department typically pays for this service on a monthly basis. The IT department can consume the service using Personal Computer PC mobile or tablet based soft clients or by plugging in hard phones into the Internet. The hard phones automatically connect to the SaaS provider and enable service. SaaS services resolve many of the key drawbacks of premise software deployments. They require little upfront costs or time to deploy the IT department can be operational within minutes. The SaaS provider handles software upgrades and typically provides service that is upgraded invisibly to the customers with great frequency. Most importantly cloud communications services have proven extremely effective at business to business b2b communications. Since there is a common SaaS provider supporting multiple business customers communications amongst those business customers is trivial.

However the SaaS model introduces difficulties too. The communications software might run in a data center far away from the business customer introducing latency. Latency is of critical importance particularly for communications applications which are far more sensitive to latency than many other applications. Furthermore loss of Internet connectivity means that the business can no longer access communications services. Another issue is that of data sovereignty. Communications services typically include storage and maintenance of personally identifiable information including user accounts. It also includes content instant messages shared documents and meeting recordings which contain highly sensitive corporate information. Many businesses would prefer that personally identifiable user information and company corporate information reside in the corporate data center not in the data centers of a third party that cannot perhaps be trusted as much.

Techniques are presented herein for facilitating a communications service that can be provided as a cloud service amongst a number of companies. Customers of this service can elect to have a portion of the software run within their own data centers. This software is still operated as a SaaS service by the cloud provider it merely physically resides within the data center of the customer. Employees of that company are served by the software that runs within the data center of that company and all communications between users of the same company remains within the boundaries of the company IP network. Furthermore user data also remains within the boundaries of the company. However users can freely communicate with users in other companies as if they were all part of the same cloud service the service is completely borderless. Users exist within a single global namespace even though they are across multiple companies. Furthermore users may consume the service directly from the cloud provider and those users can communicate with users in any other company. The software as a whole has the properties of a SaaS offering. Analytics and metrics are fed from company data centers back to the cloud provider and the cloud provider can remotely upgrade the software within each company without disruption in service. This capability I enabled primarily through a loosely federated identity service which allows for the global namespace with distributed user data combined with a cluster based Representational State Transfer REST architecture.

With reference to there is depicted a block diagram of a deployment model of an example distributed services system according to an embodiment. System is also referred to as a stack fusion system that implements stack fusion techniques presented herein. The system includes a number of companies that opt into the service. The service includes a communications service providing voice video conferencing and messaging and other features which involve communications between users. shows three such companies Company and . Companies and deploy respective platforms P P and P within their respective data centers D D and D. Each of platforms P P and P is an instance of an Infrastructure as a Service IaaS platform. Examples of such platforms include Openstack. Each IaaS platform Pi where i is 1 2 and 3 includes provides compute storage and networking services for the respective data center Di. Typically these types of platforms are deployed by public IaaS providers for example Rackspace and anyone can access them. The platforms are also sometimes deployed as private clouds within an enterprise in which case they are accessible only by enterprise IT. As depicted in each platform Pi is deployed as part of a private cloud in that the platform runs within the respective company data center Di. However the platform is made accessible to a cloud provider depicted at the top of that operates a data center D as a special tenant. To the cloud provider each platform P P or P looks much like what a public IaaS would look like. The platform exposes REST based Application Programming Interfaces APIs though any other network based API would suffice and the cloud provider can access those APIs to spin up virtual machines associated with the platform install software on those virtual machines create networks and access local disk for storage. In the example of an IT department in each data center D D or D is responsible for operating the respective platform P P or P and making sure its services and the APIs which access it are available to the cloud provider.

As mentioned above the cloud provider operates data center D similar to the company data centers D D. Data center D also has a dedicated platform P. Platform P is ideally the same technology foundation as the ones within the company data centers D D e.g. Openstack but need not be. Services within data centers D D intercommunicate over a communication network CN which may include wide area networks such as the Internet and local area networks.

The cloud provider deploys and operates a respective one of clusters C C and C on top of respective ones of company platforms P P and P in respective ones of data centers D D and D. Also a cluster C operates on platform P in data center D of the cloud service provider. A cluster includes an atomic set of software which can reside within a single data center. The cluster typically includes load balancers reverse Hypertext Transfer Protocol HTTP proxies aka REST routers application servers like chat servers conferencing servers content servers and databases. The databases are used to store user information including user profile data user entitlements along with user generated content such as chat photos videos PPT documents meeting recordings and so on.

These properties are paramount for providing the needed data sovereignty survivability security and reliability properties that the stack fusion system needs to provide.

As seen in users U and U are served by cluster C of data center D for company . Users U and U are served by cluster C of data center D for company . Users U and U are served by cluster C of data center D for company . The cloud provider has its own cluster cluster C which resides on cloud provider platform P. Users U and U are served directly by cluster C. Users U and U may work for a company but the users utilize the services of cluster C in the cloud provider. Cluster C services users which may reside across many different companies. Such multi company users are all combined together and referred to as a consumer group. Thus cluster C which serves the consumer group is referred to as the consumer cluster.

As depicted in platform P used by the cloud provider also supports operational tools Ops Tools which include scripts and software responsible for 

With reference to there is a block diagram of a variation of the deployment model depicted in . In the variation depicted in company has dedicated cluster C to serve its own users however cluster C now resides alongside the consumer cluster C on platform P hosted in data center D operated by the cloud provider. The cloud provider may host many other such clusters in addition to the consumer cluster.

Before services may be accessed by customers users of a company that are served at a given data center e.g. in data center D software that supports the services needs to be deployed to the cluster e.g. cluster C in the data center. With reference to there is depicted an example process of deploying the software to a given cluster depicted in . The deployment process for a data center operated by a given company may be performed by an administrator in an IT department of the company. The administrator is referred to as the admin. 

First at the admin deploys a private cloud or IaaS in the data center. The admin will typically do this by installing servers such as Cisco Unified Computing System UCS network switches such as a Cisco Nexus switch and host attached disks. On top of these servers the admin installs an IaaS platform such as Openstack. Openstack software provides APIs accessed over REST for spinning up Virtual Machines VMs installing software creating networks and accessing storage within the private cloud. This private cloud typically sits behind a corporate firewall however the firewall may be configured with pinholes that allow inbound traffic towards the servers within the private cloud. The private cloud is also firewalled from the rest of a corporate network.

With reference to there is shown a typical deployment for a private cloud that results from the actions at . The private cloud of includes a firewall through which the private cloud access communication network CN multiple servers network switches and a corporate firewall through which the private cloud access a corporate Intranet .

Returning to at once the admin has set up the private cloud e.g. as depicted in the admin will provision a tenant into the private cloud. The result of this provisioning is a tenant username tenant password and set of policies defining the amount of compute storage and networking resources that the tenant is allowed to access. Such provisioning is a standard capability for IaaS software platforms like Openstack.

Once provisioned at the admin visits a web portal provided by the cloud provider. The admin is a customer of the cloud provider and has credentials to log into the cloud provider web portal. Typically the admin has also purchased the appropriate entitlements that enable the admin to access the capabilities of this solution to be deployed on the private cloud i.e. on the cluster hosted by the platform of the private cloud . At and the admin selects an icon presented on a web page of the web portal to activate deployment which causes a step by step deployment process to begin. This takes the admin to a web page where at the admin enters in the credentials for the private cloud tenant they just provisioned. The admin also enters a Uniform Resource Locator URL for accessing the IaaS services. Finally at the admin selects to deploy the services.

Once the admin selects to deploy the services the operational tools Ops Tools in the cloud provider are activated to begin an installation and test process. With reference to there is depicted an example process of installing and testing services in the private cloud that were previously provisioned by the process of . At the operational tools in the cloud provider upon receipt of the final deploy button click utilize the URL. This URL is basically the root URL for accessing Openstack in the private cloud e.g. https privatecloud.company.com. Because the REST APIs for Openstack are standardized the cloud provider can create the URLs necessary to connect to the various REST endpoints which constitute the Openstack IaaS services. At the scripts in the cloud provider will take the username and password authenticate to the private cloud. Once authenticated at the scripts will then begin to spin up VMs using the number of VMs required to install the minimum capacity of the cluster. At the scripts then install the software including databases message buses applications and so on as needed. Once installed at the scripts run a battery of automated tests. These automated tests utilize servers in the cloud provider data center which emulate clients and connect to the software that was just installed in order to validate it. These tests are fully automated and require no human intervention from the admin or from employees of the cloud provider.

Once the integration tests are complete the software in the private cloud is operational and ready for use. At a final step in the process is that the scripts in the cloud provider will create a cluster name. This cluster name is arbitrarily chosen but must be a valid Domain Name System DNS name. An example of such a name might be sequential letters of the alphabet e.g. a b etc.

The next step in the process is domain claim. This is an optional step. However if not done the full privacy capabilities of the system may not be provided. In the domain claim process the admin will visit the cloud provider portal once again to enter a domain name also referred to as an organization domain e.g. company.com of the company for which the admin is acting i.e. the company that operates the data center that was provisioned by the admin in accordance with processes and of . The web portal will utilize any of a number of common techniques for verifying that the admin company does in fact have DNS ownership over the domain entered through the web portal. According to one such technique the web portal visits the WHOIS record for the associated domain search for and find the email address of the associated admin and then send an email to the admin using the found email address where the email provides a code. Once the admin receives the email the admin must then enter the code into the web portal. Another technique is to request the admin to create a subdomain with a specific name which maps to a specific IP address. The admin will visit their domain provider site make the configuration change and then return to the cloud provider portal. The admin then selects an icon to verify which causes the web portal to do a DNS query for the requested subdomain and verify that the IP address which is returned is the expected IP address.

Once the domain ownership is verified the web portal stores within the cloud provider e.g. in cluster C a mapping referred to as a globally accessible domain to cluster map. The domain to cluster map maps the claimed domain e.g. company.com to the cluster name that was created for the admin e.g. a . This mapping is accessible as a REST endpoint within the cloud provider. With reference to there is shown an example message transaction used to access the domain to cluster map. At a client user issue an HTTP query to a URL of the form e.g. GET http clustermap.provider.com company.com. The URL is directs to the domain to cluster map stored in cluster C of the cloud provider.

In response to the GET the cloud provider uses a cloud provider mapping service that returns a message including a payload that conveys the requested mapping. E.g. in a JavaScript Object Notation JSON or Extensible Markup Language XML body of the payload the requested mapping may take the form 

So for example if the scripts in the cloud provider had created a VM on one of the servers in the private cloud and the IP address of the VM was 1.2.3.4 and the script installed server with the name locus on that VM the script would create a DNS entry 

The way in which the domain to cluster mapping service and the associated DNS records are used will become more apparent later.

A key part of the system is the notion of users and how those users are reached in the various clusters.

Users are identified by an email address e.g. joe example.com. The email address can be corporate provided or the email address can be a public consumer service like Gmail or Yahoo.com email address.

There is also implemented the concept of an org. An org is an administrative entity which manages policy for a group of users. This policy includes the ability to control user access to content to control access to services to force usage of corporate credentials and the like. The org also includes the ability to pay for services for users. Most often an org is a company. Typically a company has authoritative ownership over one or more DNS domain names. For example Cisco may be an org that would have authoritative ownership over the domains cisco.com collaborate.com insieme.com and other domain names which Cisco owns or has acquired.

There is an important org which is called the consumer org. The consumer org represents the cloud provider as the administrative entity. All users which are not under the control of a different org fall within the consumer org. In a sense the consumer org is therefore a default org. 

Through a process called domain claim an administrator of an org proves that they are the DNS owner of a domain. Once proven this entitles that admin the right to take authoritative ownership of some or all users with email addresses matching the claimed domain name.

Importantly even when an org has claimed a domain there still may be email addresses with that domain name not under that org. An example of this is a company that has purchases the cloud service for only some of its employees. The remaining employees can use the cloud service but as users in the consumer org in which case the users would not be subject to IT policy controls nor would receive the benefits of IT payment for services.

In an embodiment a domain can only ever be claimed by one org. The consumer org never has claims over any domain. An email address matching a claimed domain can only be in the org that claimed that domain or in the consumer org.

With reference to there is an illustration of an example diagrammatic identity model of orgs users identified by user email addresses and domains. A Cisco org owns domain names i.e. domains Cisco.com Insieme.com and Collaborte.com. Thus example users Bob and Alice associated with belonging to the Cisco org domains Cisco.com and Insiene.com may be assigned and identified by email addresses such as Bob cisco.com and Alice insieme.com respectively. Also depicted in is a General Electric org that owns domains Ge.com and General.com to which users Prasad and Jack belong respectively. A consumer org is associated with the cloud provider. A Yahoo user Mymom belongs to the consumer org however users Smith and Joe belonging to the domains Cisco and Ge may also belong additionally to the consumer org.

The consumer org is mapped to a multiplicity of clusters across data centers e.g. across data centers D D for purposes of scale. This mapping is a function of the user. As such there exists a mapping service in the data center s of the cloud provider which can map a user email address including the user name to the cluster for that user but only for email addresses in the consumer org.

In a similar way a non consumer org such as a company org can also have one or more clusters and the mapping of a company user to a specific cluster for that company org exists in a mapping service that exists ONLY in the clusters for that company org not in the cloud provider however in an alternative embodiment a global service exists which maps domain names to the clusters for that org. The global mapping service is considered global because the mapping service accessible from all of the clusters in the system.

With reference to there is depicted a block diagram of distributed mapping as described above according to an embodiment. Multiple cloud provider data centers DCs D D and D host respective clusters C C and C where each of the clusters accesses a respective one of local consumer org maps M M and M which each map consumer org email addresses to the local hosting cluster. A Cisco org data center DC D includes a Cisco cluster C and a Cisco org map M. Cisco org map M maps email addresses belonging to the Cisco org to Cisco cluster C based on the user name identified in the email address. GE DCs and host respective clusters C and C where each of the clusters accesses a respective one of local Ge org maps M and M which each map Ge email addresses to the Ge clusters. A global domain to cluster map maps domains to clusters e.g. Cisco.com to cluster C and GE to clusters C and C.

Together the various maps provide and enable a distributed service which allows mapping of a user identified by an email address of the user into the cluster for that user.

Any user client which can be an end user piece of software or a service in one of the clusters which wants to resolve a user s email address into a service in a cluster for that user performs the following steps 

All of these data properties serve to meet data sovereignty requirements so that the cloud provider has little record or visibility into the users actually using its service. Yet we still provide global connectivity amongst users.

An alternative embodiment may be used as an optimization. In this optimization the mapping service in the consumer org is also populated with the email addresses for users in all of the clusters in all domains. To provide privacy the mapping uses a hash of the email address rather than the actual email address. Furthermore this consumer map may be distributed to all clusters not just the ones servicing the consumer org. In such an optimization the domain to cluster map is always or often empty and the users are looked up in the user to cluster mapping service. This global user to cluster map does not contain any user information because it is indexed with a hash over an infinitely large namespace and is therefore not invertible .

The next step in the process is the provisioning operation. This is the process by which the admin now provisions individual end users into their system. To do that the admin once again visits the web portal. The web portal provides means for entering the user email address which resides within the domain claimed by the admin. For example if the admin had claimed the domain company.com the admin may then provision user Joe with email address joe company.com. The admin may enter additional profile information or entitlements. Many other techniques for obtaining the email address and profile information might be provided including syncing this information from the corporate directory bulk spreadsheet uploads and so on. User credentials may also be provided or the user may instead log in with a single sign on process using one of any of a number of industry standard federated identity systems.

One way or another the user email address and profile data is obtained by the web portal. The web portal is a web server that operates within the data center of the cloud provider. This web server will return static content and JavaScript that execute within the admin s browser. Once the actual form data is collected to provision the user the browser side JavaScript will consult the mapping service obtain the cluster name for the domain of the admin and convert this into a URL for accessing the provisioning service. The provisioning service is one of the application server components that reside in each cluster. Here the browser accesses this within the company cluster. It performs a provisioning operation by POSTing against the REST endpoint for the provisioning service. In an alternative embodiment the provisioning service resides centrally in the cloud provider s data center. It receives a REST request to provision the user and it obtains the cluster name for the domain of the user and then pushes the information into the database for the cluster.

With reference to there is illustration of message exchanges used to perform an example of a provisioning operation as described above. In the example of an admin browser associated with a company data center e.g. data center D in that hosts a cluster A e.g. cluster C in to be provisioned exchanges messages with a web server and a domain to cluster map of the cloud provider. At admin browser requests and receives the JavaScript and static content mentioned above. At browser examines the domain name part of the provisioned email address e.g. company.com and at sends a query to domain to cluster map to discover the name of the cluster handling the domain name company.com . At browser receives a the name of cluster a from map responsive to the query. At browser then constructs the URL for the provisioning service in cluster a which follows the convention .provider.com as described above. The cloud provider portal had previously created DNS records for these services so that HTTP requests for this subdomain of the provider route into the private cloud in the customer data center. Furthermore because these URLs are all subdomains of provider.com the browser will utilize the OAuth token for the admin account which will be also valid within the private cloud. At browser access a provisions service in cluster A of data center based on the constructed URL to perform a requested provisioning operation on the cluster. At after the provision operation succeeds cluster A sends a success message to browser .

An important benefit of this process is that the provisioning operations of users are never seen by the cloud provider. They transact directly between the browser and the provisioning service within the customer premise. This ensures that from a data sovereignty perspective it is not possible for the cloud provider to know what users have been provisioned since those requests do not pass through the cloud provider data center. The alternative embodiment does not hide provisioning operations from the cloud provider but does not store any persistent information about provisioned users in the cloud provider clusters.

With reference to there is an illustration of example software components within a cluster implemented in a three tier web architecture. The software components include 

Some of the HTTP application services that are utilized are not communications applications. An example of this is provisioning. The provisioning service provisions a single user. As such the act of provisioning a user involves discovering the cluster for the user who is to be provisioned and then directing the HTTP request there. This same basic pattern applies to other REST operations which involve a single user. Another example would be a user updating a profile picture of the user.

Solutions presented herein enable users to communicate with each other when they reside in different clusters. To enable this the solutions make use of a partitioning model which follows a common design pattern. This pattern applies to each of the HTTP services applications which provide communications. These include locus mercury and conversation depicted in .

With reference to there is a pictorial representation of an example design pattern that enables users provisioned on different clusters Cluster and Cluster to use services that communicate across the clusters. Each of these services e.g. locus mercury and conversation models communications as occurring through an object which is a RESTful resource that implements the service. In each RESTful resource is referenced as a generic resource where the resource may be a call or a conversation or a meeting or other communications events. This resource is created e.g. at in Cluster and in Cluster by the user that wishes to communicate. This creation process happens by invoking a REST endpoint that provides the creation service. A user always creates the resource within the cluster in which the user is provisioned and thus served.

According to the representation depicted in user would create the resource by accessing the creation service in user s own cluster Cluster . User would access the creation resource in its own cluster Cluster . As such the creation resource exists in all clusters. However once a specific resource is created a call or a chat conversation that represents a specific instance of the resource this resource always exists executes solely in the cluster in which the resource was created. As such the HTTP URL representing that resource instance includes in its domain name the cluster in which the resource exists along with the unique identifier for the resource. In the example of three of the resource instances instances and exist in Cluster and three of the instances instances and exist in Cluster . Once each resource instance is created the user that created the instance can add users to the instance representing the users that communications should take place with whether it is a call or a chat for example. These users are identified by email address. The resource instance then acting like a client accesses services in the cluster of those users reaching them by mapping their email addresses into a cluster name and accessing resources there however the communications session is never split across two resources the session always exists in one place. Resources accessed in the clusters of the other users are used strictly for messaging routing and bootstrapping to direct them back to the one resource instance where the communications session exists.

This pattern is best understood with specific embodiments for the communications services we have built.

A key primitive operation is the ability to asynchronously send information to a user. Examples of where this may be needed are to deliver an instant message to a user or to place a call to a user or to acknowledge receipt of a message. For mobile clients asynchronous information can also be sent using smartphone notification services examples being Apple s Push Notification Service APNS and Google s Cloud Messaging GCM .

These notifications are handled by Mercury. With reference to there is depicted an example Mercury architecture as implemented in the multi cluster model.

At the bottom of users represent end user client applications such as an application on a smartphone or a web browser client or a desktop application. These applications render the end user UX for the communications service.

In operation the user software application will establish a Websocket connection to a connection server in its own cluster e.g. Cluster A or B . The user discovers its own cluster during the login process as the login process starts with the email address which can be used to map to a cluster. As discussed previously starting with the email address the user software can find the connection server in its own cluster.

The user software connects to its connection server and through the websocket connection authenticates and requests a notification Uniform Resource Identifier URI . This notification URI can be used by any other application to send asynchronous messages to the user software over this websocket connection. That request is sent from the connection server to the API server over a message bus. The API server constructs a URL representing notification service for this device. This URI is of the form http clustername mercury.cloudprovider.com notifications . The API server knows the cluster in which the server resides and as such populates that cluster name e.g. Cluster A or B into the URL. This URL now will properly route to one of the API servers in the cluster for this user. As such any piece of software resolving this URL will get routed to the right place.

This URL is returned from the API server to the connection server to the client. The client now remembers this URI and can register it along with its APNS and or GCM URIs with a separate registry service not shown .

Let us now consider a communications service conversation. This is a chat service. It consists of chat rooms which are created as needed. We have a specific constraint however that for 1 1 chats there is just a single conversation between them. This emulates current behavior in most IM and mobile chat apps.

With reference to there is a diagram of example message exchanges used to setup a chat session between users provisioned on different clusters e.g. user Alice in a cluster who wishes to have a chat session with user Bob provisioned on a cluster .

First at Alice will create the conversation chat session with Bob. To do this Alice invokes the creation resource in cluster creating the conversation with Bob. Because this creation operation occurs in Alice s cluster the conversation instance exists now in Alice s cluster . As part of the creation process Alice will also specify the invitee as Bob Bob Gmail.com.

When the conversation service in cluster receives the request to create the conversation the service performs a few operations. First the service creates the conversation instance object Conv also revered to as a client rendezvous protocol object and stores it in the database.

Next the service recognizes that the other participant in the conversation is Bob Gmail.com. The service needs to first notify Bob of this new conversation. To do that the service needs to access the Mercury service for Bob and to do this the service first needs to discover Bob s cluster. In the manner described above at the service queries the local domain to cluster mapping service map Dom2 Cluster and discovers at that Gmail.com is not owned by any cluster in an embodiment the service may recognize known public domains like Gmail.com and Yahoo.com so as to avoid this step entirely .

At the service then queries the user to cluster mapping service map User Cluster Consumer for the consumer org and discovers at that Bob is in cluster .

Now the service needs to notify Bob of the existence of the conversation instance object Conv in cluster . To do this the service then constructs the URI to access the mercury service for cluster http c2 mercury.wbx2.com notifications Bob Gmail.com. At the service POSTS to this URL to request delivery of a notification and the notification is routed to the mercury service in cluster which knows of user Bob through the prior registration process. At the notification is delivered to Bob.

In Bob s cluster there exists a resource conversations users Bob Conv also referred to as an index protocol object which keeps track of the conversations in which Bob is a participant which may include maintaining pointers back to conversation instance objects such as Conv in other clusters and what the most recent few messages are for each of those. This resource the index protocol object Conv in cluster must now be updated by Alice s conversation service to indicate this new conversation now exists i.e. a pointer back to Conv in cluster must be added to the index protocol object in cluster . To support that at the conversation service in cluster does a POST to the conversation service in cluster adding an event for the creation of a new conversation.

When Bob receives the notification at he can launch his smartphone app. The app will query the conversation service in his cluster asking the cluster to return all recent conversation events. He does that by performing a GET to c2.wbx2.com conv users Bob Gmail which returns an object that indicates the recent events since last timestamp. In this case the returned events indicate creation of a new conversation and includes in the JSON response the URL reference to the actual conversation in cluster c1.wbx2.com conv uah387.

Now if Bob wants to send a message to Alice he does so by POSTing directly to this conversation object in cluster . Furthermore if Bob wants to fetch older messages in this conversation or add another user or upload a file all of those operations happen against the actual conversation instance in cluster . The conversation user resource Conv exists in cluster but Conv serves primarily as a reference to allow Bob to know across all of the other clusters the conversations he is a member of and which ones have recent activity. This conversation user resource Conv also allows Bob s smartphone app to quickly show to him the most recent few messages across all conversations that he is a member of without having to directly query each cluster to find out.

The conversation server in cluster will also locally update c2.wbx2.com conv users Bob Gmail Alice foo and that resource which identifies the conversation between Bob and Alice references c1.wbx2.com conv uah387. Similarly the conversation server in cluster will update c1.wbx2.com conv users Alice foo Bob Gmail and point to the same URL c1.wbx2.com conv uah387.

There is a race condition here of course if Alice and Bob should try to chat with each other for the first time at the same instance we will create two conversation objects in two different clusters. In such a case the one that is lower will win based on some kind of hash or timestamp or anything that provides a unique ordering. This is a cleanup operation after the fact.

In a similar way the conversation servers in clusters and will maintain search indexes for the conversation. However only the index in cluster is truly complete since the index will have indicate all messages since the beginning of this conversation if messages are sent and then much later another person is added to the conversation the index in the cluster of the new user will be incomplete. This requires a multi step search process which will necessarily result in the slowest search results when a user queries history for a conversation he was recently added to for which that conversation exists in a different cluster.

Calling works in much the same way as conversations described above. There is a call object which we call the locus. Like conversation there is a resource for construction of a call which lives in every cluster and the resource for each specific call lives only in a single cluster. This is true for both 1 1 calls and group calls. In that sense this architecture is what is often referred to as a full call model in the literature. The trick is to create an index in the cluster of the other user to allow these calls to be found and manipulated.

We described above the race condition that can exist when two users create a conversation with each other at the same time. This same race condition is possible for calls. However in the case of calls the race condition is far more likely and furthermore the race condition must be resolved very quickly. To address this problem we utilize a concept we call the persistent locus. The idea is that once a conversation between a pair of users is created establishing only a single conversation object between any pair of users there is also allocated a single locus. The way to think about this is that for each pair of users we basically have a persistent conference bridge that is created and unique for the pair. When user A wants to call user B what they are really doing is joining the bridge and then asking the other user to join the same bridge. Consequently this bridge model allows us to provide a user experience which is identical to the well understood calling experience. Yet the bridge model works well for inter cluster cases because there is a single source of truth for call state and a single rendezvous point a singular REST endpoint where both participants access. This means race conditions are resolved much quicker within the timespan of local DB replication within a single data center.

This persistent locus object is created at the time the conversation itself is created. The locus URL thus exists in the same cluster as where the conversation itself was created.

With reference to there is a diagram of example message exchanges when user Alice provisioned on cluster wants to call user Bob provisioned on cluster using the above mentioned locus technique.

At generally user Alice initiates the call in the following manner. User Alice may select Bob from a contact list available on an application app on Alice s smartphone for example. Alice clicks call from the app. The app will query her local conversation service Conv to find the existing 1 1 conversation with Bob. This uses the REST endpoint c1.wbx2.com conv users Alice foo Bob Gmail. As described above this query returns a pointer to their joint conversation which also lives in cluster c1.wbx2.com conv uah387.

General operation includes operations and . At Alice s client will connect to that conversation service instance Conv and query Conv for state. At the state is returned to Alice s client. This state will include the URL of the locus instance Locus for the two users which is c1.wbx2.com locus 9283747a. Note how this resource also lives in cluster this is because this locus instance was created by the conversation server in cluster when this conversation was first created.

Now Alice has the URL of the locus. At Alice invokes the locus asking the locus to activate and thus call Bob. The locus instance in cluster knows that Bob is the other participant. At the locus then follows a process identical to the conversation server flow above to discover Bob s cluster i.e. actions . At and the locus finds Bob s cluster creates the URL to notify him of the call sends the POST to the URL and creates the URL to update Bob s user object to indicate that this locus is now active. A result of the POST is the notify to Bob at .

Bob s phone rings when he receives the notify. The notification payload will contain the locus URL. If Bob ignores the notification on his smartphone and just launches his communications app anyway the app will start up. One of the first things the app does is to query c2.wbx2.com locus users Bob Gmail and retrieve its list of active loci. In this case the one locus c1.wbx2.com conv uah387 is listed. Bob can then query this locus resource find the state of this call in this case its state is alerting Bob which causes Bob s phone to show a ringing dialog. Bob presses answer. This causes his client to again POST to c1.wbx2.com conv uah387 and updates the state to active. Alice and Bob are now talking having rendezvoused through this locus call object in cluster .

When the call ends the locus instance in cluster will POST to the user resource in cluster updating the user resource in cluster to indicate that this call is now inactive.

With reference to there is a flowchart of an example method of establishing a stack fusion architecture for distributed communication services that enables communications between users according to an embodiment. A cloud provider provides SaaS offerings to multiple organizations based on the architecture services established in method .

At an IaaS platform including compute storage and network resources is deployed and configured in each of multiple data centers. Each data center is operated by a corresponding organization associated with an organization domain claimed by that organization.

At users that belong to each organization domain are provisioned registered only on the cluster uniquely associated with that organization domain.

At high level operation users provisioned on different clusters are enabled to communicate with each other as if the users were part of a centralized cloud communication service without sharing respective user information with the cloud provider e.g. without exposing user identities or private user information stored on a give cluster with the cloud provider. High level operation includes further operations described below.

At a globally accessible domain to cluster map is created to map each cluster to the organization domain uniquely associated therewith. Also a locally accessible user to cluster map to map a given cluster to each user provisioned on that cluster is stored in that cluster.

At a user request from a first user to communicate with a second user using a communication service is received.

At the user request is directed to the communication service in the cluster uniquely associated with the organization domain to which the first user belongs based on the user email address the domain to cluster map and the user to cluster maps.

With reference to there is a flowchart of an example method of user and cluster related mapping operations performed in the stack fusion architecture for distributed communication services established in method according to an embodiment.

At a globally accessible domain to cluster map used to map each cluster to the organization domain uniquely associated therewith is stored in the architecture established in method .

At a locally accessible user to cluster map is stored in each cluster to map that cluster to each user registered to the organization domain uniquely associated with that cluster.

At a consumer organization user to cluster map is stored with the cloud provider to map email addresses of users not registered to any organization domain uniquely associated with a cluster to other clusters to which the unregistered users have access.

At a user request is received for access to a software service e.g. communication service offered by the cloud provider the user request including a user email address which includes an organization domain and a user identifier identity .

At the user request is directed to the requested software service in a cluster uniquely associated with the organization domain to with the user is registered based on the user email address the domain to cluster map one of the user to cluster maps or the consumer organization map the direct resolves the user email address to the requested software service in the cluster .

With reference to there is a flowchart of directing operation from method according to an embodiment.

At the globally accessible domain to cluster map is searched for an organization domain that matches a domain of the user email address.

At if the search in finds an organization domain that matches the domain of the user email address an address is constructed for the requested software service based on the cluster mapped to the found organization domain which vectors the search to that cluster go to next operation .

At the locally accessible user to cluster map in the mapped cluster for the user identifier is searched and if the user identifier is found in the locally accessible user to cluster map the requested software services on that cluster is accessed.

At if the search of the globally accessible domain to cluster map at does not find an organization domain therein that matches the domain of the user email address the consumer organization user to cluster map is searched for a cluster that is mapped to the user email address.

At if the search of the consumer organization user to cluster map at finds a cluster mapped to the user email address an address is constructed for the requested software service based on the cluster mapped to the user email address which vectors access to the service in the cluster.

At the requested software service in the cluster mapped to the user email address based on the constructed address from is accessed.

With reference to there is a flowchart of an example method of communicating in a distributed communication services system as established in method . Method corresponds to the message diagram of .

At a request for a communication service is received from an originator registered to an originator cluster that includes identities of the originator and at least one participant.

At responsive to the request a communication protocol object rendezvous protocol object is created in the originator cluster that represents a communication session.

At the participant is notified via the participant cluster that the communication protocol object exists.

At an index protocol object in the participant cluster that tracks communication sessions in which the participant is engaged is updated with a reference that points to the communication protocol object in the originator cluster. A POST may be used to perform the update.

With reference to there is depicted a block diagram of an example generalized controller for an IaaS platform e.g. any of platforms P P in used in a data center to execute cluster applications and Ops tools and the like. Thus controller is an example of compute storage and network resources for the IaaS platform.

Controller includes a processor that processes instructions to perform operations for a given IaaS platform and a memory to store a variety of data and software instructions for execution by the processor . Controller also includes a network interface unit e.g. network interface card or multiple network interface cards that enables network communications so that the controller can communicate with other devices. Memory may comprise read only memory ROM random access memory RAM magnetic disk storage media devices optical storage media devices flash memory devices electrical optical or other physical tangible e.g. non transitory memory storage devices. The processor is for example a microprocessor or microcontroller that executes instructions for implementing the processes described herein. Thus in general the memory may comprise one or more tangible non transitory computer readable storage media e.g. a memory device encoded with software e.g. control logic software comprising computer executable instructions and when the software is executed by the processor it is operable to perform the operations described herein e.g. to implement the stack fusion processes methods and messages exchanges represented at and . In addition memory includes a data store or database to store data used and generated by logic .

In one form a method is provided comprising in a system in which a cloud provider is configured to provide Software as a Service SaaS offerings to multiple organizations each organization to operate a distinct Infrastructure as a Service IaaS platform and being associated with at least one distinct organization domain associated with the organization deploying to each IaaS platform a cluster of software services including communication services operated by the cloud provider each cluster being uniquely associated with the organization that operates that IaaS platform provisioning users that belong to each organization on the cluster associated with that organization wherein the provisioning includes storing user information for each user only on the associated cluster and enabling users provisioned on different clusters to communicate with each other as if the users were part of a centralized cloud communication service without sharing respective user information with the cloud provider.

In another form another method is provided comprising establishing a distributed Software as a Service SaaS system in which a cloud provider offers software services to multiple organizations each organization to operate a distinct cluster of software services of the cloud provider each cluster uniquely associated with an organization domain of the organization that operates the cluster wherein users registered to a given organization domain have access limited to the cluster associated with that organization domain storing a globally accessible domain to cluster map used to map each cluster to the organization domain uniquely associated therewith storing in each cluster a locally accessible user to cluster map to map that cluster to each user registered to the organization domain associated with that cluster so as to have access thereto receiving a user request for access to a software service offered by the cloud provider the user request including a user email address and directing the user request to the requested software service in a cluster uniquely associated with the organization domain to with the user is registered based on the user email address the domain to cluster map and one of the user to cluster maps.

In yet another form a system is provided comprising multiple infrastructure as a Service IaaS platforms each to be operated by a corresponding one of multiple organizations and being associated with at least one organization domain claimed by the organization that is to operate that IaaS platform multiple clusters of software services including communication services deployed on corresponding ones of the IaaS platforms and being uniquely associated with the organization domain corresponding to the organization that operates that IaaS platform on which the cluster is deployed wherein the software services include offerings from a cloud provider wherein users that belong to each organization domain are provisioned only on the cluster uniquely associated with that organization domain such that user information for each user is stored only on the associated cluster and wherein users provisioned on different clusters are enabled to communicate with each other as if the users were part of a centralized cloud communication service and without sharing respective user information with the cloud provider.

In yet another form a method is provided comprising at an originator cluster of software services including communication services in a distributed Software as a Service SaaS system including multiple clusters each associated with an organization that operates that cluster wherein participants registered to a given organization have access limited to the cluster uniquely associated with that organization receiving a request for a communication service from an originator registered to the originator cluster that includes identities of the originator and at least one participant responsive to the request creating a communication protocol object in the originator cluster that represents a communication session discovering a participant cluster on which the participant is registered notifying the participant via the participant cluster that the communication protocol object exists and updating an index protocol object in the participant cluster that tracks communication sessions in which the participant is engaged with a reference that points to the communication protocol object in the originator cluster.

In still another form an apparatus is provided comprising an originator platform including compute resources network resources and storage resources configured to host an originator cluster of software services including communication services in a distributed Software as a Service SaaS system including multiple clusters each uniquely associated with an organization domain claimed by a corresponding organization that operates that cluster wherein participants registered to a given organization domain have access limited to the cluster uniquely associated with that organization domain the compute resources including a processor to receive a request for a communication service from an originator registered to the originator cluster that includes identities of the originator and at least one participant responsive to the request create a communication protocol object in the originator cluster that represents a communication session discover a participant cluster on which the participant is registered notify the participant via the participant cluster that the communication protocol object exists and update an index protocol object in the participant cluster that tracks communication sessions in which the participant is engaged with a reference that points to the communication protocol object in the originator cluster.

In an even further form a tangible computer readable storage media is provided. The tangible computer readable storage media is encoded with instructions that when executed by a processor on which a cluster of software services including communication services is deployed in a distributed Software as a Service SaaS system including multiple clusters each associated with an organization domain corresponding to an organization that operates that cluster wherein participants registered to a given organization domain have access limited to the cluster uniquely associated with that organization domain cause the processor to receive a request for a communication service from an originator registered to the originator cluster that includes identities of the originator and at least one participant responsive to the request create a communication protocol object in the originator cluster that represents a communication session discover a participant cluster on which the participant is registered notify the participant via the participant cluster that the communication protocol object exists and update an index protocol object in the participant cluster that tracks communication sessions in which the participant is engaged with a reference that points to the communication protocol object in the originator cluster.

The above description is intended by way of example only. Various modifications and structural changes may be made therein without departing from the scope of the concepts described herein and within the scope and range of equivalents of the claims.

