---

title: Methods and systems for detection in a state machine
abstract: A device including a data analysis element including a plurality of memory cells. The memory cells analyze at least a portion of a data stream and output a result of the analysis. The device also includes a detection cell. The detection cell includes an AND gate. The AND gate receives result of the analysis as a first input. The detection cell also includes a D flip-flop including an output coupled to a second input of the AND gate.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09280329&OS=09280329&RS=09280329
owner: Micron Technology, Inc.
number: 09280329
owner_city: Boise
owner_country: US
publication_date: 20140711
---
This application is a Continuation application of U.S. patent application Ser. No. 13 327 580 entitled Methods and Systems for Detection in a State Machine filed Dec. 15 2011 now U.S. Pat. No. 8 782 624 which issued on Jul. 15 2014 which is herein incorporated by reference.

Embodiments of the invention relate generally to electronic devices and more specifically in certain embodiments to electronic devices with parallel finite state machines for pattern recognition.

Complex pattern recognition can be inefficient to perform on a conventional von Neumann based computer. A biological brain in particular a human brain however is adept at performing pattern recognition. Current research suggests that a human brain performs pattern recognition using a series of hierarchically organized neuron layers in the neocortex. Neurons in the lower layers of the hierarchy analyze raw signals from for example sensory organs while neurons in higher layers analyze signal outputs from neurons in the lower levels. This hierarchical system in the neocortex possibly in combination with other areas of the brain accomplishes the complex pattern recognition that enables humans to perform high level functions such as spatial reasoning conscious thought and complex language.

In the field of computing pattern recognition tasks are increasingly challenging. Ever larger volumes of data are transmitted between computers and the number of patterns that users wish to identify is increasing. For example spam or malware are often detected by searching for patterns in a data stream e.g. particular phrases or pieces of code. The number of patterns increases with the variety of spam and malware as new patterns may be implemented to search for new variants. Searching a data stream for each of these patterns can form a computing bottleneck. Often as the data stream is received it is searched for each pattern one at a time. The delay before the system is ready to search the next portion of the data stream increases with the number of patterns. Thus pattern recognition may slow the receipt of data.

Hardware has been designed to search a data stream for patterns but this hardware often is unable to process adequate amounts of data in an amount of time given. Some devices configured to search a data stream do so by distributing the data stream among a plurality of circuits. The circuits each determine whether the data stream matches a portion of a pattern. Often a large number of circuits operate in parallel each searching the data stream at generally the same time. However there has not been a system that effectively allows for performing pattern recognition in a manner more comparable to that of a biological brain. Development of such a system is desirable.

Turning now to the figures illustrates an embodiment of a processor based system generally designated by reference numeral . The system may be any of a variety of types such as a desktop computer laptop computer pager cellular phone personal organizer portable audio player control circuit camera etc. The system may also be a network node such as a router a server or a client e.g. one of the previously described types of computers . The system may be some other sort of electronic device such as a copier a scanner a printer a game console a television a set top video distribution or recording system a cable box a personal digital media player a factory automation system an automotive computer system or a medical device. The terms used to describe these various examples of systems like many of the other terms used herein may share some referents and as such should not be construed narrowly in virtue of the other items listed. 

In a typical processor based device such as the system a processor such as a microprocessor controls the processing of system functions and requests in the system . Further the processor may comprise a plurality of processors that share system control. The processor may be coupled directly or indirectly to each of the elements in the system such that the processor controls the system by executing instructions that may be stored within the system or external to the system .

In accordance with the embodiments described herein the system includes a state machine engine which may operate under control of the processor . The state machine engine may employ any one of a number of state machine architectures including but not limited to Mealy architectures Moore architectures Finite State Machines FSMs Deterministic FSMs DFSMs Bit Parallel State Machines BPSMs etc. Though a variety of architectures may be used for discussion purposes the application refers to FSMs. However those skilled in the art will appreciate that the described techniques may be employed using any one of a variety of state machine architectures.

As discussed further below the state machine engine may include a number of e.g. one or more finite state machine FSM lattices. Each FSM lattice may include multiple FSMs that each receive and analyze the same data in parallel. Further the FSM lattices may be arranged in groups e.g. clusters such that clusters of FSM lattices may analyze the same input data in parallel. Further clusters of FSM lattices of the state machine engine may be arranged in a hierarchical structure wherein outputs from state machine lattices on a lower level of the hierarchical structure may be used as inputs to state machine lattices on a higher level. By cascading clusters of parallel FSM lattices of the state machine engine in series through the hierarchical structure increasingly complex patterns may be analyzed e.g. evaluated searched etc. .

Further based on the hierarchical parallel configuration of the state machine engine the state machine engine can be employed for pattern recognition in systems that utilize high processing speeds. For instance embodiments described herein may be incorporated in systems with processing speeds of 1 GByte sec. Accordingly utilizing the state machine engine data from high speed memory devices or other external devices may be rapidly analyzed for various patterns. The state machine engine may analyze a data stream according to several criteria and their respective search terms at about the same time e.g. during a single device cycle. Each of the FSM lattices within a cluster of FSMs on a level of the state machine engine may each receive the same search term from the data stream at about the same time and each of the parallel FSM lattices may determine whether the term advances the state machine engine to the next state in the processing criterion. The state machine engine may analyze terms according to a relatively large number of criteria e.g. more than 100 more than 110 or more than 10 000. Because they operate in parallel they may apply the criteria to a data stream having a relatively high bandwidth e.g. a data stream of greater than or generally equal to 1 GByte sec without slowing the data stream.

In one embodiment the state machine engine may be configured to recognize e.g. detect a great number of patterns in a data stream. For instance the state machine engine may be utilized to detect a pattern in one or more of a variety of types of data streams that a user or other entity might wish to analyze. For example the state machine engine may be configured to analyze a stream of data received over a network such as packets received over the Internet or voice or data received over a cellular network. In one example the state machine engine may be configured to analyze a data stream for spam or malware. The data stream may be received as a serial data stream in which the data is received in an order that has meaning such as in a temporally lexically or semantically significant order. Alternatively the data stream may be received in parallel or out of order and then converted into a serial data stream e.g. by reordering packets received over the Internet. In some embodiments the data stream may present terms serially but the bits expressing each of the terms may be received in parallel. The data stream may be received from a source external to the system or may be formed by interrogating a memory device such as the memory and forming the data stream from data stored in the memory . In other examples the state machine engine may be configured to recognize a sequence of characters that spell a certain word a sequence of genetic base pairs that specify a gene a sequence of bits in a picture or video file that form a portion of an image a sequence of bits in an executable file that form a part of a program or a sequence of bits in an audio file that form a part of a song or a spoken phrase. The stream of data to be analyzed may include multiple bits of data in a binary format or other formats e.g. base ten ASCII etc. The stream may encode the data with a single digit or multiple digits e.g. several binary digits.

As will be appreciated the system may include memory . The memory may include volatile memory such as Dynamic Random Access Memory DRAM Static Random Access Memory SRAM Synchronous DRAM SDRAM Double Data Rate DRAM DDR SDRAM DDR2 SDRAM DDR3 SDRAM etc. The memory may also include non volatile memory such as read only memory ROM PC RAM silicon oxide nitride oxide silicon SONOS memory metal oxide nitride oxide silicon MONOS memory polysilicon floating gate based memory and or other types of flash memory of various architectures e.g. NAND memory NOR memory etc. to be used in conjunction with the volatile memory. The memory may include one or more memory devices such as DRAM devices that may provide data to be analyzed by the state machine engine . Such devices may be referred to as or include solid state drives SSD s MultimediaMediaCards MMC s SecureDigital SD cards CompactFlash CF cards or any other suitable device. Further it should be appreciated that such devices may couple to the system via any suitable interface such as Universal Serial Bus USB Peripheral Component Interconnect PCI PCI Express PCI E Small Computer System Interface SCSI IEEE 1394 Firewire or any other suitable interface. To facilitate operation of the memory such as the flash memory devices the system may include a memory controller not illustrated . As will be appreciated the memory controller may be an independent device or it may be integral with the processor . Additionally the system may include an external storage such as a magnetic storage device. The external storage may also provide input data to the state machine engine .

The system may include a number of additional elements. For instance a complier may be used to program the state machine engine as described in more detail with regard to . An input device may also be coupled to the processor to allow a user to input data into the system . For instance an input device may be used to input data into the memory for later analysis by the state machine engine . The input device may include buttons switching elements a keyboard a light pen a stylus a mouse and or a voice recognition system for instance. An output device such as a display may also be coupled to the processor . The display may include an LCD a CRT LEDs and or an audio display for example. They system may also include a network interface device such as a Network Interface Card NIC for interfacing with a network such as the Internet. As will be appreciated the system may include many other components depending on the application of the system .

The programmable elements can be programmed to implement many different functions. For instance the programmable elements may include state machine elements SMEs shown in that are hierarchically organized into rows shown in and blocks shown in . To route signals between the hierarchically organized SMEs a hierarchy of programmable switching elements can be used including inter block switching elements shown in intra block switching elements shown in and intra row switching elements shown in .

As described below the switching elements may include routing structures and buffers. A SME can correspond to a state of a FSM implemented by the FSM lattice . The SMEs can be coupled together by using the programmable switching elements as described below. Accordingly a FSM can be implemented on the FSM lattice by programming the SMEs to correspond to the functions of states and by selectively coupling together the SMEs to correspond to the transitions between states in the FSM.

In an example the input block the output block and or the programming interface can be implemented as registers such that writing to or reading from the registers provides data to or from the respective elements. Accordingly bits from the image stored in the registers corresponding to the programming interface can be loaded on the SMEs . Although illustrates a certain number of conductors e.g. wire trace between a block input block output block and an inter block switching element it should be understood that in other examples fewer or more conductors may be used.

In an example the row includes a first and second plurality of row interconnection conductors . In an example an input of a GOT can be coupled to one or more row interconnection conductors and an output can be coupled to one row interconnection conductor . In an example a first plurality of the row interconnection conductors can be coupled to each SME of each GOT within the row . A second plurality of the row interconnection conductors can be coupled to only one SME of each GOT within the row but cannot be coupled to the other SME of the GOT . In an example a first half of the second plurality of row interconnection conductors can couple to first half of the SMEs within a row one SME from each GOT and a second half of the second plurality of row interconnection conductors can couple to a second half of the SMEs within a row the other SME from each GOT as will be better illustrated with respect to . The limited connectivity between the second plurality of row interconnection conductors and the SMEs is referred to herein as parity . In an example the row can also include a special purpose element such as a counter a programmable Boolean logic element look up table RAM a field programmable gate array FPGA an application specific integrated circuit ASIC a programmable processor e.g. a microprocessor or other element for performing a special purpose function.

In an example the special purpose element comprises a counter also referred to herein as counter . In an example the counter comprises a 12 bit programmable down counter. The 12 bit programmable counter has a counting input a reset input and zero count output. The counting input when asserted decrements the value of the counter by one. The reset input when asserted causes the counter to load an initial value from an associated register. For the 12 bit counter up to a 12 bit number can be loaded in as the initial value. When the value of the counter is decremented to zero 0 the zero count output is asserted. The counter also has at least two modes pulse and hold. When the counter is set to pulse mode the zero count output is asserted during the clock cycle when the counter decrements to zero and at the next clock cycle the zero count output is no longer asserted. When the counter is set to hold mode the zero count output is asserted during the clock cycle when the counter decrements to zero and stays asserted until the counter is reset by the reset input being asserted.

In another example the special purpose element comprises Boolean logic. In some examples this Boolean logic can be used to extract information from terminal state SMEs corresponding to terminal nodes of a FSM as discussed later herein in FSM lattice . The information extracted can be used to transfer state information to other FSM lattices and or to transfer programming information used to reprogram FSM lattice or to reprogram another FSM lattice .

In an example a state machine element comprises a plurality of memory cells such as those often used in dynamic random access memory DRAM coupled in parallel to a detect line . One such memory cell comprises a memory cell that can be set to a data state such as one that corresponds to either a high or a low value e.g. a 1 or 0 . The output of the memory cell is coupled to the detect line and the input to the memory cell receives signals based on data on the data stream line . In an example an input on the data stream line is decoded to select one of the memory cells . The selected memory cell provides its stored data state as an output onto the detect line . For example the data received at the input block can be provided to a decoder not shown and the decoder can select one of the data stream lines . In an example the decoder can convert an 8 bit ACSII character to the corresponding 1 of 256 data stream lines .

A memory cell therefore outputs a high signal to the detect line when the memory cell is set to a high value and the data on the data stream line corresponds to the memory cell . When the data on the data stream line corresponds to the memory cell and the memory cell is set to a low value the memory cell outputs a low signal to the detect line . The outputs from the memory cells on the detect line are sensed by a detection cell .

In an example the signal on an input line sets the respective detection cell to either an active or inactive state. When set to the inactive state the detection cell outputs a low signal on the respective output regardless of the signal on the respective detect line . When set to an active state the detection cell outputs a high signal on the respective output line when a high signal is detected from one of the memory cells of the respective SME . When in the active state the detection cell outputs a low signal on the respective output line when the signals from all of the memory cells of the respective SME are low.

In an example an SME includes 256 memory cells and each memory cell is coupled to a different data stream line . Thus an SME can be programmed to output a high signal when a selected one or more of the data stream lines have a high signal thereon. For example the SME can have a first memory cell e.g. bit set high and all other memory cells e.g. bits set low. When the respective detection cell is in the active state the SME outputs a high signal on the output when the data stream line corresponding to bit has a high signal thereon. In other examples the SME can be set to output a high signal when one of multiple data stream lines have a high signal thereon by setting the appropriate memory cells to a high value.

In an example a memory cell can be set to a high or low value by reading bits from an associated register. Accordingly the SMEs can be programmed by storing an image created by the compiler into the registers and loading the bits in the registers into associated memory cells . In an example the image created by the compiler includes a binary image of high and low e.g. 1 and 0 bits. The image can program the FSM lattice to operate as a FSM by cascading the SMEs . For example a first SME can be set to an active state by setting the detection cell to the active state. The first SME can be set to output a high signal when the data stream line corresponding to bit has a high signal thereon. The second SME can be initially set to an inactive state but can be set to when active output a high signal when the data stream line corresponding to bit has a high signal thereon. The first SME and the second SME can be cascaded by setting the output of the first SME to couple to the input of the second SME . Thus when a high signal is sensed on the data stream line corresponding to bit the first SME outputs a high signal on the output and sets the detection cell of the second SME to an active state. When a high signal is sensed on the data stream line corresponding to bit the second SME outputs a high signal on the output to activate another SME or for output from the FSM lattice .

In an example a single FSM lattice is implemented on a single physical device however in other examples two or more FSM lattices can be implemented on a single physical device e.g. physical chip . In an example each FSM lattice can include a distinct data input block a distinct output block a distinct programming interface and a distinct set of programmable elements. Moreover each set of programmable elements can react e.g. output a high or low signal to data at their corresponding data input block . For example a first set of programmable elements corresponding to a first FSM lattice can react to the data at a first data input block corresponding to the first FSM lattice . A second set of programmable elements corresponding to a second FSM lattice can react to a second data input block corresponding to the second FSM lattice . Accordingly each FSM lattice includes a set of programmable elements wherein different sets of programmable elements can react to different input data. Similarly each FSM lattice and each corresponding set of programmable elements can provide a distinct output. In some examples an output block from a first FSM lattice can be coupled to an input block of a second FSM lattice such that input data for the second FSM lattice can include the output data from the first FSM lattice in a hierarchical arrangement of a series of FSM lattices .

In an example an image for loading onto the FSM lattice comprises a plurality of bits of information for configuring the programmable elements the programmable switching elements and the special purpose elements within the FSM lattice . In an example the image can be loaded onto the FSM lattice to program the FSM lattice to provide a desired output based on certain inputs. The output block can provide outputs from the FSM lattice based on the reaction of the programmable elements to data at the data input block . An output from the output block can include a single bit indicating a match of a given pattern a word comprising a plurality of bits indicating matches and non matches to a plurality of patterns and a state vector corresponding to the state of all or certain programmable elements at a given moment. As described a number of FSM lattices may be included in a state machine engine such as state machine engine to perform data analysis such as pattern recognition e.g. speech recognition image recognition etc. signal processing imaging computer vision cryptography and others.

Each of the nodes can be in either an active or an inactive state. When in the inactive state a node does not react e.g. respond to input data. When in an active state a node can react to input data. An upstream node can react to the input data by activating a node that is downstream from the node when the input data matches criteria specified by an edge between the upstream node and the downstream node . For example a first node that specifies the character b will activate a second node connected to the first node by an edge when the first node is active and the character b is received as input data. As used herein upstream refers to a relationship between one or more nodes where a first node that is upstream of one or more other nodes or upstream of itself in the case of a loop or feedback configuration refers to the situation in which the first node can activate the one or more other nodes or can activate itself in the case of a loop . Similarly downstream refers to a relationship where a first node that is downstream of one or more other nodes or downstream of itself in the case of a loop can be activated by the one or more other nodes or can be activated by itself in the case of a loop . Accordingly the terms upstream and downstream are used herein to refer to relationships between one or more nodes but these terms do not preclude the use of loops or other non linear paths among the nodes.

In the diagram the root node can be initially activated and can activate downstream nodes when the input data matches an edge from the root node . Nodes can activate nodes when the input data matches an edge from the node . Nodes throughout the diagram can be activated in this manner as the input data is received. A terminal node corresponds to a match of a sequence of interest by the input data. Accordingly activation of a terminal node indicates that a sequence of interest has been received as the input data. In the context of the FSM lattice implementing a pattern recognition function arriving at a terminal node can indicate that a specific pattern of interest has been detected in the input data.

In an example each root node standard node and terminal node can correspond to a programmable element in the FSM lattice . Each edge can correspond to connections between the programmable elements. Thus a standard node that transitions to e.g. has an edge connecting to another standard node or a terminal node corresponds to a programmable element that transitions to e.g. provides an output to another programmable element. In some examples the root node does not have a corresponding programmable element.

When the FSM lattice is programmed each of the programmable elements can also be in either an active or inactive state. A given programmable element when inactive does not react to the input data at a corresponding data input block . An active programmable element can react to the input data at the data input block and can activate a downstream programmable element when the input data matches the setting of the programmable element. When a programmable element corresponds to a terminal node the programmable element can be coupled to the output block to provide an indication of a match to an external device.

An image loaded onto the FSM lattice via the programming interface can configure the programmable elements and special purpose elements as well as the connections between the programmable elements and special purpose elements such that a desired FSM is implemented through the sequential activation of nodes based on reactions to the data at the data input block . In an example a programmable element remains active for a single data cycle e.g. a single character a set of characters a single clock cycle and then becomes inactive unless re activated by an upstream programmable element.

A terminal node can be considered to store a compressed history of past events. For example the one or more patterns of input data required to reach a terminal node can be represented by the activation of that terminal node . In an example the output provided by a terminal node is binary that is the output indicates whether the pattern of interest has been matched or not. The ratio of terminal nodes to standard nodes in a diagram may be quite small. In other words although there may be a high complexity in the FSM the output of the FSM may be small by comparison.

In an example the output of the FSM lattice can comprise a state vector. The state vector comprises the state e.g. activated or not activated of programmable elements of the FSM lattice . In an example the state vector includes the states for the programmable elements corresponding to terminal nodes . Thus the output can include a collection of the indications provided by all terminal nodes of a diagram . The state vector can be represented as a word where the binary indication provided by each terminal node comprises one bit of the word. This encoding of the terminal nodes can provide an effective indication of the detection state e.g. whether and what sequences of interest have been detected for the FSM lattice . In another example the state vector can include the state of all or a subset of the programmable elements whether or not the programmable elements corresponds to a terminal node .

As mentioned above the FSM lattice can be programmed to implement a pattern recognition function. For example the FSM lattice can be configured to recognize one or more data sequences e.g. signatures patterns in the input data. When a data sequence of interest is recognized by the FSM lattice an indication of that recognition can be provided at the output block . In an example the pattern recognition can recognize a string of symbols e.g. ASCII characters to for example identify malware or other information in network data.

The first FSM lattice A is configured to receive input data for example raw data at a data input block. The first FSM lattice A reacts to the input data as described above and provides an output at an output block. The output from the first FSM lattice A is sent to a data input block of the second FSM lattice B. The second FSM lattice B can then react based on the output provided by the first FSM lattice A and provide a corresponding output signal of the hierarchical structure . This hierarchical coupling of two FSM lattices A and B in series provides a means to transfer information regarding past events in a compressed word from a first FSM lattice A to a second FSM lattice B. The information transferred can effectively be a summary of complex events e.g. sequences of interest that were recorded by the first FSM lattice A.

The two level hierarchy of FSM lattices A B shown in allows two independent programs to operate based on the same data stream. The two stage hierarchy can be similar to visual recognition in a biological brain which is modeled as different regions. Under this model the regions are effectively different pattern recognition engines each performing a similar computational function pattern matching but using different programs signatures . By connecting multiple FSM lattices A B together increased knowledge about the data stream input may be obtained.

The first level of the hierarchy implemented by the first FSM lattice A can for example perform processing directly on a raw data stream. That is a raw data stream can be received at an input block of the first FSM lattice A and the programmable elements of the first FSM lattice A can react to the raw data stream. The second level implemented by the second FSM lattice B of the hierarchy can process the output from the first level. That is the second FSM lattice B receives the output from an output block of the first FSM lattice A at an input block of the second FSM lattice B and the programmable elements of the second FSM lattice B can react to the output of the first FSM lattice A. Accordingly in this example the second FSM lattice B does not receive the raw data stream as an input but rather receives the indications of patterns of interest that are matched by the raw data stream as determined by the first FSM lattice A. The second FSM lattice B can implement a FSM that recognizes patterns in the output data stream from the first FSM lattice A.

In an example the compiler includes an application programming interface API that allows software developers to create images for implementing FSMs on the FSM lattice . The compiler provides methods to convert an input set of regular expressions in the source code into an image that is configured to program the FSM lattice . The compiler can be implemented by instructions for a computer having a von Neumann architecture. These instructions can cause a processor on the computer to implement the functions of the compiler . For example the instructions when executed by the processor can cause the processor to perform actions as described in blocks and on source code that is accessible to the processor .

In an example the source code describes search strings for identifying patterns of symbols within a group of symbols. To describe the search strings the source code can include a plurality of regular expressions regexs . A regex can be a string for describing a symbol search pattern. Regexes are widely used in various computer domains such as programming languages text editors network security and others. In an example the regular expressions supported by the compiler include criteria for the analysis of unstructured data. Unstructured data can include data that is free form and has no indexing applied to words within the data. Words can include any combination of bytes printable and non printable within the data. In an example the compiler can support multiple different source code languages for implementing regexes including Perl e.g. Perl compatible regular expressions PCRE PHP Java and .NET languages.

At block the compiler can parse the source code to form an arrangement of relationally connected operators where different types of operators correspond to different functions implemented by the source code e.g. different functions implemented by regexes in the source code . Parsing source code can create a generic representation of the source code. In an example the generic representation comprises an encoded representation of the regexs in the source code in the form of a tree graph known as a syntax tree. The examples described herein refer to the arrangement as a syntax tree also known as an abstract syntax tree in other examples however a concrete syntax tree or other arrangement can be used.

Since as mentioned above the compiler can support multiple languages of source code parsing converts the source code regardless of the language into a non language specific representation e.g. a syntax tree. Thus further processing blocks by the compiler can work from a common input structure regardless of the language of the source code.

As noted above the syntax tree includes a plurality of operators that are relationally connected. A syntax tree can include multiple different types of operators. That is different operators can correspond to different functions implemented by the regexes in the source code.

At block the syntax tree is converted into an automaton. An automaton comprises a software model of a FSM and can accordingly be classified as deterministic or non deterministic. A deterministic automaton has a single path of execution at a given time while a non deterministic automaton has multiple concurrent paths of execution. The automaton comprises a plurality of states. In order to convert the syntax tree into an automaton the operators and relationships between the operators in the syntax tree are converted into states with transitions between the states. In an example the automaton can be converted based partly on the hardware of the FSM lattice .

In an example input symbols for the automaton include the symbols of the alphabet the numerals 0 9 and other printable characters. In an example the input symbols are represented by the byte values 0 through 255 inclusive. In an example an automaton can be represented as a directed graph where the nodes of the graph correspond to the set of states. In an example a transition from state p to state q on an input symbol i.e. p is shown by a directed connection from node p to node q. In an example a reversal of an automaton produces a new automaton where each transition p q on some symbol is reversed q p on the same symbol. In a reversal start state becomes a final state and the final states become start states. In an example the language recognized e.g. matched by an automaton is the set of all possible character strings which when input sequentially into the automaton will reach a final state. Each string in the language recognized by the automaton traces a path from the start state to one or more final states.

At block after the automaton is constructed the automaton is optimized to among other things reduce its complexity and size. The automaton can be optimized by combining redundant states.

At block the optimized automaton is converted into a netlist. Converting the automaton into a netlist maps each state of the automaton to a hardware element e.g. SMEs other elements on the FSM lattice and determines the connections between the hardware elements.

At block the netlist is placed to select a specific hardware element of the target device e.g. SMEs special purpose elements corresponding to each node of the netlist. In an example placing selects each specific hardware element based on general input and output constraints for of the FSM lattice .

At block the placed netlist is routed to determine the settings for the programmable switching elements e.g. inter block switching elements intra block switching elements and intra row switching elements in order to couple the selected hardware elements together to achieve the connections describe by the netlist. In an example the settings for the programmable switching elements are determined by determining specific conductors of the FSM lattice that will be used to connect the selected hardware elements and the settings for the programmable switching elements. Routing can take into account more specific limitations of the connections between the hardware elements that placement at block . Accordingly routing may adjust the location of some of the hardware elements as determined by the global placement in order to make appropriate connections given the actual limitations of the conductors on the FSM lattice .

Once the netlist is placed and routed the placed and routed netlist can be converted into a plurality of bits for programming of a FSM lattice . The plurality of bits are referred to herein as an image.

At block an image is published by the compiler . The image comprises a plurality of bits for programming specific hardware elements of the FSM lattice . In embodiments where the image comprises a plurality of bits e.g. 0 and 1 the image can be referred to as a binary image. The bits can be loaded onto the FSM lattice to program the state of SMEs the special purpose elements and the programmable switching elements such that the programmed FSM lattice implements a FSM having the functionality described by the source code. Placement block and routing block can map specific hardware elements at specific locations in the FSM lattice to specific states in the automaton. Accordingly the bits in the image can program the specific hardware elements to implement the desired function s . In an example the image can be published by saving the machine code to a computer readable medium. In another example the image can be published by displaying the image on a display device. In still another example the image can be published by sending the image to another device such as a programming device for loading the image onto the FSM lattice . In yet another example the image can be published by loading the image onto a FSM lattice e.g. the FSM lattice .

In an example an image can be loaded onto the FSM lattice by either directly loading the bit values from the image to the SMEs and other hardware elements or by loading the image into one or more registers and then writing the bit values from the registers to the SMEs and other hardware elements. In an example the hardware elements e.g. SMEs special purpose elements programmable switching elements of the FSM lattice are memory mapped such that a programming device and or computer can load the image onto the FSM lattice by writing the image to one or more memory addresses.

Method examples described herein can be machine or computer implemented at least in part. Some examples can include a computer readable medium or machine readable medium encoded with instructions operable to configure an electronic device to perform methods as described in the above examples. An implementation of such methods can include code such as microcode assembly language code a higher level language code or the like. Such code can include computer readable instructions for performing various methods. The code may form portions of computer program products. Further the code may be tangibly stored on one or more volatile or non volatile computer readable media during execution or at other times. These computer readable media may include but are not limited to hard disks removable magnetic disks removable optical disks e.g. compact disks and digital video disks magnetic cassettes memory cards or sticks random access memories RAMs read only memories ROMs and the like.

Referring now to an embodiment of the state machine engine is illustrated. As previously described the state machine engine is configured to receive data from a source such as the memory over a data bus. In the illustrated embodiment data may be sent to the state machine engine through a bus interface such as a DDR3 bus interface . The DDR3 bus interface may be capable of exchanging data at a rate greater than or equal to 1 GByte sec. As will be appreciated depending on the source of the data to be analyzed the bus interface may be any suitable bus interface for exchanging data to and from a data source to the state machine engine such as a NAND Flash interface PCI interface etc. As previously described the state machine engine includes one or more FSM lattices configured to analyze data. Each FSM lattice may be divided into two half lattices. In the illustrated embodiment each half lattice may include 24K SMEs e.g. SMEs such that the lattice includes 48K SMEs. The lattice may comprise any desirable number of SMEs arranged as previously described with regard to . Further while only one FSM lattice is illustrated the state machine engine may include multiple FSM lattices as previously described.

Data to be analyzed may be received at the bus interface and transmitted to the FSM lattice through a number of buffers and buffer interfaces. In the illustrated embodiment the data path includes data buffers process buffers and an inter rank IR bus and process buffer interface . The data buffers are configured to receive and temporarily store data to be analyzed. In one embodiment there are two data buffers data buffer A and data buffer B . Data may be stored in one of the two data buffers while data is being emptied from the other data buffer for analysis by the FSM lattice . In the illustrated embodiment the data buffers may be 32 KBytes each. The IR bus and process buffer interface may facilitate the transfer of data to the process buffer . The IR bus and process buffer ensures that data is processed by the FSM lattice in order. The IR bus and process buffer may coordinate the exchange of data timing information packing instructions etc. such that data is received and analyzed in the correct order. Generally the IR bus and process buffer allows the analyzing of multiple data sets in parallel through logical ranks of FSM lattices .

In the illustrated embodiment the state machine engine also includes a de compressor and a compressor to aid in the transfer of the large amounts of data through the state machine engine . The compressor and de compressor work in conjunction such that data can be compressed to minimize the data transfer times. By compressing the data to be analyzed the bus utilization time may be minimized. Based on information provided by the compiler a mask may be provided to the state machine engine to provide information on which state machines are likely to be unused. The compressor and de compressor can also be configured to handle data of varying burst lengths. By padding compressed data and including an indicator as to when each compressed region ends the compressor may improve the overall processing speed through the state machine engine . The compressor and de compressor may also be used to compress and decompress match results data after analysis by the FSM lattice .

As previously described the output of the FSM lattice can comprise a state vector. The state vector comprises the state e.g. activated or not activated of programmable elements of the FSM lattice . Each state vector may be temporarily stored in the state vector cache memory for further hierarchical processing and analysis. That is the state of each state machine may be stored such that the final state may be used in further analysis while freeing the state machines for reprogramming and or further analysis of a new data set. Like a typical cache the state vector cache memory allows storage of information here state vectors for quick retrieval and use here by the FSM lattice for instance. Additional buffers such as the state vector memory buffer state vector intermediate input buffer and state vector intermediate output buffer may be utilized in conjunction with the state vector cache memory to accommodate rapid analysis and storage of state vectors while adhering to packet transmission protocol through the state machine engine .

Once a result of interest is produced by the FSM lattice match results may be stored in a match results memory . That is a match vector indicating a match e.g. detection of a pattern of interest may be stored in the match results memory . The match result can then be sent to a match buffer for transmission over the bus interface to the processor for example. As previously described the match results may be compressed.

Additional registers and buffers may be provided in the state machine engine as well. For instance the state machine engine may include control and status registers . In addition restore and program buffers may be provided for using in programming the FSM lattice initially or restoring the state of the machines in the FSM lattice during analysis. Similarly save and repair map buffers may also be provided for storage of save and repair maps for setup and usage.

As illustrated in the detection cell may include a D flip flop . This D flip flop may operate to receive the unified enable input as well as a clock signal on input . Thus the D flip flop may drive a result on a Q output that may be the state of the unified enable input D input when a positive edge at the input clock input is received. In this manner the D flip flop allows the detection cell to be a clock enabled circuit that may only output a result of an analysis performed using memory cells of that SME at a prescribed time as will be discussed below. It should also be noted that the detection cell may include a set input that may be used to set the Q output to an active high signal and a reset input that may be used to set the Q output to an active low signal regardless of value of either of the unified enable input or clock signal on input .

The detection cell in may also receive a second input . As previously discussed this input may correspond to a detect line . This detect line may carry an analysis result e.g. a match result from one or more memory cells of the SME that corresponds to the detection cell . Thus a selected memory cell provides its stored data state as an output onto the detect line which is then transmitted to the detection cell as an analysis result. This result on detect line may be transmitted to an AND gate in the detection cell . Additionally the Q output may be transmitted to the AND gate . For example when both a qualified match on detect line occurs and the detection cell is activated e.g. is in the active state via the unified enable input a match result output will be output from the detection cell on output or output for the detection cell in the SME . This qualified match may represent for example a match in an analyzed data stream from a single SME which may be utilized in conjunction with other matches in other SMEs to search for for example a pattern in a data stream. Through the use of the D flip flop in the detection cell searches and results generated therefrom may be performed at predetermined times based on the clocking signal. Additionally control of when and which results are to be output e.g. on outputs from the SMEs may be accomplished e.g. through selected use of the unified enable input . Moreover this selective activation of the SMEs via unified enable input and unified enable input allows for results found in each of the SMEs to be utilized as part of an overall broader analysis of a data stream.

In one embodiment the local routing matrix may include a plurality of row routing lines and collectively referred to hereafter as row routing lines . In this manner the number of row routing lines may correspond to the number of GOTs in a given row. Thus in the illustrated embodiment there are sixteen row routing lines . However it should be appreciated that fewer or more row routing lines may be utilized in the local routing matrix .

Each of the row routing lines may be utilized to provide enable signals for any of the SMEs of one or more GOTs . Accordingly through use of these row routing lines any particular detection cell for any particular SME e.g. SME may be activated. This may be accomplished by selectively coupling e.g. via programming the row routing lines to unified enable inputs of the SMEs . Moreover to provide further flexibility in providing enable signals to the SMEs the row routing lines may be divided up amongst the two SMEs . For example row routing lines and may be utilized to activate each of the SMEs in the row . Additionally row routing lines and may used to transmit unified enable inputs to SMEs in row while row routing lines and may used to transmit unified enable inputs to SMEs in row . Thus for example up to twelve detection cells of SMEs of a total of sixteen detection cells of SMEs in a row may be directly addressed while the remaining detection cells may be addressed through the use of for example switching elements described above with respect to . In this manner the overall number of row routing lines may be reduced while still allowing for overall flexibility and the ability to activate any detection cell of any of the SMEs in a row .

Additionally it should be noted that includes intra group circuitry . An output of this intra group circuitry may be output which may transmit an output for a respective GOT . In one embodiment this output may be coupled to any of the row routing lines and for transmitting the output of the GOT reflecting any result generated in the active SMEs . Through use of row routing lines and common to the local routing matrix with the unified enable inputs of the SMEs for transmission of the output of the GOT the overall number of row routing lines may be reduced while still allowing for overall system flexibility.

It should be noted that the intra group circuitry of may include elements of the GOT previously discussed with respect to . The particular functionality and interconnection of these elements in the intra group circuitry will be discussed in greater detail with respect to .

The intra group circuitry in includes inputs and outputs which have been previously shown to be coupled to SMEs . It should be noted that the inputs and outputs are referred to with respect to their respective relationship to the SMEs and not necessarily their function in the intra group circuitry . Additionally the intra group circuitry includes an OR gate a 3 to 1 multiplexer and switching elements coupled to outputs respectively. As illustrated the switching element coupled to output may allow for the output of SME to be transmitted to the unified enable input of the SME for example to allow for cascading searches to occur. Additionally or alternatively the switching element coupled to output may allow for the unified enable input of SME to be transmitted to the unified enable input of the SME and or the output of the SME to be transmitted to the OR gate . As previously discussed allowing the unified enable input of SME to be transmitted to the unified enable input of the SME may allow for full addressing of all detection cell elements in the SMEs of a given row via sharing of the row routing lines .

Similarly the switching element coupled to output may allow for the output of SME to be transmitted to the unified enable input of the SME for example to allow for cascading searches to occur. Additionally or alternatively the switching element coupled to output may allow for the unified enable input of SME to be transmitted to the unified enable input of the SME and or the output of the SME to be transmitted to the OR gate . Again allowing the unified enable input of SME to be transmitted to the unified enable input of the SME may allow for full addressing of all detection cell elements in the SMEs of a given row via sharing of the row routing lines . Additionally while not illustrated it should be noted that the outputs can be looped back to the SMEs that generated the outputs by coupling the output to input via one switching element and coupling the output to input via the other switching element .

The 3 to 1 multiplexer of the intra group circuitry can be set to couple the output of the GOT to either a first SME a second SME or the OR gate which may be used to couple together both outputs of the SMEs to form the common output of the GOT . Thus the 3 to 1 multiplexer may include a first output select input and a second output select input . Thus these output select inputs may programmably select what output is transmitted on output . This programming may be accomplished for example based on a loaded image performed during an initial programming stage of the FSM lattice . illustrates a truth table that sets forth an example of how the output select inputs may programmably select the output of the GOT .

As shown in when both output select inputs are low i.e. 0 the output of the GOT will be a high impedance signal thus effectively preventing any value from being transmitted on output . When output select input is high i.e. 1 and output select input is low the output of the GOT will be the output of the first SME i.e. output . When output select input is low and output select input is high the output of the GOT will be the output of the second SME i.e. output . Finally when output select inputs are high the output of the GOT will be the output of the OR gate i.e. output logically ORed with output . In this manner the 3 to 1 multiplexer programmably select no output output output or output logically ORed with output as the output of the GOT . Furthermore it should be noted that the 3 to 1 multiplexer may operate in other programmable configurations not limited to the specific embodiment illustrated in .

While the invention may be susceptible to various modifications and alternative forms specific embodiments have been shown by way of example in the drawings and have been described in detail herein. However it should be understood that the invention is not intended to be limited to the particular forms disclosed. Rather the invention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the invention as defined by the following appended claims.

