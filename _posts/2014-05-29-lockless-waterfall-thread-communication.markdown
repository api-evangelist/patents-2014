---

title: Lockless waterfall thread communication
abstract: Systems and methods are disclosed for communicating state information of a session between a plurality of processing threads in a hierarchy. The session is passed down through the hierarchy, with one or more threads processing the session at each level of the hierarchy. An example method includes reading a first pointer of a first processing thread and comparing the first pointer to a second pointer of a second processing thread. The second processing thread is dependent on the first processing thread. The method also includes in response to determining that the first pointer does not match the second pointer, processing a set of configuration items in a session. The method further includes after processing the set of configuration items in the session, updating the second pointer of the second processing thread to match the first pointer of the first processing thread.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09256477&OS=09256477&RS=09256477
owner: NETAPP, INC.
number: 09256477
owner_city: Sunnyvale
owner_country: US
publication_date: 20140529
---
The present disclosure generally relates to computing devices and more particularly to communicating state information between process threads.

An application may include data that is shared between a pool of threads. A given program may have tens hundreds or thousands of threads some of which may operate simultaneously as appropriate. A process may have its own private virtual address space and run one or more threads within that virtual address space. As noted above some of the threads in a process may share data.

Before accessing shared data a thread may lock the shared data so that another thread cannot modify the shared data while it is being accessed to ensure coherency of the data being accessed. It may be desirable however to avoid the use of locks for a variety of reasons. To ensure that data accesses are thread safe a variable may be locked before it is updated. In such a scenario the lock may be abused by programmers and a higher risk of multiple threads and more complex interactions between the multiple threads may occur resulting in possible performance loss. The use of locks may provide for complex interactions between threads as well as overhead. It is known that multi threaded programming and lock management is a major complexity requiring skilled programmers to implement properly and efficiently. As code ages and goes through maintenance from different engineers who have varying degrees of expertise on a code block and who are required to minimize lines of codes LOC modified the use of the locks may become too conservative trading code performance for safety and lines of code changed.

Additionally a single concurrency program may manifest itself in many different ways such as deadlocks live locks or plain crashes. A deadlock occurs when two threads are sleeping both waiting for the other to finish using a resource that each of them needs and the two threads never wake up. A live lock is similar but involves active processing from the threads. Moreover performance issues commonly arise from using synchronization. A lock is a bottleneck as it introduces a critical section that can only be accessed by one thread at a time. The more threads trying to get at a critical section the more contention will arise as threads have to wait for their turn. Additionally critical sections may grow and prevent scaling the code implementations. If a lock is badly placed or covers too wide a section in the interest of easier debugging or just because of general laziness performance penalties may occur. In complex systems with many levels of locks a lock ordering mechanism can be implemented and its use may prevent deadlocks but may also increase the complexity of implementing access to data.

The purposes of locking data are to enforce coherency and preserve order in conflicting operations. Locking data however generates locking overhead. For example to lock and unlock shared data a few hundred instructions may need to be executed each time. To eliminate or minimize the disadvantages of locking data nonlocking based schemes exist that enforce coherency and preserve order in conflicting operations. For example a traditional nonlocking technique uses a timestamp approach for serializing the execution of concurrent transactions. In time stamping the execution order of concurrent transactions is defined before they begin their execution. The execution order is established by associating a unique timestamp e.g. an integer to every transaction. When two transactions conflict over data their timestamps are used to enforce serialization by rolling back one of the conflicting transactions.

Avoiding the use of data locks between threads may eliminate the risk of deadlocks and synchronization delays. Moreover a lockless approach may also prevent lazy programming that relies on coarse locks to enforce coherency which may eventually create a hidden scalability issue. Thus specific approaches avoiding locks are desirable for many applications.

Embodiments of the present disclosure and their advantages are best understood by referring to the detailed description that follows. It should be appreciated that like reference numerals are used to identify like elements illustrated in one or more of the figures. The drawing in which an element first appears is generally indicated by the left most digit in the corresponding reference number.

It is to be understood that the following disclosure provides many different embodiments or examples for implementing different features of the present disclosure. Some embodiments may be practiced without some or all of these specific details. Specific examples of components modules and arrangements are described below to simplify the present disclosure. These are of course merely examples and are not intended to be limiting.

The present disclosure provides techniques to communicate state information between a plurality of threads without locking session data in a session with the use of pointers. A session may be processed by multiple threads in accordance with an order. The present disclosure uses a lockless producer consumer approach and provides a lockless thread communication methodology that enables a pipeline of threads to transfer data representing a session of work via the use of pointers that are managed by the threads.

The pipeline arrangement of threads may be referred to as a waterfall in the examples below. The threads may be thought of as stateless because they wake up and view the state of the thread s pointer above them in the waterfall and perform actions based on the pointer s value. For example a consumer thread may be below a producer thread in the waterfall the hierarchy will be explained in further detail below and track the state of the pointer managed by the producer thread. In such an example the consumer thread reads the producer thread s pointer and performs actions based on its value. The producer thread and consumer thread may agree about the state of the session before it is published by the producer thread and used by the consumer thread. Such agreement is referred to in the examples below as a contract. Techniques provided in the present disclosure enable threads to manipulate session data in the session without locking the session data with the use of pointers. The consumer thread may determine the state of a session by reading the producer thread s pointer rather than by using locks on data in the session or other mechanism.

A producer thread and a consumer thread may each manage a pointer that is initialized to reference a particular value. The producer thread may process a session by processing a first set of configuration items in the session. After the producer thread is finished processing the first set of configuration items the producer thread may publish the session. The producer thread may publish the session by updating the producer thread s pointer to reference the session. Thus the memory address that the producer thread s pointer references has changed from referencing the initial value to referencing the session. Thus a change in the producer thread s pointer may represent a transition in the session state information.

To properly process the session the consumer thread may depend on the first set of configuration items being processed by the producer thread before the consumer thread starts to process the session. To ensure that the session is ready to be processed by the consumer thread the consumer thread may read the producer thread s pointer and determine whether the producer thread s pointer matches the consumer thread s pointer. In response to determining that the producer thread s pointer matches the consumer thread s pointer the consumer thread may use the session without further synchronization because no transition has occurred in the session state information. In an example the producer thread s pointer may match the consumer thread s pointer if both pointers reference their initialized values. In another example the producer thread s pointer may match the consumer thread s pointer if both pointers reference the same session. In such an example both the producer thread and consumer thread may have processed and published the session. They are free to use the session as long as they respect their contracts. A thread may read a field published as part of the contract. In an example one of the threads writes a field and other threads read the field. The field may be volatile so the consumer threads notice the producer thread has updated it. If multiple threads write a field proper synchronization is enforced for that field between the threads. In an example the field may be guarded by a lock or it may be another lockless synchronization for example using a volatile field.

In response to determining that the producer thread s pointer does not match the consumer thread s pointer the consumer thread processes a set of configuration items in the session. If the producer thread s pointer references a value that is different from the producer thread s initialized value then the producer thread has published a session that is ready to be consumed and processed by the consumer thread. After processing the set of configuration items in the session the consumer thread updates its pointer to match the producer thread s pointer.

Computing device may execute a process. A process is an instance of an executing program and may be defined by an operating system OS kernel not shown executing on computing device . System resources are allocated to a process in order to execute a program. From the kernel s point of view a process may include user space memory containing program code and variables used by that code and a range of kernel data structures that maintain information about the state of the process. The information recorded in the kernel data structures may include various identifier numbers IDs associated with the process a table of open file descriptors information relating to signal delivery and handling process resource usages and limits the current working directory and other information.

In the example illustrated in computing device executes a multi threaded activity. The activity is referenced herein as process but can be run within a user space process or program or as a logical component inside the kernel itself using kernel threads and kernel memory with a variable degree of interaction with other components of the OS. Multi threaded process includes a plurality of processing threads. Multi threading is a mechanism that permits the operating system or applications to perform multiple tasks concurrently. The plurality of processing threads includes actions performed by one or more computer processors while executing computer code. A processing thread may also be referred to as a thread.

In multi threaded process includes a plurality of threads including a rotator thread a scheduler thread one or more worker threads A C and a cleaner thread . Each of rotator thread scheduler thread worker threads A C and cleaner thread may execute in multi threaded process and may share the same global memory including initialized data uninitialized data and heap segments. Although six threads are illustrated as executing in multi threaded process this is not intended to be limiting and fewer or more than six threads may execute in multi threaded process .

Session includes session data and may be processed by the plurality of threads in multi processor . Other threads aside from those described in the present disclosure may execute in multi threaded process that do not perform work on session . A session may be implemented using a data structure e.g. a struct in the C programming language or a class in the C or JAVA programming languages etc. . Trademarks are the property of their respective owners. Session data may include one or more fields. In an example session is implemented using a struct in the C programming language and fields in session data are properties of the struct that may be read and modified. Session data includes a file descriptor work queue and work queue pointer which will be discussed in further detail below.

Session contains state information that is pertinent to the session and independent from another session. The state of a session is passed between threads. State information may include the state of all variables such as the values of fields in session . The fields may contain information needed by the tasks that the different threads perform. Multiple threads may access shared data in session and a thread that updates shared data accessible to multiple threads typically locks the data before updating it. Although a data lock ensures that the shared data is safe from manipulation by other threads or ensures that another thread will read the most up to date data a data lock causes overhead for each access to the shared data.

The present disclosure provides a communication methodology to communicate session state information between a plurality of processing threads using a lockless producer consumer approach. The communication methodology may enforce the use of a pipeline or a hierarchy of threads to represent a session of work referenced herein as a waterfall. In an example an order of operations based on a hierarchy is enforced on a session such that a first thread at the top of hierarchy performs a first set of actions on the session before a second thread that is below the first thread performs a second set of actions on the session. In rotator thread is at a top of hierarchy scheduler thread is one level below rotator thread worker threads A C are one level below scheduler thread and cleaner thread is one level below worker threads A C. Although hierarchy is described as having four levels this is not intended to be limiting and hierarchy may include two or more levels.

The plurality of threads in multi threaded process may process session data in session in accordance with hierarchy . State information in a session may be passed between processing threads and the processing threads can manipulate data without locking data in the session. In an example a plurality of threads may be launched and each of the plurality of threads may manage a pointer that is visible to one or more other threads. Session state information may be passed with the use of pointers. The pointers may be used as a mechanism to synchronize data between threads and it may be unnecessary to lock the data in session . For example a thread may read the pointer of another thread to determine a state of the session. By passing the state information in the context of pointers managed by threads the use of locks may be avoided. A thread s pointer may refer to the pointer that is managed by the thread and modifiable by the thread.

A thread that is at a level below a higher thread in the hierarchy may be thought of as a consumer of the higher thread. Similarly the higher thread may be thought of as a producer thread that processes and produces data in session . The consumer thread may be dependent on the producer thread because the consumer thread consumes data that is produced by the producer thread. In an example session data includes a set of configuration items and the producer thread processes the set of configuration items that is eventually consumed by the consumer thread. The set of configuration items may span one or more fields in session data . In processing session data e.g. the set of configuration items the producer thread may modify one or more fields in session data e.g. file descriptor work queue or work queue pointer upon which the consumer thread is dependent upon.

The producer and consumer threads may be bound to a contract in which the producer thread agrees to process a particular set of configuration items in the session before the producer thread publishes the session. A set of configuration items in a session may refer to the work items that need to be processed by the producer thread in order for the session to be useable by a consumer thread such that the consumer thread can perform its work on the session. Under the contract the producer thread agrees to not change any of the data that the consumer thread needs to be immutable. The producer thread publishes a session when it is safe for a thread below the producer thread to consume the session. If the producer thread does not process the particular set of configuration items on which the consumer thread depends before publishing the session the consumer thread may consume invalid data or corrupt data.

Publishing a session is a contract that eliminates contention between threads when making use of the data in session . The producer thread abides by the contract agreement with the consumer thread such that before the producer thread publishes the session the producer thread has finished processing the set of configuration items on which the consumer thread depends. After the producer thread publishes the session a consumer thread may then process session data in session and may complete its own tasks. Additionally after the producer thread publishes the session the producer thread may continue to perform some work on the session that the consumer thread does not depend on or which has separate synchronization contracts. For example session data may include other fields that are consumed by consumer thread and producer thread may modify these fields.

The pointers managed by the plurality of threads may be initialized to reference a particular value. In an example the pointers managed by the plurality of threads are initialized to reference a common value. In the example illustrated in the common value is a null value which is represented by an X . Rotator thread manages a pointer that is initialized to reference a null value scheduler thread manages a pointer that is initialized to reference a null value worker thread A manages a pointer A that is initialized to reference a null value worker thread B manages a pointer B that is initialized to reference a null value worker thread C manages a pointer C that is initialized to reference a null value and cleaner thread manages a pointer that is initialized to reference a null value.

Additionally each worker thread may be designated a memory buffer. For example worker thread A may be designated memory buffer A worker thread B may be designated memory buffer B and worker thread C may be designated memory buffer C. Each worker thread may manage its own memory buffer and may write data to its designated memory buffer. A memory buffer may be a global variable or may be in the session.

The pointers managed by the threads may be manipulated such that the data structure that represents a session is stored in only one place in memory. The communication of session state information between a plurality of processing threads is described in relation to global pointers that are visible to threads in a process. As discussed each thread may manage a pointer and publish one or more sessions. A thread is independent of a session and consumes and processes session data in one or more sessions. A producer thread may publish a session by updating the producer thread s pointer to reference the session thus providing an indication that a state of the session has been updated and the session is ready for consumption by the next one or more consumer threads after the producer thread in hierarchy .

When a pointer references a session the pointer references a particular memory address associated with the session. In an example the pointer may reference the starting memory address of the session. After the producer thread updates its pointer to reference session the consumer thread may recognize that the producer thread s pointer has changed and use this as an indication that the set of configuration items in session data upon which consumer thread depends has been processed. As such session is ready for the consumer thread to process the updated session data . In this way a producer thread may use its pointer to communicate state information of a session to a consumer thread.

Each thread in multi threaded process may manage a global pointer that is visible to one or more of the other threads in multi threaded process . Each thread may expose a global pointer that is shared with another thread and can be read by the other thread. A producer thread may manage a shared pointer that is shared with the consumer threads below it in hierarchy . For example rotator thread s pointer may be managed by rotator thread and shared between rotator thread and scheduler thread such that scheduler thread is able to read pointer . Similarly scheduler thread s pointer may be managed by scheduler thread and shared between scheduler thread and worker threads A C such that worker threads A C are able to read pointer . Similarly a worker thread s pointer may be managed by the worker thread and shared between the worker thread and cleaner thread such that cleaner thread is able to read the worker thread s pointer. Lastly it is possible of any other relationship. For example the scheduler thread may spy on the state of the cleaner session pointer .

Hierarchy may be thought of as a waterfall that indicates how a session will be passed down through the threads. The threads may be thought of as stateless because they wake up and view the state of the thread above them in the waterfall via the pointers. A consumer thread performs actions based on its shared pointer with the producer thread and tracks the state of the shared pointer. Additionally a consumer thread may manage a shared pointer that is shared with the one or more threads above it in hierarchy . For example scheduler thread s pointer may be managed by scheduler thread and shared between rotator thread and scheduler thread such that rotator thread is able to read pointer . Similarly worker thread A s pointer may be managed by worker thread A and shared between rotator thread scheduler thread and worker thread A such that rotator thread and scheduler thread are able to read pointer A. Similarly cleaner thread s pointer may be managed by cleaner thread and shared between rotator thread scheduler thread worker threads A C and cleaner thread such that rotator thread scheduler thread and worker threads A C are able to read pointer .

Embodiments of the invention may make it unnecessary to lock shared fields in the session to enforce coherency as the data from previous threads in the waterfall is guaranteed to be set when the session becomes accessible. A thread may modify a field without locking the field as only one thread is allowed to modify the field independent of the number of consumers of the field. The use of the waterfall approach may enable the spawning of more threads for processing the session at one level in order to parallelize the work on the session as will be discussed in further detail below. Additionally the use of the waterfall approach may enable the scheduling and throttling of activities by programming wake up times for the threads.

In an embodiment the pointer is a volatile pointer. A volatile pointer is a pointer for which the compiler is not allowed to optimize the memory accesses because it can be modified asynchronously by other threads processes. In an example a volatile pointer may be implemented in the C or C programming language by using the keyword volatile e.g. volatile foo bar 0 . A change to the volatile pointer managed by a thread is visible to the other threads in multi threaded process . A consumer thread down the waterfall may poll the pointer of the producer thread above the consumer thread and notice that a session has been published and is safe for consumption. The use of the waterfall methodology may aid in designing a software pipeline having multiple threads in flight and each handling a portion of the processing. The throttling of thread activity may be inherent to the design with the rhythm of processing being set by the production of pointers. A producer thread can further signal consumer thread s so they detect the availability of a new session pointer before the polling cycle repeats or in lieu of polling.

Method includes blocks . In a block a first pointer of a first processing thread is read. Blocks may be implemented via a second processing thread. In an example the first processing thread is rotator thread and scheduler thread reads rotator thread s pointer. In such an example scheduler thread may be a consumer thread that wakes up and reads rotator thread s volatile pointer.

In a block the first pointer of the first processing thread is compared to a second pointer of a second processing thread the second processing thread being dependent on the first processing thread. In an example scheduler thread compares rotator thread s volatile pointer to scheduler thread s volatile pointer. If rotator thread s volatile pointer matches scheduler thread s volatile pointer either the pointers both reference a null value or both reference a common session. If rotator thread s volatile pointer does not match scheduler thread s volatile pointer a transition has occurred and rotator thread has updated its pointer to reference a session. As such rotator thread has processed a first set of configuration items in session data and session is ready for scheduler thread to consume session .

In a block in response to determining that the first pointer of the first processing thread does not match the second pointer of the second processing thread a set of configuration items in a session is processed. The set of configuration items may be relied upon by one or more threads at a level lower than the second processing thread in the hierarchy. In an example the second processing thread e.g. consumer thread may depend on the first processing thread e.g. producer thread processing a first set of configuration items in session data before the second processing thread starts to process session . In response to determining that rotator thread s volatile pointer does not match scheduler thread s volatile pointer scheduler thread processes a second set of configuration items in session . The second set of configuration items may be different from the first set of configuration items.

In a block after the set of configuration items in the session is processed the second pointer of the second processing thread is updated to match the first pointer of the first processing thread. In an example after scheduler thread processes the second set of configuration items in session scheduler thread updates pointer to match pointer which references session . Accordingly rotator thread s pointer and scheduler thread s pointer will reference session .

It is understood that additional processing may be performed before during or after blocks discussed above. It is also understood that one or more of the blocks of method described herein may be omitted combined or performed in a different sequence as desired. The passing of the session state information via the use of pointers may continue until the last thread in the hierarchy processes session data . Accordingly one or more consumer thread may implement blocks .

The following description may describe each of the threads as being responsible for performing particular actions but this is merely an example and threads may be responsible for performing other actions different from those described. In an example process is the operating system OS kernel executing in computing device and it generates archive files including performance data of subsystems. The OS kernel may desire to collect information over time about different subsystems associated with computing device .

A session relates to all the data needed to configure and track an archive file that is created updated and closed. The archive file stores all of the performance statistics from multiple components executing on a node. Referring back to examples of subsystems are NIC processor volume and disk . A subsystem may run and accrue values and counters that may be monitored to determine the performance of the subsystem. An archive file is a file that is to be stored on disk and may contain performance data of one or more subsystems during a period of time. In an example thousands of performance metrics are collected from the subsystems every second e.g. NIC processor disk controller and hard disk and stored in the archive file spanning 15 minutes intervals.

The plurality of processing threads in multi threaded process may create an archive file collect performance metrics and information from different subsystems and store the performance data in the archive file with a processing thread at each layer of the waterfall performing some work on session pertaining to the archive file. The information stored in the archive file may represent a history of the performance of subsystems in order to analyze them. Thus if a problem occurs subsystem performance counters may be analyzed to diagnose the problem. In an example worker threads A C may perform work on session in order to collect performance metrics and then pass the session to cleaner thread to write the performance data to disk . Sessions may be shared among the plurality of processing threads and session data may be processed without locking session data in the session.

Although the description may describe the threads executing in multi threaded process in the context of an archive file and the collection of performance data this is not intended to be limiting. Rather the archive file and collection of performance data are used as an example use case that may benefit from the teachings in the present disclosure.

In rotator thread s pointer scheduler thread s pointer worker thread A C s pointers and cleaner thread s pointer reference a null value. Rotator thread may be a producer thread for the scheduler thread in hierarchy which processes session data in session . In such an embodiment the rotator thread creates the archive file initializes it and updates the session data before updating the rotator thread session pointer . The scheduler thread detects the new session clears the work queues and publishes it for the worker threads to use by updating the scheduler session pointer . Scheduler thread then proceeds to update the work queues repeatedly so worker threads can perform the work until a new session is published in the rotator thread pointer .

In method includes blocks . In a block a session producer thread wakes up. In an example the session producer thread is rotator thread . After a time period rotator thread may awaken every 15 minutes. This is merely an example and the time period in which rotator thread sleeps and awakens may vary.

When the session producer thread wakes up process flow may proceed to a block . In block the session producer thread determines whether to publish a new session to its consumer threads below it in the waterfall before proceeding to perform its own work in block . In an example if rotator thread obtains a configuration notification to create a session with new data rotator thread creates session . Otherwise rotator thread creates a new session to create a new archive but using the same configuration. The configuration notification may include information on how to build a session general parameters for the session and how to initialize the session.

Other heuristics may be implemented. For example an embodiment the scheduler thread wakes up and if it receives a new session pointer in step scheduler thread may decide to publish the new session to its consumers. In a block scheduler thread may update the session with the configuration it needs to do in this case initialize the work queues for the worker threads. Scheduler thread then proceeds to publish the session in block and then performs work on the session in block which may include activating some of the work queues before going to block .

In a block if the session producer thread determines no further work is to be performed the session producer thread may go back to sleep. After a time period has elapsed in block process flow proceeds to block where the producer thread wakes up.

If the session producer thread determines to publish a new session process flow proceeds to a block . In block the session producer thread prepares a session so it can be used by the consumer threads. The session producer thread may prepare the session by initializing it. After the session producer thread initializes the session process flow proceeds to a block . In block the session is published by updating the producer thread s session pointer. In an example rotator thread is the session producer thread and creates and prepares session . As session is being created memory addresses are newly allocated from memory for session . Session is self contained and contains information e.g. session data that is needed for threads e.g. scheduler thread and worker threads A C to perform work on session .

Session data may include a first set of configuration items on which a thread that is located at a level below rotator thread in hierarchy depends. Rotator thread may process session data by processing the first set of configuration items. In an example session data includes data related to the archive file and rotator thread rotates archive files every 10 15 minutes. Rotator thread creates and initializes the archive file so that session is ready to be pushed down hierarchy . In an example rotator thread creates session and processes the first set of configuration items in session data by opening an archive file associated with session creating data in memory that tracks the file and obtaining a file descriptor that enables writing to the file. An input output I O system call refers to open files using a file descriptor. A file descriptor may be obtained by a system call e.g. the open system call which takes a pathname argument specifying a file upon which I O is to be performed.

In the example illustrated in session data includes a field for file descriptor and rotator thread may process the first set of configuration items by setting file descriptor to open to enable writing to the archive file. Scheduler thread is dependent on rotator thread processing the first set of configuration items e.g. file descriptor being set to open in order to start and finish its own tasks.

If the producer thread has finished processing the first set of configuration items process flow proceeds to a block . In block the session is published. In keeping with the above example if rotator thread has created session opened an archive file associated with session created data in memory that tracks the file and set file descriptor in session data to open rotator thread may publish session . Rotator thread may publish session by updating rotator thread s pointer to reference session .

It is understood that additional processes may be performed before during or after blocks discussed above. It is also understood that one or more of the blocks of method described herein may be omitted combined or performed in a different sequence as desired.

For example method may include a block that initializes the session pointer to null. In such an example when the session is published block the session pointer may be initialized to null. Additionally when it is determined to publish a new session block the session pointer may be initialized to null. After the session pointer may be initialized to null it may be determined whether there is more session data to process. In response to determining that there is more session data to process process flow may proceed to block . In response to determining that there is no more session data to process process flow may proceed to block .

In method includes blocks . In a block a consumer thread wakes up. In an example the consumer thread is scheduler thread . Although the consumer thread is described as being scheduler thread it should be understood that the consumer thread may be any thread in hierarchy that consumes data that is produced by a producer thread.

After a time period scheduler thread may awaken. In an example scheduler thread awakens every second. In such an example scheduler thread may wake up and perform work every second depending on configuration of the session. This is merely an example and the time period in which scheduler thread sleeps and awakens may vary.

When the consumer thread wakes up process flow may proceed to a block . In block it is determined whether a producer thread s pointer e.g. the thread above the consumer thread in hierarchy matches the consumer thread s pointer. In an example scheduler thread reads rotator thread s pointer and compares it to scheduler thread s pointer. If rotator thread s pointer and scheduler thread s pointer reference the same memory address scheduler thread may determine that rotator thread s pointer and scheduler thread s pointer match. In contrast if rotator thread s pointer and scheduler thread s pointer reference different memory addresses scheduler thread may determine that rotator thread s pointer and scheduler thread s pointer do not match.

In response to determining that the producer thread s pointer matches the consumer thread s pointer in block the consumer thread may perform work in block . Once the work is done the thread may determine to go to sleep in block . After a time period has elapsed in block process flow proceeds to block where the consumer thread wakes up after the time period has elapsed. Rotator thread s pointer and scheduler thread s pointer may match for example if they both reference the null value in which case no work will be done in block see or if they both reference a common session in which case the consumer thread will perform a task in block based on the content of the session data see . In an example if rotator thread s pointer and scheduler thread s pointer both reference a null value then scheduler thread has nothing to do yet and can go back to sleep. In such an example rotator thread may not have created and published session yet or rotator thread may have already created session but has not yet processed the first set of configuration items upon which scheduler thread depends and hence not yet published it in pointer . In another example if rotator thread s pointer and scheduler thread s pointer both reference a common session then scheduler thread has already processed a set of configuration items on which consumer threads of scheduler thread depend and has already published session .

In a block in response to determining that the producer thread s pointer does not match the consumer thread s pointer the consumer thread may further initialize the session data pointed to by the producer thread s pointer before in turn publishing the session by copying the producer thread s session pointer in the consumer thread s session pointer in block . By doing so the consumer thread informs other threads that it is processing the session. Process flow then proceeds to block and processes the session in a similar manner as described in above.

In an example rotator thread s pointer and scheduler thread s pointer do not match if they reference different sessions see . In another example rotator thread s pointer and scheduler thread s pointer do not match if rotator thread s pointer references a session while scheduler thread s pointer references a null value. For example in rotator thread s pointer and scheduler thread s pointer do not match because rotator thread s pointer references session while scheduler thread s pointer references a null value. When the producer rotator thread s pointer does not match the consumer scheduler thread s pointer scheduler thread knows that the first set of configuration items performed by the rotator thread in the session has been processed and it is scheduler thread s turn to process session data in session . Scheduler thread will eventually update its pointer to match the rotator thread s session pointer after performing a second set of initializations to the session data during block . It is important to note that while scheduler thread s pointer is illustrated as referencing a null value scheduler thread may be in the process of processing session data .

The producer thread manages its own global pointer and shares the global pointer with the consumer thread. No other thread is allowed to modify its global pointer. The producer thread shares the global pointer with the consumer threads so that the consumer threads are able to read the producer thread s global pointer. Additionally the consumer thread manages its own global pointer. No other thread is allowed to modify its global pointer. A consumer thread may share its global pointer with the producer threads if they want to know the state of the consumer thread. The consumer thread may also share the consumer thread s global pointer with other threads lower in the waterfall which in turn consume data produced by the consumer thread. A thread may be both a producer and a consumer thread.

The consumer thread also has its own local pointers. In response to determining that the producer thread s global pointer does not match the consumer thread s global pointer the consumer thread may copy the value of the producer thread s global pointer into a local pointer of the consumer thread. As such the consumer thread may have a local pointer that references session and may manipulate the pointer locally. The consumer thread may modify session data using the local pointer. When the consumer thread is finished modifying session data the consumer thread may copy its local pointer to the consumer thread s global pointer that is shared with the next one or more threads below the consumer thread in hierarchy . Accordingly the next one or more threads is able to determine that session is ready for processing by it.

Scheduler thread may process session data by processing a second set of configuration items. In session includes file descriptor work queue and work queue pointer field . In an example scheduler thread processes the second set of configuration items by initializing work queue placing one or more work items in work queue and clearing work queue pointer until there are no more work queue items to process. Scheduler thread modifies the state of session s work queue to schedule work and may also time stamp the session. Scheduler thread initializes work queue and work queue pointer so that session is ready to be pushed down hierarchy and processed by threads below scheduler thread in the hierarchy. This may complete the work for block . The scheduler thread in block then updates the scheduler thread session pointer to point to the session and then proceeds in block to schedule work by setting the work queue pointer to reference the first work item to be processed in the work queue . Scheduler thread may awaken worker threads to process work items in work queue and worker threads may go to sleep when they are done.

In an example a work item is an invocation of a subsystem application programming interface API to obtain a subsystem s performance statistics and metrics. Work queue pointer may be updated by scheduler thread and or the worker threads as the work items are being processed from work queue until the work queue is empty at which point the worker threads may go to sleep.

Referring back to if the consumer thread has finished processing the second set of configuration items process flow proceeds to a block . In block the session is published. Worker threads A C may be dependent on work queue and work queue pointer being initialized in order to start and finish their tasks. If scheduler thread has initialized work queue placed one or more work items in work queue and initialized work queue pointer to reference the first work item to be processed in work queue scheduler thread may publish session . Scheduler thread may publish session by updating scheduler thread pointer s to reference session .

After scheduler thread publishes session threads below scheduler thread in hierarchy may recognize that state information in session has changed and may process session in turn as session moves down hierarchy . At this point worker threads A C know that the second set of configuration items has been processed e.g. work queue and work queue pointer have been initialized because scheduler thread has published session and henceforth the session is in a valid state for the worker threads A C. After scheduler thread publishes session worker threads A C may consume and process session data in session including the data produced by scheduler thread .

It is understood that additional processes may be performed before during or after blocks discussed above. It is also understood that one or more of the blocks of method described herein may be omitted combined or performed in a different sequence as desired. In an example when scheduler thread wakes up it may determine whether to reset any of the fields in session data . For example scheduler thread may determine whether to reset work queue in session data .

In another example method may enable the consumer thread to run until its task is completed. In another example the consumer thread is allowed to run for a given period of time and after the given period of time elapses the consumer thread goes to sleep. In such an example when the consumer thread wakes up it may determine whether there is session data to be processed in a session. If the consumer thread determines that there is no session data in a session to process process flow may proceed to block and the consumer thread may go back to sleep. In contrast if the consumer thread determines that there is session data in a session to process process flow may proceed to block . For example scheduler thread may continue to process session data from where scheduler thread left off before it went to sleep. The consumer thread may determine that there is session data to be processed in a session if for example the consumer thread went to sleep before it was done processing the session for consumption by the threads below the consumer thread in hierarchy .

In method includes blocks . The following is a description of worker thread A. This description applies as well to other worker threads e.g. worker thread B or C . In a block a worker thread wakes up. After a time period worker thread A may awaken. The worker thread may awaken when a work item is placed in work queue and may go to sleep when no more work items are in work queue . In an example worker thread A awakens every ten seconds or earlier by a signal from the scheduler thread if session is ready to be processed by worker thread A. This is merely an example and the time period in which any particular worker thread sleeps and awakens may vary.

When the worker thread wakes up process flow may proceed to a block . In block it is determined whether a producer thread s pointer e.g. the thread above the worker thread in hierarchy matches the worker thread s pointer. In an example worker thread A reads scheduler thread s pointer and compares it to worker thread A s pointer. If scheduler thread s pointer and worker thread A s pointer reference the same memory address worker thread A may determine that scheduler thread s pointer and worker thread A s pointer match. In contrast if scheduler thread s pointer and the worker thread A s pointer reference different memory addresses worker thread A may determine that scheduler thread s pointer and worker thread A s pointer do not match.

In a block in response to determining that work queue pointer is null and that there no more items to process in work queue the worker thread may go to sleep. After a time period has elapsed in block B process flow proceeds to block where the worker thread wakes up after the time period has elapsed.

In a block scheduler thread s pointer and worker thread A s pointer may match for example if they both reference the null value see or if they both reference a common session see . In an example if scheduler thread s pointer and worker thread A s pointer both reference a null value then worker thread A has nothing to do yet and can go back to sleep. Accordingly there is no more session data to process block and the worker thread may go to sleep block . In such an example scheduler thread may not have processed the second set of configuration items upon which worker thread A depends e.g. initializing work queue or work queue pointer . In another example if scheduler thread s pointer and worker thread A s pointer both reference a common session then no more work items are in work queue in session and worker thread A has published session . Worker thread A waits for scheduler thread to awaken and resets work queue pointer to point to the first work item of work queue .

In a block in response to determining that the producer thread s pointer does not match the worker thread s pointer the session is published. In an example in response to determining that the producer thread s pointer does not match the worker thread s pointer the producer thread s pointer is copied to the worker thread s pointer as in this example no tertiary configuration needs to be done by the worker thread. In an example worker thread A may publish session by updating worker thread A s pointer A to reference session . Process flow proceeds to block where the session data in a session is processed. In an example session data may be processed by calling a subsystem s API to collect data. In a block worker thread A may store a result of the API in its designated buffer.

In an example scheduler thread s pointer and worker thread A s pointer do not match if they reference different sessions. In another example scheduler thread s pointer and worker thread A s pointer do not match if scheduler thread s pointer references a session while worker thread A s pointer references a null value. For example in scheduler thread s pointer and worker thread A s pointer do not match because scheduler thread s pointer references session while worker thread A s pointer references a null value. When the producer thread s pointer does not match the worker thread s pointer the worker thread knows that the second set of configuration items in the session has been processed and it is the worker thread s turn to process session data in session . Worker thread A will eventually update its pointer to scheduler thread s session. It is important to note that while worker thread A s pointer is illustrated as referencing a null value worker thread A may be in the process of processing work queue in session data .

A worker thread may process session data by processing a third set of configuration items. In an example the worker thread processes the third set of configuration items by processing work queue . Worker thread A retrieves one or more work items from work queue . For example worker thread A retrieves work item which is referenced by work queue pointer and processes work item .

A work item may be a query to a subsystem for its specific counters or performance metrics and may contain a subsystem identifier and information as to which counters are being collected. In keeping with the above example in which a work item is an invocation of a subsystem API to obtain the subsystem s performance statistics and metrics work item is an API call into NIC see that causes the return of NIC s performance statistics and metrics. The subsystem may expose a function that returns the one or more specific counters requested. The performance data for NIC may include any of a variety of data tracked by the system that has an informational value with respect to how NIC has performed. Examples include software counters that describe latency of data requests software counters that track errors at network connections and the like. Worker thread A may invoke an API at NIC and receive NIC s performance data.

After worker thread A retrieves work item worker thread A or scheduler thread may move work queue pointer to point to the next work item e.g. work item in work queue so that this or the next available worker thread e.g. worker thread B or worker thread C retrieves the next work item and processes it. A worker thread may retrieve a work item from work queue by using a separate lock that is specific to the work queue activity and is unrelated to the activity of moving sessions between threads which keeps the work queue locking straightforward and localized. In an example it may be possible to make a lockless work queue in which case the whole process may be implemented using lockless mechanisms. The worker threads process the work items in work queue for the cleaner thread lower in hierarchy .

In a block the worker thread may write the returned performance information e.g. statistics and metrics to the memory buffer designated to the worker thread. In an example worker thread A writes the results of the API call to NIC into memory buffer A. The worker threads may continue to process work items placed in work queue until no more work items are left in work queue . Process flow may go back and forth between blocks and .

Worker thread A may be a producer thread that processes session data in session for consumption by cleaner thread . Cleaner thread may be dependent on data being written to a memory buffer before cleaner thread starts and finishes its task. In a block the worker thread may determine whether the memory buffer that is designated to the worker thread should be emptied.

In a block in response to determining that the worker thread s designated memory buffer should be emptied a request to the cleaner thread to empty the memory buffer is sent. In an example in response to determining that memory buffer A should be emptied worker thread A sends a request to cleaner thread to empty memory buffer A. In an example if the worker thread realizes that its designated memory buffer has become oversubscribed the worker thread may determine that its designated memory buffer should be emptied. The request may cause cleaner thread to empty the designated memory buffer and write the data stored in the memory buffer to disk . When cleaner thread writes the data stored in the memory buffer to disk cleaner thread may remove the data from the memory buffer or mark the data as deleted. To avoid this situation cleaner thread may wake up at regular intervals and preemptively check the worker thread A C buffers and write them to disk. In such a situation worker threads may only signal the cleaner thread during a peak of data where the amount of data written to the buffer is greater than the amount of data committed to disk at regular intervals.

The worker thread may determine whether there is more session data to process in the session. In an example if the worker thread determines that there is more session data to process in the session process flow may proceed to block where session data in the session is processed. In such an example the worker thread may continue to retrieve work items from work queue . In another example if the worker thread determines that there is no more session data to process in the session process flow may proceed to a block where the cleaner thread goes to sleep.

As illustrated in the example of the worker threads have started processing work items in work queue and may write the results to the memory buffer. Worker thread A may send a request to cleaner thread that causes cleaner thread to write the data stored in memory buffer A to disk or the cleaner thread may wake up regularly to scan and empty buffers A C.

It is also understood that additional processes may be performed before during or after blocks discussed above. It is also understood that one or more of the blocks of method described herein may be omitted combined or performed in a different sequence as desired.

For example method may enable the worker thread to run until its task is completed. In another example the worker thread may be allowed to run for a given period of time and after the given period of time elapses the worker thread goes to sleep. If the worker threads have not finished processing the work items in session data scheduler thread may raise an error and allow the worker threads to continue processing session data in session until all of their work has been completed e.g. all of the work items in work queue have been processed .

Cleaner thread may write the data stored in a memory buffer to disk . In the example described above a worker thread may send a request to cleaner thread to write the data stored in the worker thread s designated memory buffer to disk . The request may wake up cleaner thread . In an example if the memory buffer has a threshold amount of used space or free space the worker thread may send the communication to cleaner thread . In another example after a time period has elapsed cleaner thread awakens and scans the memory buffers. In an example cleaner thread awakens every ten seconds. If a scanned memory buffer has data to write to disk cleaner thread may write the data to disk . Alternatively if a scanned memory buffer has a threshold amount of used space or free space cleaner thread may write the data stored in the scanned memory buffer to disk .

Cleaner thread writes data stored in a memory buffer to disk to ensure that the performance data is stored in the archive file associated with session . It may be disadvantageous to wait until a memory buffer is partially full before writing the data stored in the memory buffer to disk because a crash may result in a lot of missing performance data.

In keeping with the above example of writing performance data of the subsystems to an archive file cleaner thread updates the archive file with the performance data stored in the worker threads designated memory buffers. In an example when there is no more performance data to store in the archive file cleaner thread closes the archive file. In another example when cleaner thread notices a new session that is created by rotator thread cleaner thread closes the old session and eventually writes data to the new session. When cleaner thread closes the archive file cleaner thread sets file descriptor to close and publishes session . In an example cleaner thread determines whether all of the worker threads are processing the same session. In response to determining that all of the worker threads are processing the same session cleaner thread may publish session . Cleaner thread may publish session by updating cleaner thread s pointer to reference session .

In the example illustrated in rotator thread scheduler thread and worker thread A all reference session . Rotator thread may create more sessions that are passed through the hierarchy of threads. A session is independent from a thread. Computing device may be slow and may not be able to handle the processing of another session without performance issues. For example the memory buffers designated to the worker threads may be full and cleaner thread may be slow in writing the data stored in the memory buffers to disk .

From bottom to top in rotator thread scheduler thread worker thread A and cleaner thread have processed session and have published session . Additionally rotator thread scheduler thread and worker thread A have processed a session and scheduler thread and worker thread A have published session . Rotator thread has processed and published session which has not yet been published by scheduler thread . Session may have its own fields e.g. file descriptor work queue and work queue pointer and scheduler thread may not have yet seen session or may be in the process of processing the session data in session to perform the secondary initialization prior to publishing the session.

In scheduler thread has not published session . Accordingly scheduler thread has not processed the set of configuration items in session upon which the worker threads depend. For example scheduler thread may not yet have initialized the work queue placed work items in the work queue and initialized the work queue pointer in session such that the worker threads can properly process the session data in session . Rotator thread references session scheduler thread and worker thread A reference session and cleaner thread references session . Accordingly rotator thread references a different session from the threads below it and scheduler thread and worker thread A reference a different session from cleaner thread .

Rotator thread may awaken and want to create a new session and push it down to the threads in hierarchy for processing. Rotator thread may be able to determine whether the threads in hierarchy are able to handle processing of another session so that no session is leaked. In an example rotator thread looks down to the other threads in hierarchy to determine how they are behaving and determines the state of a thread lower than rotator thread in hierarchy .

In an embodiment a session producer thread e.g. rotator thread determines whether a consumer thread e.g. scheduler thread that is one level below the session producer thread in hierarchy has published the session producer thread s most recently published session. In rotator thread s pointer references session and rotator thread s most recently published session is session . Scheduler thread has not yet published session . In an example rotator thread reads the pointer managed by scheduler thread and determines whether the pointer references the session that rotator thread most recently published. In such an example rotator thread may compare the memory addresses referenced by the rotator thread s pointer and scheduler thread s pointer and determine whether they match.

In an example in response to determining that the consumer thread has not published the session producer thread s most recently published session the session producer thread waits a period of time before attempting to push down the new session into hierarchy for processing. In such an example rotator thread does not publish new session if the previous session published by rotator thread e.g. session has not yet been published by scheduler thread . In this way the system automatically throttles itself and may ensure that all sessions are processed and that no sessions are leaked.

In another example in response to determining that the consumer thread has not published the session producer thread s most recently published session the session producer thread destroys its most recently published session e.g. session and replaces it with new session . In such an example rotator thread synchronizes with scheduler thread using a lock on scheduler thread s pointer because this behavior is an exception that breaks the flow of the waterfall by destroying a session after it has been produced as it is flowing to another level of the waterfall. When scheduler thread decides to process a session scheduler thread locks its pointer before it reads the rotator thread s session pointer and copies it onto the scheduler thread s session pointer. Scheduler thread then processes the session. In this example the secondary initialization may be moved to the rotator thread so that the scheduler thread s critical lock section stays small. The secondary initialization may also stay and force the rotator thread to stall longer in case of lock contention. This is not an issue in this case as the rotator thread is not in the critical code path.

In another example the same activity can be performed by having the scheduler thread own two pointers a scheduler consumer session pointer used to synchronize work between rotator thread and scheduler thread and a scheduler producer session pointer used to synchronize scheduler thread with worker threads A C. In that case the rotator thread may publish a new session using a lock only on the scheduler consumer pointer to prevent the scheduler thread from updating it. In an example the scheduler thread only uses the scheduler consumer session pointer to indicate it will consume the session. The scheduler thread s session grabs the lock when the scheduler thread updates the scheduler consumer pointer as no other thread is allowed to update it.

In yet another example a lockless variant may be implemented but may implement a more complex manipulation of the pointers. For example the rotator thread can publish two session pointers by adding one for sessions to destroy by the scheduler thread. Before updating the session pointer the rotator thread checks if the destroy session pointer is null. If the session pointer is null the rotator thread moves its session pointer to the session destroy pointer and copies the new session into the rotator thread s session pointer . If the session pointer is not null the rotator thread destroys the new session without committing it to the waterfall. When the scheduler thread wakes up it grabs the rotator thread session pointer and sets it into its scheduler session pointer . If the destroy session pointer is not NULL the scheduler thread then frees the session if the scheduler thread has not yet used the session and clears the destroy pointer.

In an embodiment it may be unnecessary to manage two pointers per thread because of the activities performed by the threads. In such an embodiment scheduler thread may have a lock on its pointer and rotator thread may grab scheduler thread s lock and verify that scheduler thread s pointer does not change while rotator thread updates the pointer. When this is done rotator thread has swapped its session pointer and can free the unused pointer. In another embodiment each thread may manage two pointers. For example if scheduler thread makes changes to the session it may be advantageous for scheduler thread to maintain two pointers one pointer for the active session the scheduler s consumer thread pointer and one pointer for the published session the scheduler s producer pointer .

Additionally a layer of the pipeline may be multi threaded. For example multiple worker threads may be defined at one layer of the pipeline and may process session data concurrently. A first worker thread and a second worker thread run concurrently when execution of the first and second worker threads has some overlap. The multiple worker threads may run concurrently on a single or multiple central processing units CPUs . In an example the first worker thread may run on a first processor during a period of time in which a second worker thread is running on a second processor. In another example the first worker thread may start running on a processor and stop before completion the second worker thread may start running on the processor and stop before completion and the first worker thread may resume running on the processor and finish. In another example the first worker thread may start running on a processor and stop before completion the second worker thread may start running on the processor and finish and the first worker thread may resume running on the processor and finish.

In an embodiment in response to scheduler thread identifying a newly created session by the rotator thread scheduler thread determines whether or not to process it right away by verifying if cleaner thread s pointer references the same session as scheduler thread . In response to determining that cleaner thread s pointer references the same session as scheduler thread s pointer scheduler thread may start to process the newly created session. In such an example rather than look to the state of all the worker threads scheduler thread may look to the state of cleaner thread to determine whether to process the newly created session. When scheduler thread awakens it may wake up the worker threads. When the worker threads start to process a session the worker threads may update their pointers to reference the session that is referenced by scheduler thread s pointer.

Additionally in response to determining that none of the worker threads are still processing data from older sessions cleaner thread may close the older session and update its pointer to reference the same session as scheduler thread . In such an embodiment the worker threads states in the session switch may be side stepped by scheduler thread looking below at cleaner thread s state.

As discussed above and further emphasized here and A E are merely examples which should not unduly limit the scope of the claims. For example although the plurality of threads is illustrated as referencing a null value this is not intended to be limiting. In another example the pointers managed by the plurality of threads may be initialized to reference a value different from null. As long as the consumer thread below the producer thread knows the value that the producer thread s pointer is initialized to the consumer thread may determine whether it can start processing the session. Additionally a consumer thread may determine whether a producer thread s pointer falls within a range of memory addresses rather than determining whether the producer thread s pointer matches the consumer thread s pointer. For example the consumer thread may be aware that session is stored at a particular set of memory addresses and determine that if the producer thread s pointer references a memory address that falls within the particular set of memory addresses the consumer thread may start to process the session.

Computer system includes a bus or other communication mechanism for communicating information data signals and information between various components of computer system . Components include an input output I O component that processes a user action such as selecting keys from a keypad keyboard selecting one or more buttons or links etc. and sends a corresponding signal to bus . I O component may also include an output component such as a display and an input control such as a cursor control such as a keyboard keypad mouse etc. .

An optional audio input output component may also be included to allow a user to use voice for inputting information by converting audio signals into information signals. Audio I O component may allow the user to hear audio. A transceiver or network interface transmits and receives signals between computer system and other devices via a communication link to a network. In an embodiment the transmission is wireless although other transmission mediums and methods may also be suitable. Processor which may be a micro controller digital signal processor DSP or other processing component processes these various signals such as for display on display coupled to computer system or transmission to other devices via communication link . Processor may also control transmission of information such as cookies or IP addresses to other devices.

Components of computer system also include a system memory component e.g. RAM a static storage component e.g. ROM and or a disk drive . Computer system performs specific operations by processor and other components by executing one or more sequences of instructions contained in system memory component . Logic may be encoded in a computer readable medium which may refer to any medium that participates in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media volatile media and transmission media. In various implementations non volatile media includes optical or magnetic disks or solid state drives volatile media includes dynamic memory such as system memory component and transmission media includes coaxial cables copper wire and fiber optics including wires that include bus . In an embodiment the logic is encoded in non transitory computer readable medium. In an example transmission media may take the form of acoustic or light waves such as those generated during radio wave optical and infrared data communications.

Some common forms of computer readable media include for example floppy disk flexible disk hard disk magnetic tape any other magnetic medium CD ROM any other optical medium punch cards paper tape any other physical medium with patterns of holes RAM PROM EEPROM FLASH EEPROM any other memory chip or cartridge or any other medium from which a computer is adapted to read.

In various embodiments of the present disclosure execution of instruction sequences e.g. methods and to practice the present disclosure may be performed by computer system . In various other embodiments of the present disclosure a plurality of computer systems coupled by communication link to the network e.g. such as a LAN WLAN PTSN and or various other wired or wireless networks including telecommunications mobile and cellular phone networks may perform instruction sequences to practice the present disclosure in coordination with one another.

Moreover computing device may be coupled over a network e.g. via NIC . The network may include various configurations and use various protocols including the Internet World Wide Web intranets virtual private networks wide area networks local networks private networks using communication protocols proprietary to one or more companies cellular and other wireless networks Internet relay chat channels IRC instant messaging simple mail transfer protocols SMTP Ethernet WiFi and HTTP and various combinations of the foregoing.

Where applicable various embodiments provided by the present disclosure may be implemented using hardware software or combinations of hardware and software. Also where applicable the various hardware components and or software components set forth herein may be combined into composite components including software hardware and or both without departing from the spirit of the present disclosure. Where applicable the various hardware components and or software components set forth herein may be separated into subcomponents including software hardware or both without departing from the spirit of the present disclosure. In addition where applicable it is contemplated that software components may be implemented as hardware components and vice versa.

Application software in accordance with the present disclosure may be stored on one or more computer readable mediums. It is also contemplated that the application software identified herein may be implemented using one or more specific purpose computers and or computer systems networked and or otherwise. Where applicable the ordering of various blocks or actions described herein may be changed combined into composite blocks or actions and or separated into sub blocks or sub actions to provide features described herein.

The foregoing disclosure is not intended to limit the present disclosure to the precise forms or particular fields of use disclosed. As such it is contemplated that various alternate embodiments and or modifications to the present disclosure whether explicitly described or implied herein are possible in light of the disclosure. Changes may be made in form and detail without departing from the scope of the present disclosure. Thus the present disclosure is limited only by the claims.

