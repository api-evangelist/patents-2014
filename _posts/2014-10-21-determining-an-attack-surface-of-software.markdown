---

title: Determining an attack surface of software
abstract: A method of determining an attack surface of software may include generating a platform for testing at least one deployment of software code, identifying protocols that are used by the at least one deployment, mapping the protocols to at least one port in the at least one deployment, and computing a metric comprising parameters for the at least one deployment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09489517&OS=09489517&RS=09489517
owner: FUJITSU LIMITED
number: 09489517
owner_city: Kawasaki
owner_country: JP
publication_date: 20141021
---
A software application may include hundreds or thousands of files and hundreds of thousands or millions of lines of code. The code of the software application may include parts that may access sensitive data from databases or data stored on an associated electronic device. Additionally the software application may include code that accesses communication networks such as the Internet and transmits and receives data over those networks. In general the security of a software application depends on how it interacts with its environment of users communication networks and storage.

Some software applications may be deployed in many different ways in which different parameters and customizations may be available. Determining which deployment of a software application is more secure and less vulnerable to attack as compared to another deployment may be difficult.

The subject matter claimed herein is not limited to embodiments that solve any disadvantages or that operate only in environments such as those described above. Rather this background is only provided to illustrate one example technology area where some embodiments described herein may be practiced.

According to an aspect of an embodiment a method of determining an attack surface of software may include generating a platform for testing at least one deployment of software code. Protocols that are used by the at least one deployment may be identified. The protocols may be mapped to at least one port in the at least one deployment. A metric may be computed comprising parameter for at least one deployment.

The object and advantages of the embodiments will be realized and achieved at least by the elements features and combinations particularly pointed out in the claims.

It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory and are not restrictive of the invention as claimed.

Some embodiments described herein relate to determining an attack surface of software for at least one deployment of software code. For example the software code may be cloud computing software. A platform may be generated for testing the at least one deployment. For example the platform may be a testbed. Protocols that are used by the at least one deployment may be identified. The software includes ports that serve as communication endpoints. The protocols may be mapped to at least one port in the at least one deployment. In some embodiments static analysis may be performed on the at least one deployment. Static analysis may include identifying paths that access sensitive information.

A metric may be computed comprising parameters for the at least one deployment. The parameters may include a number of unused ports a number of open ports information about at least one protocol used a volume of traffic transmitted to external internet protocol addresses IP a number of choke points a link traffic volume a mapping of protocols to nodes and a percentage of sensitive paths. In some embodiments information about the at least one protocol may be used to calculate a danger score for each protocol that reflects whether any of the protocols have a security hole and how long the protocol has existed and a total danger score that may be a sum of the danger score for all protocols used by each of the first and second deployments. The volume of traffic transmitted to external IP addresses may be used to determine whether anyone is committing malfeasance for example by snooping on the software. The choke point may be a single point of failure such as any node whose removal may cause the software to fail or have a significant decrease in performance. The link traffic volume may be used to determine how much traffic is being communicated across certain links. For example high volume may be an indicator of a snooper. The link traffic volume may be calculated as at least one of an aggregate amount of link traffic an average and maximum for each link a sum of all the volumes of link traffic and a sum of a ratio of all volumes. In some embodiments multiple deployments may be compared. For example a base line deployment may be compared to a first deployment or a first deployment may be compared to a second deployment. A visualization of the deployments may be generated based on a number of metrics available.

In some embodiments the software code may be generated using one of the following programming languages Perl C C C Java JavaScript Python Ruby assembly language Fortran common business oriented language COBOL structured query language SQL hypertext preprocessor PHP extensible markup language XML hypertext markup language HMTL among others.

The flow graph A may include ports A B C D E F and G collectively referred to herein as the ports that are connected together by edges that are depicted as lines with arrows in . The nodes in the flow graph A may each correspond to a different operation within the software code such as a function or method other operations such as while statements if statements let statements case statements among other types of code statements operators such as among other operations. In some embodiments the nodes may include ports in the software. Ports may serve as communication endpoints in a computer s host operating system. For example when the software is cloud computing software the ports may be endpoints for communicating with the network used for the cloud computing. The ports may be open or closed. Open ports are accessible for communications with entities outside of the software closed ports are not accessible. The ports may be associated with protocols.

In some embodiments the software code is analyzed to determine choke points in the network. For example in node C is a choke point because removing the node C may break communications between a first set of nodes of the software code and a second set of nodes of the software code. The metric application discussed in greater detail below may be configured to determine metrics associated with the software code. For example the metric application may determine a deployment of the software code and metrics including a number of unused ports a number of open ports a number of protocols used a volume of traffic transmitted to external IP addresses a number of choke points a link traffic volume a mapping of protocols to nodes and a percentage of sensitive paths.

The processor may include any suitable special purpose or general purpose computer computing entity or processing device including various computer hardware or software modules and may be configured to execute instructions stored on any applicable computer readable media. For example the processor may include a general purpose controller a microprocessor a microcontroller a digital signal processor DSP an application specific integrated circuit ASIC a Field Programmable Gate Array FPGA or any other digital or analog circuitry configured to interpret and or to execute program instructions and or to process data. Although illustrated as a single processor in it is understood that the processor may include any number of processors configured to perform any number of operations.

The memory may store instructions and or data that may be executed by the processor . The instructions and or data may include code that performs the techniques described herein. In some embodiments the instructions may include instructions and data that cause the processor to perform a certain function or a group of functions. In some embodiments the memory may include computer readable media for carrying or having computer executable instructions or data structures stored thereon. Such computer readable media may be any available media that may be accessed by a processor that is programmed to execute the computer executable instructions stored on the computer readable media. By way of example and not limitation such computer readable media may include tangible or non transitory computer readable storage media including Random Access Memory RAM Read Only Memory ROM Electrically Erasable Programmable Read Only Memory EEPROM Compact Disc Read Only Memory CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices flash memory devices e.g. solid state memory devices or any other storage medium which may be used to carry or store desired program code in the form of computer executable instructions or data structures and which may be accessed by a general purpose or special purpose computer. Combinations of the above may also be included within the scope of computer readable media.

The memory may store instructions for executing a metric application and the software code . In some embodiments the software code may be stored on a different client from the metric application . For example when the software code is a cloud computing application the software code may be stored as a distributed system with components on different clients that communicate with each other via the network . Additionally in some embodiments a library of the configurations for the software code may be stored on the same client as the metric application and software code or on a separate client . The metric application may analyze two or more different deployments of the software code and may determine metrics associated with each deployment.

As used herein the terms module or component may refer to specific hardware implementations configured to perform the actions of the module or component and or software objects or software routines that may be stored on and or executed by general purpose hardware e.g. computer readable media processing devices etc. of the computing system. In some embodiments the different components modules engines and services described herein may be implemented as objects or processes that execute on the computing system e.g. as separate threads . While some of the system and methods described herein are generally described as being implemented in software stored on and or executed by general purpose hardware specific hardware implementations or a combination of software and specific hardware implementations are also possible and contemplated. In this description a computing entity may be any computing system as previously defined herein or any module or combination of modulates running on the system B.

The deployment generator may be configured to receive software code . The software code may be generated using one of the following programming languages Perl C C C Java JavaScript Python Ruby assembly language Fortran COBOL SQL PHP XML HTML among others. The software code may be received from a database from a network such as the network of from a tangible computer readable storage media or from some other location.

The deployment generator may be configured to generate at least one deployment of the software code . The deployment generator may be configured to generate the deployment from different scripts configuration files and customizations that are available for the software code . For example the software code may be cloud computing software and the cloud orchestration of cloud computing software may be deployed on a cloud computing network in a variety of ways. In some embodiments the deployment generator accesses a library of configurations to generate the deployment. The deployment generator may generate a platform for testing the deployment of the software code . For example the deployment generator may create a testbed which measures and deploys techniques for generating at least one deployment of the software code .

In some embodiments the deployment generator may be configured to generate multiple deployments of the software code . For example the deployment generator may be configured to generate a platform for testing a first deployment of the software code and once the metric is generated for the first deployment the deployment generator may be configured to generate a platform for testing a second deployment of the software code . In another example the deployment generator may be configured to generate a baseline deployment and a first deployment for comparison.

The port mapper may be configured to receive the at least one deployment from the deployment generator . The port mapper may be configured to retrieve protocols associated with the at least one deployment from a database identify protocols that are used by the at least one deployment with protocols and map the protocols to at least one port in the at least one deployment. Based on the mapping the port mapper may be configured to know which processes are running on each node. The port mapper may be configured to generate a list of open ports and identify the instances where there is a unique mapping between protocols and nodes. In some embodiments the port mapper may be configured to retrieve from a database known protocols and their versions to determine their vulnerability level. For example some version of the protocol may be deemed to have dangerous vulnerabilities.

The static code analyzer may be configured to receive the at least one deployment. The static code analyzer may be configured to perform static analysis on the at least one deployment using application programming interfaces APIs . For example the static code analyzer may determine specific modules in the software code if the source code is available that open ports and deploy protocols. For those modules the static code analyzer measures paths that access sensitive information to give a more detailed measurement. In some embodiments the static code analyzer may be configured to measure paths in the deployments of the software code that access sensitive information.

In some embodiments the static code analyzer may be configured to create actions using API lists. For example once the testbed is running the static code analyzer may be configured to use an API to create actions for creating multiple users computing tasks and jobs to be run administration for setting up a database and populating the database with 1 000 entries managing identities managing access privileges initially populating a database creating accounts setting up computer jobs etc. Additional information about this process may be found in U.S. patent application Ser. No. 13 862 234 entitled DETERMINING SOFTWARE METRICS and filed on Apr. 12 2014 the entire contents of which are herein incorporated by reference.

The network scanner may be configured to receive the at least one deployment from the deployment generator . The network scanner may generate a list of unused ports external IP connections traffic to the external IP connections choke points and link traffic volume.

The network scanner may be configured to determine a volume of traffic to external IP addresses. For example when the software code is cloud computing software the nodes may represent different virtual machines. The virtual machines may be on the same physical computer or server and may behave as separate computers on the network or they may be on separate physical computers or servers . The network scanner may be configured to measure what kind of traffic is going outside of the private cloud by determining whether the node is communicating with an IP address that is external to the private cloud. For example devices within the same local network may use a 32 bit 4 byte IP address that may have the same numbers for the two most significant bytes and different numbers for the two least significant bytes. If the two most significant bytes of the IP address for the node are different from the entity the node is communicating with the node is communicating with an external IP address.

The network scanner may be configured to determine the choke points based on the centrality of some nodes that lie on most paths in the deployment of the software code . In some embodiments the network scanner may determine the choke points using standard graph algorithms.

The network scanner may be configured to determine the link traffic volume by determining how much traffic is being communicated across certain links. In some embodiments the network scanner may be configured to use one or more APIs to determine the link traffic volume. The link traffic volume may include an amount of link traffic an average and a maximum for each link a sum of all volumes and or a sum of the ratio of all volumes.

The filter may be configured to receive the network traffic from the network scanner . The filter may also be configured to receive data from the port mapper and or the static code analyzer . The filter may be configured to parse and filter the data and transmit the remaining data to the metric analyzer . For example the filter may receive dumps and log files parse the files and filter out irrelevant data for the metric analyzer .

The metric analyzer may be configured to combine the remaining data from the filter and compute a metric for the at least one deployment. The metric may be a reflection of the attack surface vulnerability of the different deployments. For example the metric analyzer may determine that the deployment has a choke point and several nodes that receive a high volume of traffic which suggests that the deployment could experience a failure and that entities may be snooping on the software. The metric analyzer may be configured to generate a report on differences between different deployments of the software code .

In some embodiments the metric analyzer computes a metric comprising parameters for the at least one deployment the parameters including a number of unused ports a number of open ports a number of protocols used a volume of traffic transmitted to external IP addresses a number of choke points a link traffic volume a mapping of protocols to nodes and a percentage of sensitive paths.

The unused ports may be ports that are not used for communication during execution of the deployment of the software code . A higher number of unused ports may indicate a higher degree of vulnerability because the unused ports represent potential security holes where unauthorized entities may obtain access to the network and intercept the network traffic.

The open ports are ports that are available for communication. Open ports are ports that are listening for communications which exposes the ports to communication with unauthorized entities. As a result an increase in the number of open ports may also indicate increased vulnerability.

For the number of protocols the metric analyzer may determine the number of protocols used at each node. The metric analyzer may be configured to assign a danger score to each protocol based on the version of each protocol being used at each node how long the protocol has been used where a longer time period is associated with a safer protocol because there has been more opportunity to test the protocol and whether the protocols are associated with known security holes. In some embodiments the metric analyzer may be configured to determine a total danger score for each deployment that is a sum of the danger score for each protocol used with the first and second deployments of the software code .

The volume of traffic transmitted to external IP addresses may be used to determine whether an unauthorized entity is snooping on the software code . For example if a node is transmitting a high volume of traffic to an external IP address the node may be transmitting private data to the unauthorized entity. As a result a lower volume of traffic to external IP addresses indicates a more secure deployment of the software code .

The choke points in the deployment are potential points of vulnerability because the failure of a node that is a choke point may cause the software code to have a diminished functionality or stop working. As a result a lower number of choke points is associated with a more secure deployment of the software code .

Similar to the volume of traffic being communicated to external IP addresses a high volume of link traffic may be indicative of an unauthorized entity snooping on the software code . As a result a lower volume of link traffic is associated with a less vulnerable deployment of the software code .

The metric analyzer may be configured to use the mapping of protocols to nodes determined by the port mapper to identify a number of unique cases where there is a unique mapping. If a protocol is running on only one node taking down the node would stop the protocol from running which makes the software code more vulnerable to failure. For example if only one node is running a web server that gives a user access to a dashboard node failure would cause the client side of the software code to fail and frustrate the user. As a result redundant protocols indicate less vulnerability and a lower number of cases where there is a unique mapping of protocols to nodes may be associated with a more secure deployment of the software code .

Further in some embodiments the metric analyzer may be configured to generate a percentage of sensitive paths based on the paths that access sensitive information determined by the static code analyzer .

In some embodiments the metric analyzer may be configured to present the metric also known as an attack surface metric as a list of the parameters for the at least one deployment. In some embodiments the metric analyzer may be configured to present the metric as a single value instead of multiple parameters. For example the metric may be a normalized sum of all the parameters.

In some embodiments the metric analyzer may be configured to present a comparison of the metric for multiple deployments. The multiple deployments may include a baseline deployment and another deployment a first deployment and a second deployment etc. The presentation may include an element wise comparison of the two or more deployments. In some embodiments the metric analyzer may be configured to generate the total metric for the multiple deployments as a comparison. For example the metric analyzer may determine that the first deployment is 25 less vulnerable than the second deployment.

In these or other embodiments the metric analyzer may be configured to normalize the metric according to a baseline to give a difference between the metric and the baseline. For example the metric analyzer may determine that the first deployment has an attack surface metric of 10 lower than the baseline and that the second deployment has an attack surface metric of 15 higher than the baseline.

In yet another embodiment the metric analyzer may be configured to generate a metric for a subset of the parameters and may include individual details for the remaining parameters. For example in some embodiments the number of unused ports and the number of open ports may be displayed separately because of in some instances importance and the remaining parameters are combined into the metric . In yet another embodiment the metric analyzer may be configured to apply a weight to some of the parameters based on their importance. For example the metric analyzer may apply weights to the number of unused ports and the number of open ports by using a dot product of a weight vector. The metric analyzer may then generate a metric as a sum of the individual parameters.

The user interface engine may be configured to receive the metric from the metric analyzer and generate visualizations of the parameters. For example the user interface engine may be configured to generate a network view as illustrated in a process view as illustrated in an overall view as illustrated in or a different report that illustrates differences in the parameters using radar as illustrated in . The figures will be discussed in greater detail below.

Modifications additions or omissions may be made to the system without departing from the scope of the present disclosure. For example the user interface engine may be optional. In some embodiments certain aspects of the system may be different depending on the programming language for the software code . For example a filter used for parsing Java may be different than a filter used for parsing C. However the fundamental principles described with respect to the system remain the same regardless of the programming language used for the software code . In some embodiments the system may be implemented using computer readable media for carrying or having computer executable instructions or data structures stored thereon that implement the system .

The method may begin at block where a platform may be generated for testing at least one deployment of software code . For example the platform could be a testbed.

In block protocols that are used by the at least one deployment may be identified. For example the protocols used by the deployment are identified from a database and information associated with the protocols such as the version any known security holes in the protocols and the length of time that they have been in use are retrieved.

In block the protocols may be mapped to at least one port in the at least one deployment. The mapping may be used to identify which ports are open.

In block the metric comprising parameters for the at least one deployment may be computed the parameters including a number of unused ports a number of open ports information about at least one protocol used a volume of traffic transmitted to external IP addresses a number of choke points a link traffic volume and a mapping of protocols to nodes.

The method may begin at block where a platform may be generated for testing a deployment of software code . In block protocols that are used by the at least one deployment may be identified. In block the protocols may be mapped to at least one port in the deployment. In block static analysis of the software code may be performed for example using application programming interfaces APIs .

In block network traffic at the at least one port associated with the deployment may be collected. For example ports with unusually high traffic may be accessed by unauthorized entities that are snooping on the software code .

In block irrelevant data may be parsed and filtered. For example the dumps and log files are parsed and filtered to prepare the data for computing metrics. In block the remaining data may be combined.

In block a metric may be computed comprising parameters for the deployment. Parameters may include a number of unused ports a number of open ports information about the one or more protocols used a volume of traffic transmitted to external IP addresses a number of choke points a link traffic volume a mapping of protocols to nodes and a percentage of sensitive paths. In some embodiments the parameters may be combined to create a first attack surface metric for the first deployment and a second attack surface metric for the second deployment. The attack surface metric may be a summation of the individual parameters or a summation of a dot product of a weight and a value for each parameter.

In block it may be determined whether there is an additional deployment to analyze. For example the deployment could be a baseline deployment and a first deployment could be available for comparison. In another example the deployment could be a first deployment and a second deployment could be available. If there is an additional deployment to analyze the method may repeat starting at block . If there is not an additional deployment to analyze the method may proceed to block . In block a visualization of the metrics may be generated. For example a graph may include an overlay of the parameters for the first deployment on top of the second deployment a line graph comparing the parameters a graph with the attack surface metric etc.

One skilled in the art will appreciate that for this and other processes and methods disclosed herein the functions performed in the processes and methods may be implemented in differing order. Furthermore the outlined steps and operations are only provided as examples and some of the steps and operations may be optional combined into fewer steps and operations or expanded into additional steps and operations without detracting from the essence of the disclosed embodiments. Furthermore the method is only one example of a method that may be used to determine path counts within a contracted flow chart. Other methods for determining path counts may be used without departing from the scope of the present disclosure.

The foregoing detailed description has set forth various embodiments via the use of block diagrams flowcharts and or examples such as the block diagram that illustrates the system of and the flow charts that illustrate the methods of respectively. Insofar as such block diagrams flowcharts and or examples contain one or more functions and or operations it will be understood by those within the art that each function and or operation within such block diagrams flowcharts or examples may be implemented individually and or collectively by a wide range of hardware software firmware or virtually any combination thereof. In some embodiments several portions of the subject matter described herein may be implemented via Application Specific Integrated Circuits ASICs Field Programmable Gate Arrays FPGAs digital signal processors DSPs or other integrated formats. However those skilled in the art will recognize that some aspects of the embodiments disclosed herein in whole or in part may be equivalently implemented in integrated circuits as one or more computer programs running on one or more computers e.g. as one or more programs running on one or more computer systems as one or more programs running on one or more processors e.g. as one or more programs running on one or more microprocessors as firmware or as virtually any combination thereof and that designing the circuitry and or writing the code for the software and or firmware would be well within the skill of one of skill in the art in light of this disclosure. In addition those skilled in the art will appreciate that the mechanisms of the subject matter described herein are capable of being distributed as a program product in a variety of forms and that an illustrative embodiment of the subject matter described herein applies regardless of the particular type of signal bearing medium used to carry out the distribution

Furthermore the embodiments described herein may include the use of a special purpose or general purpose computer including various computer hardware or software modules as discussed in greater detail below.

Embodiments described herein may be implemented using computer readable media for carrying or having computer executable instructions or data structures stored thereon. Such computer readable media may be any available media that may be accessed by a general purpose or special purpose computer. By way of example and not limitation such computer readable media may comprise tangible computer readable storage media including RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other storage medium which may be used to carry or store desired program code in the form of computer executable instructions or data structures and which may be accessed by a general purpose or special purpose computer. Combinations of the above may also be included within the scope of computer readable media.

Computer executable instructions comprise for example instructions and data which cause a general purpose computer special purpose computer or special purpose processing device e.g. a processor to perform a certain function or group of functions. Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

All examples and conditional language recited herein are intended for pedagogical objects to aid the reader in understanding the invention and the concepts contributed by the inventor to furthering the art and are to be construed as being without limitation to such specifically recited examples and conditions. Although embodiments of the present inventions have been described in detail it should be understood that the various changes substitutions and alterations could be made hereto without departing from the spirit and scope of the invention.

