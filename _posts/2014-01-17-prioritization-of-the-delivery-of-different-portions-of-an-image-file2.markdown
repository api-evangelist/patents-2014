---

title: Prioritization of the delivery of different portions of an image file
abstract: Prioritizing delivery of different portions of images is disclosed, including: receiving a request for an image file; identifying a cluster of characterized images in an N-dimensional space to which the image file belongs; assigning a split point to the image file that is associated with the identified cluster of characterized images; and prioritizing a delivery of a first portion and a second portion of the image file based at least in part on the assigned split point.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09560160&OS=09560160&RS=09560160
owner: Instar Logic, Inc.
number: 09560160
owner_city: Palo Alto
owner_country: US
publication_date: 20140117
---
In at least some conventional systems an image to be rendered is completely downloaded before the resources e.g. client server connection used to download render the image can be used to download render another image. However especially when there are several images to be downloaded and fewer available resources than are needed to concurrently download every image to completion the end user desiring to view the images may suffer a lower quality user experience by virtue of having to wait a potentially long time to view all the images.

The invention can be implemented in numerous ways including as a process an apparatus a system a composition of matter a computer program product embodied on a computer readable storage medium and or a processor such as a processor configured to execute instructions stored on and or provided by a memory coupled to the processor. In this specification these implementations or any other form that the invention may take may be referred to as techniques. In general the order of the steps of disclosed processes may be altered within the scope of the invention. Unless stated otherwise a component such as a processor or a memory described as being configured to perform a task may be implemented as a general component that is temporarily configured to perform the task at a given time or a specific component that is manufactured to perform the task. As used herein the term processor refers to one or more devices circuits and or processing cores configured to process data such as computer program instructions.

A detailed description of one or more embodiments of the invention is provided below along with accompanying figures that illustrate the principles of the invention. The invention is described in connection with such embodiments but the invention is not limited to any embodiment. The scope of the invention is limited only by the claims and the invention encompasses numerous alternatives modifications and equivalents. Numerous specific details are set forth in the following description in order to provide a thorough understanding of the invention. These details are provided for the purpose of example and the invention may be practiced according to the claims without some or all of these specific details. For the purpose of clarity technical material that is known in the technical fields related to the invention has not been described in detail so that the invention is not unnecessarily obscured.

Embodiments of prioritization of the delivery of different portions of an image file are described herein. A request for an image file is received. A cluster of characterized images in an N dimensional space to which the image belongs is identified. The image file is assigned a split point that is associated with the identified cluster of characterized images. In various embodiments a split point refers to a measure of a portion of an image file to deliver first to the requestor in the prioritized delivery of different portions of the image file. For example the split point may refer to a percentage of the image file. The split point may refer to a percentage of the image file starting from the lower frequency components of a progressive image file e.g. starting from the beginning of the discrete cosine transform DCT encoded data of a progressive image file .

In some embodiments a requested image file is delivered as one or more portions of the image file. Because the delivery of a portion of an image file at a time is more efficient than the delivery of the entire image file the delivery of a portion of the image file is desirable if the delivered portion can be rendered into an acceptable even if degraded version of the original image. For example in response to the request for an image file a first portion of the image file that is determined based on a split point assigned to the image file is delivered. The first portion of the image file is delivered and to be rendered by the requestor. So long as the first portion of the image file includes less than the entire image file the rendering of the first portion of the image file will be a degraded version of the rendering of the entire image file. However in various embodiments the split point is automatically determined on the basis that a first portion of the image file generated with the split point will be rendered into a degraded but still acceptable e.g. aesthetically pleasing version of the original image.

In some embodiments a client server system is used to virtualize a document object model DOM of a web browser. Virtualization of a DOM of a web browser allows the client server system to take control of the DOM for different kinds of optimizations while keeping the optimization transparent to other code running within the web browser. When the web browser sends any network messages over a network that are related to the downloading of webpages or other information the messages may be either intercepted and processed by the client e.g. a JavaScript program that is running at the device on which the web browser is running or directly received and then processed by a server supporting virtualization. For example the prioritization of different portions of the delivery of the image file included in the DOM may be implemented using the client server system.

A webpage accessed by web browser may be described by different markup languages including Hypertext Markup Language HTML Extensible Markup Language XML and the like. The webpage may also be described by different scripting languages including JavaScript Object Notation JSON and the like. The webpage may be described by other custom languages as well. HTML is used hereinafter as an example of the various languages for describing webpages. Note that the examples of HTML are selected for illustration purposes only accordingly the present application is not limited to these specific examples.

For example in response to an end user interaction with device to request a webpage web browser is configured to send a e.g. Hypertext Transfer Protocol or HTTP request message to edge server requesting the HTML webpage file. After edge server locates the requested HTML webpage file edge server returns the requested HTML webpage file in an HTTP response message to web browser . In some embodiments web browser begins to render the webpage on a screen web browser parses the received webpage file and builds a data structure to represent the various components of the webpage in a local memory. As will be further described below one such data structure is a DOM tree.

In some embodiments client may be injected into web browser based on standards based e.g. HTML or JavaScript procedures. For example after edge server receives a request from web browser requesting an HTML webpage file edge server may parse the HTML webpage file inject client into the HTML webpage file and then send the response back to web browser . In some embodiments client may be injected by adding JavaScript client code in the head section of the HTML webpage file.

After receiving the requested webpage file web browser is configured to fetch an image included in the webpage file from a uniform resource locator URL associated with the origin server associated with the image. Accordingly web browser sends a request via network requesting the image file to be downloaded. In some embodiments when web browser sends any network messages onto network that are related to the downloading of images or other information the messages may be either intercepted and processed by a client or directly received and then processed by edge server to enable the prioritization of delivering different portions of the images. For example method API calls by web browser or any JavaScript code to manipulate the image file related objects in a DOM tree may be intercepted processed or modified by client .

The following describes examples of an image being requested by web browser and the different portions of the image being delivered in a prioritized manner 

Web browser is configured to request an image file. In some embodiments the request for the image is generated in response to an event. For example the event can be an end user interaction with a webpage to which web browser has rendered or the event can be part of the process of web browser attempting to retrieve the image file related object in a DOM tree that has been built for a requested webpage. In some embodiments web browser is configured to send the request for the image file directly to edge server . In some embodiments the request for the image file generated by web browser is intercepted by client and potentially modified before client sends the modified request to edge server .

Edge server receives the request for the image file. In some embodiments proxy server of edge server determines whether it has previously received a request for the image file e.g. from an entity running at device or any other device and or determines that the split point for the requested image file is already stored.

In the event that proxy server determines that it has not previously received a request for the image file or that the split point for the requested image file is not already stored in some embodiments proxy server is configured to obtain the image file. For example the requested image file may be obtained from cache if a copy of the requested image file is already stored in cache of edge server or the requested image file may be obtained from the origin server a server that is not shown in the diagram associated with the requested image file based on a locator e.g. uniform resource locator URL that is included in the request. Once proxy server has obtained the requested image file proxy server is configured to send back to web browser at least a portion of the requested image file based on a user configurable determination. Because proxy server has not previously received a request for that image file and therefore has not previously determined and stored the split point for the image file to ensure a good user experience for the end user who is to view the rendered image file at device in some embodiments the user configurable determination may be configured to return a conservative at least portion of the image file to web browser . For example the user configurable determination may return the entire image file or a large percentage e.g. 80 or 90 of the image file to web browser such that the image to be rendered by web browser is assumed to appear visually pleasing e.g. because the image is rendered based on the entire requested image file or a large portion of the requested image file . In addition to returning at least a portion of the requested image file to web browser proxy server is configured to send the obtained requested image file to split point analyzer . In some embodiments proxy server is also configured to store the requested image file at cache . As will be described in further detail below split point analyzer is configured to determine a split point that is appropriate for the image file. In some embodiments a corresponding relationship is stored at edge server e.g. in cache between the image file and its corresponding determined split point. In some embodiments the first portion and or the second portion the second portion comprises the remainder portion of the image file without the first portion of the image file in accordance with the determined split point of the image file is stored in cache . The stored corresponding relationship between the image file and its corresponding determined split point and or the stored first and or portions of the image file may be used in response to a subsequent request for that image file as is described below.

In the event that proxy server determines that it has previously received a request for the image file and or that the split point for the requested image file is already stored in some embodiments proxy server is configured to determine the first portion of the requested image and deliver the first portion to web browser . In this case where the split point has been previously determined for a requested image file the first portion of the image file that is determined based on the stored split point can be efficiently delivered to web browser instead of based on a potentially conservative user configurable determination. In some embodiments proxy server is configured to obtain a cached copy of the first portion of the requested image file from cache . In some embodiments proxy server is configured to obtain the split point based on a corresponding relationship between the image file and its corresponding split point stored at cache . Then proxy server is configured to determine the first portion of the requested image file based on the obtained split point and a cached copy of the requested image file. In some embodiments proxy server may or may not deliver the second portion of the requested image file to web browser depending on one or more factors as will be described further below.

At a request for an image file is received. For example the request for the image file is received from a web browser or a client injected into the web browser. In some embodiments the requested image file comprises a progressive image file or is in a format that can be converted into a progressive image file.

At a cluster of characterized images in an N dimensional space to which the image file belongs is identified. In various embodiments a plurality of images has been sorted into various clusters in an N dimensional space where similar images are sorted into the same cluster. The value of N may be determined based on one or more factors. Because these images have been analyzed and clustered in various embodiments they are referred to as characterized images or known images. In some embodiments a split point is assigned to each cluster of images. For example the split point may be manually assigned by a user e.g. a system operator to one or more images in a cluster based on a manual evaluation that the chosen split point is the minimum split point that yields a first portion of each of the one or more images that can be rendered into images of an acceptable quality. The standard of acceptable quality may be chosen by the user. Then the remaining images of the cluster inherit the same split point assigned to those one or more images by virtue of belonging to the same cluster of images. The remaining images of the cluster inherit the same split point assigned to those one or more images by virtue of belonging to the same cluster of images because it is assumed that since images of a cluster are similar the split point appropriate for one image is also appropriate for the others of the same cluster. Put another way one split point is assigned to each cluster of images and each image in the cluster is associated with the split point assigned to that cluster.

In some embodiments if the requested image has not been previously clustered it is sometimes referred to as an unknown image. In some embodiments one or more candidate split points are determined and a candidate first portion of the unknown image file is generated based on each candidate split point. For example the one or more candidate split points are predetermined percentages e.g. 40 50 60 70 80 and 90 of the unknown image file that are used as candidate first portions of the image file. In some embodiments one or more metric values are determined for each of the candidate first portions of the unknown image file. For example the value of N is equal to the number of candidate first portions multiplied by the number of types of metric values determined for each candidate first portion. For example if there were six candidate first portions of the unknown image file and two types of metric values were determined for each candidate first portion then N 6 2 12. A coordinate in N dimensional space can be determined for the unknown image file. In some embodiments the coordinate in N dimensional space may be represented by a data structure e.g. vector that includes all the metric values computed for each candidate first portion. Then a cluster of characterized images to which the unknown image belongs in the N dimensional space is determined based at least in part on the data structure. For example the unknown image file is determined to belong to a cluster with which the N dimensional data structure is determined to be within a predetermined threshold e.g. Euclidean distance.

At a split point that is associated with the identified cluster of characterized images is assigned to the image file. In some embodiments the unknown image file inherits the split point that was assigned to the cluster of characterized images to which the unknown image file was identified to belong. For example the split point assigned to the identified cluster can be any one of the predetermined percentages e.g. 40 50 60 70 80 and 90 of the unknown image file to use to determine the first portion of the image to deliver in a prioritized delivery of different portions of the image file. In some embodiments the split point assigned to the unknown image file is stored so that it can be obtained upon a subsequent request for the same image.

At a delivery of a first portion and a second portion of the image file is prioritized based at least in part on the assigned split point. The first portion of the requested image file is determined based on the split point that is assigned to that image file. In some embodiments the first portion of the requested image file is sent to the requestor prior to sending the second portion e.g. the remaining portion of the image file to the requestor at a later time or not at all depending on one or more factors.

Because the first portion of the requested image file is smaller than the entire image file the first portion will be received and rendered sooner at the requestor than if the entire image file had been sent. The first portion of the image file was determined based on the split point selected for the cluster of characterized images to which it was determined to belong and is assumed to represent a portion of the original image that includes enough information to be rendered by the requestor as an acceptable even if degraded version of the original image. Thus determining the first portion of the requested image file can result in an efficient delivery of less than the entire image file that can still be rendered in a manner that can provide a quality user experience with respect to viewing the image.

At a request for an image file is received. A request for an image file is received from a requestor. For example the requestor comprises a web browser or a client e.g. JavaScript that has been injected in a web browser. The request may include identifying information e.g. a URL associated with the image file.

At it is determined whether a split point has been stored for the image file. In the event that a split point has been stored for the image file control is transferred to . Otherwise in the event that a split point has not been stored for the image file control is transferred to . For example a split point may already be stored for the image file if a request for the image file has been previously received and an appropriate split point had been determined and stored for the image file. However a split point may not already be stored for the image file for example if a request for the image file has not been previously received and or a split point has not previously been determined for the image file.

At at least a portion of the image file is sent based at least in part on a user configurable determination. If the split point of the image file is not stored then at least a portion of the image file e.g. after the image file is obtained from its origin server is delivered based on a user configurable determination. For example the user configurable determination may indicate to send a conservative at least portion of the image file e.g. most of the image file or even the entire image file to deliver to the requestor such that the rendered image will be a relatively high or of the highest possible quality to ensure a good user experience in viewing the requested image. The user configurable determination may also indicate to deliver a remaining portion of the image file at a later time based on one or more factors if less than the entire image file is initially delivered.

At a split point for the image file is determined. A split point for the image file is determined and stored for a subsequent request for the same image file. In some embodiments after the split point is determined a first portion and or a second portion of the image file is cached.

At a first portion of the image file is sent. In some embodiments a first portion of the image file is dynamically determined based on a copy of the image file and the stored split point and sent. In some embodiments a cached copy of the first portion of the image file is obtained and sent.

At it is determined whether to send a second portion of the image file. In the event that the second portion is to be sent control is transferred to where the second portion of the image file is sent. Otherwise in the event that the second portion is not to be sent process ends. The second portion of the image file is the remaining portion of the image file less the already sent first portion. In some embodiments whether to send a second portion of the image file such that the entire image file could be rendered at the requestor is determined based at least in part on end user actions. For example during a browsing session an end user may scroll to the bottom of a webpage before the webpage is loaded to completion such that the image file is no longer within the displayed portion of the webpage. Also for example an end user may expand or minimize certain portions of the webpage such that the image file is no longer within the displayed portion of the webpage. As a result if the image file is no longer needed at the requestor e.g. because the image file is no longer within the displayed portion of the webpage after the first portion has been sent the second portion of the image file may not be sent at all. However if the image file is still needed at the requestor after the first portion has been sent then based on one or more factors e.g. the availability of connection resources the second portion of the image file may be sent to the requestor. In some embodiments a request for the second portion of the image file may be received from the requestor e.g. after network traffic has subsided . In some embodiments a request for the second portion of the image file is not received from the requestor but rather the edge server automatically determines whether to send the second portion of the image file.

Process is an example process that may be used to determine a split point for an image file for which a split point is not stored.

At a plurality of candidate first portions of an image file is determined. If the image file is not stored then the image file is obtained from its origin server. In some embodiments a set of one or more predetermined candidate split points is used to generate corresponding candidate first portions of the image file. For example the predetermined split points and corresponding candidate first portions may include 40 50 60 70 80 and 90 of the image file.

At a set of first metric values for the plurality of candidate first portions of the image file is determined. In some embodiments a first metric comprises a first type of metric. A first metric value is determined for each candidate first portion. For example if the six candidate first portions of the image file are 40 50 60 70 80 and 90 then a first metric value would be computed for each of the 40 50 60 70 80 and 90 candidate first portions of the image file. In various embodiments the first type of metric measures a difference between an image rendered by the first candidate portion of the image file and the original entire image file.

For example the first type of metric may be a measure of structural similarity SSIM of a candidate first portion relative to the original image file. SSIM is obtained by comparing the local patterns of pixel intensities that have been normalized for luminance and contrast between the original image and the degraded image rendered with a candidate first portion of the original image file. In some embodiments a SSIM value is computed for each of various local windows applied to the degraded image rendered with a candidate first portion and then a mean SSIM index value is determined for the candidate first portion by averaging all the SSIM values associated with the local windows.

At a set of second metric values for the plurality of candidate first portions of the image file is determined. In some embodiments a second metric comprises a second type of metric different from the first type of metric. A second metric value is determined for each candidate first portion. For example if the six candidate first portions of the image file are 40 50 60 70 80 and 90 then a second metric value would be computed for each of the 40 50 60 70 80 and 90 candidate first portions of the image file. In various embodiments the second type of metric may measure a difference between an image rendered by the first candidate portion of the image file and the original entire image file.

For example the second type of metric may be a measure of peak signal to noise ratio PSNR that describes the quality of an image rendered by the first candidate portion of the image file relative to the original image file. The PSNR is defined as a function of the maximum possible pixel value of the image and the mean squared error MSE . The MSE of an image rendered with a candidate first portion of the image file can be determined for example by squaring the difference between each pixel of the image rendered with a candidate first portion and the original image and then taking a mean of the squared errors. For example the maximum possible pixel value may be determined using the formula of 2 1 where B represents the number of bits in per sample.

At a data structure is determined for the image file based at least in part on the set of first metric values and the set of second metric values. In some embodiments the first metric values and the second metric values computed for each of the candidate first portions are included in a data structure. In some embodiments the data structure comprises a vector or an array. For example the vector is of N dimensions where the value of N is the product of the number of types of metrics e.g. two including SSIM and PSNR and the number of candidate first portions of the image file e.g. six including 40 50 60 70 80 and 90 . Thus in the example where there are two types of metric values determined for each of six candidate first portions N equals 12. The image file may be mathematically represented by the N dimensional vector and may be plotted as a coordinate in an N dimensional space.

At it is determined whether the image file belongs to an existing cluster based at least in part on the data structure. In the event that the image file is determined to belong to an existing cluster of characterized images control is transferred to . Otherwise in the event that the image file is determined to not belong to an existing cluster of characterized images control is transferred to . In some embodiments a set of images has already been sorted into one or more clusters where each cluster includes a set of one or more known images that are similar to each other. In some embodiments each known image is represented by a corresponding data structure of N dimensions and is sorted into a cluster based on comparisons of their respective data structures. Because each image is represented by a respective data structure of N dimensions each image can be plotted as a coordinate in an N dimensional space where coordinates associated with images that are similar to each other are located close to each other within the N dimensional space. Using any known clustering technique images that are within a certain closeness in the N dimensional space may be included in the same cluster.

In some embodiments one split point of the set of one or more predetermined candidate split points has been assigned to each such existing cluster. For example the split point may be assigned by a user e.g. a system administrator to one or more images of the cluster based on a manual determination of which candidate split point associated with the minimum percentage or other portion size based split point of the image yields a degraded copy of the original image that is acceptable e.g. aesthetically pleasing to the user . Each other image in the same cluster inherits the split point assigned to the one or more images of that cluster.

If the image file for which a split point has not been stored has not been previously clustered then the image file may be referred to as an unknown image or an unknown image file. It is determined whether the unknown image belongs to any of the existing clusters of characterized images based on the values stored in the data structure. In some embodiments the unknown image belongs to an existing cluster if the unknown image is similar to the images of the existing cluster. For example if the e.g. Euclidean distance between the data structure of the unknown image and those of the one or more images in an existing cluster in the N dimensional space is within a predetermined threshold distance then the unknown image is determined to belong to that existing cluster. For example if the distances between the data structure of the unknown image and those of two or more existing clusters are both within the predetermined threshold distance then the existing cluster associated with the shorter distance to the unknown image is determined as the cluster to which the image file belongs.

At a split point associated with a cluster to which the image file belongs is assigned to the image file. The unknown image file is assigned the split point that has been previously assigned to the existing cluster to which the image file is determined to belong.

However if the distance between the data structure of the unknown image and that of any of the existing clusters is not within the predetermined threshold distance then it represents that the image file is not similar to any known images that have been sorted into existing clusters and so a new cluster is created for the image file.

At a new cluster including the image file is created. A new cluster is created for the unknown image file.

At a split point associated with the new cluster is determined. In some embodiments a split point may be assigned the new cluster by a user e.g. a system administrator . In some embodiments after the unknown image file is sorted into a cluster and or assigned a split point it is also referred to as a known image. 

At a split point associated with the new cluster is assigned to the image file. The image file is then assigned the split point assigned to the new cluster. In some embodiments at some point after the new cluster of image s including the image file is created the set of known images is again sorted into the one or more clusters including the new cluster. It is possible that images previously sorted into an existing cluster may sort into the new cluster after this new round of sorting. In some embodiments after the re sorting process has been performed the new cluster is also referred to as an existing cluster. 

As described above a split point is assigned to each cluster of characterized images. For example a user assigns a split point to a cluster of characterized images by evaluating at least one image from the cluster and assigning the minimum candidate split point that the user believes yields a corresponding first portion of the image that can be rendered into an acceptable degraded copy of the original image. The remaining images of that cluster would inherit the split point assigned to the at least one image. Applying the example technique to if a split point of 50 were assigned to image of Cluster A in some embodiments image and the other remaining images of Cluster A would also inherit a split point of 50 without needing to be manually evaluated by a user. Similarly if a new image is to be added to the clusters of it is determined whether the new image belongs to one of existing Clusters A B and C for example based on the distance between the new image and the characterized images. For example if the new image were found to be within a predetermined threshold distance to Cluster C but not to Clusters A and B then the new image would belong to Cluster C and receive the split point of 80 that was assigned to Cluster C.

However if the new image is not found to belong to any of existing Clusters A B and C then a new cluster e.g. Cluster D which is not shown in the diagram may be generated for the new image.

The Document Object Model DOM is a standardized model supported by different web browsers e.g. Internet Explorer Firefox and Google Chrome to represent the various components of a webpage. The DOM tree is a cross platform and language independent convention for representing and interacting with objects in HTML documents as well as XHTML and XML documents. Objects in a DOM tree may be addressed and manipulated using methods on the objects. The public interface of a DOM is specified in its application programming interfaces APIs .

The DOM standard includes different levels. DOM core level 0 and level 1 are the core standards supported by all web browsers while DOM levels 2 and above are extensions to DOM core level 0 and level 1 which can be optionally supported by different web browsers. DOM core level 0 and level 1 define a minimal set of objects and interfaces for accessing and manipulating document objects. It provides a complete model for an entire HTML document including the means to change any portion of the document.

The DOM standard represents documents as a hierarchy of node objects called a DOM tree. Some types of nodes may have child nodes of various types and others are leaf nodes that cannot have any object below them in the document structure hierarchy.

For example when the web browser e.g. such as web browser of system of renders webpage of on a screen the web browser parses the received HTML webpage file and builds a DOM tree to represent the various components of webpage of in a local memory. For example when the image tag shown as in is parsed by the web browser the image is represented as an image object and the image object is inserted into the DOM tree accordingly.

After the webpage file is parsed and the corresponding DOM tree is created the entire DOM tree can be traversed to retrieve any dependent resources e.g. images audio clips or videos indicated by any of the nodes in the DOM tree via a network. For example the image object corresponding to the image tag in webpage of redirects the web browser to fetch an image file from a uniform resource locator URL e.g. associated with an origin server . Accordingly the web browser sends a request via a network requesting the image resource to be downloaded. There are two ways a request may be issued statically in which case it is the browser which manipulates the DOM or dynamically in which case the DOM manipulation is done by JavaScript. In response to the request the requested dependent resource is sent to the web browser via a network.

For example if the nodes of the DOM tree include M different resources and or URLs M separate GET requests e.g. M separate HTTP GET requests are sent via a network requesting the dependent resources to be sent to the web browser. In response M separate GET responses e.g. M separate HTTP GET responses are sent to the web browser delivering the dependent resources to the web browser.

The round trip time or network response time for a GET request to arrive at an edge server e.g. such as edge server of system of and for its corresponding GET response to arrive at the web browser is dependent on the latency of the network which is different for different types of networks. The network may be any combination of different types of public or private networks including intranets local area networks LANs wide area networks WANs radio access networks RANs Wi Fi networks the Internet and the like. Therefore the latency associated with the network may vary depending on its network type s .

Some networks have relatively lower network latency. For example the network latency associated with WANs or Wi Fi networks is relatively low e.g. on the order of 10 milliseconds. Suppose the number of resources and or URLs included in the DOM tree M is equal to twenty. The total network latency associated with receiving the twenty resources and or URLs from the edge server then is approximately 200 milliseconds. To improve network performance present day browsers have become more efficient in reusing connections to the same server such that typically less than 20 of the connections may be fresh connections.

Some networks have relatively higher network latency. For example the network latency associated with a 3rd generation mobile telecommunications 3G network is relatively high e.g. on the order of 100 milliseconds. In this instance the total network latency associated with receiving the dependent resources associated with the twenty resources and or URLs from the edge server is then on the order of two seconds.

Since the network latency associated with different types of networks varies widely and the web browser needs to receive the dependent resources associated with the links and URLs before the web browser can complete the rendering of webpage of the startup wait time experienced by the end user of the browsing session may be insignificant in low latency networks such as Wi Fi networks but unacceptably long for an end user in higher latency networks such as 3G networks. Therefore prioritized delivery of different portions of an image in a webpage may be desirable.

Virtualization of a DOM of a web browser allows the client server system to take control of the DOM for different kinds of optimizations while keeping the virtualization transparent to the web browser. A web browser accesses webpages and other information through a network. When the web browser sends any network messages onto the network that are related to the downloading of webpages or other information the messages may be either intercepted and processed by a client e.g. such as client of system of or directly received and then processed by an edge server supporting virtualization. Webpages or other information related to the webpages that are sent to the web browser may be intercepted filtered processed or provided by the client or the edge server. In addition method API calls by the web browser or any JavaScript code to manipulate the objects in a DOM tree may be intercepted processed or modified by the client. The client may also manipulate the DOM tree by making the appropriate method API calls to the DOM tree. As a result the client and the edge server together create a virtualization engine for the DOM of the web browser. The virtualization engine may access and manipulate a DOM tree including the creation deletion or update of nodes within the DOM tree. Using the virtualization engine the delivery of the information e.g. the order in which the information is delivered or the granularity of the information delivered and the actual content of the delivered information corresponding to any nodes of the DOM tree may be altered thereby speeding up the rendering of a webpage without compromising the end user s experience. With respect to delivering an image file to the web browser the image file may be split into a first portion and a second portion at a split point determined for that image file the first portion can be delivered first to avoid comprising the end user s experience and the second portion can be delivered later or not at all.

Virtualization of the DOM of the web browser includes handling static and dynamic interactions with the DOM of the web browser. Both types of interactions may be intercepted or virtualized by the virtualization engine.

Dynamic interactions with the DOM of the web browser include interactions that are effected by JavaScripts e.g. Ajax . The DOM of the web browser is virtualized by having the client intercept and virtualize method API calls to create delete or update elements in the DOM. In some embodiments only DOM core level 1 APIs which are supported by all standardized web browsers are intercepted and virtualized. The DOM core level 1 APIs for manipulating the DOM tree are supplanted by the equivalent JavaScript interfaces of the virtualization engine.

Static interactions to the DOM of the web browser include interactions corresponding to static HTML tags in an HTML webpage file e.g. the tag of webpage as shown in . An HTML tag redirects the web browser to fetch a dependent resource e.g. an image file from a URL. Because the static GET request is not made via a JavaScript the static request is not intercepted by the client. Instead the static request is sent by the web browser in its native form and then routed over the network e.g. by means of DNS resolution to an edge server supporting virtualization.

In some embodiments the server may discern whether a GET request is sent by the web browser or the client using a signature based scheme thus enabling the server to handle the static case as mentioned above. For example if a GET request was sent by the client the GET request would be stamped with a predetermined signature. Conversely if the GET request was sent directly from the web browser as in the static case the GET request would not be stamped with the predetermined signature.

In some embodiments when a GET request is sent directly from the web browser in a static case the server may send dummy content in response causing the web browser to create a dummy node in the DOM tree. At the same time the server may also notify the client e.g. by sending a JavaScript that a dummy node has just been created in the DOM tree thereby eliminating the need for the client to poll the DOM tree for any new dummy nodes added to the DOM tree. The client being notified of the newly created dummy node in the DOM tree may dynamically update the dummy node with the actual content by issuing one or more JavaScript requests to the server. In response to the one or more requests the server sends one or more JavaScript updates which are then intercepted by the client which may then populate the dummy node with the actual image content.

In some embodiments the startup wait time of a webpage can be reduced by splitting a progressive JPEG image file or other image files that are compressed in multiple passes of progressively higher detail into at least two portions. Having control of both ends of the communication in a client and server system the first portion of the image can be requested by the client and sent to the server first and in some embodiments then the second portion can be requested by the client and sent by the server dynamically to refresh and sharpen the image.

In some embodiments since a webpage may include content retrieved by multiple GET requests by dividing each GET request into a plurality of GET requests the server transmit queue is reprioritized to transmit and the web browser is reprioritized to render the higher priority components of each of the GETs first. In particular the first portion of each image to be rendered for a webpage may be prioritized higher and therefore requested by the client earlier and or delivered by the server earlier than the second portion of each image. As a result the latency of an end user seeing at least a version of each image is reduced.

However by prioritizing the delivery of different portions of images A B C and D the first portions of each of the four images A B C and D can be delivered to the web browser first such that the end user can at least view a degraded version of each image before any of the second portion of each image is delivered to the web browser. Thus the two available concurrent GET requests can be used to deliver the first portion of each of images A B C and D before delivering the second portions of A B C and D if needed . By prioritizing the delivery of the first portion of each of the four images in this example the end user could enjoy a better experience with webpage by being able to view at least a somewhat degraded version of each image A B C and D based on the rendered first portions sooner than the end user would have been able to view all four images in their entirety as would have occurred without prioritizing the delivery of different portions of the images.

Assume that the first portions of the images A B C and D may be represented by A B C and D and the second portions of the images of the A B C and D may be represented by A B C and D. By prioritizing the delivery of different portions of four images of assume that the order in which the two GET requests could obtain the first and second portions of the four images would be as follows A B C D A B C and D. This way the delivery of A B C and D are prioritized such that the end user could more quickly view at least a version of each of images A B C and D based on the renderings of A B C and D. Any or all of A B C and D could be delivered at a later time depending on one or more factors such as end user actions e.g. if the end user does not navigate away from webpage .

Although the foregoing embodiments have been described in some detail for purposes of clarity of understanding the invention is not limited to the details provided. There are many alternative ways of implementing the invention. The disclosed embodiments are illustrative and not restrictive.

