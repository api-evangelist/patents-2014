---

title: Integrated software development and test case management system
abstract: Improved techniques involve marking each test case routine written in the source code with test case identifiers that describe that test case routine. Software in a development system parses source code to locate such identifiers and, upon compilation of the source code, generates a report based on those identifiers. Advantageously, the improved techniques ensure that test cases remain current with the source code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09304893&OS=09304893&RS=09304893
owner: EMC Corporation
number: 09304893
owner_city: Hopkinton
owner_country: US
publication_date: 20140307
---
This Patent Application is a Non provisional utility application which claims the benefit under 35 U.S.C. 119 e from U.S. Provisional Patent Application No. 61 774 614 filed on Mar. 8 2013 entitled TEST REQUIREMENT COVERAGE USING MARKERS the contents and teachings of which are herein incorporated by this reference in their entirety.

Modern software development typically involves constructing and running high quality automated test cases. Automated test cases are routines macros or scripts that call compiled executables built from source code under test. When run such test cases pass specified parameters to the compiled executables which in turn generates test case output. In some scenarios quality assurance QA personnel use the output from running the test cases to determine which bugs in a bug report may be closed.

In a conventional test case environment QA personnel use a test case management system TCM to manage the test cases and their output. A typical TCM has a database for storing information about the test cases as well as their respective output. For example a TCM may list a test case identifier bugs and requirements that the test case addresses output from the latest software build in an entry in the database and whether the test case passes or fails according to goals set for the test case.

Unfortunately there are deficiencies with the above described conventional test case environment. For example the test case code and source code are typically developed in separate environments by different groups of people e.g. software engineers for the former and QA engineers for the latter. In such an environment it is difficult to synchronize versions of the source code and the test case code as each is managed separately. Thus a report generated within a TCM may not reflect the latest version of the source code. For example suppose that an initial requirement of software under development involves displaying a dialog box when an incorrect password was input into a login window. A TCM might have in its database a series of test cases that test whether such a dialog box appears in response to an incorrect password under various scenarios. Suppose further however that the software developers have updated the dialog box to a warning within the login window. Because the development of the software is separate from the development of the test cases it is plausible that test case reports never record this change and thus do not accurately reflect updated requirements of the software under test.

In contrast to the above described conventional test case environment in which test case reports may not accurately reflect requirements of the source code improved techniques involve marking each test case routine written in the source code with test case identifiers that describe that test case routine. Software in a development system parses source code to locate such identifiers and upon compilation of the source code generates a report based on those identifiers. Advantageously the improved techniques ensure that test cases remain current with the source code.

One embodiment of the improved techniques is directed to a method of producing a test case report. The method includes parsing by a computing device the source code to locate sets of test case identifiers each set of test case identifiers including symbols distinct from symbols used in syntax of the source code and describing of a corresponding test case routine of a set of test case routines within the source code. The method also includes compiling by the computing device the source code. The method further includes outputting by the computing device the test case report based on the set of test case identifiers the test case report describing the set of test case routines within the source code in response to the compiling of the source code.

Additionally some embodiments of the improved techniques are directed to an apparatus constructed and arranged to produce a test case report. The apparatus includes a network interface memory and a controller including controlling circuitry constructed and arranged to carry out the method of producing a test case report.

Furthermore some embodiments of the improved techniques are directed to a computer program product having a non transitory computer readable storage medium that stores code including a set of instructions which when executed by a computer cause the computer to carry out the method of producing a test case report.

Improved techniques involve marking each test case routine written in the source code with test case identifiers that describe that test case routine. Software in a development system parses source code to locate such identifiers and upon compilation of the source code generates a report based on those identifiers. Advantageously the improved techniques ensure that test cases remain current with the source code. illustrates an example computing device for carrying out the improved technique. Computing device includes a controller which in turn includes processor and memory . Computing device also includes network interface circuitry and storage device .

Network interface circuitry is configured to access a computer network. Network interface circuitry may take the form of an Ethernet card in some arrangements network interface circuitry may take other forms including that of a wireless receiver or a token ring card for example.

Storage device is configured to store data persistently. Storage device includes non volatile memory and takes the form of but is not limited to disk memory and or solid state memory.

Processor may take the form of but is not limited to Intel or AMD based CPUs and can include a single or multiple cores each running single or multiple threads. Processor is coupled to memory and is configured to execute instructions from compiler and source code .

Memory is configured to store source code . Memory is further configured to store compiler . Memory generally takes the form of e.g. random access memory although in some arrangements memory includes flash memory or a non volatile memory.

Compiler includes a set of instructions for compiling source code and building executable software e.g. libraries DLLs binaries and the like from the compiled source code.

Parser includes a set of instructions for parsing source code in order to locate test case identifiers that describe routines within test case routine . Parser further includes a set of instructions for generating a report containing results of running the routines of the test cases.

Source code includes routines written by software developers that are intended to be compiled into a software product that satisfies a set of requirements. Among the various lines of code are comments used for explaining what each code segment does identifying the author and the like. As is known in the art comments are demarcated with special symbols such as . Compiler is configured to not include text within comment markers in a compilation. Parser on the other hand is configured to examine test case code identifiers within the comments in the cases when the identifiers are located within the comments.

Source code also includes routines of test case code . In some arrangements such as when test case code is written in a different language from source code routines of test case code are demarcated using particular markers so that compilation software knows to not include them in compilation. In other arrangements however when test case code and source code are written in the same language compiler may compile both test case code and source code together 

It should be understood that source code may be arranged in separate files within a project. For example in object oriented code written in Java or C it is common for each class to be written into separate files with each routine being a method of that class. Each routine in these languages may also have a header file containing routine metadata such as files that contain routines used in the current routine.

Further each test case routine has metadata that describes that test case routine the metadata is demarcated by special symbols within comments for reporting purposes. The metadata includes for example a description of the use case the steps performed by the test case routine the scenarios that are being tested and any active bugs around which the test case routine was written. Further detail about the test cases is provided in .

Test case code as described above contains a routine that is run by compiler see upon completion of the build of source code . In the example shown in the routine is written in Java code the routines of test case code may be written in any language compiled or interpretive. Routine has a marker that is a statement Test outside of comments marker identifies routine as a test case routine rather than a source code routine.

It should be understood that test case routines written in a compiled language may either be compiled with the source code or separately from the source code. Further in some arrangements test case code may be written in an interpretive macro language. For example source code may be associated with an application programming interface API that has its own macro language which calls executable routines.

Appearing also within test case code is the metadata for routine . It should be understood that the various elements of the metadata each have a separate identifier for recognition by compilation software . As shown in test case code includes a use case identifier for identifying a use case the identifier shown in is usecase . Test case code also includes test step identifiers for identifying the test steps of routine teststep . Test case code further includes scenario identifiers for identifying scenarios such as requirements that routine must satisfy in order that the test case pass scenario . In some arrangements test case code also includes bug report identifiers such as that from a JIRA bug tracking system jira .

During an example operation compiler parses source code in a similar manner as a typical software compiler in that compiler searches outside of comments for source code which compilation software recognizes as properly expressed code in e.g. Java C etc.

For each routine compiler identifies however compiler checks for a test identifier. If such an identifier is found then the routine is a test case routine and is temporarily excluded from the build process. Parser then locates test case identifiers as described above in lines of code adjacent to such a test case routine. In some arrangements these test case identifiers are located within comment markers containing text that compiler is configured to ignore.

If no such identifier is found however then compiler includes the routine in the normal compilation and build process. It should be understood that if there is a syntax error or some other error that stops normal compilation then compilation software releases test cases routines such as routine from memory and ceases the build process altogether.

For each test identifier parser parses comments immediately above the routine to locate the various metadata identified by respective identifiers e.g. usecase teststep scenario and jira. Once the metadata for a routine is parsed parser places the metadata in a location in memory corresponding to the location in memory where its routine is stored e.g. in a location adjacent to it routine.

In the case that test case code is written in a compiled language compiler performs a compile and build operation on test case code . In some arrangements however compiler may perform a single compile and build for both source code and test case code . In still further arrangements when test case code is written in an interpretive language compiler places the routine in memory until source code is built. Once source code is compiled and the subsequent executables are built compiler begins to access test case routines e.g. routine from memory for running against the newly built executables.

Upon completion of the compilation parser generates a human readable report containing all of the gathered test case information from the metadata. In some arrangements the human readable report is generated in HTML to be displayed in a web browser window on a computer or sent to a remote system via network interface . Further details of such a report will now be described in connection with .

Entry contains values of fields and corresponding to those extracted from routine see while entry contains values of those fields corresponding to another test case routine. For example the value of the test method field is testCustomerUserCreate which is the name of routine . The value of use case field is the value of the metadata marked with the usecase identifier. The value of text steps field is the value of the metadata marked with the teststep identifier. The value of the scenarios field contains all of the metadata marked with the scenarios marker note that each such scenario has its own scenario marker and is separated in the entry by semicolons. The value of the JIRA Tickets field contains the metadata marked with the jira identifier. In some arrangements web based report will also include output from each test case and an indication of whether the test case has passed or failed.

In some arrangements each listed scenario in fields and contains a hyperlink to a wiki page defining that scenario. Such a wiki page is illustrated in .

It should be understood that wiki page may be stored in storage device on computing device . In some arrangements however wiki page may be stored in a central location remote from computing device .

As illustrated in parser differentiates source code under test from test case code . For a compilation process then computing device compiles source code under test with a first compiler while computing device compiles test case code using a different compiler .

While various embodiments of the invention have been particularly shown and described it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the spirit and scope of the invention as defined by the appended claims.

Furthermore it should be understood that some embodiments are directed to computing device which is constructed and arranged to test whether source code satisfies a set of requirements. Some embodiments are directed to a process of testing whether source code satisfies a set of requirements. Also some embodiments are directed to a computer program product that enables computer logic to test whether source code satisfies a set of requirements.

In some arrangements computing device is implemented by a set of processors or other types of control processing circuitry running software. In such arrangements the software instructions can be delivered within computing device either in the form of a computer program product see or simply instructions on disk or in pre loaded in memory of computing device each computer program product having a computer readable storage medium which stores the instructions in a non volatile manner. Alternative examples of suitable computer readable storage media include tangible articles of manufacture and apparatus such as CD ROM flash memory disk memory tape memory and the like.

