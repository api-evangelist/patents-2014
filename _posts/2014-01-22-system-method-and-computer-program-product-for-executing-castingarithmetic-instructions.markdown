---

title: System, method, and computer program product for executing casting-arithmetic instructions
abstract: A system, method, and computer program product are provided for executing casting-arithmetic instructions. The method comprises receiving a casting-arithmetic instruction that specifies an arithmetic operation to be performed on input data and at least one casting operation of an input casting operation and an output casting operation. Upon determining that the casting-arithmetic instruction specifies the input casting operation, the input casting operation is performed on identified terms comprising the input data. Then the arithmetic operation is performed on the input data to generate an arithmetic result. Upon determining that the casting-arithmetic instruction specifies the output casting operation, the output casting operation is performed on the arithmetic result.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09477477&OS=09477477&RS=09477477
owner: NVIDIA Corporation
number: 09477477
owner_city: Santa Clara
owner_country: US
publication_date: 20140122
---
The present invention relates to computer systems and more specifically to casting arithmetic instructions.

A conventional processing unit such as a graphics processing unit GPU or a central processing unit CPU typically provides floating point arithmetic instructions having a large dynamic range and a large numeric resolution precision that are each more than sufficient to support a wide range of applications. For example a GPU conventionally provides thirty two bit floating point arithmetic instructions that may be executed by a shader program to perform mathematical functions specified by the shader program. In general a thirty two bit floating point arithmetic representation provides more than adequate dynamic range and numeric resolution. However in many common scenarios shader programs are configured to generate data for display buffers comprising eight bit to twelve bit color channels that are conventionally used to drive display devices.

In such scenarios thirty two bit floating point instructions are typically executed by the GPU to generate data associated with the color channels. A majority of bits associated with numeric resolution for resulting thirty two bit floating point data may be discarded because only eight bits or twelve bits of numeric resolution are actually required by each color channel. Furthermore exponent bits associated with the thirty two bit floating point data may be discarded because the color channels are configured to operate within a narrow predefined dynamic range. The process of computing unused data bits and subsequently discarding the unused data bits wastes power and results in lower overall GPU power efficiency. In other scenarios GPUs often perform computations using normal vectors three component vectors whose vector magnitude is unity. Even though the individual components of these vectors may have high dynamic range the exponent bits of each component may be discarded because the vector as a whole has limited dynamic range. Thus there is a need for addressing this issue and or other issues associated with the prior art.

A system method and computer program product are provided for executing casting arithmetic instructions. The method comprises receiving a casting arithmetic instruction that specifies an arithmetic operation to be performed on input data and at least one casting operation of an input casting operation and an output casting operation. Upon determining that the casting arithmetic instruction specifies the input casting operation the input casting operation is performed on identified terms comprising the input data. Then the arithmetic operation is performed on the input data to generate an arithmetic result. Upon determining that the casting arithmetic instruction specifies the output casting operation the output casting operation is performed on the arithmetic result.

A technique is provided for transforming certain source arithmetic operations specified by a computer program to corresponding arithmetic operations configured to generate substantially identical arithmetic results and require less execution power. In one embodiment each source arithmetic operation is specified as a floating point operation and each corresponding arithmetic operation is performed as an integer operation having equivalent or lower numeric resolution precision . Performing a given arithmetic operation using a fixed point representation rather than a floating point representation may eliminate circuit switching activity associated with exponent calculations resulting in relatively lower execution power. Similarly performing an arithmetic operation at a lower resolution eliminates circuit switching activity associated with computing additional significant bits resulting in relatively lower execution power. By transforming at least a portion of arithmetic instructions within the computer program from floating point types to fixed point operations or to lower precision floating point operations overall execution power may be reduced.

In one embodiment certain combined arithmetic operations are implemented within a processor to execute both a selected arithmetic operation and at least one selected casting operation in the same instruction. Combining the selected arithmetic operation and any associated casting operations into a single instruction eliminates the need to fetch and execute additional instructions associated with the associated casting operations thereby improving execution efficiency. In other embodiments casting instructions are implemented within the processor as distinct operations. In certain embodiments both combined arithmetic operations and distinct casting operations are implemented within the processor.

In one embodiment a compiler such as a shader program compiler is configured to identify which floating point operations may be transformed to corresponding fixed point integer operations. A set of propagation rules define which operations may be performed as fixed point operations based on dynamic range and numeric resolution requirements of each operation. For example if a shader program is configured to generate twelve bit fixed point color channel results comprising a frame buffer output then certain thirty two bit floating point operations associated with computing the twelve bit or eight bit color channel results may be transformed to corresponding fixed point integer operations.

In one embodiment the compiler is configured to generate an executable object that targets an associated graphics processing unit GPU . The executable object comprises binary instructions associated with an instruction set architecture ISA for the GPU. The compiler generates the executable object based on input code such as source code written by a software engineer e.g. programmer and information that specifies required resolution for shader program results. The compiler may execute in conjunction with a GPU driver on a central processing unit CPU to generate the executable object for subsequent execution within the GPU. In an alternative embodiment the compiler is configured to generate a binary object that is stored within a file comprising an application program. The binary object is then loaded into the GPU in conjunction with execution of the application program.

Method begins in step where the compiler generates an initial graph representation of input code. The input code includes ordered programming statements that may reside within a memory or storage system and may be organized according to any technically feasible structure. For example the input code may reside within a string data structure allocated within an application memory space. Alternatively the input code may reside within a file associated with a file system. The input code may include without limitation high level language constructs low level language constructs machine code or any combination thereof. The high level language constructs may comprise statements including mathematical operations statements that define program flow statements comprising declarations and the like. The statements may be syntactically compliant with a specific high level computer language such as the well known languages of C C OpenGL or OpenCL. The high level language may also be a shader language such as GLSL or HLSL. The low level language constructs may comprise abstract assembly statements intermediate representation IR statements or assembly language instructions associated with a specific ISA for a specific processing unit. In general the initial graph representation of the input code may comprise an abstract syntax tree a data flow graph or any other technically feasible form of graph that represents data dependency and computation within the input code. As shown the graph representation comprises a data flow graph. In certain embodiments step includes multiple compiler phases that may generate two or more different intermediate graph representations. In such embodiments the initial graph representation comprises one of the two or more different intermediate graph representations. The initial graph representation may be implemented as a data structure using any technically feasible data structure configured to represent a graph comprising two or more nodes associated through one or more edges.

In step the compiler annotates the initial graph representation with initial attributes for known or predefined edges to generate a partially annotated graph representation. The attributes may include without limitation dynamic range sign and numeric resolution requirements for output data types input data types or any combination thereof. For example if an output product of the program code comprises unsigned twelve bit integer values then a corresponding output edge would be annotated to indicate a predefined attribute of a positive value having a narrow dynamic range and twelve bits of numeric resolution.

In step the compiler applies one or more propagation rules to the partially annotated graph representation to generate a fully annotated graph representation. A given propagation rule may propagate a dynamic range sign or numeric resolution requirement from an operation output to associated inputs for the operation. A given propagation rule may instead propagate dynamic range or numeric resolution attributes from an operation input to an associated output. In one embodiment the compiler visits each node within the partially annotated graph representation once in a given propagation pass to generate a first intermediate fully annotated graph representation. If a propagation rule applies to a node then the compiler updates edge attributes associated with the node based on the propagation rule. The compiler performs sequential propagation passes over a sequence of intermediate fully annotated graph representations to generate subsequent intermediate fully annotated graph representation and so forth until no propagation rule matches any node within a given intermediate fully annotated graph representation during the propagation pass. When no propagation rule matches are found in a given propagation pass the intermediate fully annotated graph representation is designated the fully annotated graph representation. In one embodiment step is implemented by a method described below in .

In step the compiler selects appropriate numeric types for each edge within the fully annotated graph representation to generate a transformed graph representation. For example if a particular edge attribute specifies a positive narrow dynamic range number requiring twenty four bits of numeric resolution then an unsigned twenty four bit integer type may be selected for the edge.

In step the compiler generates code based on the transformed graph representation. Each node within the transformed graph representation includes a specification for an arithmetic operation and each edge includes attributes specifying dynamic range and numeric resolution. The generated code may comprise machine instructions intermediate representation instructions executable instruction or any other technically feasible set of instructions. The compiler may implement any technically feasible technique to generate code from the transformed graph representation.

The generated code may comprise one or more instructions. A given instruction may perform a specified arithmetic operation a specified casting operation or a combination of a specified arithmetic operation and at least one specified casting operation. Casting operations may be performed on an output of an arithmetic operation on one or more inputs to the arithmetic operation or a combination thereof. Each casting operation casts data from a source type to a target type. In one embodiment a casting operation may cast a floating point source type to a fixed point target type. The fixed point target type may provide similar or different numeric resolution compared to the floating point source type. In another embodiment a casting operation may cast a floating point source type to a floating point source type with a different precision. In yet another embodiment a casting operation may cast a fixed point source type to a fixed point source type with a different precision. A single instruction that performs both an arithmetic operation and a casting operation is referred to herein as a casting arithmetic instruction. A given casting arithmetic instruction may operate on scalar data or vector data. For example a casting arithmetic scalar addition instruction may be configured to add two scalar floating point inputs to generate a scalar twelve bit integer output while a casting arithmetic vector instruction may operate on a vector of floating point elements vec2 vec3 and so forth to generate a corresponding vector of twelve bit fixed point integers as an output.

A set of arithmetic instructions casting instructions casting arithmetic instructions or any combination thereof may be implemented within a processing unit configured to serve as a target for the compiler. For example streaming multi processors SMs of may be configured to implement an appropriate collection of arithmetic instructions casting instructions and casting arithmetic instructions. The compiler is configured to generate targeted code for the SMs whereby the targeted code may include instructions from the appropriate collection. The targeted code may be transmitted to the target processing unit for immediate execution or stored for later execution. In one embodiment the generated code is cached within a target processor such as PPU for execution on demand.

Method begins in step where the compiler initializes state information for a propagation pass. In one embodiment the state information includes a match flag configured to indicate whether a propagation rule was matched and therefore applied during the current propagation pass. Initializing the state information should include resetting the match flag to indicate no propagation rule was matched during the current propagation pass. While method is described with respect to a match flag any technically feasible indicator may be implemented to indicate whether a propagation rule was matched indicating a change to the graph representation. Each propagation pass should visit every node within the graph representation. Any technically feasible graph traversal algorithm may be performed to visit each node within the graph and initializing the state information may comprise selecting a designated initial node to begin each propagation pass.

In step the compiler selects a node within the graph representation. The selected node may comprise an input node or an output node during an initial iteration and one node in a sequence of nodes comprising the graph representation thereafter. In one embodiment a node adjacent to a recently modified node is preferentially selected by the algorithm. Any technically feasible technique may be implemented to select a node in the sequence of nodes. In one embodiment an output node for the graph representation comprises the first selected node.

In step the compiler selects a propagation rule from a set of propagation rules to test against the selected node. A propagation rule defines criteria for matching a node within the graph representation and specifies attribute modifications for the graph representation should a match occur. The criteria may include different attributes for anode and edges associated with the node such as a type of arithmetic operation specified by the node a sign attribute for inputs to the node dynamic range requirements for an output of the node numeric resolution requirements for the output of the node and the like. If in step the selected propagation rule is a match for the selected node then the method proceeds to step where the compiler updates the graph representation based on the selected propagation rule. Updating the graph representation may include without limitation attribute modifications to edges associated with the node. Additionally the match flag should be set to a true state. If however the selected propagation rule is not a match for the selected node then the method proceeds to step .

If in step the selected rule is the last rule then the method proceeds to step otherwise the method proceeds back to step . If in step the selected node is the last node to be visited in the graph representation then the method proceeds to step otherwise the method proceeds back to step . If in step any propagation rule matches occurred during a current propagation pass such as indicated by the match flag then the method proceeds back to step . Otherwise the method terminates.

The first rule propagates dynamic range exponent range indicated as an E from an output to inputs through an addition operation. If both inputs to the addition operation are of the same sign then both can be limited to the output range of the operation. The input with the larger exponent will determine the exponent of the output and the LSBs of the other input can be dropped to bring the other input up to the same exponent. Note that this rule does not apply if the inputs have different signs. Two numbers with large exponents could be subtracted resulting in a difference with a small or negative exponent. Propagation is indicated here with respect to only dynamic range E with precision unchanged and each term known to be positive .

The second rule propagates numeric resolution also referred to as precision indicated by a P leaving dynamic range unchanged . For example if the result of an addition operation needs only twelve bits of output precision and if both inputs are the same sign then neither input needs to be more than twelve bits or precision.

The third and fourth rules propagate dynamic range and precision from the input of an addition operation to the output of the addition operation. More specifically the third rule propagates the larger dynamic range of the two inputs E1 E2 to define the dynamic range of the output MA E1 E2 . This is accomplished by propagating the larger of two exponent ranges E1 and E2 as the output exponent range. For example if E1 corresponds to the number of exponent bits in a floating point representation and E2 represents zero exponent bits associated with a fixed point representation then the output dynamic range is propagated to be that of E1. The fourth rule propagates precision along with dynamic range.

Propagation rules for certain multiplication scenarios are shown in the fifth rule through the eighth rule. The fifth rule propagates precision. More specifically in the fifth rule an output precision for a multiplication operation P defines input precision for the multiplication operation. Any additional input precision beyond that of the output precision is superfluous. In the sixth rule an input precision representing the least available input precision defines output precision. In multiplication the output exponent is the sum of the input exponents therefore if any two of three exponents comprising two input exponents and an output exponent are known then the third of three exponent may be inferred. The seventh rule infers dynamic range for the second input based on the dynamic range of the output and the dynamic range of a first input. The eighth rule infers an output dynamic range Eo based on dynamic range of the first input and second input.

In one embodiment if any of the above rules are in conflict then one rule may be selected that yields the lowest precision and most restricted range of exponents. For example if a multiply operation has inputs with 24 bit precision and an output with 12 bit precision then rule 5 will be applied in preference to rule 6 to reduce the input precision. In one embodiment a rule will not be applied if its application increases precision or dynamic range. Rules are only applied when they reduce precision and or restrict dynamic range.

In one embodiment the PPU includes an input output I O unit configured to transmit and receive communications i.e. commands data etc. from a central processing unit CPU not shown over the system bus . The I O unit may implement a Peripheral Component Interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the I O unit may implement other types of well known bus interfaces.

The PPU also includes a host interface unit that decodes the commands and transmits the commands to a task management unit or other units of the PPU e.g. memory interface as the commands may specify. The host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory e.g. memory or system memory that is accessible i.e. read write by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the task management unit TMU with pointers to one or more streams. The TMU selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.

A work distribution unit that is coupled between the TMU and the SMs manages a pool of active grids selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the TMU when a pending grid is eligible to execute i.e. has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit and the work distribution unit the TMU also receives grids that are dynamically generated by the SMs during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.

In one embodiment the CPU executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions i.e. API calls that cause the driver kernel to generate one or more grids for execution. In one embodiment the PPU implements a SIMD Single Instruction Multiple Data architecture where each thread block i.e. warp in a grid is concurrently executed on a different data set by different threads in the thread block. The driver kernel defines thread blocks that are comprised of k related threads such that threads in the same thread block may exchange data through shared memory. In one embodiment a thread block comprises 32 related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may exchange data through global memory.

In one embodiment the PPU comprises X SMs X . For example the PPU may include 15 distinct SMs . Each SM is multi threaded and configured to execute a plurality of threads e.g. 32 threads from a particular thread block concurrently. Each of the SMs is connected to a level two L2 cache via a crossbar or other type of interconnect network . The L2 cache is connected to one or more memory interfaces . Memory interfaces implement 16 32 64 128 bit data buses or the like for high speed data transfer. In one embodiment the PPU comprises U memory interfaces U where each memory interface U is connected to a corresponding memory device U . For example PPU may be connected to up to six memory devices such as graphics double data rate version 5 synchronous dynamic random access memory GDDR5 SDRAM .

In one embodiment the PPU implements a multi level memory hierarchy. The memory devices may be located off chip in SDRAM coupled to the PPU . Data from the memory devices may be fetched and stored in the L2 cache which is located on chip and is shared between the various SMs . In one embodiment each of the SMs also implements an L1 cache. The L1 cache may be implemented as private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .

In one embodiment the PPU comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads rectangles triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes or rendering parameters associated with each vertex of the primitive. Rendering parameters may include one of more of position color surface normal vector texture coordinates etc. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display . The driver kernel implements a graphics processing pipeline such as the graphics processing pipeline defined by the OpenGL API.

An application writes model data for a scene i.e. a collection of vertices and rendering parameters to memory such as system memory associated with the CPU or memory devices . The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to a buffer to perform one or more operations to process the model data. The commands may encode different shader programs including one or more of a vertex shader hull shader geometry shader pixel shader etc. For example the TMU may configure one or more SMs to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the TMU may configure different SMs to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA a digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PPU may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPU may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

As described above the work distribution unit dispatches active grids for execution on one or more SMs of the PPU . The scheduler unit receives the grids from the work distribution unit and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different thread blocks allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units i.e. cores DPUs SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. 192 etc. of distinct processing cores . Each core implements a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M DPUs that implement double precision floating point arithmetic N SFUs that perform special functions e.g. copy rectangle pixel blending operations and the like and P LSUs that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 64 DPUs 32 SFUs and 32 LSUs .

Each SM includes interconnect network configured to connect each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

In one embodiment the SM is implemented within a GPU. In such an embodiment the SM comprises J texture units . The texture units are configured to load texture maps i.e. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs. The texture units implement texture operations such as anti aliasing operations using mip maps i.e. texture maps of varying levels of detail . In one embodiment the SM includes 16 texture units .

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

As shown in the graphics processing pipeline comprises a pipeline architecture that includes a number of stages. The stages include but are not limited to a data assembly stage a vertex shader stage a hull shader stage a tessellation primitive assembly stage a domain shader stage a geometry shader stage a viewport transform stage a rasterization stage a pixel shader stage and a raster operations stage . In one embodiment the input data comprises commands that configure the processing units to implement the stages of the graphics processing pipeline and high order geometric primitives to be processed by the stages. The output data may comprise pixel data i.e. color data that is copied into a frame buffer or other type of surface data structure in a memory e.g. memory . The SMs may be configured by shader program instructions to function as one or more of the shader stages e.g. vertex hull domain geometry and pixel shaders .

The data assembly stage receives the input data that specifies vertex data for high order graphics geometry. The data assembly stage collects the vertex data defining the high order graphics geometry in a temporary storage or queue such as by receiving a command from the host processor that includes a pointer to a buffer in a memory system and reading the vertex data from the buffer. In one embodiment the memory system may include one or more of the memory the L2 cache and the shared memory L1 cache . The vertex data is then transmitted to the vertex shader stage for processing.

The vertex shader stage processes vertex data by performing a set of operations i.e. a vertex shader or a program once for each of the vertices. Vertices may be e.g. specified as a 4 coordinate vector associated with one or more vertex attributes. The vertex shader stage may manipulate properties such as position color texture coordinates and the like. In other words the vertex shader stage performs operations on the vertex coordinates or other vertex attributes associated with a vertex. Such operations commonly including lighting operations i.e. modifying color attributes for a vertex and transformation operations i.e. modifying the coordinate space for a vertex . For example vertices may be specified using coordinates in an object coordinate space which are transformed by multiplying the coordinates by a matrix that translates the coordinates from the object coordinate space into a world space or a normalized device coordinate NCD space. The vertex shader stage generates transformed vertex data that is transmitted to the hull shader stage .

Conventional graphics processing pipelines transmit the transformed vertex data between different stages through a set of pipeline registers or a dedicated FIFO buffer. As shown in the vertex shader stage may pass the vertex data directly to the hull shader stage .

The tessellation primitive assembly stage receives the control points passed from the hull shader stage and tessellates the patches into geometric primitives for processing by the domain shader stage . For example the tessellation primitive assembly stage may be configured to group every three consecutive vertices as a geometric primitive i.e. a triangle for transmission to the domain shader stage . In some embodiments specific vertices may be reused for consecutive geometric primitives e.g. two consecutive triangles in a triangle strip may share two vertices . After tessellation the amount of data representing graphics geometry received as input data may be significantly larger because the granularity of the geometry typically becomes finer requiring more data as the geometry is processed by the different stages of the graphics processing pipeline.

The domain shader stage computes vertex position attributes for each tessellated vertex. The vertex position attributes generated by the domain shader stage may be passed directly to the geometry shader stage or may be passed to the geometry shader stage . The geometry shader stage processes geometric primitives by performing a set of operations i.e. a geometry shader program on the geometric primitives. Geometry shading operations may generate one or more geometric primitives from each geometric primitive. In other words the geometry shader stage may subdivide each geometric primitive into a finer mesh of two or more geometric primitives for processing by the rest of the graphics processing pipeline . The geometry shader stage transmits resulting geometric primitives e.g. points lines triangles and the like to the viewport stage .

The viewport stage performs a viewport transform culling and clipping of the geometric primitives. Each surface being rendered to is associated with an abstract camera position. The camera position represents a location of a viewer looking at the scene and defines a viewing frustum that encloses the objects of the scene. The viewing frustum may include a viewing plane a rear plane and four clipping planes. Any geometric primitive entirely outside of the viewing frustum may be culled i.e. discarded because the geometric primitive will not contribute to the final rendered scene. Any geometric primitive that is partially inside the viewing frustum and partially outside the viewing frustum may be clipped i.e. transformed into a new geometric primitive that is enclosed within the viewing frustum. Furthermore geometric primitives my each be scaled based on depth of the viewing frustum. All potentially visible geometric primitives are then transmitted to the rasterization stage .

The rasterization stage converts the 3D geometric primitives into 2D fragments. The rasterization stage may be configured to utilize the vertices of the geometric primitives to setup a set of plane equations from which various attributes can be interpolated. The rasterization stage may also compute a coverage mask for a plurality of pixels that indicates whether one or more sample locations for a pixel intercept the geometric primitive. In one embodiment z testing may also be performed to determine if the geometric primitive is occluded by other geometric primitives that have already been rasterized. The rasterization stage generates fragment data i.e. coverage masks for each covered geometric primitive that are transmitted to the pixel shader stage .

The pixel shader stage processes fragment data by performing a set of operations i.e. a fragment shader or a program on each of the fragments. The pixel shader stage may generate pixel data i.e. color values for the fragment such as by performing lighting operations or sampling texture maps using interpolated texture coordinates for the fragment. The pixel shader stage generates pixel data that is transmitted to the raster operations stage . In one embodiment the pixel shader stage may access data generated by an upstream processing unit. For example the pixel shader stage may read per patch attributes that were generated by the hull shader stage and or per primitive attributes that were generated by the geometry shader stage . In one embodiment the viewport stage may be configured to compute additional attributes for clipped perspective corrected barycentric coordinates that are used by the pixel shader stage to perform barycentric interpolation to compute per sample or per pixel attributes. In another embodiment the pixel shader stage may read per patch control point attributes and compute the per sample or per pixel attributes.

The raster operations stage may perform various operations on the pixel data such as performing alpha tests stencil tests and blending the pixel data with other pixel data corresponding to other fragments associated with the pixel. When the raster operations stage has finished processing the pixel data i.e. the output data the pixel data may be written to a render target such as a frame buffer a color buffer or the like. The raster operations stage may be configured to perform gamma adjustment operations to decode and or encode one or more sets of digital video data.

It will be appreciated that one or more additional stages may be included in the graphics processing pipeline in addition to or in lieu of one or more of the stages described above. Various implementations of the abstract graphics processing pipeline may implement different stages. Furthermore one or more of the stages described above may be excluded from the graphics processing pipeline in some embodiments. Other types of graphics processing pipelines are contemplated as being within the scope of the present disclosure. Furthermore any of the stages of the graphics processing pipeline may be implemented by one or more dedicated hardware units within a graphics processor such as PPU . Other stages of the graphics processing pipeline may be implemented by programmable hardware units such as the SM of the PPU .

As shown the arithmetic unit comprises an input casting unit a math function unit and an output casting unit . An instruction op code is configured to include an arithmetic operation and at least an output casting operation an input casting operation or a combination of both casting operations and . The arithmetic operation the output casting operation and the input casting operation may be encoded together or as independent fields comprising the instruction op code . The input casting operation configures the input casting unit to perform a specified casting operation on an input an input or both input and input . In one embodiment input and input may have different independent casting operations applied. Input may comprise a scalar value or a vector comprising W1 numeric elements. Similarly input may comprise a scalar value or a vector comprising W2 numeric elements. Input and input may each be cast to a required type to generate input and input respectively. Math function unit is configured to perform the arithmetic operation on input and input to generate output which may include a scalar value or a vector comprising W3 numeric elements.

In one embodiment math function unit comprises a plurality of independent math function units each configured to perform arithmetic operation according to a specific numeric type. For example math function unit may include independent math function units whereby a first math function unit is configured to operate on twelve bit integers a second math function unit configured to operate on twenty four bit integers and a third math function unit configured to operate on floating point values. When a twelve bit arithmetic operation is required the twelve bit math function unit performs the arithmetic operation requiring less power than either of the other two math function units. A given math function unit may be selected based on dynamic range and numeric resolution requirements associated with input input and output . Alternatively math function unit may comprise a single math function unit configured to perform arithmetic operations at different numeric resolutions in either a floating point or fixed point mode. To reduce power consumption the math function unit may include certain circuit features configured to disable superfluous circuitry. For example circuitry associated with calculating an output exponent may be disabled when the math function unit is computing a fixed point output . In such an embodiment the math function unit may be configured to compute output according to a minimum numeric resolution and a minimum dynamic range dictated by requirements of input input and output .

Method begins in step where a processing unit receives a casting arithmetic instruction. The casting arithmetic instruction specifies an arithmetic operation and one or more casting operation. A given casting operation may be specified to apply to an input of the arithmetic operation or the output of the arithmetic operation. If in step the casting arithmetic instruction specifies a casting operation for at least one input then the method proceeds to step . In step the processing unit applies the casting operation to a specified first input. In certain embodiments the casting operation a different casting operation or no casting operation is applied to a second input.

Returning to step if the casting arithmetic instruction specifies no casting operation for an input then the method proceeds to step . In step the processing unit performs the specified arithmetic operation associated with the casting arithmetic instruction. The specified arithmetic operation generates an intermediate output value. The specified arithmetic operation may comprise without limitation addition subtraction multiplication division a square root a power function a reciprocal or any other technically feasible arithmetic function. The arithmetic operation may be performed as a floating point operation a signed fixed point operation or an unsigned fixed point operation. These arithmetic operations may be performed on one or more scalar inputs or one or more vector inputs. Each arithmetic operation may be performed over one or more pipeline stages. Each input value may be retrieved from a register that is local to the processing unit a memory subsystem coupled to the processing unit or any other technically feasible data storage circuit.

If in step the casting arithmetic instruction specifies a casting operation for the output then the method proceeds to step where the processing unit applies an output casting operation to the intermediate output value to generate an output value. If the casting arithmetic instruction does not specify a casting operation then the output value is assigned to be the intermediate output value.

An edge may be labeled with a specified numeric attribute in the form sign dynamic range numeric resolution in bits . A question mark in the sign field indicates that an associated numeric value may be arbitrary. That is the numeric value may be positive or negative. A in the sign field indicates that the numeric value must be positive while a indicates that the numeric value must be negative. A question mark in the dynamic range field indicates that the dynamic range may be arbitrary with respect to available dynamic ranges. A floating point representation accommodates an arbitrary dynamic range limited only by the number of available exponent bits. A zero in the dynamic range field indicates the value has a narrow dynamic range in the range 0 1 . A number such as 24 or 12 in the last position of an edge attribute indicates twenty four bits or twelve bits of precision respectively. As shown light normal is a vec3 type and has attributes of 0 24 indicating that each element of the vec3 may have an arbitrary sign each element is in the range 0 1 and that each element requires a numeric resolution of twenty four bits. By contrast gl fragcolor is vec4 comprising four elements with each of the four elements defined to be a positive value in the range 0 1 and requiring twelve bits of precision.

As shown the table lists a total number of floating point operations under Floating Point Operations associated with computing each output of gl fragcolor. A total of thirty eight floating point multiplies F twenty one floating point additions F two floating point reciprocals FR one floating point square root and one floating point power function POW are performed conventionally using pure floating point arithmetic throughout the fragment shader program. Energy per operation Eop for each floating point multiply is approximately nine units of energy and each floating point addition consumes approximately eight units of energy. Total energy for generating each gl fragcolor output is approximately five hundred and ten units of energy comprising three hundred and forty two units of energy for performing floating point multiplication and one hundred and sixty eight units of energy for performing floating point addition. By transforming ten floating point multiplication operations within statement seven of to corresponding twenty four bit integer multiplication operations I24 approximately fifty units of energy may be saved. Similarly approximately one hundred and seventy six units of energy may be saved by transforming a total of twenty two multiplication statements associated with statements five six seven and nine to corresponding twelve bit integer multiplication operations. In total three hundred and forty seven units of energy may be saved from a total of five hundred and ten units of energy required by multiplication and addition operations performed in conjunction with generating each gl fragcolor output.

In one embodiment numeric attributes are propagated between and among different rendering passes or resulting data sets. For example numeric attributes for output image may be propagated through rendering pass and further propagated to shadow map and environment map and further propagated to the shadow map rendering pass Environment map rendering pass and finally geometry node . Method may be applied recursively over data flow graph and each rendering pass associated with nodes comprising data flow graph . In another embodiment the programmer may explicitly declare the attributes for the output of each rendering pass. For example a shadow map typically is a binary representation 0 1 . With respect to a given light source a fragment is either in shadow or it isn t. Thus the programmer can declare the required range and precision for the shadow map.

In one embodiment the compiler of is configured to execute on central processor of and to generate a shader program for execution on graphics processor configured to implement a parallel processing unit of . The shader program may comprise casting instructions casting arithmetic instructions integer instructions or any combination thereof. The shader program may also comprise floating point instructions.

The system also includes input devices a graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit GPU .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk DVD drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner. Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. The main memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor a chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit board system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant PDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

