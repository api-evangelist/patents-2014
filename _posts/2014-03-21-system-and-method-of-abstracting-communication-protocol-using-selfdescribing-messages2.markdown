---

title: System and method of abstracting communication protocol using self-describing messages
abstract: A system and method for abstracting communication protocol using self-describing messages. The method includes providing a first communication protocol having control codes and binary messages having a self-describing schema of a data object model. The method includes providing a second communication protocol where instances of the second communication protocol are associatively mapped to the instances of the first communication protocol. The method includes receiving a message in the second communication protocol. The method includes classifying the message as being either a control message or a data message and translating it to a second message where upon the message has been classified as a control message, the processor maps the control message to one or more control codes and where upon the message has been classified as a data message, the processor maps the data message to a corresponding binary message having the self-describing schema.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09560170&OS=09560170&RS=09560170
owner: PTC Inc.
number: 09560170
owner_city: Needham
owner_country: US
publication_date: 20140321
---
This invention generally relates to machine to machine communication. More particularly in certain embodiment the invention relates to abstracting messages embodied in a third party communication protocol to self describing message embodied in a dynamic REST communication protocol.

The business of building a connected world also referred to as the Internet of Things is rapidly growing. Some industry analysts have estimated that the number of connected devices and systems in an industrial consumer government and business setting may rise from five billion devices to a trillion devices over the next ten years. A substantial portion of that growth will be devices and systems using wireless communication such as over cellular networks.

Common challenges in the controls and management of such connected devices include scalability and operability not only within a particular vendor s own platform but among the various platforms being offered by different vendors. One particular intersection of these challenges is the communication protocol used in the controls and management of such devices. These protocols define how devices talk among each other what they say when they say it and who they say it to. Another intersection of these challenges is the architecture defining the organization of these devices.

To promote inter intra operability a flexible protocol is desired. A popular communication protocol and architecture is the Hypertext Transfer Protocol based HTTP REpresentational State Transfer REST application programming interface API also referred to as HTTP RESTful API. REST is a style of software architecture for distributed systems that may employ a standardized interface such as HTTP. An application conforming to the REST constraints may be described as RESTful .

In some implementations HTTP RESTful API may use open standard formats. Two popular open standard formats include JavaScript Object Notation JSON and Extensive Markup Language XML data formatting. Both formats employ human readable text to transmit data objects and thus provide a flexible and open scheme for communication. The trade off for such open standard formats is verbosity.

HTTP is the foundation of data communication for the World Wide Web commonly referred to as the Web which is a system of interlinked hypertext documents accessible via the Internet. The Internet collectively describes an interconnected network of computers and networks. Although HTTP is not restrictive as a communication protocol the usage of HTTP has been limited to unidirectional communication due to traffic routing devices and security devices such as firewalls and Network Address Translation employed with a computing and network infrastructure often employ security mechanisms.

HTTP polling is a typical technique used to overcome the unidirectional nature of HTTP across such Internet infrastructure. The technique provides firewall transparency and two way communication but at a tradeoff of high reply message latency responsiveness high bandwidth consumption and high server utilization.

In general overview a vast number of computing devices connects to a computing platform that services data and information for the computing devices. This disclosure describes the usage of persistent connections such as provided by WebSocket API protocols to provide a low latency bidirectional connection between two nodes in a network.

To promote inter intra operability while reducing bandwidth usage over this connection a messaging protocol is employed to serialized the binary data of messages constructed from data and informational models that are understood by the computing application operating at both the ends of the transmission node. For example in some implementations this protocol uses a binary representation of message and metadata constructs of existing dynamic REST API protocols. The protocol in some implementations is easily convertible to and from open standard formats such as JavaScript Object Notation JSON .

To promote ease of use of the protocol the protocol may employ a similar request response construct as HTTP though in binary format. Layered on to of this is a RESTful style architecture that supports the reading writing of data executing remote procedures services event transport and extended functionality such as file transfer and application tunneling.

To facilitate the transmission of large messages using a small fixed memory usage of each connection the protocol chunks the message and reassembles them at the application level rather than at the transport level.

To reduce the memory requirement for the protocol in some implementations the protocol encodes a first portion set of a message with binary representations using symbols from a codebook library. In some implementations the binary representation includes byte enumerations. The protocol may convert a second portion set of the message using standard data formats that are native to a given computing device. Examples of such standard data formats may include the Unicode characters such as UTF 8.

In one aspect the present disclosure describes a communication device including a port configured to receive binary data streams representing messages. Each of the data stream may include a binary header and a binary body. The binary body may have a metadata construct and a message construct in which the message construct includes one or more groups of data values. The metadata construct may include one or more groups of description values corresponding to a given data value of the one or more data values forming the message construct.

In some implementations the communication device includes a memory that stores a first structural description of binary header and a binary body. The memory may also store a second structural description of the metadata construct. The binary header may be unencrypted where the binary body is encrypted.

In some implementations the communication device may include a processor. The processor may parse a received binary data stream to reproduce a received message. The processor may parse the received binary data stream using the first structural description to determine the binary header and the binary body. The processor may parse the binary body using the second structural description to determine the one or more groups of description values forming the metadata construct. The processor may use a portion of the determined description values of the metadata construct to determine the one or more groups of data values of the message construct.

In some implementations each of the one or more data values of the message construct and each of the one or more description value of the metadata construct may be delineated by a binary marker. The binary marker may be a single byte long. The binary marker may include a first value to define each beginning of a data value set or a description value set and a second value to define an end of each of the metadata construct and the message construct. The entire message construct may be delimited only with the binary marker.

In some implementations each of the one or more groups of description values may form the metadata construct having a data value name descriptor a data value description descriptor and a data value type descriptor. The groups of description value collectively may form a definition for each of the data value in the message construct. The metadata construct may precede the message construct in forming the binary body.

In some implementations a portion of the metadata construct and a portion of the message construct correspond to a set of characters defined by a universal standard code.

In one aspect the present disclosure describes a method of using binary Dynamic REST message. The method may include storing at a memory a first structural description of the binary header and the binary body and a second structural description of the metadata construct where the metadata construct comprises one or more groups of description values corresponding to a given data value of the one or more data values forming the message construct. Each of the one or more data values of the message construct and each of the one or more description value of the metadata construct may be delineated by a binary marker.

In some implementations the method may include receiving at a port a plurality of binary data streams representing a plurality of messages. The binary data streams may be received via Web sockets.

In some implementations the method may include parsing using a processor each of the received binary data streams using the first structural description to determine the binary header and the binary body. The binary header is unencrypted and the binary body is encrypted.

In some implementations the method may include parsing using the processor the parsed binary body using the second structural description to determine the one or more groups of description values forming the metadata construct where the processor uses a portion of the determined description values of the metadata construct to determine the one or more groups of data values of the message construct. The metadata construct may include a data value name descriptor a data value description descriptor and a data value type descriptor. descriptor. The metadata construct may precede the message construct in forming the binary body. A portion of the metadata construct and a portion of the message construct may correspond to a set of characters defined by a universal standard code.

In one aspect the present disclosure describes a non transitory computer readable medium having instructions stored thereon where the instructions when executed by a processor cause the processor to store at a memory a first structural description of the binary header and the binary body and a second structural description of the metadata construct where the metadata construct comprises one or more groups of description values corresponding to a given data value of the one or more data values forming the message construct. Each of the one or more data values of the message construct and each of the one or more description value of the metadata construct may be delineated by a binary marker.

In some implementations the instructions when executed further cause the processor to receive at a port a plurality of binary data streams representing a plurality of messages. The binary data streams may be received via Web sockets.

In some implementations the instructions when executed further cause the processor to parse using a processor each of the received binary data streams using the first structural description to determine the binary header and the binary body. The binary header is unencrypted and the binary body is encrypted.

In some implementations the instructions when executed further cause the processor to parse using the processor the parsed binary body using the second structural description to determine the one or more groups of description values forming the metadata construct where the processor uses a portion of the determined description values of the metadata construct to determine the one or more groups of data values of the message construct. The metadata construct may include a data value name descriptor a data value description descriptor and a data value type descriptor. The metadata construct may precede the message construct in forming the binary body. A portion of the metadata construct and a portion of the message construct may correspond to a set of characters defined by a universal standard code.

In one aspects the present disclosure describes a communication device having a memory for storing a structural description of a message defined by a self describing schema where the structural description describes a structure interspersed by both one or more label elements and one or more punctuation elements among the data objects to describe a given message. The memory further stores a codebook having a set of binary symbols corresponding to the binary representations. The communication device may include a processor configured to generate a binary data stream to transmit to another computer device via a communication port. The processor may generate the binary data stream from a received message defined by the self describing schema in which the received message may include one or more data objects delimited by one or more both label elements and one or more punctuation elements. The processor may parse the received message for one or more data objects according to the stored structural description. The processor may serially map each of the elements of a parsed data objects to a binary symbol defined in the codebook to produce a binary data stream where when serially mapping each of the elements of the parsed data objects the processor does not map the one or more label elements and one or more punctuation elements interspersed among the data objects in to the binary data stream.

In another aspect the present disclosure describes a communication device including a port configured to transmit and receive a data stream via a persistent stateless connection. the persistent stateless connection may be over a web socket connection.

In some implementations the communication device may include a memory storing a dynamic REST API model.

In some implementations the communication device may include a processor configured to connect to a second communication device over the persistent stateless connection. The processor formats a request message with the stored dynamic REST API model to produce a self describing request message. The dynamic REST API model may include a data model that includes a data object an event object a service object a property object and an attribute object. The processor causes the self describing request message to be transmitted over the port. The port may be a HTTP or HTTPS port having a value of 80 or 443. The self describing request message may be presented in at least one of a JavaScript Object Notation JSON object and an Extensible Markup Language XML object. The self describing request message may be formatted in a binary format. The self describing request message may be encrypted.

In another aspect the present disclosure describes a method of using dynamic REST messages with Web sockets. The method may include storing at a memory of a device a binary dynamic REST API model.

In some implementations the method may include formatting via a processor at the device a request message using the binary dynamic REST API model to produce a self describing request message.

In some implementations the method may include transmitting via a port of the device the request message over a persistent state connection. The dynamic REST API model may include a data model that includes a data object an event object a service object a property object and an attribute object. The processor causes the self describing request message to be transmitted over the port. The port may be a HTTP or HTTPS port having a value of 80 or 443. The self describing request message may be presented in at least one of a JavaScript Object Notation JSON object and an Extensible Markup Language XML object. The self describing request message may be formatted in a binary format. The self describing request message may be encrypted.

In another aspect the present disclosure describes a non transitory computer readable medium having instructions stored thereon where the instructions when executed by a processor cause the processor to store at a memory of a device a binary dynamic REST API model.

In some implementations the instructions when executed further cause the processor to format via a processor at the device a request message using the binary dynamic REST API model to produce a self describing request message.

In some implementations the instructions when executed further cause the processor to transmit via a port of the device the request message over a persistent state connection. The dynamic REST API model may include a data model that includes a data object an event object a service object a property object and an attribute object. The processor causes the self describing request message to be transmitted over the port. The port may be a HTTP or HTTPS port having a value of 80 or 443. The self describing request message may be presented in at least one of a JavaScript Object Notation JSON object and an Extensible Markup Language XML object. The self describing request message may be formatted in a binary format. The self describing request message may be encrypted.

In yet another aspect the present disclosure describes a method of abstracting a communication protocol using self describing message. The method may include providing a first communication protocol and a second communication protocol in a memory of a device where the first communication protocol includes a number of control codes and binary messages having a self describing schema. The self describing schema may be of a data object model wherein instances of the second communication protocol are associatively mapped to the instances of the first communication protocol. The associative mapping between the first communication protocol and the second communication protocol may be stored in persistent memory.

In some implementations the associative mapping of the control codes may be based on a HTML framework.

In some implementations the associate mapping of the data message may be based on a service request selected from a group consisting of a GET request a PUT request a POST request and a DELETE request.

The wireless connection may include a network selected from a group consisting of Zigbee Bluetooth WiMax Wi Fi GSM PCS and D AMPS IEC 6LoWPAN Ant DASH7 EnOcean INSTEON NeuRF ON Senceive WirelessHART Contiki TinyOS GPRS TCP IP CoAP MQTT TR 50 OMA LW M2M ETSI M2M. The data object model may be structured in a dynamic REST API object model.

In some implementations the method may include receiving at a port of a computing device a first instantiation of a message in the second communication protocol. The message may be received via a wireless connection.

In some implementations the method may include classifying by a processor of the computing device the first instantiation of the message as being either a control message or a data messages.

In some implementations the method may include translating by a processor of the computing device the first instantiation of the message to produce a second instantiation of the message where upon the message having been classified as a control message the processor maps the control message to one or more control codes of the plurality of control codes and where upon the message having been classified as a data message the processor maps the data message to a corresponding binary message having the self describing schema.

In some implementations the method may include transmitting at the port of the computing device the second instantiation of the message. The first communication device may transmit the second instantiation of the message to the platform server over a web socket connection.

In yet another aspect the present disclosure describes a system including a processor and a memory the memory storing instruction that when executed by the processor cause the processor to provide a first communication protocol and a second communication protocol in a memory of a device where the first communication protocol includes a number of control codes and binary messages having a self describing schema. The self describing schema may be of a data object model wherein instances of the second communication protocol are associatively mapped to the instances of the first communication protocol. The associative mapping between the first communication protocol and the second communication protocol may be stored in persistent memory.

In some implementations the wireless connection may include a network selected from a group consisting of Zigbee Bluetooth WiMax Wi Fi GSM PCS and D AMPS IEC 6LoWPAN Ant DASH7 EnOcean INSTEON NeuRF ON Senceive WirelessHART Contiki TinyOS GPRS TCP IP CoAP MQTT TR 50 OMA LW M2M ETSI M2M. The data object model may be structured in a dynamic REST API object model.

In some implementations the associative mapping of the control codes may be based on a HTML framework. In some implementations the associate mapping of the data message may be based on a service request selected from a group consisting of a GET request a PUT request a POST request and a DELETE request.

In some implementations the instructions when executed further cause the processor to receive at a port of a computing device a first instantiation of a message in the second communication protocol. The message may be received via a wireless connection.

In some implementations the instructions when executed further cause the processor to classify the first instantiation of the message as being either a control message or a data messages.

In some implementations the instructions when executed further cause the processor to translate the first instantiation of the message to produce a second instantiation of the message where upon the message having been classified as a control message the processor maps the control message to one or more control codes of the plurality of control codes and where upon the message having been classified as a data message the processor maps the data message to a corresponding binary message having the self describing schema.

In some implementations the method may include transmitting at the port of the computing device the second instantiation of the message. The first communication device may transmit the second instantiation of the message to the platform server over a web socket connection.

In yet another aspect the present disclosure describes a non transitory computer readable medium having instructions stored thereon where the instructions when executed by a processor cause the processor to provide a first communication protocol and a second communication protocol in a memory of a device where the first communication protocol may include a number of control codes and binary messages having a self describing schema. The self describing schema may be of a data object model wherein instances of the second communication protocol are associatively mapped to the instances of the first communication protocol. The associative mapping between the first communication protocol and the second communication protocol may be stored in persistent memory.

In some implementations the wireless connection may include a network selected from a group consisting of Zigbee Bluetooth WiMax Wi Fi GSM PCS and D AMPS IEC 6LoWPAN Ant DASH7 EnOcean INSTEON NeuRF ON Senceive WirelessHART Contiki TinyOS GPRS TCP IP CoAP MQTT TR 50 OMA LW M2M ETSI M2M. The data object model may be structured in a dynamic REST API object model.

In some implementations the associative mapping of the control codes may be based on a HTML framework. In some implementations the associate mapping of the data message may be based on a service request selected from a group consisting of a GET request a PUT request a POST request and a DELETE request.

In some implementations the instructions when executed further cause the processor to receive at a port of a computing device a first instantiation of a message in the second communication protocol. The message may be received via a wireless connection.

In some implementations the instructions when executed further cause the processor to classify the first instantiation of the message as being either a control message or a data messages.

In some implementations the instructions when executed further cause the processor to translate the first instantiation of the message to produce a second instantiation of the message where upon the message having been classified as a control message the processor maps the control message to one or more control codes of the plurality of control codes and where upon the message having been classified as a data message the processor maps the data message to a corresponding binary message having the self describing schema.

In some implementations the method may include transmitting at the port of the computing device the second instantiation of the message. The first communication device may transmit the second instantiation of the message to the platform server over a web socket connection.

In further yet another aspect the present disclosure describes a communication engine including a communication port configured to receive one or more data streams including a first data stream and a second data stream wherein the data stream comprises a binary dynamic REST messages. The data stream may include one or more data fields where each of the data fields include a field value and a length identifier of the field value the length identifier preceding a corresponding field value in each of the data fields. The communication port may receive the one or more input data stream over a web socket connection. The message may include a data object having an event object a service object a property object and an attribute object. Each of the one or more input data streams may include an identifier of a number of one or more data streams that form a given complete executable message. Each of the one or more data streams may include a message number identifier that indicate a location of a given decoded data stream within the complete executable message. Each of the one or more data streams may form a portion of a complete executable message.

In some implementations the communication engine may include a first buffer to store a received first data stream and a received second data stream.

In some implementations the communication engine may include a second buffer to store portions of a decoded message.

In some implementations the communication engine may include a processor configured to decode the received data stream buffered within the first buffer to produce a given decoded portion. The processor may store the given decoded portion to the second buffer where the processor initiates decoding of the received first data stream buffered within the first buffer prior to a complete receipt of the received second data stream.

In some implementations the communication engine may include a second buffer to store decoded portions of the one or more data streams having been buffered in the first buffer where the processor transmits a signal when the second buffer comprises each of the one or more data streams forming a given complete executable message.

In some implementations the communication engine may include a decryption engine to decode an encrypted portion of the input data streams which is encrypted.

In further yet another aspect the present disclosure describes a method of using chunk based communication of binary Dynamic REST message. The method may include receiving at a port one or more data streams including a first data stream and a second data stream. The data stream may include one or more data fields where each of the data fields include a field value and a length identifier of the field value the length identifier preceding a corresponding field value in each of the data fields. The communication port may receive the one or more input data stream over a web socket connection. The message may include a data object having an event object a service object a property object and an attribute object. Each of the one or more input data streams may include an identifier of a number of one or more data streams that form a given complete executable message. Each of the one or more data streams may include a message number identifier that indicate a location of a given decoded data stream within the complete executable message. Each of the one or more data streams may form a portion of a complete executable message.

In some implementations the method may include storing at a first buffer a received first data stream and a received second data stream.

In some implementations the method may include storing at a second buffer portions of a decoded message.

In some implementations the method may include decoding using a processor the received data stream buffered within the first buffer to produce a given decoded portion. The processor initiates decoding of the received first data stream buffered within the first buffer prior to a complete receipt of the received second data stream.

In further yet another aspect the present disclosure describes a non transitory computer readable medium having instructions stored thereon where the instructions when executed by a processor cause the processor to receive at a port one or more data streams including a first data stream and a second data stream. The data stream may include one or more data fields where each of the data fields include a field value and a length identifier of the field value the length identifier preceding a corresponding field value in each of the data fields. The communication port may receive the one or more input data stream over a web socket connection. The message may include a data object having an event object a service object a property object and an attribute object. Each of the one or more input data streams may include an identifier of a number of one or more data streams that form a given complete executable message. Each of the one or more data streams may include a message number identifier that indicate a location of a given decoded data stream within the complete executable message. Each of the one or more data streams may form a portion of a complete executable message.

In some implementations the instructions when executed further cause the processor to store at a first buffer a received first data stream and a received second data stream.

In some implementations the instructions when executed further cause the processor to store at a second buffer portions of a decoded message.

In some implementations the instructions when executed further cause the processor to decode using a processor the received data stream buffered within the first buffer to produce a given decoded portion. The processor initiates decoding of the received first data stream buffered within the first buffer prior to a complete receipt of the received second data stream.

The features and advantages of the present disclosure will become more apparent from the detailed description set forth below when taken in conjunction with the drawings in which like reference characters identify corresponding elements throughout. In the drawings like reference numbers generally indicate identical functionally similar and or structurally similar elements.

A computing device in some examples is an electronic device that can communicate properties services and events data and information relating a physical assets devices computer applications and systems people data objects and platform services. In some implementations the computing device is a sensor or a machinery at an industrial complex a computer or an office equipment at a business or government office a point of sale machine at a market place or a vending machine a construction equipment or a vehicle a power generation or distribution equipment a power substation or a transmission equipment a building meter a server a networking or routing equipment a smart appliance an exercise machine a medical device or a prosthesis device a medical diagnostic device or a hospital equipment a commercial vehicle or a transport container a motor vehicle or an electric bicycle a cellphone a laptop a tablet an electronic reader or a clothing electronic tag.

While serving data and information for sets of computing devices one or more edge servers communicate to an intermediary server referred to as an API server or connection server . In some implementation the communication exchange occurs across a network infrastructure such as the Internet a Wide area network or a third party network . In turn one or more API servers communicate to the platform server . The platform server the API servers and the edge servers collectively form a distributed computing environment for serving data and information of the computing devices . In some implementations a given API server communicates to a set of edge servers through a set of network security equipment that secures the API server and the platform server from the network infrastructure and that secures the groups of edge servers and computing devices . For example the network security equipment may run a firewall or Network Address Translation NAT protocol.

The platform server runs a server client application having an API protocol library defining the API protocol. The edge server runs a server client application having the same API protocol library . To this end messages being communicated between the platform server and the edge servers share for the most part the same structure. In some implementations the same API protocol is employed among all of the components within the distributed computing environment.

This symmetry is intended to reduce the complexity of operation of the connection server as the connection server can service each communicated message in the same manner without much regard to the source or target.

The API protocol library operates with a number of server client application functions that dynamically generates application interfaces for servicing data and information. In some implementation the application interface is based on a Dynamic REST API that generates binary message. In other implementations the interface is based on JavaScript Object Notation JSON or Extensive Markup Language XML data formatting. Examples of usage of Dynamic REST APIs in a model based development application is described in U.S. patent application Ser. No. 13 678 885 titled METHODS FOR DYNAMICALLY GENERATING APPLICATION INTERFACES FOR MODELED ENTITIES AND DEVICES THEREOF filed Nov. 16 2012. The application is incorporated by reference in its entirety.

The Dynamic REST API employs a model based schema to describe data and information in which the inputs and outputs of the schema is expressed in a self describing textual data format such as JSON or XML. The application interface is dynamic in that data and information are represented in an evolving and modify able framework. Specifically the application interface employs a series of characteristic definitions to describe types of information relating to a given entity such as a physical asset device a computer application system a person a data object or a platform service.

In some implementations the binary Dynamic REST API component outputs serialized binary data representing data and informational models.

In some implementations these characteristic definitions include a property definition a service definition an event definition and an attribute definition . Each of these characteristic definitions serves as an elementary building block in describing a model of the entity and is expressed as an abstract class that can inherit one or more classes abstract classes and data structures. The characteristic definitions are organized collectively in a template class with other characteristic definitions. To this end a developer of applications to service data and information of a computing device may model an entity also referred to as a Thing that represents a physical world equivalent containing the complete set of data services events historical activities collaboration relationships that define a Thing and its place in the organizational landscape.

In some implementations a Thing is defined as an instance of a Thing Template. A Thing Template is also an abstract class that can inherit from one or more Thing Shapes. Properties services and events can be defined at the Thing Shape Thing Template or Thing instance. If a Thing Template inherits from one or more Thing Shapes all of the properties events and services of the Thing Shapes are a part of the Thing Template. When a Thing instance is created from a Thing Template all of the properties events and services of the Thing Template are realized within the Thing instance. 

In some implementations data objects may be represented as InfoTables and Streams. InfoTables and Streams may be beneficially described and defined by DataShapes which are reusable abstract data object definitions. An InfoTable is similar to a relational database table which represents a two dimensional data object having columns and rows . A Stream is designed to capture time series data. Time series data is the data that is most often found as part of the communication flow for devices and machines. Streams and InfoTables also have services and events.

All of the entities can based on authorizations subscribe to any other entities events and can consume other entity services. When an entity is defined it is immediately discoverable through a standard Representational State Transfer REST interface over HTTP or HTTPS. Therefore the complete model namespace is available over a dynamic REST interface. Whatever a user defines the model to be appears as a REST interface. The REST interface for the model also includes a full description of the properties services and events for each entity. A service is a simple or complex function provided on a server which is accessible to a State Representational State Transfer REST interface. A service has inputs processing and outputs. An event is a simple or complex change of data and or status of an entity. An event has a well defined complex data output that is sent to each event subscriber when the event is detected.

The dynamic REST interface is based on an inheritance or object oriented model. If a new service property or capability is defined at the Thing Shape or Thing Template level each Thing instance that is derived from those entities immediately inherits that service property or capability. The Dynamic REST API employs this dynamic REST interface.

The REST interface for the namespace describes how to consume services for each entity in the model. As soon as a new Thing is defined in the model the full set of services and data for the Thing is available as a set of REST interfaces.

A message generated from the binary Dynamic REST API may include a metadata construct and a message construct. The metadata construct describes a given structure of the message construct. Collectively in some implementations the metadata construct and a message construct forms a message body .

The message construct may include the actual data sets that a server client application intends to transmit. In some implementations these data sets are referred to as Row Data . The datasets may include one or more data values . The metadata construct may include one or more description sets corresponding to a given data value forming the data set. The description sets may include one or more description values . In some implementations the metadata construct is referred to as a Datashape where each of the description sets forms a given field definition of the Datashape. Examples of field definitions may include a name description type and aspects. These definitions describe a given data in the Row Data .

In some implementations the message generated from the binary Dynamic REST API preferably includes a first type of binary markers to delineate each of the data sets and each of the description sets . These binary markers may mark the beginning of the data sets and the description sets. Additionally each of the metadata construct and the message construct may include a second binary marker to mark the end of the metadata construct and the message construct .

In some implementation each of the data sets and the description sets may include a data expressed as character strings numbers and enumerations . Character strings are text data. Numbers may include floating and fixed point numbers. Enumeration generally includes data types. Each character strings may include a length description field preceding the actual string value to provide a forward descriptor of the content. To this end a given character string in encoded form may be parsed without the complete character string being available. To this end groups of unknown data may include a count field to identifier the number of such data to follow.

To reduce the memory requirement for the protocol in some implementations the protocol encodes a first portion set of a message using binary representations defined as symbols stored in a codebook library. In some implementations the binary representation includes byte enumerations.

The protocol may convert a second portion set of the message using standard data formats that are native to a given computing device. Examples of such standard data formats may include the Unicode characters such as UTF 8.

The message may be formatted as a binary string optimized for transmission using a WebSocket protocol.

Turning back to the HTTP REST API may include messaging type definition codes and status codes derived from the HTTP framework as defined the Hypertext Transfer Protocol application protocol version 1.1 commonly referred to as HTTP 1.1 or HTTP and published in IETF W3C RFC 2616. The HTTP REST API codes are provided in . Examples of status codes include success code client error codes and server error codes . Examples of messaging type definition codes include those related to device binding authentication and request messaging.

In some implementations the messaging type definition codes and status codes may be a part of a message header having routing information for the message. An example of the structure of the message header is shown in . In some implementations the message header may include a header identification number routing information such as request identification number session number and endpoint identification number and method codes . The method codes may be used to specify the type of message located in the message content. The message header may include a multipart marker to indicate the message being a part of a collection of messages in which all of the data content of these messages form a single message.

Turning back to in some implementations the API protocol library may include a message partitioning module for segmenting a given message into a fixed size for transport. The segmenting may facilitate the transmission of large messages using a small fixed memory usage for each of the connection. The message partitioning module may chunk or partition a given message and reassemble them at the application level rather than at the transport level.

The API protocol library may inject metadata such as the length description field for character strings or the count fields as described in relation to to allow parsing of a given message content without the complete message. That is the metadata describes the content that is to follow. Using the message partitioning module a given message generated by the binary Dynamic REST API may be partitioned into chunks where each of the chunks may be decoded prior to the complete message is received.

To this end a message of any length may be decoded using a buffer of only two message lengths for the decoding. In some implementation the server client side application may employ a fixed buffer preferably between 1 Kbytes and 1 MBytes buffer even more preferably between 4 Kbytes and 64 Kbytes even more preferably between 4 Kbytes and 8 Kbytes.

An example of the structure of the message multipart header is shown in . As shown in the figure the message multipart header may include a current chunk identification number a total chunk number and a chunk size identifier . The message multipart header may be inserted between the header and the message body .

In some implementations the API protocol library may employ different message structures depending on the direction of message flow. For example for an inbound message from a client side application to the server side application the routing information may be reproduced in the multi part message header to provide the destination information.

Turning back to in some implementation the API protocol library may be used in conjunction with the WebSocket API to communicate the output message of the API protocol library via WebSocket. WebSocket API may be employed to stream messages on top of the Transmission Control Protocol TCP . In some implementation the WebSocket API is a part of HTML5 WebSocket protocol. The message output of the API protocol library may be configured to be entirely binary to further improve communication over the WebSocket API .

In some implementations the binary Dynamic REST API outputs a serialized binary stream corresponding to a self described message.

To this end the example shows a reduction of over 50 percent of the message length compared to a JSON format message of the same message content. A typical JSON message is organized having an attribute value pair delimited by colons in which the pair values may be another nest attribute value pair delimited by an open bracket and a closed bracket . The attribute value pair format provides a flexible schema to describe a message.

To improve the information efficiency of a given message the binary dynamic REST API may generate the message with only the data object. The binary dynamic REST API may store a structural description of the description values that form the metadata construct namely the DataShape . The description values in turn may provide a definition for the data values namely the Row Data in the message construct . In some implementations the binary dynamic REST API may inject a first binary markers to mark the beginning of the data sets the description sets and a second binary marker to mark the end of the metadata construct and the message construct . To this end the various punctuation and label elements such as those associated with JSON base message may not be necessary to include.

Specifically show examples of generating a metadata portion of a message in accordance with an embodiment of the invention. shows an example of generating the data portion of the message in accordance with an embodiment of the invention.

Turning now to the message structure of the metadata portion is shown along with a marked up of the JSON message shown in . The JSON message shows a self describing message having a metadata construct and a message construct.

The metadata portion may include one or more field definitions corresponding to the Datashape as described in relation to . As indicated each of the field definitions includes a marker field a name field a description field a type field an aspect count field and an aspect field .

A given message construct may include groups of data values to which a given metadata construct may include one or more groups of description values that describes this group of data value. As described in relation to the message construct may refer to the Row Data shown in the example as rows and the metadata construct may refer to the DataShape shown in the example as datashape .

As shown the datashape includes three field definitions. Encoding of two of the three field definitions pushThreshold and push Type are discussed in and the third three field definition edge Name is discussed in .

As shown each of the field definitions and includes a group of description values common to each other namely name description baseType and aspects . These description values are example implementations of a type of the characteristic definitions that may collectively form a template class of the model based schema used by the dynamic REST API as described in relation to .

As shown each of the group of definitions has an attribute value pair as is the style of the JSON format. In encoding the message only the value portion of the pair is used. The attribute is stored as part of a structural definition of the model based schema that is incorporated into the binary dynamic REST API .

To generate a binary message of this JSON example message in some implementations a marker value is first added to the binary message. As discussed in relation to a marker delineates each of the data sets such as the row data of the message construct and each of the description sets such as the field definitions of the metadata construct. The marker marks the beginning of the data sets and the description sets. Additionally a second type of marker marks the end of the metadata construct and the message construct. In some implementations the marker value may be a single digit binary value i.e. 1 or 0 .

In some implementations a name value a description value a baseType value and an aspect value may follow the marker .

The name value may be expressed as a character string. In the binary message a given character string may be defined by a length identifier that precedes the value of the character string which is expressed in UTF 8 format Unicode standard . As shown the character string pushThreshold has a length of 13 characters which can be represented in hexadecimal code as 0x0d and has a data value in hexadecimal code of 0x70 0x75 0x73 0x68 0x54 0x68 0x72 0x65 0x73 0x68 0x6f 0x6c 0x64 when expressed in UTF 8. This conversion is annotated in box . To this end the hexadecimal value 0x0d 0x70 0x75 0x73 0x68 0x54 0x68 0x72 0x65 0x73 0x68 0x6f 0x6c 0x64 is appended to the binary message.

As shown the description value is a character string having 39 characters hexadecimal code 0x57 . In UTF 8 the character string Change threshold to generate event for numeric properties is expressed in hex value as 

As shown the baseType value is represented as a type of data format. In some implementations the data format information is preferably expressed as a binary symbol that is defined in a codebook composing a portion the API protocol library . is an example codebook of the API protocol library in accordance with an embodiment of the invention. In some implementations the binary symbol is preferably 8 bits long. This conversion is annotated in box .

As shown the aspects value is a number. In some implementations the aspects value is a two byte SHORT i.e. having two bytes each being 4 bits in length . Here the value is NULL or EMPTY and is expressed in hex value as 0x00 0x00. This conversion is annotated in box .

In some implementations this process of appending binary representations of the group of definitions to form the metadata construct is repeated for the entirety of the message . To this end the various data values of the edge Name and pushType field definitions are appended to the binary message. The values of these data values are provided in annotated box and . In some implementations an end marker e.g. code 0x00 follows the data values to delineate the end of the message construct. In some implementations the sequencing of the field definitions in the binary message is not relevant as each of the field definitions is described as its name value.

Referring to in some implementations a group of aspect value may be nested within the group of data values. The aspect count field may define number of such groups. In some implementations each of the aspect groups may include an aspect name value an aspect type value and an aspect data value . Encoding of a given aspect group may be similar to encoding of the other group in which for example character strings are preceded by a length identifier and data types are expressed as binary symbols. In some implementations the aspect name value is a character string the aspect type value is a data type and the aspect data value is a value having a format described by the aspect type value.

Referring now to encoding of the message construct of the example message is described. As discussed in relation to the metadata construct describes a given structure of the message construct. To this end in some implementations each of the Row Data of the message construct may be described by the description values enunciated in the metadata construct.

As shown the metadata construct includes three field definitions namely a pushThreshold field definition an edge Name field definition and a pushType field definition . To this end the Row Data and is preferably structured according to these field definitions .

In some implementations a Row Data may include a marker a row count field and a number of data groups corresponding to the number of row count field . Each of the data groups may include a data type field and a value field .

As shown Row Data includes a pushThreshold value 100000 an edge Name value InMemory String and a pushType value NEVER .

As defined by the pushThreshold field definition the value 100000 is a NUMBER. In some implementations a number is expressed as an 8 byte DOUBLE. To this end the value 100000 is equivalent to hex value 0x40 0f8 0x6a 0xa0 0x00 0x00 0x00 0x00 as is shown in box .

The edge Name and pushType data are character strings as defined by their respective field definitions and and may be encoded in the manner described above.

In some implementations binary representations of the Row Data are appended to form the message construct for the entirety of the message .

Turning back now to subsequent to the binary Dynamic REST API generating the serialized binary stream the message partitioning module of the API protocol library as described in relation to may partition the encoded message into a number of chunked messages .

The segmenting may facilitate the transmission of large messages using a small fixed memory usage of each of the connection. In some implementations the message partitioning module may chunk or partition a given message and reassemble them at the application level rather than at the transport level.

Moreover the API protocol library may inject metadata such as the length description field for character strings or the count fields to allow parsing of a given message content without the complete content object. To this end a given message generated by the binary Dynamic REST API may be partitioned into chunks where each of the chunks may be decoded prior to the complete message is received.

In some implementations the message partitioning module may inject metadata information relating to the partitioning into a header such as for example the multipart header. show example structures of multi part headers utilized by the API protocol library in accordance with an embodiment of the invention. In some implementations the multi part header may include a chunk message identification number a total number of chunks forming the message and a chunk size of a given chunked message. To this end the message may be decoded in any order as the identification number allows for assembly of the chunks in any sequence. Moreover the total number of chunk message allows the assembler to know the end of the message based on the number of chunks received. Moreover the chunk size allows the chunked messages to be of variable length as defined by the size identifier.

In certain implementations routing information see may be included in the multi part message to assist with the routing of the message such as for outbound messages being transmitted from the platform server . The other implementations the routing information may be included for inbound messages.

In some implementations the message partitioning module includes a buffer window having a size preferably between 4 Kbytes and 1024 Kbytes even more preferably between 8 Kbytes and 16 Kbytes. For large files the binary Dynamic REST API may employ an external file transfer protocol that may operate independently of the binary Dynamic REST API to transact the data exchange.

Turning back now to subsequent to the message partitioning module partitioning the encoded message into one or more chunked messages the API protocol library packages the chunked message with metadata information about the message in the message s header and message s body of the message.

The API protocol library may add identity and target metadata information to the message s header and the message s body. The API protocol library may encrypt the message using an encryption module defined in some implementations within the API protocol library . The encrypted portion may include the entire message or a portion of the message.

Examples implementations that employ metadata information in the message s header and body is described in co pending concurrently filed U.S. patent application titled SYSTEM AND METHOD OF MESSAGE ROUTING USING NAME BASED IDENTIFIER IN A DISTRIBUTED COMPUTING ENVIRONMENT filed Mar. 21 2014 naming inventors Rick Bullotta John Canosa Bob DeRemer and Mike Mahoney and having attorney docket no. 2009132 0032. The application is incorporated by reference herein in its entirety.

In some implementations the header may include a session identification number that is associated to a given name identifier belonging to a particular computing device . In some implementations the session identification number may be used by a given connection server to determine binding path of a given computing device . In some implementations the session identification number is preferably a 32 digit long binary number with the most significant digit MSB first though it can be of various data length and endian.

In some implementations the header may include an endpoint identification number that is associated to routing information for a given persistent connection . The endpoint identification number is preferably a 32 digit long binary number with the most significant digit MSB first.

In some implementations the header may include a message type field referred to as a Method code . For request type messages the message type field may include a code corresponding to the request type message. In some implementations the request type message may be based on an HTTP framework and thus may include a GET request a POST request a PUT request or a DELETE request.

In some implementation the metadata information may include an entity name corresponding to the source of the data or request a characteristic field a target name corresponding to an intended recipient of the data or request and a number of message count

In some implementations the API protocol library may generate message produced from the multiple binary Dynamic REST API .

Turning back now to in some implementations the client or server side application may employ a WebSocket protocol to transmit the output message of the API protocol library to a corresponding client or server side application. The corresponding client or server side application may be running a mirroring API protocol library to decode the message.

To decode the received message the encrypted portion of the received message may be decrypted via a decryption module . As indicated the encrypted portion may include the entire message or a portion of the message. The decryption module may return a decrypted message having the header and the chunked message .

The API protocol library may receive the header and parse the method code field of the header to determine the type of message. In certain instances in which the method code field includes a HTTP request code the API protocol library may send the message body for further processing.

To decode a request message in some implementations the API protocol library processor may parse the chunked message using marker identifiers length identifier field type identifier and field counts identifier to retrieve the group of field definitions and message construct may include groups of data values. In some implementations in which all of the information needed to parse a given encoded portion of the message immediately precedes the encoded data the API protocol library may parse the message in portions or chunks without having to wait for the entirety of the message. In instances in which the message was chunked the partial decoded message is stored in a buffer . Upon the message being decoded in its entirety the API protocol library may signal the buffer or the client server application to retrieve the complete message to be serviced by the client server application

To perform the decoding in its entirety the first encoded data stream may be organized with a known DataShape and may include metadata to describe unrestrictive elements within the data stream. In some implementations the metadata may include forward descriptors of an unrestrictive element. Unrestrictive element may include objects having variable number of elements. This can include textual information such as strings of text as well as variable numbers of objects. Unrestrictive element may also include the variable number of chunked message portions that constitute the entire message. The metadata may include markers to identify separations between the various DataShape.

In being able to decode partial messages independent of one another the client side application may be implemented as a light weight application. A small fixed decoding buffer typically reduces the cost of implementation for a given device.

The edge server may continue to receives the subsequent encoded data streams and . The edge server continues to index the decoded portions and of the messages in the memory.

If a message chunk was corrupted or not received the edge server may wait for a retransmission of the missing chunk message . Using the chunk identifier the edge server can decode a given received encoded data stream out of its sequence from with the message .

Alternatively the API protocol library may be employed as an encoder or decoder. is a block diagram of an example of a message transmission and reception using the API protocol library in accordance with an alternative embodiment of the invention. In this embodiment a client or server side application sends a message to the API protocol library . The message may be formatted in a human readable text language format. Examples include for example JSON and XML. The message may include data objects delimited by one or more data objects.

The binary Dynamic REST API may parse through the message to retrieve one or more data objects according to the stored structural description as shown and described in . The binary Dynamic REST API may serially map each of the elements of a parsed data objects to a binary symbol that is defined in the codebook to produce a binary data stream.

The API protocol library provides a dynamic REST API interface that flexibly interoperate with other communication protocol.

In some implementations the method may be performed at the API servers . To this end legacy sensors and computing devices may be upgraded in the context of communication and controls.

In some implementations the method include receiving at a port a plurality of binary data streams representing a plurality of messages step .

In some implementations the method include parsing using a processor each of the plurality of received binary data stream using the first structural description to determine the binary header and the binary body step .

In some implementations the method may include parsing using the processor the parsed binary body using the second structural description to determine the one or more groups of description values forming the metadata construct where the processor uses a portion of the determined description values of the metadata construct to determine the one or more groups of data values of the message construct step . Each of the one or more data values of the message construct and each of the one or more description value of the metadata construct may be delineated by a binary marker.

In some implementations the method may include storing at a memory of a device a binary dynamic REST API model step . The dynamic REST API model may include a data model that includes a data object an event object a service object a property object and an attribute object.

In some implementations the method may include formatting via a processor at the device a request message using the binary dynamic REST API model to produce a self describing request message step .

In some implementations the method may include transmitting via a port of the device the request message over a persistent state connection step . The persistent stateless connection may be over a Web socket connection using a HTTP or HTTPS port.

In some implementations the method may include receiving at a port of a computing device a first instantiation of a message in the second communication protocol .

In some implementations the method may include classifying by a processor of the computing device the first instantiation of the message as being either a control message or a data message. The method then may include translating by a processor of the computing device the first instantiation of the message to produce a second instantiation of the message step . If the message has been classified as a control message the processor may map the control message to one or more control codes. If the message has been classified as a data message the processor may map the data message to a binary message having the self describing schema as described in relation to .

In some implementations the method may include transmitting at the port of the computing device the second instantiation of the message step .

In some implementations The method may include receiving at a port one or more data streams among a plurality of data streams including a first data stream and a second data stream .

In some implementations the method may include storing at a first buffer a received first data stream and a received second data stream step .

In some implementations the method may include storing at a second buffer portions of a decoded message step .

In some implementations the method may include decoding using a processor the received data stream buffered within the first buffer to produce a given decoded portion. The processor may store the given decoded portion to the second buffer where the processor initiates decoding of the received first data stream buffered within the first buffer prior to a complete receipt of the received second data stream.

The computing device may include a processor a memory a storage device a high speed interface connecting to the memory and multiple high speed expansion ports and a low speed interface connecting to a low speed expansion port and the storage device . Each of the processor the memory the storage device the high speed interface the high speed expansion ports and the low speed interface are interconnected using various busses and may be mounted on a common motherboard or in other manners as appropriate. The processor can process instructions for execution within the computing device including instructions stored in the memory or on the storage device to display graphical information for a GUI on an external input output device such as a display coupled to the high speed interface . In other implementations multiple processors and or multiple buses may be used as appropriate along with multiple memories and types of memory. Also multiple computing devices may be connected with each of the device providing portions of the necessary operations e.g. as a server bank a group of blade servers or a multi processor system .

The memory stores information within the computing device . In some implementations the memory is a volatile memory unit or units. In some implementations the memory is a non volatile memory unit or units. The memory may also be another form of computer readable medium such as a magnetic or optical disk.

The storage device is capable of providing mass storage for the computing device . In some implementations the storage device may be or contain a computer readable medium such as a floppy disk device a hard disk device an optical disk device or a tape device a flash memory or other similar solid state memory device or an array of devices including devices in a storage area network or other configurations. Instructions can be stored in an information carrier. The instructions when executed by one or more processing devices for example processor perform one or more methods such as those described above. The instructions can also be stored by one or more storage devices such as computer or machine readable mediums for example the memory the storage device or memory on the processor .

The high speed interface manages bandwidth intensive operations for the computing device while the low speed interface manages lower bandwidth intensive operations. Such allocation of functions is an example only. In some implementations the high speed interface is coupled to the memory the display e.g. through a graphics processor or accelerator and to the high speed expansion ports which may accept various expansion cards not shown . In the implementation the low speed interface is coupled to the storage device and the low speed expansion port . The low speed expansion port which may include various communication ports e.g. USB Bluetooth Ethernet wireless Ethernet may be coupled to one or more input output devices such as a keyboard a pointing device a scanner or a networking device such as a switch or router e.g. through a network adapter.

The computing device may be implemented in a number of different forms as shown in the figure. For example it may be implemented as a standard server or multiple times in a group of such servers. In addition it may be implemented in a personal computer such as a laptop computer . It may also be implemented as part of a rack server system . Alternatively components from the computing device may be combined with other components in a mobile device not shown such as a mobile computing device . Each of such devices may contain one or more of the computing device and the mobile computing device and an entire system may be made up of multiple computing devices communicating with each other.

The mobile computing device may include a processor a memory an input output device such as a display a communication interface and a transceiver among other components. The mobile computing device may also be provided with a storage device such as a micro drive or other device to provide additional storage. Each of the processor the memory the display the communication interface and the transceiver are interconnected using various buses and several of the components may be mounted on a common motherboard or in other manners as appropriate.

The processor can execute instructions within the mobile computing device including instructions stored in the memory . The processor may be implemented as a chipset of chips that include separate and multiple analog and digital processors. The processor may provide for example for coordination of the other components of the mobile computing device such as control of user interfaces applications run by the mobile computing device and wireless communication by the mobile computing device .

The processor may communicate with a user through a control interface and a display interface coupled to the display . The display may be for example a TFT Thin Film Transistor Liquid Crystal Display display or an OLED Organic Light Emitting Diode display or other appropriate display technology. The display interface may comprise appropriate circuitry for driving the display to present graphical and other information to a user. The control interface may receive commands from a user and convert them for submission to the processor . In addition an external interface may provide communication with the processor so as to enable near area communication of the mobile computing device with other devices. The external interface may provide for example for wired communication in some implementations or for wireless communication in other implementations and multiple interfaces may also be used.

The memory stores information within the mobile computing device . The memory can be implemented as one or more of a computer readable medium or media a volatile memory unit or units or a non volatile memory unit or units. An expansion memory may also be provided and connected to the mobile computing device through an expansion interface which may include for example a SIMM Single In Line Memory Module card interface. The expansion memory may provide extra storage space for the mobile computing device or may also store applications or other information for the mobile computing device . Specifically the expansion memory may include instructions to carry out or supplement the processes described above and may include secure information also. Thus for example the expansion memory may be provide as a security module for the mobile computing device and may be programmed with instructions that permit secure use of the mobile computing device . In addition secure applications may be provided via the SIMM cards along with additional information such as placing identifying information on the SIMM card in a non hackable manner.

The memory may include for example flash memory and or NVRAM memory non volatile random access memory as discussed below. In some implementations instructions are stored in an information carrier. that the instructions when executed by one or more processing devices for example processor perform one or more methods such as those described above. The instructions can also be stored by one or more storage devices such as one or more computer or machine readable mediums for example the memory the expansion memory or memory on the processor . In some implementations the instructions can be received in a propagated signal for example over the transceiver or the external interface .

The mobile computing device may communicate wirelessly through the communication interface which may include digital signal processing circuitry where necessary. The communication interface may provide for communications under various modes or protocols such as GSM voice calls Global System for Mobile communications SMS Short Message Service EMS Enhanced Messaging Service or MMS messaging Multimedia Messaging Service CDMA code division multiple access TDMA time division multiple access PDC Personal Digital Cellular WCDMA Wideband Code Division Multiple Access CDMA2000 or GPRS General Packet Radio Service among others. Such communication may occur for example through the transceiver using a radio frequency. In addition short range communication may occur such as using a Bluetooth Wi Fi or other such transceiver not shown . In addition a GPS Global Positioning System receiver module may provide additional navigation and location related wireless data to the mobile computing device which may be used as appropriate by applications running on the mobile computing device .

The mobile computing device may also communicate audibly using an audio codec which may receive spoken information from a user and convert it to usable digital information. The audio codec may likewise generate audible sound for a user such as through a speaker e.g. in a handset of the mobile computing device . Such sound may include sound from voice telephone calls may include recorded sound e.g. voice messages music files etc. and may also include sound generated by applications operating on the mobile computing device .

The mobile computing device may be implemented in a number of different forms as shown in the figure. For example it may be implemented as a cellular telephone . It may also be implemented as part of a smart phone personal digital assistant or other similar mobile device.

Various implementations of the systems and techniques described here can be realized in digital electronic circuitry integrated circuitry specially designed ASICs application specific integrated circuits computer hardware firmware software and or combinations thereof. These various implementations can include implementation in one or more computer programs that are executable and or interpretable on a programmable system including at least one programmable processor which may be special or general purpose coupled to receive data and instructions from and to transmit data and instructions to a storage system at least one input device and at least one output device.

These computer programs also known as programs software software applications or code include machine instructions for a programmable processor and can be implemented in a high level procedural and or object oriented programming language and or in assembly machine language. As used herein the terms machine readable medium and computer readable medium refer to any computer program product apparatus and or device e.g. magnetic discs optical disks memory Programmable Logic Devices PLDs used to provide machine instructions and or data to a programmable processor including a machine readable medium that receives machine instructions as a machine readable signal. The term machine readable signal refers to any signal used to provide machine instructions and or data to a programmable processor.

To provide for interaction with a user the systems and techniques described here can be implemented on a computer having a display device e.g. a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input.

The systems and techniques described here can be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the systems and techniques described here or any combination of such back end middleware or front end components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network . Examples of communication networks include a local area network LAN a wide area network WAN and the Internet.

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

In view of the structure functions and apparatus of the systems and methods described here in some implementations a system and method for communication using Dynamic REST messages are provided. Having described certain implementations of methods and apparatus for supporting communication using Dynamic REST messages it will now become apparent to one of skill in the art that other implementations incorporating the concepts of the disclosure may be used. Therefore the disclosure should not be limited to certain implementations but rather should be limited only by the spirit and scope of the following claims.

