---

title: Multicore processor fault detection for safety critical software applications
abstract: A method for multicore processor fault detection during execution of safety critical software applications in a multicore processor environment involves dedicating the complete resources of at least a part of at least one processor core to execution of diagnostics software application whilst dedicating remaining resources to execution of a safety-critical software application, thereby enabling parallel execution of the diagnostics software application and the safety-critical software application. There is also provided a controller for multicore processor fault detection during execution of safety critical software applications in a multicore processor environment. The controller includes a multicore processor environment. The controller may be part of a control system. The method may be provided as a computer program.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09632860&OS=09632860&RS=09632860
owner: ABB Schweiz AG
number: 09632860
owner_city: Baden
owner_country: CH
publication_date: 20140509
---
Embodiments presented herein relate to multicore processor fault detection and particularly to multicore processor fault detection for safety critical software applications.

Industrial control systems are for instance applied in manufacturing and process industries such as chemical plants oil production plants refineries pulp and paper mills steel mills and automated factories. Industrial control systems are also widely used within the power industry. Such an industrial control system may comprise or may be combined with certain devices adding safety features. An example of such a device is a safety controller. Example of processes which requires additional safety features other than what a standard industrial control system provides are processes at off shore production platforms certain process sections at nuclear power plants and hazardous areas at chemical plants. Safety features may be used in conjunction with safety shutdown fire and or alarm systems as well as for fire and gas detection.

The use of complex computer systems relating to industrial control systems with added safety features raises challenges in the increased need for error free execution of software in an industrial controller.

The standard IEC 61508 outlines requirements for systems consisting of hardware and software grouped into the following equipment failure categories 

Random hardware failures can be either permanent or transient. Permanent failures exist until repaired. Transient failures can be resolved by measures to control failures by employing detection and correction mechanisms .

Systematic failures can exist in hardware and software. In general terms systematic failures can only be eliminated if found during system home or proof site testing. Measures on how to avoid systematic failures are specified in the above referenced standard. Typically avoidance of systematic failures is handled through good design procedures and measures for detecting design flaws while control of systematic failures can be achieved with diversity etc.

Common cause failures are the result of one or more events causing concurrent failures of two or more separate channels in a multiple channel system leading to system failure. Common cause failures are typically caused by environmental issues such as temperature EMC etc. at the same time in redundant hardware safety function carried out more than once . In general terms diversity introducing differences in hardware design or technology may reduce this kind of errors.

Current multicore processors do not satisfy HFT 1 according to Appendix E in IEC 61508 2. It may be possible to enable internal core to core redundancy but issues concerning diversity still remain when executing two copies of the safety critical application on the same silicon. This can to some extent be solved by using different design principles or completely different technology to carry out the same safety critical functionality.

When using multicore processors for safety applications there is thus a need for on line diagnostic testing of the processors and in particular of the processor cores. The diagnostic software normally runs as a background task and thus competes for the processing power with the safety application. Thereby the benefits of using a multicore processor may be lost.

Hence there is still a need for improved safety considerations for safety critical software applications in industrial control systems.

An object of embodiments herein is to provide improved safety considerations for safety critical software applications in industrial control systems.

To reduce the effects of the above noted problem the inventors of the present invention have realized that the diagnostics software should be designed such that its execution does not interfere with the execution of the safety application. A particular object is therefore to provide improved safety considerations for safety critical software applications in industrial control systems without interfering with the execution of the safety application.

According to a first aspect there is presented a method for multicore processor fault detection during execution of safety critical software applications in a multicore processor environment. The method comprises partitioning processor cores of the multicore processor environment into at least two logical units. The method comprises dedicating all processing resources of one of the at least two logical units to execution of a diagnostics software application DSA the DSA being arranged for fault detection of a processor core of said one of the at least two logical units. The method comprises dedicating processor resources of at least one of the remaining logical units to execution of a safety critical software application SSA. The method comprises executing the DSA by said one of the at least two logical units whilst in parallel executing the SSA by said at least one of the remaining logical units.

Advantageously the method provides improved safety considerations for safety critical software applications in industrial control systems. Advantageously the method enables improved safety during execution of the SSA. By performing the diagnostic testing in this way the execution efficiency in the multicore processor environment is increased because there is no need for task switching. Advantageously the method thus enables improved safety without relying on diagnostics being performed as background tasks and thus without relying on task switches. Advantageously the method enables optimized execution of diagnostics functionality as provided by the DSA . Advantageously the method provides an improved fault tolerant system with higher uptime for execution of the SSA. Advantageously the method is scalable to any number of cores. Advantageously the method does not rely on static allocation of cores. Advantageously the partitioning enables improved utilization of cores with increased diagnostic coverage.

The diagnostic test software can also test the cores that are normally used for non safe applications. The disclosed method can also be used for increasing the availability of computing resources since a core that is not error free can be marked as unavailable faulty and the applications safety critical as well as non safety critical can be executed by the remaining cores. The disclosed method can be combined with a safety application simultaneously being executed by multiple cores for increased redundancy.

According to a second aspect there is presented a controller for multicore processor fault detection during execution of safety critical software applications in a multicore processor environment. The controller comprises a multicore processor environment. The multicore processor environment is arranged to partition processor cores of the multicore processor environment into at least two logical units. The multicore processor environment is arranged to dedicate all processing resources of one of the at least two logical units to execution of a diagnostics software application DSA the DSA being arranged for fault detection of a processor core of said one of the at least two logical units. The multicore processor environment is arranged to dedicate processor resources of at least one of the remaining logical units to execution of a safety critical software application SSA. The multicore processor environment is arranged to execute the DSA by said one of the at least two logical units whilst in parallel executing the SSA by said at least one of the remaining logical units.

According to a third aspect there is presented a control system comprising at least one controller according to the second aspect.

According to a fourth aspect there is presented a computer program for multicore processor fault detection during execution of safety critical software applications in a multicore processor environment the computer program comprising computer program code which when run on a controller causes the controller to perform a method according to the first aspect.

According to a fifth aspect there is presented a computer program product comprising a computer program according to the fourth aspect and a computer readable means on which the computer program is stored. The computer readable means may be non volatile computer readable means.

It is to be noted that any feature of the first second third fourth and fifth aspects may be applied to any other aspect wherever appropriate. Likewise any advantage of the first aspect may equally apply to the second third fourth and or fifth aspect respectively and vice versa. Other objectives features and advantages of the enclosed embodiments will be apparent from the following detailed disclosure from the attached dependent claims as well as from the drawings.

Generally all terms used in the claims are to be interpreted according to their ordinary meaning in the technical field unless explicitly defined otherwise herein. All references to a an the element apparatus component means step etc. are to be interpreted openly as referring to at least one instance of the element apparatus component means step etc. unless explicitly stated otherwise. The steps of any method disclosed herein do not have to be performed in the exact order disclosed unless explicitly stated.

The invention will now be described more fully hereinafter with reference to the accompanying drawings in which certain embodiments of the invention are shown. This invention may however be embodied in many different forms and should not be construed as limited to the embodiments set forth herein rather these embodiments are provided by way of example so that this disclosure will be thorough and complete and will fully convey the scope of the invention to those skilled in the art. Like numbers refer to like elements throughout the description.

The at least one control object is subject to safety control by a controller . The controller is operatively connected to the at least one control object so as to enable safety control of the at least one control object . The controller is thereby arranged to control operations of the at least one control object . Communications between the controller and the at least one control object is per se performed in any suitable known manner and includes exchanging various signals and or messages between the controller and the at least one control object 

As will be further disclosed below the controller inter alia comprises a multicore processor environment . A multicore processor environment may enable improved safety during control of the at least one control object . schematically illustrates a multicore processor environment . The multicore processor environment comprises at least two processor cores . In general the multicore processor environment may comprise a plurality of processor cores . . . . A multicore processor environment with two processor cores is referred to as a dual core processor a multicore processor environment with four processor cores is referred to as a quad core processor. The processor cores of the multicore processor environment are arranged for external communications i.e. outside the multicore processor environment via an input output I O interface . The multicore processor environment may further comprise at least one internal memory for example each processor cores may be associated with its own cache memory.

The embodiments disclosed herein relate to multicore processor fault detection during execution of safety critical software applications in a multicore processor environment . In order to obtain improved multicore processor fault detection during execution of safety critical software applications in a multicore processor environment there is provided a controller comprising a multicore processor environment a method performed by the controller a computer program comprising code for example in the form of a computer program product that when run on the controller causes the controller to perform the method.

When testing safety critical software applications SSA executed in a multicore processor environment the diagnostics software application DSA is normally executed as a background task and thus competes for the processing power with the SSA. This may lead to task switching. That is one processor core switches between executing parts of the SSA and executing parts of the DSA. Instead of having the DSA executed as a background task the DSA is according to the herein disclosed embodiments enabled to take over one complete processor core or part thereof whilst the SSA is executed by another processor core . That is the complete resources of one processor core may be dedicated to execution of the DSA and resources of the remaining processor cores are dedicated to execution of the SSA. This enables parallel execution of the DSA and the SSA. According to the present invention there is thus provided mechanisms for multicore processor fault detection during execution of safety critical software applications in a multicore processor environment enabling parallel execution of a diagnostics software application DSA and the safety critical software application SSA . Before disclosing these mechanisms the following notations and definitions are introduced.

AMP Asymmetric Multiprocessing provides an execution environment that is similar to conventional uniprocessor systems. It offers a straightforward path for porting legacy code and provides a direct mechanism for controlling how the CPUs are used. In most cases it enables standard debugging tools and mechanisms to be used. AMP can be homogeneous where each CPU runs the same type and version of the Operating System OS or heterogeneous where each CPU runs either a different OS or a different version of the same OS .

sAMP supervised Asymmetric Multiprocessing is similar to AMP with a virtualization layer between OS s and CPUs serving as a virtual machine monitor to run and execute virtual machines a so called Kernel based Virtual Machine KVM .

SMP Symmetric Multiprocessing is executed using only one copy of the OS on all of the system s CPUs. Because the OS has insight into all system elements at all times it can allocate resources on the multiple CPUs with little or no input from the application designer using spinlock for shared resources.

BMP Bound Multiprocessing provides the scheduling control of an asymmetric multiprocessing model while preserving the hardware abstraction and management of symmetric multiprocessing. BMP is similar to SMP but enables specification of which processors a thread can run on. Both SMP and BMP can be used on the same system allowing some threads to migrate from one processor to another while other threads are restricted to one or more processors.

A HV Hypervisor allows a developer to securely run one or more operating systems or multiple instances of the same OS in defined partitions herein also denoted logical units . In general terms it controls access to memory peripherals and other assigned resources to ensure no OS steps outside its bounds. Shared or unique resources like the interrupt controller are strictly managed.

The MMU Memory Management Unit is a computer hardware component responsible for handling access to memory requested by a CPU. It translates virtual addresses to physical addresses virtual memory management . For a multicore processor environment there are typically several MMUs and often one for each core . The same kind of unit is used for peripheral access protection PAMU .

The CPU Central Processing Unit used in conjunction with Multicore refers to all hardware resources contained in the single core domain and replicated for each core . This is due to increased core complexity including resources like the core itself with registers and instructions first level cache L1 L2 MMU temperature sensor clocking power supervision etc. almost a full scale CPU without peripherals . In this disclosure the notation CPU processing core and core will be used with the same meaning.

RTOS Real Time Operating System is an operating system with real time behavior. It is compact and deterministic without time consuming functionality. It is normally driven by a scheduler activated by regular timer ticks and interrupts. It offers an API Application Programming Interface to the application and manages all resources by controlling tasks or threads and executing drivers.

A VM Virtual Machine is a software implementation of a machine that executes programs like a physical machine. In an embedded context this means a machine that provides a complete system platform emulating existing architecture supporting execution of one or several operating systems. The hardware complexity one or several CPUs is hidden for the user.

The Privilege mode User Supervisor and Hypervisor mode decides which entity or device is allowed to access what information in a layered approach. For traditional single core processors the two privilege modes Supervisor and User exists where typically the RTOS is executing with the highest privilege also called Kernel mode . Applications are typically executed in User mode without access to Kernel privileges. With Multicore the new Hypervisor privilege mode is added above the Kernel mode adding another layer of hardware protection.

A Process in the context of RTOS is a program loaded into memory uniquely identified owning resources as memory with code and data open devices files etc. all protected from other processes. It is an encapsulation mechanism protecting internal from external violation.

Threads in the context of RTOS are single flows of execution or control with its own priority scheduling algorithm register set and mask etc. required by a running code. Threads run in a process and share all the process resources. At least one thread must run within a process.

A Platform is a generic term referring to both hardware and software functionality supporting application development. This means both tools and libraries. Herein it refers to the API served by the RTOS with supported drivers.

Partition is a way to divide one or several physical devices into one or multiple logical units. In multicore executing SMP the entire multicore may be regarded as one partition while when executing AMP each core may be regarded as a separate partition. In the traditional configuration with two redundant single chip CPUs from same or different manufactures it is referred to as two partitions.

A Safety Channel SC is a channel that is able to perform the safety function. E.g. in a 1oo2 one out of two architecture either of the two channels can perform the safety function meaning if one channel fails the other is still able to bring the system to a safe state.

A Black Channel is a safe way to transport information between several parties independent of the media. The information sent out is tagged in such a way that if changed on its way this is detected on the receiving side.

Failure Rate is a measure of failure per unit of time. The useful failure rate is based on the exponential distribution. The failure rate typically decreases slightly over early life and then stabilizes until wear out which shows an increasing failure rate. This should occur beyond useful life. In the stabilized period can be expressed in FIT see below .

FIT Failure In Time is the frequency at which an engineered system or component fails. E.g. 1 FIT 1 failure per 10device hours 1 10 . Often Mean Time Between Failures MTBF is reported instead of the failure rate due to a more intuitive representation.

A method for multicore processor fault detection during execution of safety critical software applications in a multicore processor environment comprises in a step S partitioning processor cores of the multicore processor environment into at least two logical units. The step S of partitioning is performed by the controller . As will be further disclosed below a logical unit may correspond to a safety channel SC . The step of partitioning is performed in order to dedicate processing resources of the multicore processor environment to a diagnostics software application DSA and to a safety critical software application SSA such that respective executions thereof do not interfere with one another. The DSA comprises a set of software instructions and is arranged for fault detection of a processor core in the multicore processor environment by operating on a logical unit. The SSA may be a Safety Function SF control application of an industrial control system. The control application may thereby relate to on line safety control of real world control objects. Example of such on line safety control and of such real world control objects have been provided above. The controller is arranged to in a step S dedicate all processing resources of one of the at least two logical units to execution of the DSA. The controller is further arranged to in a step S dedicate processor resources of at least one of the remaining logical units to execution of the SSA. After having dedicated processing resources for execution of the DSA and the SSA respectively the DSA and the SSA may be executed in parallel on different logical units. The controller is therefore arranged to in a step S execute the DSA by said one of the at least two logical units whilst in parallel executing the SSA by said at least one of the remaining logical units.

There may be different ways of determining the partitioning in step S. According to one embodiment the SSA is only executed on a subset of the available processor cores . The DSA may then be executed only on those processor cores . According to one embodiment the controller is therefore arranged to in an optional step S identify all processor cores on which the SSA is executed and executing the DSA as in step S only on the identified processor cores 

According to one embodiment each logical unit corresponds to a fractional part of the at least one processor core . According to another embodiment each logical unit corresponds to an integer number of processor cores . According to one embodiment each logical unit corresponds to one safety channel SC . A SC may thus correspond to a fractional part of the at least one processor core or an integer number of processor cores . The controller may therefore be arranged to in an optional step S define a diagnostics model comprising at least one safety channel. The DSA may then be executed at least on all logical partitions associated with the at least one safety channel. The Safety Abstraction Layer SAL is a thin layer interfacing required RTOS and drivers making all that is safety related independent of OS and drivers. If redundancy is required it will have at least two SCs with DSA replicated.

The RTOS platform generally complies with a Dynamic Adaptive Diagnostic DAD functionality. The DAD functionality is a framework made adaptable to different hardware and software platforms. The configuration valid for this DAD may comprise one to several partitions SCs executing SSA and DSA. The partitioning as in step S may be regarded as a vertical separation of processing resources . . . as schematically illustrated at reference numeral in . Here a typical configuration for a multicore safety system is illustrated where the vertical separation is done all the way from hardware to SC. Partitioning of resources available for safety and scheduling of what to run where and when is handled by the Safety Platform SP which may be implemented by the controller . The SP can be regarded as a generic support bed serving SSA with an M out of N diagnostic MooNd structure where 

If a fault is detected in a channel the DSA is able to adjust the voting output to go in favor of the non faulty channel. If execution of the DSA detects fault in all channels or a discrepancy not possible to allocate to a specific channel the DSA is arranged to set the system to a safe state.

In an execution phase the SP will make sure the platform has required resources available by continuously executing planned diagnostic functionality by means of executing the DSA see below in separate SCs. This is achieved by the Diagnostic module at different layers in hardware internal and or external watchdog low level diagnostics related to HAL Hardware Abstraction Layer and drivers like ECC error correction detection with scrubbing and fault localization injection SAL for software error support handling RTOS interface with exceptions supervision of the SC making sure processes tasks and interrupts and shared resources are balanced and are working with the possibility to do a repair reload program etc. or any combination thereof.

In this way the SSA is released from the burden of assuring used resources are proven reliable at any time. SP in itself is made independent of RTOS and drivers hidden by the Safety Abstraction Layer SAL . The partitioning of what is to be handled by the RTOS and the Safety Platform may generally depend on the RTOS used.

The Safety Platform SP holds the overall state of all resources and Safety Channels SC available to run DSAs and may have three modes of execution as will be further disclosed next. It has a START UP phase followed by an IDLE phase. When minimum required resources SCs are made available to run the DSA it enters the RUNNING phase. Returning to IDLE from RUNNING occurs when such minimum required resources no longer are available. illustrates a SP state diagram comprising these three states. State transitions are shown by arrows and named accordingly.

In general terms the SP state diagram may not be responsible for the DSA state changes as illustrated in entering an operational state Op State or a not operational state No Op State . However DSAs cannot enter the Op State before the overall SP as illustrated in is in the RUNNING state. This also implies that DSAs can be in the No Op State when the SP is in the RUNNING state meaning a DSA has detected a potential fault situation but everything in the SP is fully operational.

Next follows a detailed explanation of the SP states and transitions as in . At power on the SP is responsible for initialization and configuration with basic diagnostics bootstrap defined as START UP. It will prepare the system to be able to run the multiple partitioned modes IDLE and RUNNING. How this is implemented may vary depending on processor architecture.

According to one embodiment the following procedure will be executed in the START UP state SP prepares the entire system by running an overall Basic Diagnostics to verify system ready. This diagnostic should not overlap with the diagnostics associated with the individual state diagram in see below. The SP will then set up partitions and common resources memory communication GPIOs interrupts etc. with required software SSA SP RTOS and drivers and verify that data associated therewith is loaded correctly. Each partition SC will take over execution responsibility entering the IDLE state as marked by the transition Go. The shared Health table as in Table 1 see below is used to hold the state of each SC at the same time as it gives a summation overview used to define the SP state. If the basic diagnostics or any other item fails the system will immediately be halted as marked by Stop.

According to one embodiment the following procedures will be executed in the IDLE state The SP executes the Individual state diagram as in in each SC making sure required resources are prepared and made available. When the required number of SCs is available the SP state diagram enters the RUNNING state as marked by the transition Ready. If the required number of SCs is not satisfied after a defined timeout as monitored e.g. by a watchdog functionality the system is Reset back to the START UP state.

According to one embodiment the following procedures will be executed in the RUNNING state The SP executes the Individual state diagram as in in each SC making sure required resources are made available. A required number of DSAs must be running for the SP to remain in this state. SC is regularly taken out of service i.e. released from executing the SSA to run the DSA. When a logical unit partition SC has finished the DSA successfully it will make itself available by inserting itself into the Ready Queue and updating the Health table. If the required number of SCs is not satisfied the system is translated back to the IDLE state as marked by Not Ready. The SP is acceptable to remain in the RUNNING state even if a SC failed diagnostic as long as the number of available resources is sufficient. The reason why diagnostics failed may be examined thoroughly making sure it does not affect system stability.

In the start up operating mode fault detection is executed by prior to the step of partitioning in step S performing in an optional step S initial diagnostics. In general terms the initial diagnostics may be performed as bootstrap at power on or as a result of a hardware reset and comprise basic register setup boot strap diagnostics etc.

In the running operating mode i.e. in the RUNNING state of fault detection is executed as in any of steps S S S S S and Sas will be disclosed next. The fault detection diagnostics DSA in the running operating mode may comprise any combination of instruction test such as branch move compare add multiply etc. register test such as read write to detect stuck at etc. peripheral test such as verification of configuration file CRC etc. stack test preferably only push and pop not individual stack overflow etc. data bus test address bus test for example by setting each address pin to 0 and 1 not affecting others etc. RAM test such as read write to detect stuck at etc. and ROM test for example using a 32 bit CRC error detection algorithm .

The number of partitions to be used for safety can vary depending on requirements and needs. There may be a minimum of two partitions executing the DSA. This will enable redundancy with the possibility to compare results. The health verification is done by the diagnostics functionality i.e. the DSA .

According to one embodiment executing the DSA in step S further comprises an optional step Sof performing fault detection of the logical unit on which the DSA is executed. According to this embodiment the logical unit is in an optional step S labelled as healthy if passing the fault detection and faulty otherwise. According to this embodiment the SSA is in an optional step S prevented from being executed on a logical unit labelled faulty. illustrates a state diagram where fault detection of a single partition logical unit is illustrated according to such an embodiment. The state labels are shown in capital letters. In the number in parenthesis is the assumed approximate time slice dedicated to the different modes when everything is operating normally. State transitions are marked by arrows and named accordingly. In the following functionality is associated with the illustrated state diagram the functionality of which may be implemented by the controller .

TBC To Be Checked In this state the DSA is executed thus performing diagnostics. No execution of SSA is allowed while the DSA is being executed. The outcome of executing the diagnostics will result in either failure FLT or success HLT . If the waiting time in the HLT state before entering the RUN state expires or if not responding in the HLT state a supervising watchdog functionality is arranged to return the logical unit under consideration to the TBC state. Before the state is changed from RUN to TBC the SSA must have been swapped to another SC.

According to one embodiment the requirements for how to handle transitions into TBC the state include at least one of the following considerations Execution of the SSA is not allowed and if so the system is defined unsafe. If a non safety related functionality is executed it should in general be allowed to do so until completed. However if the execution of the non safety related is not completed within a predetermined time limit the execution thereof is forced to stop by entering the FLT state. The DSA will start to be executed as soon as nothing else is executed the DSA thus having full control of the entire logical unit for optimized performance thus reducing the time in the TBC state.

HLT Healthy In this state further diagnostics are run while in queue for executing the SSA. This state is entered after successful diagnostic as in the TBC state . The logical unit having passed the check in the TBC state is scheduled into a queue of readily available logical units to be used by the SSA until ready to swap. While waiting for the swap the further diagnostics are executed on the logical unit to ensure that the healthy state of the logical unit is preserved.

According to one embodiment the further diagnostics comprise a distinct subset of the full diagnostic instructions in the DSA and includes the possibility to stop immediately when ready to enter the RUN state see below. A logical unit in the HLT state can also be trusted for verification required by a faulty FLT logical unit. If the diagnostic fails the logical unit will enter the FLT state. In addition a timeout supervises the SC and may return the logical unit to the TBC if it stays too long in the HLT state.

RUN Running executing SSA In this state required SSAs are executed in the safety loop for a defined time before execution of the DSA is again required thus returning the logical unit to the TBC state. Execution of the SSA functionality is only allowed when in this state. According to one embodiment no other application is allowed to be executed on this logical unit when the SSA is being executed.

According to one embodiment the requirements for a logical unit to be selected for execution of Safety Critical instances of the SSA involves at least one of the following considerations The core must be healthy. The core selected must not already execute or otherwise be involved with Safety Critical instances of another SSA. Synchronization between the Safety Critical instances of the SSA must be supported so they individually can compare result and make decisions.

FLT Faulty executing recover function After the DSA has detected a fault in the logical unit the SC cannot be trusted. Execution of the SC on the logical unit is stopped and all further activities towards this logical unit are handled under control of another healthy SC. A fault analysis can be performed to decide fault criticality such as whether the fault is permanent or if further diagnostics should be executed after a timeout and fault effect such as if only one logical unit is affected or if the entire multicore environment is affected . Depending on the outcome thereof one action may involve a SC repair with re initialization of memory. Nothing but repair under full control of another healthy logical unit may be allowed to be executed on this logical unit. Further for further test purposes a logical unit labelled as faulty might be forced to enter the TBC state again by another healthy logical unit.

According to embodiments the controller is thus arranged to in an optional step S prevent the SSA from being executed on a logical unit on which fault detection has not been performed at all or if fault detection has not been performed within a predetermined duration in time. A logical unit denoted healthy is in an optional step S scheduled for execution of the SSA. For a logical unit denoted healthy additional fault detection may in an optional step S be performed until the logical unit denoted healthy is scheduled to execute the SSA.

In general terms all healthy cores may be regarded as being part of a pool of resources available to the SSA. When a core is labelled unhealthy it is treated on an individual basis. Cores no longer working are thus labelled FLT Faulty and should be made sure not to disturb operational activity. In general terms cores labelled TBC may be regarded as no longer healthy but may still be used to execute non safe functionality.

In general terms the further diagnostics may be the same diagnostic as in the DSA but with the possibility to stop immediately when an external event occurs like receiving a Mutex a mutual exclusion . This forces the interface to the further diagnostics to be configured in such a way that it can be scheduled to run for a minimum of time. For example the interface to the memory test may have two parameters one for memory start position and one for memory length. In this way the memory test could be a single 32 bit word but the implementation of the test is the same for the ordinary DSA.

A common data area e.g. represented as a table may be used by all safe partitions or Safety Channels SC to share data among themselves. In general terms the data is not persistent meaning it should not be stored before power down. Initially the table should be created depending on the content in a configuration file making it easy to perform changes thereto. Further properties of the configuration file will be disclosed below.

According to one embodiment the controller is therefore arranged to in an optional step S share first data relating to the execution of the DSA by a first logical unit with second data relating to the execution of the DSA by a second logical unit. Execution of the SSA may then in an optional step S be scheduled based on the shared first and second data. As the skilled person understands there may be also third data fourth data etc. which may be shared and on which the scheduling may be based.

Below is an example snap shot of an 8 partition 8 SC configuration with the value 1 indicating active and 0 for inactive. The bottom summation indicates only one mode active at any time for each channel. The right summation is the number of channels active in each mode. The following labelling is used a indicates SC not ready to run SSA b indicates SC ready to run SSA but not yet executed in queue and c indicates SC currently executing SSA.

For each SC additional information may be registered. Examples include but are not limited to any of statistics counters for each time the different modes have been entered optionally with a timestamp for a last change individual watchdog timers for each SC making sure it is not locked up triggers and handles like events mutual exclusions so called mutexes or messages for signaling other partitions communication rerouting making it possible to setup a communication channel once but change which SC is active.

Rules for accessing the table may be applied. All SCs should be allowed to read data from other SCs but updating is only allowed by the SC owning the data. However this may depend on the current state of the SC for example SC is the only SC allowed to update data related to this channel but according to one embodiment this cannot be done if in FLT mode. There may be a condition that when in the FLT state another SC in the HLT state must confirm the update.

A configuration file could be used for configuration and setup of the system. The configuration file should follow standards for this kind of tasks meaning the configuration file should have the correct format such as XML and correct content according to an application domain . The configuration file could be stored in a Flash memory with CRC protection. The configuration file may comprise information such as 

The diagnostics software application DSA is typically a control loop with strict time requirements. In general terms the control loop is based on evaluating input measurement against pre defined thresholds which may be provided by configuration data . If the threshold is reached an output signal is generated or removed . A simple and classical safety response is to just de energize power off . The DSA may be associated with a state diagram having only two states 

Two DSA instances may be required to run in two different partitions such as SC and SC . This is only possible when the Individual state diagram of is in the RUN state for each DSA thereby automatically setting the SP in the RUNNING state as illustrated in .

In general terms the DSA may satisfy the following requirements the number of safety instances should be configurable herein referred to as MooN the Process Safety Time PST should be configurable deterministic behavior should be shown half the PST realistic CPU load should be generated to verify that the safety critical function is working properly synchronization mechanism between safe channel for regularly cross compare should exist safe channel communication as may be provided by black channel with input and output devices see above real time processing and performance measurement performance and or verification that the DSA is working as defined. Only one instance of the DSA should run in one logical unit but several different DSAs could be executing in the same logical unit.

As disclosed above immediately when a SC has successfully passed the diagnostics as performed by the DSA the SC will enter the HLT state and queue up for SSA execution. According to one embodiment the first SC to queue will be the first SC to execute the SSA according to the first in first out FIFO principle .

3. SC will be inserted into the Ready Queue with SC as ready first then SC SC and finally SC all with the HLT state and with the SP still in the IDLE state.

5. SC will be the second to run SSA also entering the RUN state. Now two instances of SFs are running which may be required to change the SP state to RUNNING meaning the multicore processor environment is ready and available to run required SSA. Note that it is the SSA that may decide whether its state should change to operational.

6. The two remaining logical units will have to wait until one of the running SCs enters the TBC state. While waiting they must make sure to keep their health status updated. This is achieved by performing further diagnostics. The further diagnostics may be interrupted when ready to swap see step 7 .

7. The swap from SC to SC is the next step and is shown in the lower part of the . This could be done with help from the RTOS functionality release Mutex by SC and reserve Mutex by SC.

The invention has mainly been described above with reference to a few embodiments. However as is readily appreciated by a person skilled in the art other embodiments than the ones disclosed above are equally possible within the scope of the invention as defined by the appended patent claims.

