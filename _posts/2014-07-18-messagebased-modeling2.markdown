---

title: Message-based modeling
abstract: A system and method may generate executable models having message sending objects and message receiving objects. A message may include a fixed data payload, and the message may persist for only a determined time interval of a total execution or simulation time of model. Message queues may be established for the messages, and the queues may have attributes. The model may include a state-based portion having states and transitions. States may be configured to generate and send messages, and to receive and process messages. In addition, transitions may be guarded by particular messages. The system and method also may generate standalone code, such as source code, for the model. The standalone code may include code that establishes a message passing service to support the sending and receiving of messages.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09594608&OS=09594608&RS=09594608
owner: The MathWorks, Inc.
number: 09594608
owner_city: Natick
owner_country: US
publication_date: 20140718
---
This application is a continuation in part CIP application of application Ser. No. 14 163 147 filed Jan. 24 2014 for MESSAGE BASED MODELING now U.S. Pat. No. 9 304 840 which is a continuation of application Ser. No. 13 117 531 filed May 27 2011 for MESSAGE BASED MODELING now U.S. Pat. No. 8 689 236 which application claims the benefit of U.S. Provisional Patent Application Ser. No. 61 349 401 which was filed on May 28 2010 by Alan Moore et al. for a MESSAGE BASED TRACES AND VERIFICATION which applications are hereby incorporated by reference in their entireties.

Exemplary embodiments of the disclosure generate executable models having objects configured to run in accordance with message based execution semantics. A message may include a payload comprising one or more data elements that may not change during the execution of the model. In addition a message may be generated at a particular point in the execution or simulation time of the model by a message sender object and the message may persist for a determined time interval of the total model execution or simulation time.

A message based modeling entity which may be included within a modeling system may support message based functionality in the model. The system may include a library of pre defined object types such as graphical block types configured to generate and send messages and to receive and process messages. The library of message based blocks may be organized as a class hierarchy. The modeling environment may include a graphical editor that provides a model canvas in which a user may construct and or edit a model. Message based objects may be configured to have one or more message ports for sending and receiving messages. In response to the message ports of selected objects being interconnected such as through message based connections extending from source ports to destination ports the system may establish message based relationships among the interconnected objects.

The system may establish one or more message queues for storing messages. The message queues may have attributes such as a length a processing order an overflow policy and a priority. Message generated during execution of the model may be logged and may be routed to other message queues and or message based receiver objects.

The system may also include a message based execution engine that controls the execution of the model s message based objects. More specifically during execution a message sender object may generate a message at a particular point in the execution time of the model. The message based execution engine may maintain the message for a determined portion or time interval of the total execution time of the model. In addition the execution engine may send the message to one or more message based receiver objects which may or may not trigger their execution and the execution engine may control the processing of the message by the one or more message based receiver blocks.

In an embodiment the modeling system may include entities or modules that support other execution domains such as a time based and state based execution domains. In addition the message based modeling entity may cooperate with such a time based and or state based execution entities or modules to implement hybrid execution models.

The time based entity or module may include a library of time based objects or blocks and selected time based objects or blocks may be added to the model. A time based block describes a dynamic system of equations that defines time based relationships between signals and state variables. Signals represent quantities that change over time and may have values at all points in time. The relationships between signals and state variables may be defined by the set of equations represented by the time based blocks. Time based blocks may include signal ports that may be interconnected with signal based connections. The source of a signal corresponds to the block that writes to the signal during the evaluation of the block s equations and the destination of the signal is the block that reads the signal during the evaluation of the destination block s equations.

The state based entity or module may include a library of state based objects such as states sub states transitions junctions etc. The state based objects may be configured to generate and or receive messages. For example programming syntaxes such as a textual programming syntax may be defined for generating and or evaluating messages by state based objects. In addition state transitions may be guarded by messages. For example the programming syntaxes may support the specification of particular messages to guard transitions or other state based objects.

The time based execution engine executes the time based blocks in the diagram by evaluating the relationships between signals and state variables over time beginning at a start time and continuing to a stop time. Each evaluation of the relationships may be referred to as a time step.

As mentioned the message based system and the time based and or state based execution engines may cooperate to implement a hybrid environment. In particular the time based execution engine may organize time based and or state based blocks or objects into a scheduled or sorted order which refers to the order in which the blocks operations or methods e.g. execution methods are invoked. The time based and or state based blocks or objects may then be executed according to the scheduled order.

The message based system may also include a verification engine. The verification engine may support a library containing one or more verification blocks. Instances of the verification blocks may be added to the model to evaluate the operation of message based blocks. The types of verification blocks may include an observer type a message sink type a generator type and a scenario type. The observer block may be used to visualize a set of messages referred to as a trace generated by one or more selected message based objects of the model. The set of messages of the trace may be ordered in time between a start time and an end time by the observer block. The observer block may be a floating block within the model and it may be associated with a message based connection. The message sink block may be directly connected to a message based block and may be used to visualize a trace generated by that message based block. The generator block may be used to represent an external source of messages to the model. The generator block may be connected to one or more message based blocks as a source and configured to generate one or more messages or traces that may then be received and processed by the one or more message based blocks to which the generator block is connected. The scenario block may be used to define valid and invalid traces. It may also or alternatively be used to define one or more constraints on one or more messages or traces. For example temporal constraints may be defined on one or more messages or between two or more messages. The scenario block may be associated with one or more message based connections in the model whose messages may form a runtime trace to be evaluated. The scenario block may compare the defined valid and invalid traces and the one or more constraints to the runtime trace produced during execution of the model. The scenario block may be further configured to take one or more actions if one or more of the runtime traces is not equivalent to the defined valid traces or the runtime traces are equivalent to the defined invalid traces. The scenario block may also take a specified action if the one or more constraints are not satisfied.

The removable medium drive may accept and read a computer readable medium such as a CD DVD floppy disk solid state drive tape flash memory or other medium. The removable medium drive may also write to the computer readable medium .

Suitable computer systems include personal computers PCs workstations laptops tablets palm computers and other portable computing devices etc. Furthermore exemplary processing elements include single or multi core Central Processing Units CPUs Graphics Processing Units GPUs Field Programmable Gate Arrays FPGAs Application Specific Integrated Circuits ASICs etc. Nonetheless those skilled in the art will understand that the system of is intended for illustrative purposes only and that the present disclosure may be used with other computer systems data processing systems or computational devices. The present disclosure may also be used in a networked e.g. client server computer architecture or a public and or private cloud computing arrangement.

Suitable operating systems include the Windows series of operating systems from Microsoft Corp. of Redmond Wash. the Linux operating system the MAC OS series of operating systems from Apple Inc. of Cupertino Calif. and the UNIX series of operating system among others.

A user or developer such as an engineer scientist programmer etc. may utilize the keyboard the mouse and the display to operate the high level modeling environment and construct or open one or more models of a system that is being designed. The model which may have executable semantics may represent a real world dynamic system that is being modeled simulated and or analyzed by the user.

In an implementation high level modeling environment may receive inputs by a user as the user creates edits revises and or opens one or more models as indicated by arrow . The model execution engine in cooperation with the modeling systems and may execute the model generating one or more results that may be presented to the user as indicated by arrow . A model may include a plurality of portions each operating according to a different execution domains. For example a first portion may operate according to message based semantics a second portion may operate according to time based semantics and a third portion may operate according to state based semantics.

In an embodiment a graphical model may be executable such that the model receives one or more inputs processes those inputs and produces one or more outputs.

In an embodiment a suitable high level modeling environment includes the MATLAB technical computing environment from The MathWorks Inc. of Natick Mass. The high level modeling environment may thus operate at a level that is even higher than other well known programming languages such as the C C and C programming languages. A suitable time based graphical modeling system includes the SIMULINK environment from The MathWorks Inc. A suitable state based modeling system includes the Stateflow charting tool from The MathWorks Inc.

It should be understood that other modeling tools in addition to or in place of the time based modeling system and or the state based modeling system may be used in the environment . Other such modeling tools include dataflow systems such as the LabVIEW programming system from National Instruments Corp. of Austin Tex. and the Visual Engineering Environment VEE from Agilent Technologies Inc. of Santa Clara Calif. physical modeling systems such as The Simscape product from The MathWorks Inc. Unified Modeling Language UML systems and Systems Modeling Language SysML systems among others. In addition a lower level programming language such as the C C and C programming languages among others may also be used to create one or more models or model portions.

The propagation engine message based execution engine verification engine report generator interface engine message based object constructor and class packages may each comprise registers and combinational logic configured and arranged to produce sequential logic circuits. In an embodiment the propagation engine message based execution engine verification engine report generator interface engine message based object constructor and class packages may be implemented through one or more software modules or libraries containing program instructions pertaining to the techniques described herein. The software modules may be stored on main memory and or computer readable media such as computer readable medium and executable by one or more processing elements such as processing element . Other computer readable media may also be used to store and execute these program instructions. In alternative embodiments various combinations of software and hardware including firmware may be utilized to implement the present disclosure.

In an embodiment the message based components of a graphical model as well as the messages generated during execution of the model may be objects and these objects may be defined by creating classes which are not objects themselves but which act as templates that instruct the constructor how to construct an actual component and message object. A class may for example specify the number and type of data variables and the steps involved in the functions which manipulate the data. The object constructor may use the corresponding class definition and additional information such as arguments provided during object creation to construct the object. Likewise objects may be destroyed by a special function called a destructor . Objects may be used by manipulating their data and invoking their functions.

It should be understood that other possibly more complex class hierarchies may be provided. For example additional base classes may be provided and one or more of the subclasses may include subclasses of its own and so on.

While the message types are referred to as classes in an embodiment they do not have any methods. Instead the specialization of the message classes may add new properties i.e. data members only.

In an embodiment an instance of a message object may include one or more data elements. is a schematic illustration of a data structure representing the data elements of an instance of a message object. The data structure may be organized into a plurality of fields and sub fields each storing particular information. For example the data structure may include a message type field a message identifier ID field a valid flag a time to live TTL field and a payload field . The message type field may store information that indicates the particular type of message the message ID field may store an identifier that uniquely identifies the message the valid flag may indicate whether the message is valid or invalid the TTL field may store information indicating how long the message should be maintained and the payload field may store information associated with the message that was generated by the message source and that may be used by one or more message destinations.

It should be understood that the data structure may include additional or fewer fields. In addition the payload field may be organized into a plurality of sub fields.

In another embodiment message based components and or messages may be instances generated from types instead of being objects generated from classes. Those skilled in the art will understand that other implementations of message based components and or messages may be utilized.

In an embodiment a user may select one or more types of message based components from the library browser. In response the constructor may access the component class package and create an object instance of the selected type as indicated at block . The object instance may be stored in memory such as main memory and an icon such as a block may be added to the canvas as indicated at block .

The user may configure one or more of the components of the model to generate and or receive a message as indicated at block . For example a user may open a properties or other page associated with a selected message based component that has been added to the canvas. The property page may include fields or other data entry elements for receiving information for example from the user specifying a message type that the component is to receive. In response the object constructor or another module such as the model builder may add an input port to the block as presented on the canvas. Similarly the property page or another property page may include fields and data entry elements for receiving information that specifies a message type that a selected component is to send. In response an output port may be added to the block as presented on the canvas. In this way a user may add a plurality of blocks representing message based components to the canvas and provide these blocks with input and output ports for receiving and sending messages.

The user may define message based relationships among the message based components of the model as well as the other components as indicated at block . For example the user may define a message based relationship graphically by drawing a message based connection between the input and output ports of message based blocks. More specifically the user may configure a given message based component to receive a particular message by drawing a connection from the source of the message such as the output port of another message based component to the respective input port of the given message based component. Likewise the user may configure a selected message based component to send a message by drawing a connection from the respective output port of the selected message based component to the destination of the message. In response to the definition of message based relationships e.g. by the user the message based execution engine may add the destination component to a list of listeners for the respective message as indicated at block . Specifically the execution engine may create a list of listeners for each message for which a message based relationship has been defined in the model. If a message based relationship is removed for example by the user deleting a message based connection between two message based blocks the execution engine may remove the destination component from the list of listeners for that message.

In an embodiment model components operating in domains other than the message based execution domain may be configured to send or receive messages. For example a user may draw a message based connection between a message based block and a block operating in another domain such as the time based domain the state based domain the dataflow domain etc. Likewise a user may draw a message based connection from a block operating in another domain to a message based block.

The Message Generator block may be configured to have two input ports each associated with a respective type of message that the Message Generator block is interested in receiving. The Message Generator block also may be configured to have one output port that is associated with a message type that the Message Generator block may send. The Message Buffer block may be configured with an input port and an output port each associated with a respective message type. The Message Receive block may be configured with an input port and two output ports each associated with a respective message type. In addition the state based portion may be configured with a first input port that is associated with a type of message and a second input port that is associated with a signal. The state based portion may be further configured with a first output port that is associated with a type of message and a second output port that is associated with a signal.

Message based relationships may be established among the time based portions the state based portion and the message based portion . For example a user may connect various input and output blocks of the model with message based connections. In response constructor may create message object instances and the execution engine may establish message based relationships among the respective portions or components of the model .

In an embodiment before execution of the model the propagation engine may analyze the construction and configuration of the model to determine whether during execution of the model those blocks that are configured to receive messages will receive the intended messages as indicated at block . In particular the message based execution engine and the model execution engine may build an in memory representation of the model such as an intermediate representation IR . The IR may include a plurality of nodes that may represent the blocks of the model and edges that represent connections within the model. The IR may also be annotated with additional information such as the types of messages that destination blocks are configured to receive the types of messages that source blocks are configured to send etc. The IR may be created as part of a compilation stage that marks the start of model execution. This compilation stage may include preparing data structures and evaluating parameters configuring and propagating block characteristics determining block connectivity and performing block reduction and insertion. In addition one or more optimization techniques may be applied to the IR. After the application of an optimization technique an additional IR may be generated. The propagation engine may analyze one or more of these IRs.

The propagation engine may evaluate this IR examining for example those elements of the IR that represent the input ports of message based and other blocks. The propagation engine may determine the type of message that the given message block expects to receive on a subject input port. The propagation engine also may identify the upstream block that is connected to the subject input port of the given message based block. The propagation engine may determine the type of message issued by this upstream block. In addition the engine may determine whether the type of message defined for the output port of the source component complies with the type of message defined for the input port of the destination component. If a mismatch is identified by engine it may be reported. For example an error message or error report may be generated and presented for example on the display for review by the user.

The model may be simulated e.g. executed or run. For example the model editor window may include a Run command button that may be selected by the user e.g. with the mouse . Alternatively the user may enter a text based run command for example in a Command Line Interface CLI or the model may be run programmatically.

In an embodiment the model execution engine interfaces with the time based system the state based system and the message based system to execute the entire model as indicated at block .

In an embodiment the time based modeling system may create a sorted order of the time based components of the model as indicated at block . The sorted order may refer to the order in which to invoke block methods during execution of the model . Exemplary block methods for time based components may include an output method that computes the output signals of the block based on its input signals and its state an update method that computes the block s states and a derivatives method that computes the derivatives of the block s continuous states. Time based components that are configured to execute together may be identified as a group in the sorted order. For example a time based subsystem may include a plurality of time based blocks and the subsystem may be configured to run as an atomic subsystem. In this case all of the time based blocks of the atomic subsystem execute atomically as a group. The time based modeling system may also define a simulation start time a simulation end time and a plurality of time steps between the start and end times. The size of the time steps may depend on the particular solver being used to execute the model.

Input and output signals may be represented graphically in the model or block diagram by arrow elements extending between time based blocks. Input and output signals represent quantities for example input and output data that change over time during the execution of the model and the quantities represented by the signals may be defined and thus have values for all points in time between a model s start time and its stop time. Execution of a model may also be referred to as simulation of the model.

In an embodiment one or more initialization steps may be performed before execution of the model begins. For example one or more state based portions of the model may execute one or more default transitions as indicated at block . Initialization steps for message based portions of the model may involve typical operations such as dequeuing a waiting message.

For each time step of the simulation which may begin with the simulation start time execution of model may proceed as follows. The time based modeling system in cooperation with the model execution engine may begin executing the time based components of the model according to the sorted order as indicated at block . If an event that is a triggering event for a state based portion of the model occurs the execution of the time based components may be suspended as indicated at block . The triggered state based portion may be executed as an atomic unit for example by the state based modeling system in cooperation with the model execution engine as indicated at block . Upon completing the execution of the state based portion the execution of the time based components may resume from the point in the sorted order at which execution had been suspended as indicated at block . For example the model execution engine may record where in the sorted order the execution was suspended to execute the state based portion.

In an embodiment an input triggering event may occur outside of a state based portion for example by a time based or other component but may be visible within the state based portion. Exemplary input trigger events may include an edge triggered input event and a function call for example from a time based component. An edge triggered input event may be configured to operate on a rising edge a falling edge or either a rising or falling edge. To operate as an input edge triggered input event a signal from a time based component may need to cross zero such as a changing from 1 to 1. In contrast a function call input event may consist of an instantaneous flow of control from a caller subsystem to a callee subsystem. A triggering event for a state based portion whether it is an edge function call or other trigger may not provide any input data to the state based portion which the state based portion might otherwise use for processing for example to generate output data. Instead the triggering event may operate as a control signal that triggers execution of the state portion and the state based portion may operate upon input data that is internal to the state based portion or that is received in other ways besides a triggering event.

If the triggering event for the state based portion occurs during the execution of a group of time based components that are configured to execute atomically then the execution of the entire group of time based components may be completed. Further execution of time based components may then be suspended and the execution of the triggered state based system performed.

If a message is generated and sent for example during the execution of time based components according to the sorted order then the execution of time based components may be suspended as indicated at block . The message based execution engine may examine the list of listeners for the respective message. The execution engine may send the message to the components on the list of listeners as indicated at block . If the destination component is triggered by the receipt of the message the execution engine may execute the destination component as indicated at block . The message based execution engine may also start a timer associated with the generation of a message and may track the age of the message as indicated at block . For example the engine may use the clock to operate one or more timers. When the age of the message reaches its maximum age which may be indicated in message s TTL field the message may be destroyed by the message based execution engine as indicated at block . Each message may thus persist for only a defined time period during the execution of a model.

Upon completing the execution of the components triggered by the message the execution of the time based components may resume from the point in the sorted order at which execution had been suspended as indicated at block .

It should be understood that the model execution flow described in connection with one or more of steps to may be nested. For example the execution of a state based portion may generate a message triggering the execution of a message based portion which may trigger the execution of a state based portion and so on.

It should be understood that a message may be sent to a message based component a state based component a time based component or some other component. In addition the message based component the state based component and the time based component may execute in response to the received message.

The life time of a message may depend on the semantics of the message processing environment. A message implemented using function call semantics may get created and consumed in the same time step thus resulting in a lifetime of a single time step. In the presence of queuing semantics messages can be produced in one time step but wait in a message queue for a number of time steps before they are consumed. In addition the consumer can choose to process a message without consuming the message thus resulting in messages with potentially infinite lifetime.

In an embodiment instead of sending a message to a destination component the message based execution engine may notify a destination component that a message has been created. In response the destination component may retrieve the message. If the destination component fails to retrieve the message before its maximum age is reached the message may be destroyed before ever being retrieved.

In an embodiment a message based component may be configured upon sending a message to expect a reply to its message. Such a component may be configured to execute in a synchronous or asynchronous manner. For example the component may be configured to execute synchronously in which case the component after sending its message waits to receive the reply before continuing with its execution. Alternatively the component may be configured to execute asynchronously in which case the component after sending its message proceeds with its execution without waiting for the reply.

In an embodiment a state based portion of the model may be configured to execute during a time step even though no triggering event for that state based portion occurred during the time step. More specifically a state based portion may register for time based triggering. If the model includes a state based portion that is registered for time based triggering and the state based portion has not already executed during the current time step then the model execution engine may execute the state based portion as indicated at block .

At this point execution during the current time step may be complete. If the current time step does not equal the simulation end time the current time step may be incremented and the execution process may be repeated. This process for example steps to may be repeated for each time step between the simulation start time and the simulation end time.

Referring to model execution at each time step may proceed as follows. Time based Constant and Gain blocks and may execute first as they may be the first blocks in the sorted order. The signal output of Gain block may be a trigger event for the state based portion . Accordingly after Gain block executes execution of other time based components may be suspended and the state based portion may be executed. The Message Receiver block is configured to listen for a message from the state based portion on input port . If the execution of the state based portion results in the generation and sending of this message the message is received by Message Receiver block causing it to be executed. Next the blocks of the second time based portion execute following the completion of execution of the Message Receiver block assuming it executes. Execution of the second time based portion results in the generating and sending of a message that is received by the Message Generator block . If the second time based portion is configured as an atomic subsystem then all of its blocks including Gain block and Outport block will execute before the Message Generator block executes. On the other hand if the second time based portion is not configured as an atomic subsystem then the Message Generator block may execute before execution of the Gain block and Outport block .

If the execution of the Message Generator block results in the generation and sending of a message then the Message Buffer block may execute as it is triggered by such a message. If the execution of the Message Buffer block results in the generation and sending of a message then the state based portion may execute again.

At this point execution of the current time step may be complete. The model execution engine may increment the time step and execute the model again unless the simulation end time has been reached.

The library of model objects may include a plurality of predefined object types or classes including time based object types state based objects and message based object types among others. Exemplary state based objects or components include state charts bubble charts junctions transitions conditions and flow graphs among others. To create a model a user may among other operations select a plurality of object types from the library . In response the modeling system may add instantiations of the selected objects to the model being constructed or edited.

The clock may be configured to generate one or more clock or time signals that may be used during execution of a model.

The message based modeling entity may include a propagation engine a message based execution engine a verification engine a report generator an interface engine a logging engine a message routing engine an object constructor that may access one or more class packages such as message based component class package and a message type class package . The message based modeling entity also may include or have access to message queues as indicated at .

The HMI engine model editor simulation engine message based modeling entity state based modeling entity and code generator may each comprise registers and combinational logic configured and arranged to produce sequential logic circuits. In an embodiment the HMI engine model editor simulation engine message based modeling entity state based modeling entity and code generator are or include software modules or libraries containing program instructions pertaining to the methods described herein that may be stored on computer readable media and executable by one or more processors and or processing elements. Other computer readable media may also be used to store and execute these program instructions. In alternative embodiments various combinations of software and hardware including firmware may be utilized to implement embodiments of the disclosure.

The modeling system may receive inputs by a user as the user creates edits revises and or opens one or more models such as computer models that when executed simulate the operation of systems such as physical systems. A model may be specified graphically textually or a combination of graphically and textually and may include a plurality of portions each operating according to a different execution domains. For example a first portion may operate according to message based semantics a second portion may operate according to time based semantics and a third portion may operate according to state based semantics. Other domains may include dataflow control flow and combined data and control flow domains. The time based and or the state based portions may further operate in accordance with message based semantics. The simulation engine in cooperation with the message based execution engine may execute the model generating one or more results that may be presented to the user.

In an embodiment the modeling system including the message based modeling entity may be configured to implement a message based modeling architecture in which producer sender objects of a model generate messages that are received consumer receiver objects during execution of the model. The model objects may be specified graphically textually or a combination of graphically and textually. In an embodiment messages may be instances of message types and may include payloads comprising one or more data elements that may be fixed during execution of the model for example a message s data does not change over the model s execution time. In an embodiment a message payload value may be modified e.g. during the message s time interval. Messages also may include one or more commands such as operation codes opcodes .

In an embodiment a model or at least a portion thereof may represent a dynamic system that defines relationships between signals and state variables that change over time. Determining the behavior of a dynamic system may involve evaluating these relationships at a plurality of intervals which may be called time steps beginning at a start time and ending at a stop time. The process of solving a model at successive time steps may be referred to as simulating the system that the model represents.

In addition sample times and sample rates may be determined e.g. at model compilation stage for at least some components of a model such as one or more objects or blocks of the model. A block s sample time may be set explicitly by a user or programmatically e.g. by setting a SampleTime parameter of the block or it may be determined in an implicit manner based on the block s type and or its context within the model. A block s SampleTime parameter may be a vector T T where Tis the sampling period and Tis the initial time offset. One or more of the solvers used to solve the model may determine the size of the simulation time steps in order to execute the model and these simulation time steps may be selected to correspond with the sample times of the blocks of the model. When a simulation time step matches the sample time for a block a sample time hit occurs and the block may be scheduled for execution during that simulation step.

The solver may generate an execution schedule for components including objects or blocks of the model over the course of the model s simulation time. In addition one or more message based components may be configured to execute at particular sample times. That is the message based components may be scheduled for execution at one or more time steps that correspond to sample time hits for the message based components.

As noted messages may persist for determined time intervals of an execution time of a model where the time interval is less than the full or entire execution time of the model. For example a model may be or may include a time based portion and may execute over a simulation time that begins at a simulation start time and ends at a simulation end time. One or more of the solvers chosen to solve the model may determine the execution time steps for the model. The time based portion of the model may produce signals that have a value throughout the execution time of the model and the value may change dynamically during the model s execution. Messages on the other hand may persist for a discrete limited portion of a model s simulation time. Messages may be configured to be triggering in which case when a message is generated a consumer receiver object is activated e.g. woken up and run in order to process the message. The consumer receiver object may process the message according to the object s normal execution schedule e.g. as determined by the solver . Alternatively messages may be configured to be non triggering in which case while a consumer receiver object may be woken up upon generation of a message the consumer receiver object is not required to process the message immediately. Instead the consumer receiver object when activated may examine a message queue to determine whether there is a message present in the queue and if so may process e.g. consume the message. Activation of the consumer receiver object may occur at some time after the message was generated and placed in the message queue. Messages also may be blocking or non blocking. With a non blocking message a producer sender may post a message and then run to completion before a consumer receiver of the message is activated e.g. woken up. With a blocking message the producer sender object may be configured to enter a wait state upon posting a message and execution may switch to the consumer receiver object. Once execution of the consumer receiver object completes execution of the producer sender may resume. In an embodiment the message based modeling entity may be configured such that messages are non triggering and non blocking. In this embodiment if a producer sender object wishes to receive an acknowledgement to a message the producer sender object may enter a wait state explicitly.

As noted the message based modeling entity may establish one or more message queues configured to store messages generated by producer sender objects of a model during execution of the model. The message queues may be accessed by consumer receiver objects to retrieve messages stored therein. In particular as part of a model initialization or set up phase the message based modeling entity may request allocation of one or more data structures e.g. in main memory to establish the message queues . Exemplary data structures include linked lists circular queues etc. Messages or alternatively message payloads generated by producer sender objects of a model may be placed and stored in the message queues .

In an embodiment a producer sender object may be configured to specify a particular one of the queues to store messages generated by the producer sender object. One or more message queues such as message queues may be global queues for storing messages generated by any message producer sender object and intended for any consumer receiver object. One or more other message queues such as message queues may be local to one or more message based objects such as a producer sender or consumer receiver object. In addition one or more message queues such as message queues may be shared by a group of objects. For example a group of consumer receiver objects that are configured to receive certain messages during execution of the model such as messages from the same producer sender object may share one of the shared message queues .

Message queues may have a plurality of attributes or properties such a length a processing order and an overflow policy which may be specified through corresponding properties. The attributes or properties may be fixed or they may be settable e.g. by a user on a queue by queue basis. Exemplary lengths include 1 2 3 etc. such that the message queue may store one two three etc. messages. Exemplary processing orders include First In First Out FIFO Last In Last Out LIFO and priority based queuing among others. An exemplary overflow policy is delete replace oldest message if message queue is full when a new message is received posted. With an overflow policy a producer sender object may continue to send messages to the message queue. That is the producer sender object may not be blocked from sending further messages when a message queue is full.

In a further embodiment at least some of the message queues may be configured with a priority attribute or property and may thus be assigned priorities such as a high priority message queue a moderate priority queue and a low priority message queue. A producer sender object may designate one of the message queues to hold a given message. For example for a message having high importance the producer sender object may designate the high priority message queue. For a message having moderate or low importance the producer sender object may designate the moderate or low priority message queues. A message receiver consumer may be configured to process messages from a higher priority queue before processing messages from a lower priority queue irrespective of the chronological order e.g. in terms of model execution time of the messages in the two queues.

In an embodiment the interface engine of the message based modeling entity may be configured to provide within an executable graphical model one or more graphical objects such as icons blocks etc. that represent a message queue. The message based modeling entity may be configured to add one or more message queue objects to a graphical model automatically or in response to user action such as selection and drag and drop operations.

The model may include a first double line arrow that connects the subsystem s output port to the Message Receive block to indicate that the Message Receive block is to receive the messages generated by the Message Send block of the subsystem . A second single line arrow may connect the Message Receive block to the Scope block . As noted a first graphical affordance e.g. a double line arrow may be used to represent message connections among message send and receive blocks while a second graphical affordance e.g. a single line arrow may be used to represent signals of the model . In an embodiment the message based modeling entity may be configured to establish at least one message queue automatically in response to the Message Receive being added to the model and configured to receive messages from the subsystem . During execution of the model messages generated and sent by the subsystem may be stored in this message queue for receipt and possibly consumption by the Message Receive block .

In an embodiment a properties page may be associated with the message queue block . The properties page may include a plurality of settable entries through which a user may specify attributes or properties of the message queue represented by the message queue block such as length processing order overflow policy and priority among others. The properties page may be opened in response to selection of the message queue block .

Furthermore instead of or in addition to having priority queues one or more messages may be assigned a priority e.g. by the producer sender object of the message. The message based execution engine may be configured to sort messages within a message queue based on the priority of the messages. For example messages assigned a high priority may be moved to the head of the queue and may be removed and consumed before other messages in the queue that have a low or a lower priority.

Exemplary message opcodes may include WARNING ERROR DIAGNOSTIC ALARM and ALERT. Nonetheless additional or other opcodes may be provided.

During execution of a model a producer sender object may generate and send a message to a consumer receiver object of the model. The generation and or sending of a message may occur at a sample time hit for the producer sender object or the generation and or sending of a message may occur independently of the model s execution time steps. The message may be stored at a message queue . As noted a consumer receiver object may be being triggered to execute upon the receipt of a message. That is upon notification of a message being added to the queue the consumer receiver object may be activated and may retrieve and consume the message. The consumer receiver object may thus operate synchronously relative to the receipt of a message. Alternatively a consumer receiver object may be configured to execute during one or more sample times instead of being triggered by the receipt of a message. For example at a sample time hit the consumer receiver object may examine its message queue to see whether there is a message in the queue. If there is a message in the queue the consumer receiver object may retrieve and consume the message as part of its execution during the sample time hit. At the next sample time hit the consumer receiver object may again access the message queue and if one or more messages are found may retrieve and consume the messages. The consumer receiver object may thus execute asynchronously with respect to the reception of a message. During initialization of a model the message based execution engine may be configured to schedule message based components or objects for synchronous or asynchronous execution. A message based component or object may be configured to include a property or parameter whose setting specifies whether the component or object executes synchronously or asynchronously.

In an embodiment the library of model objects may include time based and state based objects or components that may be further configured to send and or receive messages during execution of a model having instances of those objects or components. In particular the simulation engine in cooperation with the message based execution engine may be configured to execute state based components or objects that send and or receive messages during execution of a model or a portion thereof including those state based components or objects.

A user may interact with a Graphical User Interface GUI to open create and or revise a model including a state based model. Specifically the HMI engine may be configured to provide a model editor window in the form of a GUI having a plurality of window gadgets widgets or graphical elements which may be arranged as a desktop environment. The GUI s graphical elements may include a model canvas and one or more floating palettes that present graphical object types such as component types from the library that may be selected e.g. by a user and used to construct a desired model on the model canvas.

In an embodiment the modeling system may be configured to execute state based components or objects in response to events or messages occurring during model execution. Furthermore the modeling system may be configured to utilize a plurality of execution stages for state based components or objects. For example a state based component may have an inactive execution stage in which the component has no active states an active execution stage in which the component has one or more active states and a sleeping execution stage in which the component has one or more active states but no events or messages to process.

In an embodiment the message based modeling entity may be configured to add one or more message ports to a state based component of a model such as the chart of the model . The message ports may be represented graphically and may be added in response to user inputs or programmatically. The modeling system may be configured to open the chart e.g. for editing in response to a selection of the chart e.g. by a user. is a schematic illustration of the model editor window in which the chart is opened. With the chart component opened a user may construct or revise the chart component for example by adding program elements or components to the canvas . A menu bar for the chart may be presented on the model editor window in place of the menu bar . A popup dialog may be presented in response to a selection of a Chart command of the menu bar . The popup dialog may include an Add Inputs Outputs command that in turn may present a plurality of commands such as an Add Message Input command and an Add Message Output command . The message based modeling entity may be configured to add message ports to state based objects such as the chart component for example in response to the selection of the Add Message Input command and or the Add Message Output command e.g. by a user. In an embodiment a properties page not shown may be presented in response to the selection of the Add Message Input command and or the Add Message Output command through which a user may specify property values for the respective message ports. A message input port may have the following properties 

The message based modeling entity may be configured to assign default values to one or more of the properties of the message ports. The message based modeling entity may be configured to implement message ports as objects instantiated from a message port class or type.

Once desired values have been selected for the properties of the message ports the user may return to the model view. is a schematic illustration of the model editor window . The chart component now includes a message input port named Message and a message output port named Message1 . In an embodiment particular messages may be assigned to the message input and output ports and graphically e.g. by drawing a line or other graphical object from another component or object of the model to the message input and output ports and . Alternatively messages may be assigned to the message input and output ports and through textually specified commands or through a combination of textual and graphical inputs.

In an embodiment the message based modeling entity may be configured to assign respective message queues to the message ports such as the message input and output ports and . The message queues assigned to the input and output ports and may have a length a processing order an overflow policy and a priority.

It should be understood that the message based modeling entity may be configured to utilize other objects to implement message ports and or message queues. For example a separate graphical object such as a Message Queue block may be defined and instances of the Message Queue block may be added to a model. A Message Queue block may be associated with a message port of a state based component. For example a Message Queue block may be graphically or visually connected to the message port.

In an embodiment the logging engine may be configured to log messages generated during execution of a model. For example the logging engine may be configured to utilize one or more blocks or objects for logging message. The blocks or objects may be included in the model and may be configured to detect messages as they are added to a message and to store copies of the messages for subsequent analysis. In addition to storing copies of the message the blocks or objects may be configured to store additional data such as metadata associated with the messages. The metadata may include such things as the execution time at which messages are created and added to the queue the execution time at which messages are de queued the producer sender of a message the receiver consumer of a message etc. Exemplary blocks or objects that may be used by the logging engine include the To Workspace block of the Simulink model based design system from The MathWorks Inc. The To Workspace block may for example be connected to a message port and or a Message Queue block. During execution the To Workspace block may store information concerning messages in a workspace associated with the model. Following the execution of the model a user may access the workspace and examine the messages and their metadata.

In an embodiment the message routing engine may be configured to route messages within a model. For example the message routing engine may be configured to forward messages received at a first message queue to a second message queue. The message routing engine may call a forward method or operation on the queue. The forward method or operation may specify the second message queue to which messages are to be forwarded. In an embodiment the forward method or operation may not cause messages to be consumed e.g. deleted from the first queue. To the extent the first message queue is associated with a state based component or object of a model the message routing engine may be configured to forward messages from the first message queue when the component or object goes to sleep. In an alternative embodiment the forwarding of messages from the first queue may result in the messages being consumed.

In an embodiment one or more graphical object types may be specified and instances of these graphical object types may be included in a graphical model to specify message routing functions or operations. The graphical objects may be represented in a graphical model by preselected graphical affordances such as particular blocks icons etc.

It should be understood that other or different message routing blocks may be provided such as a message splitter block configured to distribute messages from one message source block to multiple message receiver blocks.

Message queues may be configured by the message based modeling entity to implement a plurality of methods or operations such as primitive operations or primitives during execution of a model. For example message queues may support a peek method or operation. In response to calling the peek method a message queue may reply by informing the caller or sender of the peek method whether or not a message is currently in the queue. The reply may simply indicate whether one or more messages are in the message queue e.g. Yes or No. Alternatively the reply may include the number of messages in the queue. In addition the caller of the peek method may obtain the message s payload. In an embodiment the peek method or operation may not result in the message being removed from the message queue. Accordingly the number of messages currently stored in a message queue is not changed by the peek method. A message queue may also support a pop method or operation. A message queue may respond to a pop method or operation by removing a message from the message queue and providing the message to the caller of the pop method or operation. The particular message that is removed may depend on the queue s processing order e.g. FIFO LIFO etc. A message queue also may support a consume method or operation. In response to a consume method or operation the message queue may destroy the respective message. In an embodiment multiple methods or operations may be tied together. For example the consume method may be tied to the pop method so that when a message is removed from a message queue it is also destroyed.

The modeling system including the state based modeling entity may be configured to execute actions defined or specified for state based components or objects during model execution. More specifically a user may define or specify one or more action statements for state objects of a model. For example an entry type of action which may be identified by using a label such as entry or en may be executed when a state becomes active e.g. is entered. A during type of action which may be identified by using a label such as during or du may be executed while a state is active. In an embodiment the modeling system may be configured to support the specification of during actions to be performed or executed when a specified event occurs or when a specified message and or message payload is received. An exit type of action which may be identified by using a label such as exit or ex may be executed when a state becomes inactive e.g. is exited. An on event type of action which may be identified by using a label such as on followed by an event name may be executed when the state is active and the event occurs. In an embodiment the modeling system may be configured to support the specification of actions to be performed when a state is active and a particular message is received by the state. That is the modeling system may also support an on message type of action which may also be identified by the on label.

The modeling system including the message based modeling entity may be configured to implement a programming syntax that may be used when defining or creating a model in order to configure a state based component or object of the model to post a message during execution of the model. An exemplary textual syntax is 

Using the defined syntax a user may configure a state based component or object of a model to post one or more messages during execution of the model including that state based component or object. The posting of the message may be specified as an entry type of action a during type of action a on type of action or an exit type of action. The one or more messages may be posted by the component or object to a particular message queue.

It should be understood that other programming syntaxes may be defined and used to post messages. For example other exemplary programming syntaxes include 

In an embodiment the modeling system may be configured to support transitions among state components or objects of a model based on messages generated during execution of the model. That is the transitions may occur or may not occur as a function of one or more messages. In other words a state transition may be guarded by a message. In particular the message based modeling entity may be configured to implement transitions between states 

The message based modeling entity may be configured to recognize a programming syntax and this programming syntax may be used to associate a message or a message and condition to a transition. An exemplary textual syntax is 

A state based component or object may be configured to transition between states on receipt of a message regardless of the message s payload. For example to configure the state based component to transition from state A to state B on receipt of a message regardless of the message s payload a user may associate the transition with the textual string M . The message based modeling entity may be configured to evaluate this textual string to mean determine whether any message M is received without considering the message s payload.

In an embodiment a textual command string may be associated with a transition by selecting the transition and entering the textual command string in a dialog that opens for the transition.

It should be understood that other programming syntaxes may be used to determine if a desired message exists to cause a transition among states. Alternative syntaxes that may be used include 

State based components or objects may also be configured to receive messages and process the payloads of messages as during and exit types of actions.

State transitions may also be guarded by attributes of message queues such as the length of a given message queue.

The simulation engine may be configured to execute a model over a simulation time that has a plurality of time steps including a model having components or objects that send and receive messages. The modeling system may be configured to support a programming syntax for determining whether a message is received at a given point in time during the simulation time such as a particular time step and or a particular simulation time. For example the modeling system may support the following programming syntax which may be used in a model 

This programming syntax may be used to guard transitions among states or to determine whether other operations should be performed e.g. by a state based or other component or object of a model.

In an embodiment the message based modeling entity may be configured to designate messages as consumed upon the messages being read. Once a message is designated as consumed it may be marked stale and or destroyed. Suppose for example that a transition between two states is defined to occur on the existence of a message having an attribute that satisfies some condition such as a payload equaling some value a payload being greater or less than some value the message is received at a particular point in the model execution time etc. If the message based modeling entity examines the message queue and finds a message in the queue then the message based modeling entity may read the message and mark it as consumed whether or not the message s attribute satisfies the condition. Thus even though a message does not result in a transition between the two states because the message s attribute does not meet the condition the message may be consumed and thus destroyed.

With regard to state based components or objects the message based modeling entity may be configured to mark a message as read after the state based component reaches a stable state. Suppose for example that a state based component is defined so that the component transitions from a first state to a second state upon receipt of a message regardless of the message s payload and transitions from the second to a third state if an attribute of a received message satisfies some condition. In this case upon receipt of a first message the component transitions from the first state to the second state. The first message is also tested to see whether its attribute satisfies the condition. If so the component transitions from the second to the third state. If the third state is a stable state of the component then the message based component marks the message as consumed and the message is destroyed. Nonetheless the same message may be used to effect two transitions within the state based component.

A state diagram or state chart may be considered to be in a stable state after all possible transitions among states or sub states are completed. Alternatively the message based modeling entity may be configured to treat a message as consumed after the first access to the message e.g. after accessing the message in response to a first transition of a state based component or object.

In an embodiment before a message based component goes to sleep messages that were peeked at may be popped and thus consumed.

In an embodiment the state based modeling entity e.g. as default semantics may be configured to execute the state based components of a model once for every active input event or input message to the state based components. If there are no input events or input messages for a given state based component it may be executed once each time step if the model is a time based model that executes over a plurality of time steps between a start time and an end time. In addition a given state based component or object of a model may be configured to execute multiple times for every active input event or input message or for every time step when the state based component has no input events or input messages. In this case which may be referred to as super step semantics the given state based component may take valid transitions until no more valid transitions exist for the given state based component or the number of transitions that have been taken exceeds a threshold which may be user specified. For a state based component configured with super step semantics the message based modeling entity may be configured to mark a message as read and thus consumed at the end of each single step or alternatively at the end of a super step .

In an embodiment the state based modeling entity may support the creation of state based components that include parallel AND states or sub states in which all the states or sub states of the state based component are active. The ordering of parallel states or sub states may be explicit e.g. user specified priority numbers or implicit e.g. based on internal rules of the state based modeling entity .

Suppose for example a state based component has a single message input port and two parallel states that are both interested in messages posted to the component s message input port. In an embodiment when a message is received at the message input port the message based modeling entity may be configured to wait until each parallel state or sub state has had an opportunity to read the message before marking the message as consumed. If a first parallel state is ready for a message the message is read and acted upon by the first parallel state. If a second parallel state is not ready for a message then it does not read the message and the message may be considered consumed.

In an alternative embodiment the message based modeling entity may be configured to establish a message queue for each parallel state or sub state and to place a copy of the message in each of these message queues. In this embodiment if a first parallel state is ready for a message it reads the message from its message queue and the message from that message queue is consumed. If a second parallel state is not ready for a message the message waits in the second parallel state s message queue until the second parallel state is ready to read a message.

In yet another embodiment the message based modeling entity may be configured to keep executing the parallel states until a fixed point is reach at which a message may be consumed by both of the parallel states e.g. in the same time step.

In a further aspect of the disclosure verification or other testing may be performed on one or more message based portions of a model. In an embodiment one or more verification components may be provided to verify a message based portion of a model.

In an embodiment the verification engine may create a first verification component which may be referred to as an observer for verifying one or more messages in a model. The observer may be associated with a particular message based connection in a model and may present information concerning one or more of the messages that travel across that connection during execution of the model. In an embodiment the observer component operates at least in part as a viewer to present information concerning all of the messages that travel across the selected connection during execution of the model. The observer component may provide a message based view that includes the set of message participants such as the sources and destinations the types of messages generated and sent and the payloads of those message. This collection of information may be referred to as an interaction.

Suppose a user is interested in examining and verifying the actual messages exchanged between the Bus component and the Controller component across the message based connection during execution of the model . In this case the user may access an Observer component such as Observer component or block .

The verification engine may receive a request for an Observer block as indicated at block . The verification engine may also receive a designation of one or more message based connections to which the requested Observer block is to be associated as indicated at block . In response to the request the verification engine may cooperate with the constructor to create an Observer component such as an object instance. In addition the model builder may present a corresponding Observer block such as block in the graphical model as indicated at block . A user may issue a request for an Observer block either textually e.g. by entering a command in a Command Line Interface CLI or graphically e.g. by selecting an Observer block from a library browser. In an embodiment a user may select a message based connection of interest for example connection such as with the mouse . In response the verification engine may present one or more selectable commands in a drop down list including an Insert Observer Block command. The user may select the Insert Observer Block command thereby causing an Observer component to be created that is associated with the selected message based connection.

In an embodiment the Observer block may include a plurality of Graphical User Interface GUI elements. Specifically the Observer block may include corresponding icons for the two or more message based participants e.g. the components connected by the message based connection to which the Observer block is associated. Here the Observer block may include a first box element representing the Bus component and a second box element representing the Controller component . The Observer block may also include a line element such as line elements extending from each box element . Information concerning messages exchanged between the Bus component and the Controller component across message based connector may be presented between the line elements of the Observer block .

After issuing a request for an Observer block and associating it with a message based connection of interest the model may be executed as indicated at block . As part of the execution of the model the Bus component may generate and send one or more messages to the Controller component and the Controller component may respond with one or more reply messages. Information concerning this exchange of messages may be presented by the Observer block .

Specifically the verification engine may monitor the sending and receiving of messages across the selected message based connector as indicated at block . For example the verification engine may interface with the message based execution engine . In addition as each such message is generated and sent the verification engine may add an entry to the Observer block for that message as indicated at block . The verification engine may also include within each entry one or more information elements concerning the respective message as indicated at block . For example the verification engine may add an arrow element to the Observer block for each actual message. An arrow pointing from line element which extends from box element to line element which extends from box element may represent a message sent from the Bus component to the Controller component . An arrow pointing from line element to line element may represent a reply message sent from the Controller component to the Bus component . The verification engine may also include a data element at each entry that indicates the type of message sent and that includes information from the message s payload. The entire payload or a portion thereof may be included in the entry s data element.

In addition the verification engine may include one or more time elements in the entry for a given message. The one or more time elements may contain information relating to the timing characteristics of the message. In particular a message may be sent by a source component at a particular time which may be denoted as the TimeSent T and may be received by a destination component at a particular time which may be denoted as TimeReceived T. One or more of these timing characteristics such as Tand or T may be included in the entry of the Observer block by the verification engine .

The timing characteristics of a message may be determined by the verification engine in cooperation with the message based execution engine . For example system may receive a clock signal from system clock and the message based execution engine may use this clock signal to identify one or more timing characteristics of messages.

As illustrated in the Observer block four messages were generated and sent across the message based connection during execution of the model as indicated by arrow elements . All four messages were sent by the Bus component to the Controller component as indicated by the arrow elements . Furthermore each of the four messages may be Altitude type messages and may carry the following payloads 10 000 20 000 30 000 and 40 000 . In addition the four messages were received by the Controller component at the following times 12 s 18 s 20 s and 21.4 s as indicated by timing elements of the Observer block .

The verification engine may also receive a request for a report of the messaging information presented by the Observer block as indicated at block . For example a user may request such a report. The verification engine may provide the information to the report generator as indicated at block and the report generator may create a report as indicated at block . The report generator may provide the report to an output device such as the display a printer etc. as indicated at block . The report generator may also or alternatively save the report in memory as indicated at block .

The Observer block may be docked that is fixed to the model . The Observer block also may be visually associated with the message based connection through a line element not shown connecting the Observer block to the connection . Alternatively the Observer block may be a floating block. A floating block is not locked to any particular location in the model but may be moved around the canvas for example by the user. In this case an icon such as a glasses element may be placed near the connection to indicate that an Observer block is associated with this message based connection.

In an embodiment the high level modeling environment may include one or more code generation modules for generating code from a model such as C code C code Hardware Description Language HDL code etc. The code generation module may generate code for one or more verification blocks such as the Scenario blocks. If the code for the Scenario block detects an invalid trace for example it may generate an error message that could be read by another code module which in turn may take some predetermined action such as resetting the deployed systems or sending a signal to a processing unit.

The generated code moreover may be used in a deployed system that may be a real world system that is physically separate from the data processing system on which the high level modeling environment operates. Exemplary deployed systems include controllers such as Engine Control Units ECUs used in cars and trucks Anti lock Braking Systems ABS aircraft flight control systems etc.

Suitable code generation models include the Real Time Workshop code generator and the Simulink HDL Coder products from The MathWorks Inc.

Referring to the modeling system may further include a code generator . The code generator may be configured to generate code such as computer programming code for a model or portion thereof. The generated code may be standalone code that is independently executable e.g. executable outside of the modeling system and may be compatible with a specified target platform. Exemplary target platforms include a server or other data processing machine running a Microsoft Windows operating system a server or data processing machine running a UNIX or Linux operating system and an embedded system having a microprocessor a Digital Signal Processor DSP a Field Programmable Gate Array FPGA and or an Application Specific Integrated Circuit ASIC among others. The generated code may be deployed to and run by the target platform which may not include a modeling system . During the code generation process a user may specify the target platform and may specify other options for the code generation process such as the use of one more optimizations. The generated code may be source code object code an executable a binary a hardware description language HDL description etc. and may conform to a programming language such as C C VHDL Verilog etc. In an embodiment the code generator may be configured to generate code that when compiled or interpreted on the target platform creates a message passing architecture or service. This message passing architecture or service may be used by other modules of the generated code representing message based components or objects of a model.

In another embodiment the code generator may generate code that takes advantage of an existing message passing architecture or service of a target platform. For example in addition to specifying a particular target platform a user may indicate a message passing service already present and available on the target platform. For example the VxWorks real time operating system RTOS from Wind River Systems Inc. of Alameda Calif. creates message channels to support fast communication between applications tasks and processes. These message channels provide a connection oriented bidirectional messaging mechanism based on the Transparent Interprocess Communication TIPC open source protocol. The Run time Environment RTE of the Automotive Open System Architecture AUTOSAR an open and standardized automotive software architecture jointly developed by various automobile manufacturers suppliers and tool developers also defines an information exchange service. The Portable Operating System Interface for UNIX POSIX is a set of IEEE and ISO standards defining an interface between application programs and UNIX type operating systems. PROFINET is an industrial networking standard designed for automation. The code generator may be configured to generate code that interfaces to the message channels of the VxWorks RTOS the RTE from AUTOSAR the POSIX standard or the PROFINET standard instead of creating a separate message passing service. For example an interface specification such as an Application Programming Interface API may provide details for interfacing to a particular message passing service such as VxWorks message channels. The code generator may be configured to generate code that includes calls to the message passing service based on the interface specification.

The code generator may include or have access to code replacement tables containing message passing service implementations for one or more existing message passing services. When the code generate reaches a point in the generated code regarding the passing of a message the code generator may access the one or more code replacement tables for the selected message passing service and utilize within the generated code the message passing service implementations contained in the one or more tables. It should be understood that other techniques may be used to specify an implementation of an existing message passing service.

An executable graphical model may include portions such as sub models subsystems blocks etc. that are configured to execute at different rates relative to each other. The different model rates may be a function of a fundamental rate or a fundamental model sample time.

The foregoing description of embodiments is intended to provide illustration and description but is not intended to be exhaustive or to limit the disclosure to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from a practice of the disclosure. For example while a series of acts has been described above with respect to the flow diagrams the order of the acts may be modified in other implementations. In addition the acts operations and steps may be performed by additional or other modules or entities which may be combined or separated to form other modules or entities. Further non dependent acts may be performed in parallel. Also the term user as used herein is intended to be broadly interpreted to include for example a computer or data processing system e.g. system or a user of a computer or data processing system unless otherwise stated.

Further certain embodiments of the disclosure may be implemented as logic that performs one or more functions. This logic may be hardware based software based or a combination of hardware based and software based. Some or all of the logic may be stored in one or more tangible non transitory computer readable storage media and may include computer executable instructions that may be executed by a computer or data processing system such as system . The computer executable instructions may include instructions that implement one or more embodiments of the disclosure. The tangible non transitory computer readable storage media may be volatile or non volatile and may include for example flash memories dynamic memories removable disks and non removable disks.

No element act or instruction used herein should be construed as critical or essential to the disclosure unless explicitly described as such. Also as used herein the article a is intended to include one or more items. Where only one item is intended the term one or similar language is used. Further the phrase based on is intended to mean based at least in part on unless explicitly stated otherwise.

The foregoing description has been directed to specific embodiments of the present disclosure. It will be apparent however that other variations and modifications may be made to the described embodiments with the attainment of some or all of their advantages. For example one or more message based blocks such as a verification block may be configured through a command line Application Programming Interface API that may be provided by the message based object constructor or the verification engine. Therefore it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the disclosure.

