---

title: Systems and methods for finding project-related information by clustering applications into related concept categories
abstract: A system, method, and computer-readable medium, is described that finds similarities among programming applications based on semantic anchors found within the source code of such applications. The semantic anchors may be API calls, such as Java's package and class calls of the JDK. Latent Semantic Indexing may be used to process the application and semantic anchor data and automatically develop a similarity matrix that contains numbers representing the similarity of one program to another.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09256422&OS=09256422&RS=09256422
owner: Accenture Global Services Limited
number: 09256422
owner_city: Dublin
owner_country: IE
publication_date: 20140805
---
This application is a continuation of application Ser. No. 13 248 877 filed Sep. 29 2011 which is incorporated herein by reference in its entirety to provide continuity of disclosure.

Retrieving similar or related web pages is a feature of popular search engines e.g. Google Ask.com HotBot . For example after a user submits a search query Google displays links to relevant web pages along with a link labeled Similar next to each result. These Similar links point to web pages that Google s algorithm judges to be similar by aggregating various factors that may include target link association as when one webpage contains links to each of the Similar web pages topical similarities and popularity scores of the retrieved pages. One benefit of the Similar link is that it lets users find pages similar to a known web page without the need to determine the proper keyword search to achieve this result.

One technical area where a similarity search function would be desirable is in the realm of application development. A software application is a collection of all source code modules libraries and programs that when compiled result in the final deliverable that customers install and use to accomplish certain business functions. Detecting similarity between applications however is a notoriously difficult problem in part because it means automatically detecting that the high level requirements of these applications match semantically. Such detection is difficult for a variety of reasons. For example many application repositories are polluted with poorly functioning projects which could lead to non functioning projects being misidentified as similar to functioning projects. Further keyword searching may also lead to erroneous results because for example a keyword match between words in a requirements document with words in the descriptions or source code of an application does not guarantee relevance between the two corresponding applications. Also applications may be highly similar to one another at a low level even if they do not perform the same high level functionality which could result in the misidentification of similar applications that perform dissimilar functions. Moreover it may be difficult to recognize similarity between software artifacts belonging to different applications because programmers rarely record traceability links between different applications.

Knowing similarity between applications plays an important role in assessing reusability of applications improving understanding of source code prototyping for rapid development and discovering code theft and plagiarism. Allowing programmers to compare how different applications implement the same requirements may contribute to their knowledge about application requirements and to the efficient reuse of code. Retrieving a list of similar applications may allow programmers to concentrate on the new aspects of the requirements thus saving time and resources for programmers. Programmers could spend this time instead understanding the functionality of similar applications and seeing the complete context in which the functionality is used.

Consider a typical project in a large scale software development enterprise in which company programmers engage in several hundred software projects at the same time. The enterprise may have previously delivered thousands of applications many of which may have had similar requirements and implementations to the project at hand.

A typical project starts with writing a proposal in response to a bid request from a company that needs an application. A winning bid proposal has many components well written requirements preliminary models and design documents and proof of experience in building and delivering similar applications in the past. A company that submits a bid proposal that contains these components with the closest correlation to a desired application will likely win the bid. Reusing the components from successfully delivered applications in the past will save time and resources and further increase chances of winning the bid. Thus recognizing similarities between past and present applications is important for preserving knowledge leveraging experience winning bids on future projects and successfully building new applications.

The process of finding similar applications may start with code search engines that return code fragments and documents in response to queries that contain key words from elicited requirements. However returned code fragments are of little help when many other non code artifacts e.g. different functional and non functional requirements documents UML models or design documents are required. Matching words in queries against words in documents and source code may be a good starting point but keyword search results do not establish how applications are similar at a high level scale.

A problem in detecting closely related applications is in the mismatch between the high level intent reflected in the descriptions of these applications and low level details of the implementation. This problem is known as the concept assignment problem. For any two applications it is too imprecise to establish their similarity by simply matching words in the descriptions of the applications comments in their source code and the names of program variables and types e.g. names of classes and functions as well as identifiers . Thus existing code search engines do not effectively detect similar applications and programmers must typically invest a significant intellectual effort to analyze and understand the functional similarity of retrieved applications.

Similarities between documents can be found using syntagmatic associations by considering documents similar when terms in these documents occur together in each document. This technique is used by the MUDABlue similarity engine. Alternatively similarities between documents can be found using semantic anchors and by developing paradigmatic associations where documents contain terms with high semantic similarities. Semantic anchors are elements of documents that precisely define the documents semantic characteristics. Semantic anchors may take many forms. For example they can be expressed as links to web sites that have high integrity and well known semantics e.g. cnn.com or whitehouse.gov or they can refer to elements of semantic ontologies that are precisely defined and agreed upon by different stakeholders. Without semantic anchors documents or applications are considered as collections of words with no semantics and the relevance of these documents to user queries and to one another is determined by matches between words. Using semantics represents the essence of paradigmatic associations between documents whereas using word matching represents the essence of syntagmatic associations.

Programmers routinely use Application Programming Interface API calls from third party packages e.g. the Java Development Kit JDK to implement various requirements. Unlike names of program variables types and words used in comments API calls from well known and widely used libraries have precisely defined semantics. Since programs contain API calls with precisely defined semantics the API calls may serve as semantic anchors to compute the degree of similarity between applications by matching the semantics of applications as expressed by the API calls. Using the API calls to compute similarities among applications may result in better precision than syntagmatic associations among applications.

Therefore a method of finding similarities in applications based on underlying semantics of the applications would be useful to allow programmers needing to find similar applications to do so with less intellectual and manual efforts than currently used search methods. A method of finding a similar application based on underlying semantics would also be useful to help preserve knowledge base and correlate supporting software documentation in similar applications.

A method system and computer readable medium are described where the method receives by a computer source code for a plurality of applications and associates each application to semantic anchors found with each application. The method system and computer readable medium also compare the applications based on the semantic anchors and assign based on the comparison a similarity index representing the similarity between two applications.

It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory only and are not restrictive of the application as claimed.

The accompanying drawings which are incorporated in and constitute a part of this specification illustrate several embodiments of the application and together with the description serve to explain the principles of the application.

Reference will now be made in detail to the exemplary embodiments. Wherever possible the same reference numbers will be used throughout the drawings to refer to the same or like parts.

Embodiments consistent with the present disclosure may use semantic anchors and dependencies among such semantic anchors to compute similarities between documents with a higher degree of accuracy when compared with results obtained with documents that have no commonly defined semantic anchors. This approach is based on three observations. First if two applications share some semantic anchors e.g. API calls then their similarity index should be higher than for applications that do not share any semantic anchors. Sharing semantic anchors means more than the exact syntactic match between two API calls it also means that two different API calls will match semantically if they come from the same class or a package. This idea is rooted in the fact that classes and packages in the JDK contain semantically related API calls for example the java.security package contains classes and API calls that enable programmers to implement security related requirements and the java.util.zip package exports classes that contain API calls for reading and writing the standard ZIP and GZIP file formats. The exemplary process may thus exploit relationships between inheritance hierarchies in JDK to improve the precision of computing similarity.

Second different API calls have different weights. Many applications have many API calls that deal with collections and string manipulations. The exemplary process automatically assigns higher weights to API calls that are encountered in fewer applications and conversely to assign lower weights to API calls that are encountered in a majority of applications. There is no need to know what API calls are used in the applications this task may be done automatically improving the precision of the process by preventing API calls to common packages like java.lang from skewing the similarity index.

Third an application requirement is often implemented using combinations of different API calls rather than a single API call meaning that co occurrences of API calls in different applications may form a pattern indicating that these applications implement similar requirements. For example a requirement for efficiently and securely exchanging XML data is often implemented using API calls that read XML data from a file compress and encrypt it and then send this data over a network. Even though different ways of implementing this requirement are possible the patterns of co occurrences of these API calls may be reflected in the similarity index thus improving the precision of the results when compared with alternative approaches.

Although some exemplary embodiments have been described in terms of finding similarities between Java applications it should be understood that the system may also be used in some embodiments to find similarities between applications written in other programming languages. For example similarities between C applications may be found by equating Java s packages to C s namespaces and Java s classes to C s classes. Other embodiments may use only one TDM to correlate API calls or similar function calls derived from any source. In other embodiments the system may use other TDMs built using the same concepts as presented herein but keyed on other metadata found in the programming applications and documentation such as a TDM based on syntagmatic associations word matching or a TDM based on focused syntagmatic associations keyword matching . In some embodiments the MetaData Extractor and Applications Metadata may contain processes to cull alternative metadata out of the Application archive for further processing by the TDM Builder to support additional or different TDMs.

In an embodiment the exemplary system may use Latent Semantic Indexing LSI a well established conceptual framework of relevance step but extend it by including semantic layers that correspond to packages and class hierarchies that contain functional abstractions. This approach is based on the concept that applications that contain functional abstractions in the form of API calls whose semantics are defined precisely and implement the same requirement e.g. different API calls from a data compression library have a higher degree of similarity than those that do not have API calls that are related to a requirement. LSI may be applied separately to TDMand TDMto compute class and package matrices P and C respectively where each row contains coordinates that indicate the packages P or classes C of API calls that are invoked in the application. Matrices P and C may be combined into a Similarity Matrix using a process described in more detail below. The Similarity Matrix S is a matrix whose rows and columns designate applications. For any two applications Aand A each element of S Srepresents a similarity score between these applications that may be defined as follows 

Once found one use of the similarity between applications is in finding existing applications that meet a defined set of requirements. After obtaining the initial set of requirements the user may enter keywords representing aspects of these requirements into search engine which will return applications relevant to these keywords. The results may also include non code artifacts which may be important for the bidding process or to expedite application documentation.

After reviewing the returned applications the user may determine which code and non code artifacts are relevant to the requirements and which artifacts are missing. The user may focus the search to find applications that contain the missing artifacts and which are also similar to relevant applications that the user has already found. Exemplary embodiments may reduce query or document mismatch by expanding the query with concepts that are similar to the set of relevant documents. In this case the exemplary system may expand the initial query using the previously found application to include artifacts from this application that matched some of the requirements determined by the user and thus find applications containing artifacts similar to the ones in the found application.

When a user enters a query it is passed to the Search Engine that retrieves applications with relevancy ranking based on the Similarity Matrix . Search Engine uses the Application Metadata to extract and deliver a map of API calls for each pair of similar applications. This map shows API calls along with their classes and packages that are shared by similar applications. The user is allowed to select and view the returned applications API calls to help determine which project requirements are met. The user may also select to find similar applications to any particular returned application. Upon selection of this option a new list of applications is returned to the user based on the similarity matrix index.

For example suppose that a programmer was tasked with creating an application that records musical data from an electronic instrument into a MIDI file. The user may submit a search query that contains key words such as record MIDI and file. The exemplary search engine may retrieve a list of applications that are relevant to these key words. The applications retrieved may include the application MidiQuickFix that may be of interest to the user. After clicking on the link corresponding to this application the exemplary system may present the user with a list of similar applications ranked in descending order. The user may select a relevant similar application and in response the system may present the user with a visual interface as shown in part in .

The exemplary interface of shows three tabs. The leftmost tab the active tab in presents packages classes and API calls common to both applications. The two other tabs present packages classes and API calls for each application separately. Comparing applications directly based on functionally related API calls may help programmers to concentrate on highly related details rather than examine the entire source code. In this example the most similar application retrieved is mbox a command line utility to convert MIDI files to mappings of music box drums. Packages com.sun.media.sound and javax.sound.midi are shown in as common for both applications MidiQuickFix and mbox. When expanded common classes and API calls are shown to the user. For example indicates that the class AbstractMidiDevice includes an API call doClose that is invoked in both applications.

Note that this example display of is not intended to be restrictive. Additional tabs or other delimiters may be included to assist the programmer in comparing two or more applications. For example the display may include a tab for each application that represents class and package information for each API call not found in each other application. This would help the programmer to understand the differences as well as the similarities between the two applications. In addition the user interface may contain other elements such as breadcrumbs to make navigation of the search results more convenient for the user. Also the user interface may allow the user to select and compare similarities and differences among three or more applications.

Returning to one or more of the components depicted in may be implemented in software on one or more computing systems. For example the components may comprise one or more applications which may in turn comprise one or more units of computer readable instructions which when executed by a processor cause a computer to perform steps of a method. Computer readable instructions may be stored on a computer readable medium such as a memory or disk. Such media typically provide non transitory storage. One or more of the components depicted in may be hardware components or combinations of hardware and software such as for example special purpose computers or general purpose computers. A computer or computer system may also comprise an internal or external database. The components of a computer or computer system may connect through a local bus interface.

In some embodiments one or more of the components shown in may be a computer server with web services enabled. For example the search engine could contain a processor web service for processing code search requests initiated by users connected via a network using a web browser. The components depicted in may be operatively connected to one another via a network not shown such as the Internet an intranet or any type of wired or wireless communication system. Connections may be implemented through a direct communication link a local area network LAN a wide area network WAN and or other suitable connections. Apps Archive and API Archive may be implemented in databases files or other suitable repositories and may be accessed by other components directly via an external connection or via a network not shown .

TFrepresents a normalized measure of the package API call count. The Term frequency for a particular package may be calculated as follows 

The Inverse Document Frequency IDF is a measure of the general importance of the API call obtained by dividing the total number of applications by the number of applications containing the API call and then taking the logarithm of that quotient 

Once the weight is found for TDMthe process considers at step whether all package API calls in Application j have been considered. If not then the i index is incremented in step and the process returns to step . If so then the process considers at step whether all eligible applications have been considered. If not then the j index is incremented and i index set to one 1 in step and the process returns to step for further processing. If so then the process ends.

The set of TDMvalues found in exemplary process define the TDM where each row corresponds to a unique package API call and each column corresponds to a unique application found in the Application Archive .

The exemplary process may use the Application MetaData to help determine the data determined in steps and because the Application MetaData already contains associations of package or class API calls to Applications.

Each element of the resulting TDMmay represent a normalized metric determined from the process that represents how frequently this package API call row is used in this application column but tempered by the relative importance of the package API call in the application. A simple metric like the API call count alone showing the number of times a given API call appears in applications regardless of any context may be subject to bias thereby skewing the distribution of these calls toward large applications which may have a higher API call count regardless of the actual importance of that API call. Therefore a normalized metric such as the one presented by the exemplary process may reduce bias by accounting for the total number of API calls in the particular application and correlating it to the general importance of a particular API call in all applications. API calls that are used less frequently across all applications will in general be more important to determine similarity than API calls used in nearly every application.

TDMs for other semantic anchors syntagmatic associations or for other programming languages may be developed in a similar way.

SVD decomposes TDMand TDM into three matrices using a reduced number of dimensions r whose value may be chosen experimentally. The number of dimensions is commonly chosen to be r 300 but may be greater or less than 300. Three exemplary decomposed matrices are shown on the right hand side of the schematic equation in . The first matrix contains term vectors describing the relative weights that terms e.g. classes or packages that contain API calls found in applications have for different dimensions. The second matrix contains scaling factors and the third matrix contains application vectors describing the relative weights that applications have for different dimensions. Each column in the third matrix is a vector whose elements specify coordinates for a given application in the r dimensional space. Similarities between applications may be determined by computing the cosines between vector rows of the third matrix . One of ordinary skill will understand that other methods of calculating and expressing the angular similarity between the vector rows may also be used to determine the similarities between applications.

As mentioned above r may be experimentally chosen but an effective number for r is 300. Increasing r will result in finding more similar applications requiring less semantic similarities to determine that an application is similar while reducing r will result in fewer similar applications requiring more semantic similarities to determine that an application is similar . Therefore while r may theoretically be any number the user will likely find better results in choosing an r in the 100 to 500 range. One factor that may influence the r chosen is the number of applications in the pool. Note that if the r value changes then the decomposition matrices may have to be recalculated.

Note that the concepts presented herein are not dependent on the use of LSI to correlate the API calls with applications. This correlation may occur by other data abstraction means. For example another means of finding a correlation is through a Vector Space Model VSM . In a VSM documents are represented as vectors of words and a similarity measure is computed as the cosine between these vectors. Typically a VSM is used to find syntagmatic associations such as word similarities between documents.

In an embodiment VSM techniques may be applied to determine similarity between two programs. First VSM may consider the source code and documentation content of the two programs. Second for each program VSM may filter everything but the package and class API calls providing a semantic representation of the program. In a traditional VSM all identifiers language keywords comments API calls are words without any semantics. Third VSM may represent these programs as vectors of the API calls. Fourth VSM may determine similarity by computing the cosine between these vectors. Filtering out words other than the API calls solves the problem where different programmers can use the same words to describe different requirements the synonymy problem and where different programmers can use different words to describe the same requirements the polysemy problem . Keeping only the API calls also solves the more general vocabulary problem which holds that no single word can be chosen to describe a programming concept in the best way. Because API calls from the JDK have precise meanings this modified VSM approach addresses the polysemy synonymy and vocabulary problems.

In some embodiments traditional VSM techniques may be further altered to reduce some of the bias as discussed above with regard to LSI. Because a majority of applications use API calls from collections and string manipulation classes finding two applications similar only because they share many of such API calls may be imprecise. In addition the sheer number of possible API calls suggests that many of these calls are likely to be shared by different programs that implement completely different requirements. Therefore in some embodiments the VSM may be modified to filter out the more common API calls. Common API calls may be found by a process similar to the Inverse Document Frequency calculation discussed above with respect to step of process .

In addition the JDK contains close to 115 000 API calls that are exported by a little more than 13 000 classes and interfaces that are contained in 721 packages. LSI reduces the dimensionality of this space while simultaneously revealing similarities between latent high level requirements. Because VSM does not itself reduce the dimensionality of the vector space though it was reduced through the filtering as discussed above it may be computationally infeasible to calculate similarities using VSM for some application archives.

In an embodiment Matrices P and C may be combined by matrix operator into the Similarity Matrix using the following formula P . S S where is the interpolation weight for each similarity matrix and matrices S and S are similarity matrices for C and P respectively. As described above these similarity matrices may be obtained by computing the cosine between the vector for each application a corresponding column in the matrix and vectors for all other applications. Thus S and S are each matrices of n n dimensions where n is the number of eligible Applications found in the Application Archive . Weights and may be determined independently of applications. Adjusting these weights allows for experimentation with how underlying structural and textual information in an application affects resulting similarity scores. In an embodiment 0.5 so that both class and package level similarity scores contribute equally to the Similarity Matrix. However class level and package level similarities may be different because applications are often more similar on the package level than on the class level reflecting the fact that there are fewer packages than classes in the JDK. Therefore there is a higher probability that two applications may have API calls that are located in the same package but not in the same class. Using this knowledge one of ordinary skill may experimentally adjust the weighting coefficients and as needed to achieve the best result for a given data set.

Turning back to and using the similarity matrix in an embodiment the system allows a user to search for an application based on an input and to use those results through an interface to find similar applications and display details on the interface as in .

Other embodiments of the disclosure will be apparent to those skilled in the art from consideration of the specification and practice of the embodiments disclosed herein. It is intended that the specification and examples be considered as exemplary only with a true scope and spirit of the embodiments being indicated by the following claims.

