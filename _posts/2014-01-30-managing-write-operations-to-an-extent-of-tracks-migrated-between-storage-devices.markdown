---

title: Managing write operations to an extent of tracks migrated between storage devices
abstract: Provided are a computer program product, system, and method for managing write operations to an extent of tracks migrated between storage device. An operation to migrate an extent of tracks from the second storage to the first storage is processed. A determination is made of the tracks in the extent having a write indicator indicating that the track was updated in the second storage since the previous time. The data for the determined tracks is copied from the second storage to free locations in the first storage. An extent object for the extent is updated to indicate the free locations to which the data for the tracks were copied as an active address for the track.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09218141&OS=09218141&RS=09218141
owner: INTERNATIONAL BUSINESS MACHINES CORPORATION
number: 09218141
owner_city: Armonk
owner_country: US
publication_date: 20140130
---
This application is a continuation of U.S. patent application Ser. No. 13 455 433 filed Apr. 25 2012 which issued as U.S. Pat. No. 8 656 122 on Feb. 18 2014 which is a continuation of U.S. patent application Ser. No. 12 784 427 filed May 20 2010 which issued as U.S. Pat. No. 8 380 949 on Feb. 19 2013 which patent applications are incorporated herein by reference in their entirety.

The present invention relates to a method system and computer program product for managing write operations to an extent of tracks migrated between storage devices.

In a hierarchical storage environment extents of tracks may be migrated between different tiers of storage devices such as hard disk drives solid state storage devices etc. depending on the characteristics of the storage devices and the frequency of access and priority of data. For instance more frequently accessed extents and or higher priority extents may be migrated to a faster access tier from a slower access tier and less frequently accessed extents and or lower priority extents may be migrated to a faster access tier. When migrating extents all the data from the extent may be copied over from one storage device to another.

There is a need in the art for improved techniques for migrating extents of tracks between storage devices.

Provided are a computer program product system and method for managing write operations to an extent of tracks migrated between storage device. An operation is processed to migrate an extent of tracks from the second storage to the first storage. A determination is made as to whether an extent object exists for the extent to migrate. The extent object exists if the extent was previously migrated from the first storage to the second storage at a previous time. The extent object includes for each track a write indicator indicating whether the track was updated in the second storage since the previous time when the extent was previously migrated to the second storage. In response to determining that the extent object exists a determination is made of the tracks in the extent having the write indicator indicating that the track was updated in the second storage since the previous time. The data for the determined tracks is copied from the second storage to free locations in the first storage. For each determined track the entry for the determined track in the extent object is updated to indicate the free location to which the data for the track was copied as an active address for the track.

The server may communicate with the first and second storages over a network via separate cables through a storage interface in a loop architecture etc. The first and second storages may comprise different types of storage devices such as a solid state storage device SSD comprised of solid state electronics such as a EEPROM Electrically Erasable Programmable Read Only Memory flash memory flash disk Random Access Memory RAM drive storage class memory SCM etc. magnetic storage disk optical disk tape etc. The memory may comprise one or more volatile or non volatile memory devices. The extent migration code may alternatively be implemented as application code external to the operating system or may be implemented with hardware logic such as an Application Specific Integrated Circuit ASIC or as a programmable processor executing code in a computer readable storage medium.

In one embodiment the first and second storages may comprise storage tiers in a hierarchical arrangement of storage devices where tiers define storage based on characteristics such as speed of their Input Output I O access profile redundancy etc. For instance the first storage may comprise a high speed storage such as an SSD or RAM drive and the second storage may comprise a slower access storage such as a hard disk drive or tape medium. The operating system may call the extent migration code to migrate extents that are not frequently accessed and or having lower priority from the first storage to the second storage and migrate more frequently accessed and or higher priority extents of tracks from the second storage to the first storage employing hierarchical management storage techniques known in the art. Data characteristics other than or in addition to the frequency of data access and priority of the data may be used to determine whether to migrate extents between higher and lower tier storage devices in the storage hierarchy.

In certain embodiments the extent object identifies tracks that are stored contiguously in the second storage which is advantageous in embodiments where the second storage comprises a storage device that has improved read write access for tracks stored contiguously in the media such as a hard disk drive and a tape drive. However the data for the tracks in the extent may not be contiguously stored in the first storage which may comprise a storage device that does not experience improved access for contiguously stored tracks such as the case with a solid state storage device SSD or Random Access Memory RAM drive.

The extent object includes entries for each track managed in one extent. Each track may comprise a same size single unit of data. The server may maintain multiple extent objects for each separate extent the server manages in the first and second storages. Further there may be additional storage devices such that the server may manage the migration of an extent of tracks among more than two storages where the different storages may have different I O access profiles.

In certain embodiments data updates may be written to a new free location in the first storage . In such case the extent entry for the track would maintain a previous version address . . . for each previous version a . . . n of the track stored in the first storage and previous version checksum . . . calculated from the previous version of the track. The order of the previous version addresses . . . in the extent table may indicate the age of the previous versions where the newest previous version address is the first and the oldest is the last . The server may limit the number of versions of data maintained in the first storage based on various factors such as available space predefined number of versions limit predefined space available to store previous versions etc.

In embodiments where the first storage comprises an SSD newly written data is written to a new physical location in the first storage as part of a process called wear leveling to distribute writes across the storage device when updating a frequently accessed logical address which prolongs the life of a solid state storage device. Continually writing to the same physical location of a solid state device can wear out the storage blocks in the solid state storage device.

If at block an extent object already exists for the extent being promoted then the extent was previously migrated from the first storage to the second storage and a loop is performed at blocks through for each track in the extent to migrate or promote from the second storage to the first storage . If at block the modify indicator for the track being considered indicates that the track was not updated while on the second storage then no action is performed on the track and the data is not copied over because the data has not changed. If at block the modify indicator for the track indicates the track was modified then the data for the track is copied at block from the second storage to a free location in the first storage . A new previous version address for the track is set to the current active address making the current data for the track a previous version and a new previous version checksum for the track is set to the current active checksum . Then the active address is set at block to the address of the free location to which the data was copied and the active checksum is set at block to a checksum value calculated from the data copied to the free location. The previous version pairs previous version addresses . . . and previous version checksums . . . are then reordered at block so the previous version information is ordered by the age or version number of the previous version.

In one embodiment where the extent object comprises an extent table to perform the reorder operation of block and make the current active data and checksum a previous version the extent migration code may shift the columns for the current previous versions . . . and . . . to the right two columns to overwrite and occupy columns for the previous versions 2 . . . n 1 and then copy the current active address and the current active checksum to a new most current previous version address and . In this way the current version address and checksum is made the most recent previous version to make room in the active fields and for the updated data copied to the free location. In alternative embodiments the ordering may be indicated by pointers or other information indicating an ordering of the previous versions.

With the operations of only tracks that have changed in the second storage since the extent was migrated or demoted from the first storage to the second storage are copied over to the first storage when migrating or promoting the extent from the second storage to the first storage . In embodiments where the first storage comprises an SSD this described operations provide for wear leveling because new data is written to a new location and unnecessary writes to the first storage are avoided because data that has not been modified in the second storage since the previous migration are not copied to the first storage .

In embodiments where the extent object comprises an extent table after creating the new previous version address and previous version checksum to perform the reorder operation of block the operating system may shift all the current previous version addresses . . . and checksums . . . two columns to the right in the table to overwrite the column data and make them the previous version addresses . . . and checksums . . . and then the created new previous version address and checksum become previous version address and checksum . In alternative embodiments the ordering may be indicated by pointers or other information indicating an ordering of the previous versions.

If at block the temporary checksum matches a determined one of the previous version checksums . . . . then the operating system buffers at block the determined previous address and the previous checksum for the matching previous checksum. The operating system sets at block a new previous version address and new previous version checksum to the values for the current active address and the active checksum to make the current active address and checksum the most current previous version. After performing block the operating system then sets at block the active address and the active checksum to the buffered previous version address and the previous version checksum respectively. In embodiments where the extent object comprises an extent table after making one previous version address e.g. and previous version checksum e.g. the current active versions and at blocks the operating system may then shift all columns of previous version addresses . . . and previous version checksums . . . following the matching buffered previous version address and checksum to the left two columns in the table to overwrite the columns which the matching buffered previous version address and checksum copied to the active fields and occupied.

With the described embodiments of the operating system tries to use the current active address and or one previous version address . . . and checksum . . . for the new active address and checksum to avoid having to write the data to the first storage . In this way the operating system is reusing the data already present in the first storage for the new write data. In embodiments where the first storage comprises an SSD using the active or previous version data for the write to avoid writing avoids wear and prolongs the life of the SSD.

If at block the temporary checksum does not match the active checksum then the operating system determines at block whether the temporary checksum matches one of the previous version checksums . . . . There may be zero or more previous version addresses and checksums. If at block there is a match then the operating system performs operations to use a track for a previous version at one of the previous version addresses . . . because the track for a determined previous version in the first storage matches the data to write to the track in the second storage . The operating system buffers at block the determined previous version address e.g. and the previous version checksum e.g. for the matching previous version checksum . The operating system sets at block a new previous version address and new previous version checksum to the values for the current active address and the active checksum . After performing block the operating system sets at block the active address and the active checksum to the buffered previous version address and the previous version checksum respectively. The operating system clears at block the modify indicator to indicate the track is unmodified because the first storage has the data modified at the second storage . Control then proceed to block to block to complete the write to the second storage .

In embodiments where the extent object comprises an extent table after making one previous version address e.g. and previous version checksum e.g. the current active versions and at blocks the operating system may then shift all columns of previous version addresses and previous version checksums following the matching buffered previous version address and checksum to the left two columns in the table to overwrite the columns which the matching buffered previous version address and checksum occupied.

If at block the temporary checksum does not match one previous version checksum then the modify indicator is set at block to indicate that the data has been modified in the second storage and control proceeds to block to complete the write to the second storage . Setting the modify indicator indicates that the first storage may not have the data written to the second storage . In such case the data in the first storage at the active address is not active data because the data for the track has since been modified in the second storage and the track data at the active address may be for a most recent previous version. Thus when the modify indicator is set the active address and active checksum information may not be for actual active data for the track.

With the described embodiments of the operating system tries to use the current active address and or one previous version address . . . and checksum . . . for the new active address and active checksum in the first storage if the preexisting data for the track in the first storage matches the data to write to the second storage . By updating the extent object to reflect that the first storage has the data written to the second storage the first storage does not have to subsequently be updated with the write data to the track in the second storage when migrating the extent having the modified track from the second storage back to the first storage because the modify indicator is cleared. In embodiments where the first storage comprises an SSD using the active or previous version of the track in the first storage for the write to the second storage avoids having to write to the first storage during a later migration from the second storage to the first storage . Avoiding writes to the first storage reduces wear and prolongs the life of the SSD.

In the embodiments of in the event that there is no extent object maintained for the track being written in the first or second storage the write may be allowed to proceed without performing any further action. Further if there are multiple tracks to write for a write operation then the operations of would be performed for each track to write.

Described embodiments provide techniques for reducing the number of writes to the first storage when migrating an extent from a second storage to the first storage when performing a write to an extent existing in the first storage and when performing a write to the second storage. In embodiments where the first storage comprises an SSD or other storage device whose storage life is reduced by continual updates to the same location the described embodiments reduce wear and prolong the life of the storage device.

The described operations may be implemented as a method apparatus or computer program product using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof. Accordingly aspects of the embodiments may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the embodiments may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

In certain embodiments the server of may be implemented as a cloud component part in a cloud computing environment. In the cloud computing environment the systems architecture of the hardware and software components involved in the delivery of cloud computing may comprise a plurality of cloud components communicating with each other over a network such as the Internet. For example in certain embodiments the server of may provide clients and other servers and software and or hardware components in the networked cloud with storage and data processing services. The server may provide reliable storage services and access to the storages and to meet quality of service requirements for customers in the cloud including clients requiring storage and other servers providing storage services to clients. The server may communicate with clients to provide storage services for the storages and through a web interface or other application programming interface.

The terms an embodiment embodiment embodiments the embodiment the embodiments one or more embodiments some embodiments and one embodiment mean one or more but not all embodiments of the present invention s unless expressly specified otherwise.

The terms including comprising having and variations thereof mean including but not limited to unless expressly specified otherwise.

The enumerated listing of items does not imply that any or all of the items are mutually exclusive unless expressly specified otherwise.

Devices that are in communication with each other need not be in continuous communication with each other unless expressly specified otherwise. In addition devices that are in communication with each other may communicate directly or indirectly through one or more intermediaries.

A description of an embodiment with several components in communication with each other does not imply that all such components are required. On the contrary a variety of optional components are described to illustrate the wide variety of possible embodiments of the present invention.

Further although process steps method steps algorithms or the like may be described in a sequential order such processes methods and algorithms may be configured to work in alternate orders. In other words any sequence or order of steps that may be described does not necessarily indicate a requirement that the steps be performed in that order. The steps of processes described herein may be performed in any order practical. Further some steps may be performed simultaneously.

When a single device or article is described herein it will be readily apparent that more than one device article whether or not they cooperate may be used in place of a single device article. Similarly where more than one device or article is described herein whether or not they cooperate it will be readily apparent that a single device article may be used in place of the more than one device or article or a different number of devices articles may be used instead of the shown number of devices or programs. The functionality and or the features of a device may be alternatively embodied by one or more other devices which are not explicitly described as having such functionality features. Thus other embodiments of the present invention need not include the device itself.

The illustrated operations of show certain events occurring in a certain order. In alternative embodiments certain operations may be performed in a different order modified or removed. Moreover steps may be added to the above described logic and still conform to the described embodiments. Further operations described herein may occur sequentially or certain operations may be processed in parallel. Yet further operations may be performed by a single processing unit or by distributed processing units.

The foregoing description of various embodiments of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description but rather by the claims appended hereto. The above specification examples and data provide a complete description of the manufacture and use of the composition of the invention. Since many embodiments of the invention can be made without departing from the spirit and scope of the invention the invention resides in the claims hereinafter appended.

