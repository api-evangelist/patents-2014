---

title: Method for transporting relational data
abstract: A method for transporting relational data from one relational database to another such database. The data transported may be a subset of data in the entire database and the relations between the root of this data and other data entities are preserved in a way allowing their reconstruction in the target database. This preservation, itself further directed through configuration, is able to recreate new data identifiers without collision, yet also without requiring maintenance of the original identifiers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09460174&OS=09460174&RS=09460174
owner: IFWizard Corporation
number: 09460174
owner_city: Coeur d'Alene
owner_country: US
publication_date: 20140520
---
 2014 IFWIZARD CORPORTION. A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever. 37 CFR 1.71 d .

Database management systems DBMS provide centralized structured information services to client programs. The data within a DBMS is defined stored and retrieved according to certain basic information storage patterns known as data models. For example a DBMS using a hierarchal data model would relate data entities within it through a tree like structure with each entity having a single parent entity or no parent for the root entity and any number of child entities. This hierarchal data model is used in the popular XML data format and for XML databases.

The most common DBMS data model for sophisticated computerized information is the relational data model which is used by relational database management system RDBMS . Relational data can be understood as a set of two dimensional data tables with rows representing data entities and columns representing entity properties. Rows typically have a key column that identifies each row or entity uniquely. These keys are most often a positive integer incremented with each subsequently inserted row. Because table rows may be identified solely through their keys a row in table A can relate to a row in table B by including a column with a key from table B.

By using these row identifiers for relations between tables all data for a row other than the row identifier itself does not need to be duplicated and may be stored only in its canonical table. For example a table of customers may contain street address information. When referring to this customer such as in a list of sales orders only the customer row identifier is required as described before the customer address does not need to be duplicated within the customer portion of the sales order. One of the major advantages of these normalized intra table relations is that the customer address may be modified by only changing its information in the customer table as there are no duplicate inclusions of the customer address i.e. in the sales orders to maintain.

Row identifiers are typically automatically generated by the RDBMS as a simple incrementing positive number such as 1 2 3 and so on. As these identifier sequence generators are distinct from the tables themselves if two databases share the same types of tables and columns the row identifiers may be different between the two databases despite having identical content. These differences can arise from the order number and deletion history of the table rows. For example if three customers were added in opposite order in two databases likely zero but no more than one row would have identical row identifiers across the databases.

While an RDBMS provides benefits of reduced storage size improved data consistency and for some operations higher query performance its data model is extremely dependent upon correct and consistent use of the row identifier keys. Since data duplication is reduced or even eliminated if the correct row is not related through the row identifier there is no recourse to recover the correct row by examination of included duplicate data. For example a sales order would contain only the customer row identifier and not additional customer columns such as their name or street address which would allow cross referencing. Furthermore mistaken row identifiers have a high likelihood of not merely referring to missing rows in another table but may relate extant but incorrect rows.

A DBMS typically runs on a single server in a single location although more esoteric varieties are sometimes transparently spread among locations. As a RDBMS contains two principle parts 1 the data tables describing and defining the data structure and 2 the data rows which conform to the model so described a server may likewise be seen as both the defining container and the content so contained. While interaction between completely distinct databases i.e. both the tables and the data are distinct is possible there are a number of situations where multiple RDBMS servers are operational with the same table definitions though the data they hold may be the same or different. In these same definition scenarios there may be a need to transport data between the database servers.

One such scenario is representing a multitude of software installations through a multitude of database servers. For example stores in multiple locations may all have the same sales tracking software installed but each have their own database server to track their local sales data. In this case one may want to move partial data such as a customer and their related records such as order history from one installation to the server of another installation. Another scenario involves duplicating the same data in several different database servers perhaps located in different regions to allow continued availability and security. A third scenario is the use of data within one database server as the template for new data insertion in another server. A variation of this scenario is the use of such a template within the original database server.

From the aforementioned particulars about relational databases there emerge four major difficulties in accomplishing the above transportation of tabularly identical data between and within an RDBMS 

Because of these difficulties transportation between relational databases is typically restricted to three scenarios all limited in practice. These three limited scenarios are 

As these scenarios all demonstrate considerable restrictions of specificity application or scope there presently exists no general solution for transportation of relational data in particular for partial interrelated subsets of a RDBMS.

The following is a summary of the present disclosure in order to provide a basic understanding of some features and context. This summary is not intended to identify key critical elements of the invention or to delineate the scope of the invention. Its sole purpose is to present some concepts of the present disclosure in a simplified form as a prelude to the more detailed description that is presented later.

Accordingly it is an object of the present disclosure to provide a general method for transporting data within a relational database. The data to be transported may be any row within any table that has an arbitrary row identifier. All other data dependent on the transported row as well as all other data the transported row depends upon will be automatically determined and transported along with the given row. The method further permits optional specification of tables to be ignored in the transportation allowing for non essential or otherwise functionally unneeded data to be omitted.

It is also an object of the present invention to provide an intermediate format for the transported data that allows for complete reconstruction of the transported data including all attached relations. This transport format supports the secure masking of the original row identifiers through consistent substitution of a random key cipher. These temporary keys are then replaced during the subsequent reconstruction of importing.

In accordance with the present disclosure the intermediate format is reconstructed in a sequence and way that preserves the original internal relational identity while grafting the data onto a new database and stock. During this importing process the method allows specific substitution of row column values allowing for complex integration of the new data without explicit analysis and alteration of the reconstruction.

The invention is intended to be implemented in software i.e. in one of more computer programs routines functions or the like. Thus it may best be utilized on a machine such as a computer or other device that has at least one processor and access to memory as further described later. Accordingly in this description we will sometimes use terms like component subsystem routine or the like each of which preferably would be implemented in software.

Additional aspects and advantages of this invention will be apparent from the following detailed description of preferred embodiments which proceeds with reference to the accompanying drawings.

The following detailed description refers to the accompanying drawings. Wherever possible the same reference numbers are used in the drawings and the following description to refer to the same or similar elements. For clarity and simplicity not all characteristics of practical embodiments are described in the specification. However it is appreciated that many embodiment specific decisions have to be made in developing the practical embodiments in order to achieve a particular object of the developer. While embodiments of the invention may be described a person skilled in the relevant art would recognize that modifications adaptations and other implementations are possible without parting from the spirit and scope of the invention. For example substitutions additions or modifications may be made to the elements illustrated in the drawings and the methods described herein may be modified by substituting reordering or adding stages to the disclosed methods. Accordingly the following detailed description does not limit the invention. Instead proper scope of the invention is defined by the appended claim.

Using the internal export representation generated by the export subsystem the transport input output subsystem can provide the source client with a data file representing the transported data. This data file is later provided by the target client via the import interface to the transport input output subsystem for translation into an internal representation.

The target client has access to the import interface specifying the necessary parameters for reconstruction in the target database and a data file produced previously by the transport input output subsystem . The target database connection establishes the connection to the target database and the import subsystem uses an internal representation of the data file created through the transport input output subsystem to reconstructively import the data into the target database returning graft point information to the target client .

The central loop of the export subsystem begins by exporting the initial row specified in the parameters . If the export process determines more rows require exporting the row export is performed for the additional rows until no more rows require exporting. When all rows have been exported they are arranged into a list in a sequence that will allow them to be reconstructed progressively during import.

The process is finished when this row list is converted into the external storage format . This conversion through the transport input output subsystem allows the data file to be provided to the source client .

The columnar data of the row is fetched from the source database . If the row identifier is found to not exist export of the row is skipped . Otherwise the columnar data is processed into an internal representation prepared for the transport input output subsystem .

The relations to and from the given row are determined and each row referenced by the exporting row is examined . If the referenced row is from an ignored table a dummy value is stored into the internal representation for later detection during import. Otherwise the referenced row is exported and its resulting encoded identifier or existing encoded identifier if it has already been exported is stored into the internal representation. If more referenced rows exist these are also examined .

When the referenced row loop is complete the internal representation is then stored into the collection of existing encoded data and encoded identifiers. The rows which are referencing the exporting row are then examined with each such row being exported until no more referencing rows need exporting. The process finishes returning the encoded identifier which has use during the internal exporting of referenced rows.

Likewise those columns which reference the exporting table are retrieved from the source database . Each column is examined skipped if it is of the same table as the exporting row and otherwise included . This is repeated until no more columns remain and the process if finished .

Upon receiving the table name and row identifier of the row to be encoded the table name encoding key and row identifier are combined together. The resulting text string is used as input for a message digest algorithm such as MD5 creating a binary message digest . This digest is then converted into an ASCII text format using a binary to text encoder such as Base64 thereby completing the key generation.

This process produces keys that are consistently the same with the same table name and row identifier and thereby allowing for functional comparison. But upon disposal of the encoding key the original identifiers are very difficult to determine even with a large pool of contemporaneously exported keys.

If the queue is not empty the table is drawn from the queue and all tables referenced by it are added to a new list . If the list of tables contains any tables that are not presently in the queue said tables are removed from the list. If the resulting list is not empty the list test proceeds for the next table within the queue. However if the list is empty the table from the queue is removed from the queue and its rows are prepended to the result list.

The first such collection is that of data column types mapping a table column name to a descriptive column type such as an integer . The second collection is the data columns which map table column names to raw data such as an integer value itself. The third and final collection is the reference columns containing table column names mapped to encoded row identifiers generated as through .

These data rows are grouped together per their database table in simple named lists known as data tables . The reconstructable sequences of these data tables arranged in are the basis for the transportable data files used in the transport input output subsystem . In the exemplary embodiment these data tables are serialized to binary XML and compressed using LZ77 and Huffman coding. These steps are reversed prior to importation to regenerate the arranged data tables .

Each row column in examined and tested for whether the column is a data column the raw value is built into the SQL operation according to the column type . If the column is instead a reference column the particular column is checked for matching a previously provided replacement identifier building into the SQL the replacement identifier if found. Otherwise the encoded identifier is matched decoded to find the row identifier newly generated by the target database and this new identifier is built into the SQL command.

After preparing the SQL for the column the process is repeated if more columns remain. After the SQL for all columns have been prepared the SQL statement is executed against the target database and the resulting newly generated row identifier is recorded for later use as their relation is indicated . The database row generation is repeated for all rows in the table continuing on to each sequential table in order to reconstruct the data in the source database with an entirely new set of row identifiers. The process finishes by returning the new row identifier for the root table provided in .

As explained above the present invention preferably is implemented or embodied in computer software also known as a computer program or code we use these terms interchangeably . Programs or code are most useful when stored in a digital memory that can be read by a digital processor. We use the term computer readable storage medium or alternatively machine readable storage medium or the like to include all of the foregoing types of memory as well as new technologies that may arise in the future as long as they are capable of storing digital information in the nature of a computer program or other data at least temporarily in such a manner that the stored information can be read by an appropriate digital processor. By the term computer readable we do not intend to limit the phrase to the historical usage of computer to imply a complete mainframe mini computer desktop or even laptop computer. Rather we use the term to mean that the storage medium is readable by a digital processor or any digital computing system. Such media may be any available media that is locally and or remotely accessible by a computer or processor and it includes both volatile and non volatile media removable and non removable media. In some cases for example a simple text document or flat file a digital computing system may be able to read the file only in the sense of moving it copying it deleting it emailing it scanning it for viruses etc. In other words the file may not be executable on that particular computing system although it may be executable on a different processor or computing system or platform.

Where a program has been stored in a computer readable storage medium we may refer to that storage medium as a computer program product. For example a portable digital storage medium may be used as a convenient means to store and transport deliver buy sell license a computer program. This was often done in the past for retail point of sale delivery of packaged shrink wrapped programs. Examples of such storage media include without limitation CD ROM and the like. Such a CD ROM containing a stored computer program is an example of a computer program product.

It will be obvious to those having skill in the art that many changes may be made to the details of the above described embodiments without departing from the underlying principles of the invention. The scope of the present invention should therefore be determined only by the following claims.

