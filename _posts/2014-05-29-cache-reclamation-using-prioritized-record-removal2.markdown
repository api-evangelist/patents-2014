---

title: Cache reclamation using prioritized record removal
abstract: In an example implementation, a method includes receiving an indication to reclaim memory from a cache, the cache including a plurality of data buckets each configured to store one or more records and corresponding access bits. The method also includes selecting a data bucket from the cache, and processing the selected data bucket. Processing the selected data bucket includes determining access bits of the selected data bucket that are clear, and expunging data records corresponding to those access bits from the cache. Processing the selected data bucket also includes determining access bits of the selected data bucket that are set and do not correspond to records relevant to outstanding requests by a process utilizing the cache, and clearing those access bits. The method also includes repeating selecting and processing data buckets until a stop criterion is satisfied.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09558122&OS=09558122&RS=09558122
owner: Apple Inc.
number: 09558122
owner_city: Cupertino
owner_country: US
publication_date: 20140529
---
In computing a cache is a component that stores data so that future requests for that data can be served faster. The data that is stored within a cache might be for example values that have been computed earlier records that have been previously retrieved or duplicates of original information that are stored elsewhere e.g. on another component or system . If requested data is contained in the cache the request can be served by reading the cache which might be comparatively faster than re computing the requested data or re retrieving the requested data from its original location. Due to system constraints e.g. memory or storage limitations a cache often can only store a finite amount of data. In order to make room for additional data portions of the cache can be reclaimed for example by expunging unused or low priority data from the cache.

Systems methods and computer program products for reclaiming memory from a cache. During use a cache accumulates data e.g. data records in anticipation for future retrieval. However in some implementations the cache might be suited to only store a finite amount of data. In order to make room for addition data portions of the cache can be reclaimed for future use for example by expunging unused or low priority data from the cache. In some implementations an access bit associated with each data record can be used to identify records that have been recently accessed and are accordingly of relatively high priority. Access bits can be set and cleared in a manner that reflects each record s importance and can be used to prioritize the removal of data that is relatively unimportant over the removal of data that is relatively more important.

In general in an aspect a method includes receiving by one or more processors an indication to reclaim memory from a cache the cache including a plurality of data buckets each configured to store one or more records and corresponding access bits. The method also includes selecting by one or more processors a data bucket from the cache and processing by one or more processors the selected data bucket. Processing the selected data bucket includes determining access bits of the selected data bucket that are clear and expunging data records corresponding to those access bits from the cache. Processing the selected data bucket also includes determining access bits of the selected data bucket that are set and do not correspond to records relevant to outstanding requests by a process utilizing the cache and clearing those access bits. The method also includes repeating selecting and processing data buckets until a stop criterion is satisfied.

In some implementations processing the selected data bucket further includes determining access bits of the selected data bucket that are set and clearing those access bits based on an indication of a memory constraint.

In some implementations the cache is a domain name system cache or a multicast domain name system cache.

In some implementations the cache includes a hash table and each bucket of the cache corresponds to an output of a hash function. In some cases each bucket includes a linked list.

In some implementations selecting a data bucket from the cache includes selecting a random data bucket from the cache where repeating selecting and processing data buckets until a stop criterion is satisfied includes repeating selecting and processing random data buckets until a stop criterion is satisfied. In some cases selecting a random data bucket from the cache includes selecting a random data bucket based on an output of a pseudo random number generator. In some implementations the output of the pseudo random number generator corresponds to a substantially uniform probability distribution.

In some implementations each record includes a resource name and a resource location. The resource location can be an internet protocol address.

In some implementations the stop criterion corresponds to a desired number of records stored in the cache. In some cases the stop criterion corresponds to a desired amount of memory that is allocated to the cache. In some cases the memory constraint corresponds to a desired number of records stored in the cache. In some implementations the memory constraint corresponds to a desired amount of memory that is allocated to the cache.

Other implementations are directed to systems devices and non transitory computer readable storage mediums.

Particular implementations disclosed herein provide one or more of the advantages. For example in some implementations memory can be reclaimed from a cache in a manner that prioritizes the removal of certain data records over others such that data records that are of relatively higher importance are more likely to be preserved. For example memory can be reclaimed by prioritizing the removal of data records that have not been recently accessed over the removal of data records that have been recently accessed. Further in some implementations memory from a cache can be reclaimed differently based on various criteria or constraints such that data records are preserved or removed based on the immediate or anticipated needs of a particular system.

The details of the disclosed implementations are set forth in the accompanying drawings and the description below. Other features objects and advantages are apparent from the description drawings and claims.

In some implementations in order for one device e.g. the device to communicate specifically with a target device e.g. the device information regarding the location of the target device must be known. Location information can include among other things a network address that identifies a particular node or network interface of a network. Examples of location information include internet protocol IP addresses Internetwork Packet Exchange IPX addresses network layer addresses media access control MAC addresses and host addresses.

A device can determine location information corresponding to the target computing device in a variety of ways. As an example a device can retrieve information e.g. location information using a multicast domain name system mDNS service e.g. Bonjour . As shown in in an example implementation a device can attempt to retrieve location information concerning a target device by broadcasting a multicast query message to the network requesting the location of the device . The multicast query message is transmitted non specifically to the other devices that are connected to the network as indicated by the arrows such that each device receives a copy of the query message.

As shown in in response the target device broadcasts a multicast response message to the network . The response message includes identifying information and location information regarding the target device e.g. the name and network address of the computing device . In a similar manner as the multicast query message the multicast response message is transmitted non specifically to the other computing devices that are connected to network such that each device receives a copy of the response message as indicated by the arrows . Upon receipt of the response message each device saves the received information into a cache located on each computing device. In this manner each device saves a local copy of the location information pertaining to the computing device

Referring to the device transmits data specifically to the device by referencing the location information regarding the device stored in the cache . Though the devices did not specifically request location information from the device each device also has this location information saved to their respective local caches . Thus should the devices also wish to communicate specifically with the device the pertinent location information can be retrieved from the caches instead of re requesting the location information directly from the device . By locally caching this information each of the devices can fulfill subsequent communication requests more quickly and the overall network traffic on the network can be reduced.

The devices can be any computing devices that process transmit and or receive data. As examples the devices can be personal computers mobile devices e.g. cellular telephones tablet computers PDAs smartphones and so forth client computers server computers or other electronic devices capable of transmitting or receiving data.

The network can be any data communications network that provides data interconnectivity between computing devices. As an example the network can be a local area network LAN a Wi Fi network a wide area network WAN the Internet a cellular telephone network a Bluetooth network or any other wired or wireless data communications network.

Although the above example shows data as being cached on each device of the network data need not be cached in this manner. For example in some implementations only a subset of the devices of the network might cache resource information. Further while the above example shows how resource information might be requested and fulfilled using mDNS service this is only one example implementation. Accordingly in some cases resource information might be requested and fulfilled using other techniques. As an example in some implementations one or more devices might maintain a cache of resource information pertaining to the other devices of the network and might transmit resource information to other devices in response to received requests. As an example resource information might be maintained requested and transmitted using a traditional domain name system DNS service in which one or more centralized devices e.g. a server computer maintain a cache of resource information and serve portions of the resource information upon request.

Caches can be implemented in a variety of ways. As an example referring to a cache might include a hashing module and a hash table . The hash table includes several buckets for storing data. When a resource record is input into the cache the cache identifies an appropriate bucket of the hash table in which to save data from the resource record and saves the data into the appropriate bucket for future retrieval.

A resource record might contain information pertaining to the identity and location of a device on a network. For instance in example system a resource record can include location information corresponding to a multicast response messages . A resource record might include one or more data fields for storing different types of data. For example the resource record might include a data field that contains information regarding the identity of a particular resource e.g. the name of a particular device and a data field that contains information regarding the location to that resource e.g. the network address of that device . In some implementations a resource record might also include other fields of information for example a list of services that are available on that particular resource.

Upon receipt of the resource record the cache identifies a suitable location in the hash table in which to store data from the resource record . As an example the cache might include a hash module that produces a mathematical hash value based on information from the resource record. As shown in a hash module can calculate a hash value based on the name of the resource e.g. the data contained within data field . The hash module need not use all of the data contained within a data field. As an example the hash module might produce a hash value based on a portion of the data e.g. the first N characters of the data field . The hash module can produce a hash value using any number of mathematical hashing techniques for example by using a hashing function. Example hashing functions include cyclic redundancy check CRC functions checksum functions non cryptographic hash functions e.g. XOR hashing and cryptographic hash functions e.g. MD5 or SHA 512 .

The produced hash value acts as a key and identifies a particular bucket of the hash table. For example in some implementations a portion of the hash value e.g. the final N digits of the hash value might correspond to a unique bucket within the hash table . In some implementations a module e.g. processing module that performs a modulo operation can be used to convert the hash value into a corresponding bucket identification value. In the example shown in by inputting data from the resource name field into the hashing module the module outputs a key that identifies the bucket of the hash table .

As shown in the data from the resource record is then stored in the identified bucket. As an example data from the resource name field and the resource location field can be stored in bucket of the hash table for future retrieval. In addition to information from the resource record the cache can also store additional data corresponding to each stored record. As an example the cache can also store one or more access bits associated with each record. These access bits can indicate if a corresponding record has been recently modified and or accessed from the cache. In another example the cache can also store information regarding the intended lifespan of each stored record e.g. a time to live value indicating the length of time for which the stored record is valid . As another example the cache can store information regarding services offered by each resource e.g. printers scanners media streaming modules other peripherals or services and so forth . The cache can store other additional data depending on the implementation.

In some implementations the hashing module might produce hash collisions. That is the hashing module might output identical hash values for each of multiple unique inputs. In these implementations two unique resource records might result in the same key value and as a result could be saved in the same bucket of the hash table. To account for hash collisions in some implementations each bucket might include a data structure e.g. a linked list that can store information from more than one record at a time. As an example as shown in the bucket of the hash table might include a linked list . The listed list can store data from each of multiple resource records in a corresponding node. Each node can also store other information associated with each record e.g. access bits or TTL values . In this manner data from unique resource records can be stored as unique entries within the same bucket.

Data can also be retrieved from the cache using the hashing module . For example as shown in a request might include the name of a desired resource e.g. a data field and a request for the resource s location e.g. a data field . To retrieve the requested data from the cache the hashing module can determine a key by calculating a hash value based on the name of the desired resource e.g. using all or part of the information from data field . In a manner similar as above hashing module calculates a key value that identifies a bucket of the hash table e.g. the bucket . Referring to data stored in the identified bucket is then retrieved to fulfill the request. In implementations where buckets contain data structures for storing information from more than one record at a time e.g. a linked list each record of a bucket can be parsed to identify the requested record. As an example in some implementations if bucket contains a linked list having multiple nodes each node containing a different record the requested record can be identified by parsing the resource names contained in each node to find a match. The matching record can then be retrieved to fulfill the request.

During use the cache accumulates data in anticipation for future retrieval. However in some implementations the cache might be suited to only store a finite amount of data. As an example the cache might be constrained by a limited amount of available memory or storage space in which to store data. These constraints might be based on limitations of the device implementing cache e.g. based on finite available resources available to a device that implements cache limitations that have been designed into cache e.g. designed restrictions that define the number of records that can be stored by the cache or the storage space or memory that can be utilized by the cache or both. In these implementations in order to make room for additional data portions of the cache can be reclaimed for future use for example by expunging unused or low priority data from the cache.

Unused or low priority data can be identified in a variety of ways. For instance the access bit of each record can be used to identify records that have been recently accessed and are accordingly of relatively high priority. Access bits can be set and cleared in a manner that reflects each record s importance. As an example when a particular data record is initially written into a cache the cache might store a cleared access bit e.g. a value of 0 in association with the stored record. When the record is accessed e.g. when the record is subsequently retrieved in order to fulfill a request or when the record is retrieved for other purposes for instance to test if the record exists in the cache the access bit might be set e.g. changed to a value of 1 indicating that the record had been requested in the past and thus is of relatively higher priority. Accordingly when an indication is received to reclaim portions of the cache expunging of records with cleared access bits indicating that the records have not been previously accessed might be prioritized over expunging records with set access bits indicating that the records have been previously accessed . In some implementations access bits can be periodically cleared e.g. according to particular time criteria intermittently cleared e.g. according to particular system parameter criteria or user initiated commands or cleared according to some other criteria e.g. randomly . In this manner access bits can indicate if the records have been recently accessed e.g. since the last time the access bits were cleared and can be used to assess the relative importance of each record.

An example process for reclaiming memory from a cache is shown in . The process can be used for example to reclaim memory from the caches of or the caches of and .

The process begins by receiving an indication to reclaim memory from a cache step . This indication can be received for example by the cache a device or system on which the cache is implemented or a device or system in communication with the cache. An indication can be for example an instruction or command sent from a device or system a component of a device or system or the cache itself to reclaim memory from the cache. In some implementations the indication to reclaim memory from the cache might be sent when certain criteria are met. As an example an indication to reclaim memory from the cache might be sent based on a determination that the cache has grown too large e.g. a determination that the cache contains too many records or consumes too much memory or storage space . As another example an indication to reclaim memory from the cache might be sent periodically e.g. according to particular time criteria such as after a particular time has elapsed since the last indication was sent . As another example an indication to reclaim memory from the cache might be sent in response to a user initiated command. As another example an indication to reclaim memory from the cache might be sent based on a determination that a device or system is under memory pressure e.g. when a device or system is running low on memory or when the amount of available memory on the device or system decreases below a particular threshold .

Upon receipt of the indication to clear memory from the cache a random bucket from the cache is selected step . As an example referring to cache of a bucket can be selected from among all of the buckets of the hash table . A bucket can be randomly selected using techniques for randomly selecting one element from among a set. As an example a bucket can be randomly selected using a random number generator RNG a computational or physical device designed to generate a sequence of numbers or symbols that lack any pattern i.e. appear random . An RNG need not be a true random number generator and can be for example a pseudo random number generator PRNG that generates a sequence of numbers that approximates the properties of random numbers. Example RNGs and PRNGs include Mersenne twister based PRNGs xorshift based PRNGs and RNGs that harvest entropy from natural sources e.g. based on observations of physical phenomena . The output of the RNG or PRNG can vary depending on the application. In some implementations the output of RNG or PRNG can be a substantially uniform distribution such that the output values are uniformly distributed within a particular range of values correspondingly in some implementations a bucket of the cache can be randomly selected such that each bucket of the cache has an approximately equal chance of being selected. In some implementations the output of the RNG or PRNG can have non uniform distributions e.g. a Gaussian distribution correspondingly in some implementations a bucket of the cache can be randomly selected where some buckets have a greater chance of being selected than others.

Once a bucket has been selected the status of the selected bucket s access bit is determined step . For example referring to the cache of the selected bucket is parsed and the status of the access bit stored within it is determined i.e. it is determined whether the access bit is set or clear .

If the access bit of the selected bucket is clear in response the access bit and its corresponding data record are expunged from the cache step . Expunging can include for example removing the access bit and the corresponding data record from the cache and making its consumed memory or storage space once again available for use. In some implementations expunging can include overwriting the access bit and corresponding data record e.g. with zeros or other information and making its consumed memory or storage space once again available for use. In some implementations expunging can include simply indicating that its consumed memory or storage space is once again available for use.

If the access bit of the selected bucket is set in response it is determined if the corresponding record is relevant to an outstanding request by one or more processes step . As an example a record might be considered relevant if there is an outstanding request for access to that record e.g. if there is an access request for the record that has not yet been fulfilled . As another example a record might be considered relevant if there is an outstanding request for information contained within that record. For instance if a record describes the identity of a device the location of the device and a service offered by the device the record might be relevant to a request for the identity and location of a device that provides that particular service. In some implementations this can be implemented by comparing the record against a list of outstanding requests. For example if the record contains data e.g. a resource name or service that substantially matches data on the list of outstanding requests then it is determined that the record is relevant to the outstanding request. In some implementations the relevance of a record can be determined by calling out the contents of the record e.g. using an appropriate function that requests information regarding the relevance of the data record and determining if the record is relevant to an outstanding request based on the result. As an example a call out request can include an indication of a particular data record as an input parameter and can output a relevance metric regarding that data record. In some implementations the result of calling out e.g. the outputted relevance metric can be binary information. For example the result might indicate if the record is either relevant or not relevant. In some implementations the result of calling out can provide more granular information. For example the result might indicate the relative relevance of the record e.g. provide a relevance score or other metric that defines the relative relevance of the record . In these implementations the cache might determine if a record is relevant or not relevant by determining if the returned relevance score or metric is greater than or less than a particular threshold value.

If it is determined that the record is relevant to an outstanding request the access bit is not cleared i.e. is maintained as set step .

If it is determined that the record is not relevant to any outstanding request the access bit is cleared step .

Upon competition of steps or it is determined if a particular stop criterion is met step . Stop criteria can include for example a requirement that a particular number of records be expunged a requirement that a particular amount of storage space or memory be reclaimed a requirement that a particular number of records be maintained on the cache a requirement that the number of records maintained on the cache does not exceed a particular amount or other criteria. If the stop criteria has been met e.g. indicating that a sufficient amount of the cache has been reclaimed process ends. If the stop criteria has not been met e.g. indicating that additional portions of the cache need to be reclaimed the process continues again with the selection of another random bucket stop . In this manner the reclamation process will continue selecting random buckets determining the status of access bits within the selected buckets expunging the contents of the selected buckets and or clearing access bits of the selected buckets until a satisfactory amount of the cache has been reclaimed.

Implementations of the process can also be used in cases where data from multiple records are stored in each bucket of the cache e.g. the cache of . In these implementations when a particular bucket is randomly selected each of the access bits and records of the selected bucket can be read and processed as described in the steps and . For example if a selected bucket has multiple records and corresponding access bits stored within it the process shown in the steps and can be carried out for each of the records and access bits of the bucket. That is each access bit is individually parsed and may be individually expunged along with its corresponding data record individually cleared or individually maintained. Accordingly in some implementations even if a selected bucket contains multiple records and access bits not all records contained within the bucket need to be unilaterally expunged nor do all of the access bits within the bucket need to be unilaterally cleared or unilaterally maintained.

In some implementations portions of the process can be modified to accommodate certain circumstances. For example in some implementations the steps and can be excluded such that if it is determined that an access bit is set step then the access bit is cleared step regardless if the corresponding record is relevant to an outstanding request. In some implementations the steps and can be excluded selectively. As an example in some cases the steps and can be excluded based on a constraint that requires a particular number of records to be free or a certain amount of storage or memory be available for use. If the constraint is met e.g. if a specified number of records are free or if a specified amount of storage or memory is available for use then the steps and might be undertaken. If the constraint is not met e.g. if the specified number of records are not free or if the specified amount of storage or memory is not available for use then the steps and might be excluded accordingly if it is determined than an access bit is set then the access bit is cleared regardless if the corresponding record is relevant to an outstanding request. In this manner access bits can be cleared or maintained according to different strategies depending on the current state of the system and the amount of resources available to the system.

As another example in some implementations process can be modified such that the determination of whether a record is relevant to an outstanding request e.g. as described in step can instead occur upon determining that an access bit is clear e.g. as described in step . For example after determining that an access bit is clear in response it determined if the corresponding record is relevant to an outstanding request. This can be performed for example by calling out the record as described above. Upon determining that the record is not relevant to an outstanding request the record and its corresponding access bit are expunged from the cache e.g. as described in step . Upon determining that the record is relevant to an outstanding request the record is preserved. In some implementations determining whether a record is relevant to an outstanding request can be performed upon determining that an access bit is clear upon determining that an access bit is set or both. As above in some implementations the step of determining whether a record is relevant to an outstanding request can be selectively excluded based on various criteria for example based a constraint that requires a particular number of records to be free or a certain amount of storage or memory be available for use.

As another example in some implementations process can be modified such instead of selecting random data buckets from the cache e.g. as described in step data buckets are selected sequentially from the cache. As an example data buckets can be arranged in a particular order and one particular data bucket e.g. the first data bucket can be selected for processing by steps and or . Upon completing these steps and upon determining that the stop criterion has not been met e.g. as described in step another data bucket can be selected sequentially from the cache e.g. the next data bucket in the order . In some implementations an indication of the last data bucket that was processed by process can be retained such that if process is subsequently performed again the next data bucket in the sequence can be recalled and selected for processing.

In some implementations the process can be used in conjunction with other cache reclamation techniques. For example in implementations where each stored record has an associated TTL value upon receiving an indication to reclaim memory the cache might first parse each record stored in the cache in order to find records that have expired i.e. records which have a lapsed TTL . If after this process a stop criterion has not been met e.g. an insufficient number of records were reclaimed that the process can continue reclaiming memory until the stop criterion a met.

Implementations of process can provide certain benefits. For example in some implementations memory can be reclaimed from a cache in a manner that prioritizes the removal of certain data records over others such that data records that are of relatively higher importance are more likely to be preserved. For example memory can be reclaimed by prioritizing the removal of data records that have not been recently accessed over the removal of data records that have been recently accessed. Further in some implementations memory from a cache can be reclaimed differently based on various stop criteria or memory constraints such that data records are preserved or removed based on the immediate or anticipated needs of a particular system. Further still in some implementations by randomly selecting data buckets for processing e.g. as described in step data buckets might be processed more effectively compared to other data bucket selection techniques. However selecting data buckets using other techniques for example sequential selection might also be beneficial under certain circumstances. Accordingly implementations of process can differ depending on each particular application.

Although implementations of the process are described in the context of reclaiming memory from caches used to store resource records implementations of the process are not limited solely to this application. In some implementations the process can be adapted for use in applications pertaining to page replacement e.g. paging in virtual memory management or another other applications in which stored information must be reclaimed in order to accommodate additional information. Similarly the process is not limited solely to implementations of caches with hash tables and can be adapted for use with any other mechanism for storing cached data e.g. arrays tables or other data structures that are indexed by values other than a hash .

Sensors devices and subsystems may be coupled to peripherals interface to facilitate multiple functionalities. For example motion sensor light sensor and proximity sensor may be coupled to peripherals interface to facilitate orientation lighting and proximity functions of the device. For example in some implementations light sensor may be utilized to facilitate adjusting the brightness of touch surface . In some implementations motion sensor e.g. an accelerometer gyros may be utilized to detect movement and orientation of the device. Accordingly display objects or media may be presented according to a detected orientation e.g. portrait or landscape .

Other sensors may also be connected to peripherals interface such as a temperature sensor a biometric sensor or other sensing device to facilitate related functionalities.

Location processor e.g. GPS receiver chip may be connected to peripherals interface to provide georeferencing. Electronic magnetometer e.g. an integrated circuit chip may also be connected to peripherals interface to provide data that may be used to determine the direction of magnetic North. Thus electronic magnetometer may be used with an electronic compass application.

Camera subsystem and an optical sensor e.g. a charged coupled device CCD or a complementary metal oxide semiconductor CMOS optical sensor may be utilized to facilitate camera functions such as recording photographs and video clips.

Communication functions may be facilitated through one or more communication subsystems . Communication subsystem s may include one or more wireless communication subsystems. Wireless communication subsystems may include radio frequency receivers and transmitters and or optical e.g. infrared receivers and transmitters. Wired communication system may include a port device e.g. a Universal Serial Bus USB port or some other wired port connection that may be used to establish a wired connection to other computing devices such as other communication devices network access devices a personal computer a printer a display screen or other processing devices capable of receiving or transmitting data.

The specific design and implementation of the communication subsystem may depend on the communication network s or medium s over which the device is intended to operate. For example a device may include wireless communication subsystems designed to operate over a global system for mobile communications GSM network a GPRS network an enhanced data GSM environment EDGE network 802.x communication networks e.g. Wi Fi Wi Max code division multiple access CDMA networks NFC and a Bluetooth network. Wireless communication subsystems may include hosting protocols such that the device may be configured as a base station for other wireless devices. As another example the communication subsystems may allow the device to synchronize with a host device using one or more protocols such as for example the TCP IP protocol HTTP protocol UDP protocol and any other known protocol.

Audio subsystem may be coupled to a speaker and one or more microphones to facilitate voice enabled functions such as voice recognition voice replication digital recording and telephony functions.

I O subsystem may include touch controller and or other input controller s . Touch controller may be coupled to a touch surface . Touch surface and touch controller may for example detect contact and movement or break thereof using any of a number of touch sensitivity technologies including but not limited to capacitive resistive infrared and surface acoustic wave technologies as well as other proximity sensor arrays or other elements for determining one or more points of contact with touch surface . In one implementation touch surface may display virtual or soft buttons and a virtual keyboard which may be used as an input output device by the user.

Other input controller s may be coupled to other input control devices such as one or more buttons rocker switches thumb wheel infrared port USB port and or a pointer device such as a stylus. The one or more buttons not shown may include an up down button for volume control of speaker and or microphone .

In some implementations device may present recorded audio and or video files such as MP3 AAC and MPEG video files. In some implementations device may include the functionality of an MP3 player and may include a pin connector for tethering to other devices. Other input output and control devices may be used.

Memory interface may be coupled to memory . Memory may include high speed random access memory or non volatile memory such as one or more magnetic disk storage devices one or more optical storage devices or flash memory e.g. NAND NOR . Memory may store operating system such as Darwin RTXC LINUX UNIX OS X WINDOWS or an embedded operating system such as VxWorks. Operating system may include instructions for handling basic system services and for performing hardware dependent tasks. In some implementations operating system may include a kernel e.g. UNIX kernel .

Memory may also store communication instructions to facilitate communicating with one or more additional devices one or more computers or servers including peer to peer communications as described in reference to . Communication instructions may also be used to select an operational mode or communication medium for use by the device based on a geographic location obtained by the GPS Navigation instructions of the device. Memory may include graphical user interface instructions to facilitate graphic user interface processing including a touch model for interpreting touch inputs and gestures sensor processing instructions to facilitate sensor related processing and functions phone instructions to facilitate phone related processes and functions electronic messaging instructions to facilitate electronic messaging related processes and functions web browsing instructions to facilitate web browsing related processes and functions media processing instructions to facilitate media processing related processes and functions GPS Navigation instructions to facilitate GPS and navigation related processes camera instructions to facilitate camera related processes and functions and other instructions for performing some or all of the caching processes as described in reference to .

Each of the above identified instructions and applications may correspond to a set of instructions for performing one or more functions described above. These instructions need not be implemented as separate software programs procedures or modules. Memory may include additional instructions or fewer instructions. Furthermore various functions of the device may be implemented in hardware and or in software including in one or more signal processing and or application specific integrated circuits ASICs .

The term computer readable medium refers to any medium that participates in providing instructions to processor for execution including without limitation non volatile media e.g. optical or magnetic disks volatile media e.g. memory and transmission media. Transmission media includes without limitation coaxial cables copper wire and fiber optics.

Computer readable mediums or memory can further include operating system e.g. Mac OS server Windows NT server network communication module and a cache module . Operating system can be multi user multiprocessing multitasking multithreading real time etc. Operating system performs basic tasks including but not limited to recognizing input from and providing output to devices keeping track and managing files and directories on computer readable mediums and memory controlling peripheral devices and managing traffic on the one or more communication channels . Network communications module includes various components for establishing and maintaining network connections e.g. software for implementing communication protocols such as TCP IP HTTP etc. . Cache module stores data so that future requests for that data can be served faster. For example caching module can include be used to implement the caches of or the caches of and .

Architecture can be included in any computer device including one or more server computers each having one or more processing cores. Architecture can be implemented in a parallel processing or peer to peer infrastructure or on a single device with one or more processors. Software can include multiple software components or can be a single body of code.

The features described may be implemented in digital electronic circuitry or in computer hardware firmware software or in combinations of them. The features may be implemented in a computer program product tangibly embodied in an information carrier e.g. in a machine readable storage device for execution by a programmable processor and method steps may be performed by a programmable processor executing a program of instructions to perform functions of the described implementations by operating on input data and generating output.

The described features may be implemented advantageously in one or more computer programs that are executable on a programmable system including at least one programmable processor coupled to receive data and instructions from and to transmit data and instructions to a data storage system at least one input device and at least one output device. A computer program is a set of instructions that may be used directly or indirectly in a computer to perform a certain activity or bring about a certain result. A computer program may be written in any form of programming language e.g. Objective C Java including compiled or interpreted languages and it may be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment.

Suitable processors for the execution of a program of instructions include by way of example both general and special purpose microprocessors and the sole processor or one of multiple processors or cores of any kind of computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memories for storing instructions and data. Generally a computer may communicate with mass storage devices for storing data files. These mass storage devices may include magnetic disks such as internal hard disks and removable disks magneto optical disks and optical disks. Storage devices suitable for tangibly embodying computer program instructions and data include all forms of non volatile memory including by way of example semiconductor memory devices such as EPROM EEPROM and flash memory devices magnetic disks such as internal hard disks and removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory may be supplemented by or incorporated in ASICs application specific integrated circuits .

To provide for interaction with an author the features may be implemented on a computer having a display device such as a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the author and a keyboard and a pointing device such as a mouse or a trackball by which the author may provide input to the computer.

The features may be implemented in a computer system that includes a back end component such as a data server or that includes a middleware component such as an application server or an Internet server or that includes a front end component such as a client computer having a graphical user interface or an Internet browser or any combination of them. The components of the system may be connected by any form or medium of digital data communication such as a communication network. Examples of communication networks include a LAN a WAN and the computers and networks forming the Internet.

The computer system may include clients and servers. A client and server are generally remote from each other and typically interact through a network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

One or more features or steps of the disclosed embodiments may be implemented using an Application Programming Interface API . An API may define on or more parameters that are passed between a calling application and other software code e.g. an operating system library routine function that provides a service that provides data or that performs an operation or a computation.

The API may be implemented as one or more calls in program code that send or receive one or more parameters through a parameter list or other structure based on a call convention defined in an API specification document. A parameter may be a constant a key a data structure an object an object class a variable a data type a pointer an array a list or another call. API calls and parameters may be implemented in any programming language. The programming language may define the vocabulary and calling convention that a programmer will employ to access functions supporting the API.

In some implementations an API call may report to an application the capabilities of a device running the application such as input capability output capability processing capability power capability communications capability etc.

A number of implementations have been described. Nevertheless it will be understood that various modifications may be made. Elements of one or more implementations may be combined deleted modified or supplemented to form further implementations. As yet another example the logic flows depicted in the figures do not require the particular order shown or sequential order to achieve desirable results. In addition other steps may be provided or steps may be eliminated from the described flows and other components may be added to or removed from the described systems. Accordingly other implementations are within the scope of the following claims.

