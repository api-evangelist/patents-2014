---

title: Synchronized distribution of compliance policy updates
abstract: A notification is received at a workload that indicates that a compliance policy update is available for the workload at a compliance policy management system. A synchronization manager on the workload pulls the compliance policy update from the compliance policy management system and deploys it to the workload.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09444847&OS=09444847&RS=09444847
owner: Microsoft Technology Licensing, LLC
number: 09444847
owner_city: Redmond
owner_country: US
publication_date: 20140721
---
The present application is based on and claims the benefit of U.S. provisional patent application Ser. No. 61 947 195 filed Mar. 3 2014 the content of which is hereby incorporated by reference in its entirety.

Computer systems are currently in wide use. Some computer systems have compliance policies associated with them. The compliance policies often apply to the data that is generated or used in the computer system.

By way of example an electronic mail system may have certain compliance policies. For instance it may be that a compliance policy exists by which any electronic mail message that contains a customer s social security number must be encrypted prior to being sent. A document management system may also have associated compliance policies. For instance for legal reasons it may be that certain business documents must be maintained or stored for a certain number of years before they are deleted. Of course these and a wide variety of other computer systems can have many additional or different compliance policies associated with them as well.

Currently compliance policies are managed separately in each different type of computer system. For instance an electronic mail computer system has its own compliance policies which are managed within that system. A document management system has its own compliance policies which are managed within that system. Electronic meeting computer systems often have compliance policies which are managed within that system as well. The tasks to configure the compliance policies in each of the systems can be cumbersome and difficult.

The discussion above is merely provided for general background information and is not intended to be used as an aid in determining the scope of the claimed subject matter.

A notification is received at a workload that indicates that a compliance policy update is available for the workload at a compliance policy management system. A synchronization manager on the workload pulls the compliance policy update from the compliance policy management system and deploys it to the workload.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. The claimed subject matter is not limited to implementations that solve any or all disadvantages noted in the background.

In the example shown in architecture includes compliance policy authoring and management system central compliance policy store a plurality of different workloads each of which have a tenant data store and a policy store .

In the example shown in each workload can be a single tenant or multi tenant workload that comprises a computer system that generates a set of user interface displays with user input mechanisms for interaction by users . Users interact with the user input mechanisms in order to control and manipulate workloads respectively. By way of example workload may be an electronic mail computer system while workload may be a document management computer system an electronic meeting computer system etc. Each workload illustratively has a policy synchronization manager a policy evaluation system one or more processors or servers and they can include other items as well.

The example shown in also illustrates that compliance policy authoring and management system can itself generate user interface displays with user input mechanisms for interaction by user . User can illustratively interact with user input mechanisms in order to generate or update compliance policies using system and to have those policies synchronized to workloads where they are applied. Thus compliance policy authoring and management system illustratively includes policy CRUD system policy distribution system policy status processing system user interface component one or more processors or servers and it can include other items as well. Before describing the overall operation of architecture of in more detail a brief overview will first be provided.

User first accesses system in order to generate a compliance policy update. This can be to add one or more new compliance policies or rules to delete them or to modify them. In any case policy CRUD system provides functionality that allows user to do that. The policies are represented by a unified schema that is the same across all different workloads. User then invokes policy distribution system that distributes the compliance policy updates to the various workloads where they are to be applied. Policy distribution system sends notifications to workloads that policy updates are available for them. Policy synchronization managers then pull the compliance updates so that they can be applied in workloads respectively. The synchronization managers and in the workloads synchronize the compliance policy updates to their respective workload policy stores . Synchronization managers communicate statuses respectively back to policy status processing system where the status of the application of the compliance policy updates is communicated to user . The compliance policies can then be used during runtime by a unified policy evaluation system that is the same in each workload. The workload coverts items like emails and documents to be analyzed under the compliance policies into a unified representation that is the same across the workloads. The unified policy evaluation system evaluates the items and can call the workload to create instances of action objects that will perform workload specific actions when a compliance policy is triggered.

By way of example a predicate for a rule may combine a set of conditions using a logical AND operation. The conditions of rule may be that the body of an electronic mail message contains the word foo and the word bar . The binding may be a list of electronic mail accounts or mailboxes that are to be evaluated for this rule and the action may be that the electronic mail message containing the word foo and the word bar is encrypted.

User interface system can generate user interface displays that allow user to generate compliance policy updates. Schema generator component illustratively generates a schema that is unified across all workloads to represent the policy update. Policy identifier component allows user to identify an update as a new policy or a modification to a policy. Policy condition component allows user to identify the conditions associated with the new policy or the update. Policy binding component allows user to bind the new policy or updates to various items in the workloads and policy action component allows user to specify actions associated with a new policy or to modify the actions associated with an existing policy.

Compliance policy authoring and management system first receives a user input indicating that the user wishes to access the compliance policy authoring and management system in order to generate a new compliance policy. This is indicated by block in . By way of example user can provide an authentication input or other inputs .

In response policy CRUD system displays a set of user interface displays that allow user to generate the new compliance policy. First for example it can display one or more policy identifying user interface displays with mechanisms that allow user to identify the new policy. This is indicated by block . The policy identifying user interface displays can allow user to input a policy name a policy description and other identifying information .

It will be noted that the present description proceeds with respect to user adding a hold policy. This is a policy that determines how long and under what conditions certain types of data are to be stored. For instance certain kinds of data may be stored for legal reasons for a certain number of years. Other data may be stored by default for a certain number of years but it may be otherwise deleted by the user at any time. Still other data may be automatically deleted after a certain period of time and other information may be stored indefinitely. Of course this is but one type of compliance policy and a wide variety of other compliance policies can be implemented. The one described is described for the sake of example only.

Policy condition component and policy binding component then illustratively generate user interface displays that allow user to define predicates and conditions for the policy being created and to provide scope inputs that indicate what the policy being authored is to bind or apply to. This is indicated by block in . Table 1 below is a table showing some examples of predicates. Table 1 below can be read as a prefix plus a suffix. The prefix is the parent node and the suffix is the child node e.g. CreationDateEqual CreationDateGreaterThan etc. 

By way of example the UI displays may allow user to provide content keywords . It can allow user to identify that a condition is that these keywords are present in the content of the item being analyzed. It may also allow user to provide content dates . Therefore only content that is dated within the dates provided will be analyzed under this policy. It may be that it allows user to provide a content location such as certain URLs that contain content certain e mail addresses or inboxes etc. that the compliance policy is to be bound to. This indicates the location of content where the compliance policy will apply. The conditions and binding inputs can include other items as well.

It can be seen in that the system has now displayed a set of e mail boxes that can be selected by user . User can select from the list shown in pop up display and actuate add button to add those e mail boxes to the list of e mail boxes where the currently authored compliance policy will apply. shows another example of pop up display which now contains the electronic mailboxes that were chosen by the user in .

In one example user can also include distribution lists along with or instead of individual e mail boxes. shows an example of pop up display where the user has selected not only the two e mail addresses shown in but also the Human Resources distribution list.

Referring again to the flow diagram of receiving the user inputs that define conditions and scoping of the compliance policy is indicated by block .

Policy action component shown in then generates user interface displays that allow user to specify actions that are to be taken when the compliance policy is triggered. This is indicated by block . The particular actions may be dependent on the particular scenario for which the compliance policy is generated. By way of example if the compliance policy is a hold policy then the actions may indicate how long the content is to be held whether and under what conditions they can be deleted etc. However if the compliance policy is a security policy it may indicate what types of content are to be encrypted prior to being sent with a messaging system. A wide variety of other actions can be defined as well.

It will be noted that in one example at any time the user can review and confirm the policy details that have just been input. shows one example of a policy detail display . It can be seen that policy detail display includes the various details of the policy that has just been configured.

Once the policy is adequately defined by the user the user can provide an input to deploy the policy. This is indicated by block in the flow diagram of . When that occurs schema generator component generates a representation of the newly authored compliance policy according to a unified schema that is unified across all of the various workloads to which compliance policies are to be applied. This is indicated by block in .

Table 2 shows one example of a policy configuration object schema that represents a policy. Table 3 shows a markup language representation of the schema. It can be seen in Table 3 that an XML schema expresses a hierarchical relationship of logical conditions. A top level node in the schema shown in Table 3 is referred to as the rule. It expresses a hierarchy of logical nodes of and and or as well as not operators. Each condition inside the node can be a specific point for policy evaluation. Table 3 also shows the schema for representing actions indicated in the rule. This can easily be extended by including new tags in the schema to represent new conditions and new nodes in the action schema to represent workload specific actions like encryption etc. 

Once the user provides an input to deploy the policy then policy distribution system shown in deploys the unified representation of the policy to the relevant workloads . This is indicated by block in .

It is first assumed that the user has already defined one or more policies that the user wishes to deploy to various workloads. User then provides an input using a user input mechanism that indicates that user wishes to deploy the policies to the workloads. Receiving an input to deploy a policy is indicated by block in .

Policy distribution system then begins enabling or deploying the selected policy to the desired workloads . In doing so it illustratively generates a user interface display indicating with a status indicator that the policy deployment is in progress. This is indicated by block in the flow diagram of and shows one example of a user interface display that indicates this. is similar to the user interface display shown in . However now shows that the status column and the enable disable mechanism indicate that the selected policy is currently being deployed.

In one example in order to avoid conflicting changes policy distribution system disables any further changes by user to the selected policy while it is being deployed. This is indicated by block in the flow diagram of .

It will be noted that a more detailed description of how policies are actually distributed or synchronized down to workloads is described below with respect to . Suffice it to say for now that a policy can be deployed either with errors or without errors. For example it may be that a policy is successfully deployed to a certain set of mailboxes where the workload is an electronic mail system but it was unsuccessfully bound to another set of mailboxes. In this case the policy is deployed but with errors. Determining whether the policy has been completely deployed and determining whether it has been deployed with or without errors is indicated by blocks and in the flow diagram of . If it is deployed successfully without errors then policy distribution system generates a user interface display that indicates this. Displaying the status as being enabled or deployed without errors is indicated by block in the flow diagram of .

It will be appreciated that a compliance policy can be disabled or deleted as well. In that case policy CRUD system generates suitable user interface displays allowing user to disable or delete the policy. If the policy is to be disabled policy distribution system generates user interface displays similar to those shown in except that the user inputs will be to disable the policy rather than enable it. In one example it may take some time to completely disable a policy from workloads . In that case the status indicators will indicate that the policy is being disabled but that it may take a certain amount of time to disable them. All of these examples are contemplated herein.

It is also contemplated that user may wish to edit an already existing compliance policy and deploy those changes to the workloads. is a flow diagram illustrating one example of how user can do this and show examples of user interface displays that can be generated as well.

Policy CRUD system first receives a user input indicating that user wishes to edit an already existing compliance policy. This is indicated by block in . shows one example of a user interface display indicating this. It can be seen that is similar to and user has selected compliance policy . However shows that user is now actuating an edit user input mechanism . This indicates that the user wishes to edit the selected compliance policy. Selecting a policy is indicated by block in the flow diagram of and actuating the edit mechanism is indicated by block . User can provide inputs to indicate that the user wishes to edit a compliance policy in other ways as well and this is indicated by block .

Policy CRUD system then generates an edit user interface display with user input mechanisms that allow user to select a portion of the selected compliance policy to edit. This is indicated by block in the flow diagram of . shows one example of a user interface display that indicates this. is similar to that shown in except that an edit user interface display is now shown. It illustratively includes a set of selectors that allow the user to select the portion of the compliance policy for editing. In one example the user can select the identifying information portion of the compliance policy e.g. the name portion . This is indicated by block in the flow diagram of . The user can also illustratively select the conditions section the bindings section such as the sites or mailboxes that the compliance policy is bound to the actions section or other sections .

In response policy CRUD system generates a user interface display that allows user to edit the selected section. It can be seen in for instance that the user has actuated the name user input mechanism. Therefore policy CRUD system generates user input mechanisms that allow the user to edit the name and description of the compliance policy. The user can then actuate a save user input mechanism in order to save the edits.

In any case user provides edit inputs editing the compliance policy as desired. Receiving the edits is indicated by block in the flow diagram of . The user then provides a redeploy input such as actuating save mechanism and actuating a redeploy user input mechanism in order to redeploy the edits. They are then deployed as described above with respect to . Redeploying the edits to the workloads is indicated by block in .

Policy distribution system first receives a policy or a change to a policy for distribution to one or more workloads . In one example it is received from policy CRUD system . Receiving the compliance policy or change e.g. the updates for distribution is indicated by block in .

Policy distribution system then saves the update to the central compliance policy store . This is indicated by block .

Policy distribution system then identifies the relevant workloads where the update is to be applied. In doing so it can illustratively examine the bindings for the policy to see where the compliance policy is bound and thus the various workloads where it will need to be applied. Identifying these relevant workloads is indicated by block .

System then sends a notification to the relevant workloads that a compliance policy or change is available for synchronization. This is indicated by block . It then waits to receive a pull request from the workloads where the policy is to be applied. This is indicated by block in .

Once a pull request is received policy distribution system sends the unified representation of the update to the requesting workload. It is illustratively sent to the policy synchronization manager for the requesting workload . This is indicated by block in . The synchronization manager then synchronizes the update to the requesting workload and sends back a status indicator in to policy status processing system indicating that the policy is being applied has been applied successfully has been applied with errors etc. Receiving the status indicator from the requesting workload is indicated by block . Policy status processing system then updates the distribution status for the compliance policy update. This is indicated by block . Examples of how this status is displayed were described with respect to .

It can thus be seen that the compliance policy update is distributed to the relevant workloads using a hybrid push pull approach. When a policy update is ready for synchronization to a workload the policy distribution system sends a notification to that workload that a policy update is ready for synchronization. In one example it doesn t push the actual policy update which can be relatively large but only sends a notification. The relevant workload persists that notification and then pulls the actual compliance policy update from distribution system when the workload is ready to synchronize it. The pull can be done incrementally so that only certain changes are pulled at any given time. As is described in greater detail below the policy synchronization manager of the relevant workload keeps track of the various changes it has made so that it can ask for additional changes that have been notified as it can make them. This approach obtains the advantages of both a push architecture and a pull architecture while avoiding their disadvantages. For instance the advantage of a push architecture is that data is only pushed when a change has been made. This leads to efficiency. The disadvantage is that the pusher must maintain connections for all the end points it needs to push. In a large scalable service this can be problematic as there are too many end points to push and the code to do so becomes relatively complex. The advantage of a pull architecture is that the puller only needs to maintain one connection with the source so the code is relatively simple. The disadvantage of pulling is that the puller doesn t know when to pull. That is it doesn t know when a change has actually been made. If it pulls too frequently but the data hasn t changed this can waste computational and memory resources. It can also waste network bandwidth. If the puller pulls too infrequently then the user experience can suffer because the user does not see changes quickly enough. By using a hybrid push pull architecture the present system can obtain the advantages of both architectures while avoiding the disadvantages.

Policy synchronization manager can illustratively include notification receiver in memory notification queue dispatcher component one or more synchronizer components policy CRUD manager tenant information provider and status generator and publisher component . It can include other items as well. shows that in one example policy synchronization manager is also coupled to a persistent storage queue . All of the components of policy synchronization manager can share the same interface across all workloads .

Before describing the overall operation of policy synchronization manager in more detail a brief overview will first be provided. Notification receiver listens for policy update notifications from policy distribution system . It then places them in persistent queue so that they are not lost in case policy synchronization manager crashes or its operation is disrupted for some reason. It also places them in in memory queue . They can be placed in queue in a variety of different orders. For instance if they are urgent they can be placed at the top of the queue. Otherwise they can be placed in the queue on a first come first served basis. Dispatcher component drains the notifications from queue . Each notification is viewed as a work item that is to be sent to a synchronizer component . In one example dispatcher component can batch the notifications into batches and send them in batches to different synchronizer components . Synchronizer components call the policy CRUD manager which can be the same as policy CRUD system shown in but with a subset of the functionality enabled to perform the updates represented by the given notification being operated on. In doing so it can generate pull requests that it sends to policy distribution system to pull the actual compliance policy updates that need to be synchronized. In response system sends the compliance policy updates that need to be synchronized to the workload that contains policy synchronization manager . Each synchronizer component makes the necessary calls on policy CRUD manager in order to make the updates and store them in the workload policy store that stores the compliance policies for the given workload.

Tenant information provider can also make calls on tenant store in order to store relevant tenant information such as the status of the policy updates the current version of the policy diagnostic data such as how many times a given synchronizer component has attempted to synchronize a policy etc. Status generator and publisher component generates the status indicators indicating the status of application of the given compliance policy update and places it in persistent queue and in memory queue . Dispatcher component dispatches the status to a synchronizer component which sends it back to policy status processing system where it can be displayed to the user as discussed above.

The notification can indicate that a new compliance policy is to be synchronized to the workload or that a change or update to an existing compliance policy is to be synchronized. The notification can also indicate a regular synchronization request or an urgent synchronization request . A regular request may be provided for instance when user simply makes a change to the compliance policy and commits it to central compliance policy store . This will cause policy distribution system to send a regular notification to the relevant workload. An urgent sync request may be generated for instance when the policy synchronization manager has not completed synchronizing a compliance policy after a normal service interval. In that case user or policy distribution system may generate an urgent request. Of course the notifications can be generated and received in other ways as well and this is indicated by block .

Notification receiver then places the notification in persistent queue and in in memory queue . It can store the notification in other ways as well. Placing the request in a queue is indicated by block . Again if the notification is a normal notification notification receiver may simply place the notification in queue and at the end of the queue. However if it is an urgent notification then it may be placed at the head of the queue.

Dispatcher component then spawns one or more synchronizer components if they are needed and de queues the notifications from queue and sends them to the spawned synchronizer components. This is indicated by block in the flow diagram of . Again they can be batched as indicated by block . The batches can be sent to synchronizer component either in parallel as indicated by block or in serial as indicated by block . The notifications can be sent to synchronizer components in other ways as well and this is indicated by block .

The synchronizer components then call the policy distribution system to pull all updates corresponding to a notification currently being processed. This is indicated by block in . In response the unified representations of the updates corresponding to the notifications being processed are received.

The synchronizer component then call the policy CRUD manager to perform the updates and to write the updates to the workload policy store . This is indicated by block .

Synchronizer components then notify the dispatcher component and the status generator and publisher component that the change has been committed. This is indicated by block in . The synchronizer components can indicate that the update has been committed completely as indicated by block or with errors as indicated by block or in other ways as indicated by block .

Status generator and publisher places the status in queues and or this can be done by notification receiver where dispatcher component dispatches it to a synchronizer component . The synchronizer component sends the status to the policy status processing system. This is indicated by block in .

Component first determines whether all of the cascading tasks for a policy update including automatic retries have been completed. For instance it may be that a synchronizer component automatically retires to commit policy updates where the first attempt has failed. If all of these cascading tasks for performing the policy update have not yet been completed then this is detected by status generator and publisher component and component publishes the status as in progress deploying or some similar status indicating that the compliance policy update is currently in the process of being synchronized to the given workload. Determining whether the tasks are complete and reporting the status as in progress are indicated by blocks and in .

Once the tasks are complete the component determines both an object level status for the policy update and a status for each individual binding entry for the compliance policy update. Determining the object level status is indicated by block in and determining the individual binding status is indicated by block .

The object level status indicates the status of the overall compliance policy update that is being applied. The individual binding status indicates the status of whether the compliance policy update has been successfully applied to each of the individual bindings that indicate where that update is to be applied. Component aggregates the object level status and the status for each individual binding entry and reports them both to the policy status processing system in compliance policy authoring and management system shown in . This is indicated by block in the flow diagram of . In doing so component illustratively takes advantage of the structure of policy synchronization manager . Therefore it writes the status to persistent queue and in memory queue or provides status to notification receiver which writes it to queues and . Dispatcher component dispatches status to a synchronizer component which sends it to policy status processing system . This is indicated by blocks and in .

It may be that the compliance policy update is to be applied to more than one workload. In that case policy status processing system rolls up all of the statuses for the policy update from all of the workloads where it is being applied and displays these statuses along with drill down functionality so that user can drill into the details of these status indicators. Rolling up all of the statuses is indicated by block in . Rolling them up across workloads is indicated by block . Rolling them up across all tenants is indicated by block rolling them up in other ways is indicated by block and displaying them is indicated by block .

Once a compliance policy update has been successfully synchronized to a given workload it can then be used by that workload in processing data. This is illustratively done by policy evaluation systems in the workloads . In doing so evaluation systems illustratively receive payload information e.g. data to which the compliance policy is to be applied and then evaluates that data against the various compliance policy rules that have been synchronized to the workload to determine whether any apply and whether any actions need to be taken according to the compliance policy. illustrate one example of this in more detail. is a block diagram showing one example of a policy evaluation system in more detail. For the example shown in it will be assumed that the policy evaluation system is system from workload . However it will be appreciated that the description of can just as easily be applied to policy evaluation system in other workloads.

Before describing the operation of system in more detail a brief overview will first be provided. Compliance item generator calls an interface implemented by the workload to generate a unified representation of the payload item so that it can be analyzed against the compliance policies. Applicable policy identifier identities relevant policies and rule parser component parses the unified representation of the relevant policies to identify predicates conditions and actions. Action generator component generates action objects corresponding to the actions. Where the actions are workload specific actions component calls an interface on the workload and has the workload create the action object. Matching component then matches conditions for each rule against the unified representation of the payload item to see if any rules match. If so it invokes the corresponding action objects to perform desired actions.

Compliance item generator then generates a unified compliance item representation of the workload item . This is indicated by block . By way of example in order to support a common set of rules conditions and actions across multiple different types of workloads the items to be evaluated e.g. the messages documents etc. are first converted into a form by which they are represented by a common schema. In doing so compliance item generator can call an application programming interface API implemented by the workload to extract text from the workload item as indicated by block . It can also extract common content that is to be placed in the schema. This is indicated by block . Calling the API on the workload in order to obtain this type of information is indicated by block . It can generate a compliance item in the common schema in other ways as well and this is indicated by block .

Table 4 shows one example of a compliance item schema that can be used to represent a payload item that is received for evaluation by system . Table 5 shows one example of a class definition of the item implementing the common schema.

Once compliance item generator has extracted the common schema values from the payload item and generated the compliance item according to the common schema applicable policy identifier identifies applicable policies that may be applicable to the compliance item. This is indicated by block in . The relevant rules or policies can be identified along with the compliance item itself as indicated by block . Component can also evaluate the bindings in the policies being evaluated to determine whether any of its rules apply to this compliance item. This is indicated by block . Determining whether the policies apply to this item can be determined in other ways as well.

Rule parser component parses the compliance policy to identify rules and their predicates and conditions for evaluation. The rule parser component reads and parses the unified representation of each rule e.g. the rule XML and matches the tag of each condition with an object class factory API to create the runtime object that represents that rule. Where the rule is a workload specific rule the workload implements an API that can be called to create the runtime object that represents that workload specific rule. Action generator creates the objects that represent the actions in the parsed rules. Where they are workload specific actions it calls the API on the workload to have the workload create the corresponding objects. Creating the action objects is indicated by block in . Default actions are indicated by block workload specific actions are indicated by block and other actions are indicated by block .

Matching component then sorts the rules in the identified policies that are to be applied to this compliance item. This is indicated by block . It then selects a rule as indicated by block . It then compares the predicates and conditions in the selected rule against the compliance item to see whether they match. This is indicated by block . If the predicates do not match or if the predicates match but the conditions do not match then processing skips to block where additional rules are evaluated if any. However if the predicates and conditions do match the compliance item then the actions associated with the matching rules are identified and applied. This is indicated by block .

By way of example assume that the bindings provide a predicate indicating that a compliance policy is to be applied to a given set of mailboxes. Assume that the conditions indicate certain textual items that must be contained in the body of an electronic mail message in one of those mailboxes for the actions to be taken. Assume that the action to be taken is that the electronic mail message is to be saved in a data store for a specified period of time before it is automatically deleted. In that case matching component will first determine whether the compliance item that represents a given electronic mail message is in one of the listed mailboxes. If so it will then determine whether the body of the mail message contains the contextual items. If that is true then the message will be saved at a specified location and marked for automatic deletion at a certain point in the future.

Policy evaluation system performs the evaluations of all of the rules in policies that are to be applied to the compliance item. When all of the rules have been evaluated the processing is complete.

Extensibility system can be provided in policy evaluation system or spread across a workload. In one example system allows extensibility by having system implement workload specific interfaces. A compliance item interface is used to generate the compliance item that represents the payload item e.g. the document or electronic mail message etc. that is to be evaluated. A rule parser and condition action interface is implemented and represents the creation of workload specific rules.

It can thus be seen that a unified compliance policy framework includes an architecture and a set of schemas and APIs. The framework enables different services to plug into a single framework to achieve a unified experience in compliance policy management and enforcement. A single markup language e.g. XML schema and runtime object model expresses compliance policies in a way that can be used by multiple different services or workloads. This significantly increases reliability in the management of such policies. A single runtime object model represents payload items that are to be evaluated by the compliance policy evaluation system. Thus the single runtime object model represents documents e mails chat conversations etc. depending upon the workload. An extensibility system allows for the addition of different compliance policy scenarios. The policy evaluation system can be represented by an application programming interface that can be run across multiple different services or workloads to evaluate policies using the unified schema that represents the policies and the unified schema that represents the objects for evaluation. The synchronization system allows policies to be synchronized across various workloads from a central location. The synchronization model includes notification and incremental data pulling to obtain the benefits of both types of architectures.

The present discussion has mentioned processors and servers. In one embodiment the processors and servers include computer processors with associated memory and timing circuitry not separately shown. They are functional parts of the systems or devices to which they belong and are activated by and facilitate the functionality of the other components or items in those systems.

Also a number of user interface displays have been discussed. They can take a wide variety of different forms and can have a wide variety of different user actuatable input mechanisms disposed thereon. For instance the user actuatable input mechanisms can be text boxes check boxes icons links drop down menus search boxes etc. They can also be actuated in a wide variety of different ways. For instance they can be actuated using a point and click device such as a track ball or mouse . They can be actuated using hardware buttons switches a joystick or keyboard thumb switches or thumb pads etc. They can also be actuated using a virtual keyboard or other virtual actuators. In addition where the screen on which they are displayed is a touch sensitive screen they can be actuated using touch gestures. Also where the device that displays them has speech recognition components they can be actuated using speech commands.

A number of data stores have also been discussed. It will be noted they can each be broken into multiple data stores. All can be local to the systems accessing them all can be remote or some can be local while others are remote. All of these configurations are contemplated herein.

Also the figures show a number of blocks with functionality ascribed to each block. It will be noted that fewer blocks can be used so the functionality is performed by fewer components. Also more blocks can be used with the functionality distributed among more components.

The description is intended to include both public cloud computing and private cloud computing. Cloud computing both public and private provides substantially seamless pooling of resources as well as a reduced need to manage and configure underlying hardware infrastructure.

A public cloud is managed by a vendor and typically supports multiple consumers using the same infrastructure. Also a public cloud as opposed to a private cloud can free up the end users from managing the hardware. A private cloud may be managed by the organization itself and the infrastructure is typically not shared with other organizations. The organization still maintains the hardware to some extent such as installations and repairs etc.

In the embodiment shown in some items are similar to those shown in and they are similarly numbered. specifically shows that some or all items in architecture can be located in cloud which can be public private or a combination where portions are public while others are private . Therefore users can use user devices and to access those systems through cloud .

It will also be noted that architecture or portions of it can be disposed on a wide variety of different devices. Some of those devices include servers desktop computers laptop computers tablet computers or other mobile devices such as palm top computers cell phones smart phones multimedia players personal digital assistants etc.

Under other embodiments applications or systems are received on a removable Secure Digital SD card that is connected to a SD card interface . SD card interface and communication links communicate with a processor which can also embody the various processors from along a bus that is also connected to memory and input output I O components as well as clock and location system .

I O components in one embodiment are provided to facilitate input and output operations. I O components for various embodiments of the device can include input components such as buttons touch sensors multi touch sensors optical or video sensors voice sensors touch screens proximity sensors microphones tilt sensors and gravity switches and output components such as a display device a speaker and or a printer port. Other I O components can be used as well.

Clock illustratively comprises a real time clock component that outputs a time and date. It can also illustratively provide timing functions for processor .

Location system illustratively includes a component that outputs a current geographical location of device . This can include for instance a global positioning system GPS receiver a LORAN system a dead reckoning system a cellular triangulation system or other positioning system. It can also include for example mapping software or navigation software that generates desired maps navigation routes and other geographic functions.

Memory stores operating system network settings applications application configuration settings data store communication drivers and communication configuration settings . Memory can include all types of tangible volatile and non volatile computer readable memory devices. It can also include computer storage media described below . Memory stores computer readable instructions that when executed by processor cause the processor to perform computer implemented steps or functions according to the instructions. Application or the items in data store for example can reside in memory . Similarly device can have a client system which can run various applications or embody architecture . Processor can be activated by other components to facilitate their functionality as well.

Examples of the network settings include things such as proxy information Internet connection information and mappings. Application configuration settings include settings that tailor the application for a specific enterprise or user. Communication configuration settings provide parameters for communicating with other computers and include items such as GPRS parameters SMS parameters connection user names and passwords.

Applications can be applications that have previously been stored on the device or applications that are installed during use although these can be part of operating system or hosted external to device as well.

Additional examples of devices can also be used. Device can be a feature phone smart phone or mobile phone. The phone can include a set of keypads for dialing phone numbers a display capable of displaying images including application images icons web pages photographs and video and control buttons for selecting items shown on the display. The phone can include an antenna for receiving cellular phone signals such as General Packet Radio Service GPRS and 1Xrtt and Short Message Service SMS signals. In some embodiments the phone also includes a Secure Digital SD card slot that accepts a SD card.

The mobile device can also be a personal digital assistant PDA or a multimedia player or a tablet computing device etc. hereinafter referred to as PDA . The PDA includes an inductive screen that senses the position of a stylus or other pointers such as a user s finger when the stylus is positioned over the screen. This allows the user to select highlight and move items on the screen as well as draw and write. The PDA also includes a number of user input keys or buttons which allow the user to scroll through menu options or other display options which are displayed on the display and allow the user to change applications or select user input functions without contacting the display. Although not shown the PDA can include an internal antenna and an infrared transmitter receiver that allow for wireless communication with other computers as well as connection ports that allow for hardware connections to other computing devices. Such hardware connections are typically made through a cradle that connects to the other computer through a serial or USB port. As such these connections are non network connections.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media is different from and does not include a modulated data signal or carrier wave. It includes hardware storage media including both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

Alternatively or in addition the functionality described herein can be performed at least in part by one or more hardware logic components. For example and without limitation illustrative types of hardware logic components that can be used include Field programmable Gate Arrays FPGAs Program specific Integrated Circuits ASICs Program specific Standard Products ASSPs System on a chip systems SOCs Complex Programmable Logic Devices CPLDs etc.

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into the computer through input devices such as a keyboard a microphone and a pointing device such as a mouse trackball or touch pad. Other input devices not shown may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A visual display or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer is operated in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a hand held device a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

It should also be noted that the different embodiments described herein can be combined in different ways. That is parts of one or more embodiments can be combined with parts of one or more other embodiments. All of this is contemplated herein.

a notification receiver that receives a notification that a compliance policy update is available at a compliance policy management system for synchronization to a workload and that stores the notification on the workload 

a policy synchronization manager that pulls the compliance policy update from the compliance policy management system and that deploying the compliance policy update to the workload and

a computer processor that is a functional part of the system and activated by the notification receiver and the policy synchronization manager to facilitate receiving the notification and pulling and deploying the compliance policy update.

Example 2 is the synchronization system of any or all previous examples wherein the policy synchronization manager comprises 

a policy CRUD manager that makes calls on a workload policy store to commit the compliance policy update to the workload policy store.

Example 3 is the synchronization system of any or all previous examples wherein the policy synchronization manager comprises 

a synchronizer component that sends a pull request to the compliance policy management system to obtain the compliance policy update in response to receiving the notification and that calls the policy CRUD manager with the compliance policy update.

Example 4 is the synchronization system of any or all previous examples wherein the synchronization manager comprises 

a notification queue the notification receiver storing received notifications in the notification queue based on a notification urgency assigned to the notifications by the compliance policy management system.

Example 5 is the synchronization system of any or all previous examples wherein the synchronization manager comprises 

a dispatcher component that obtains notifications from the notification queue and sends them to the synchronization component the dispatcher component creating additional instances of synchronization components based on the notifications in the notification queue.

Example 6 is the synchronization system of any or all previous examples wherein the dispatcher component batches notifications from the notification queue and sends batches of notifications to a plurality of different synchronization components for processing in parallel.

Example 7 is the synchronization system of any or all previous examples wherein the synchronization manager further comprises 

a status component that sends a status indicator to the compliance policy management system the status indicator indicating a status of deploying compliance policy updates to the workload.

receiving at a workload a notification that a compliance policy update is available from a compliance policy management system for deployment to the workload 

sending a pull request from the workload to the compliance policy management system to obtain the compliance policy update and

reporting a status of deployment of the compliance policy update to the compliance policy management system.

Example 10 is the computer implemented method of any or all previous examples wherein receiving the notification comprises 

storing the notification in a notification queue according to a priority assigned to the notification by the compliance policy management system.

Example 11 is the computer implemented method of any or all previous examples wherein receiving the notification further comprises 

Example 12 is the computer implemented method of any or all previous examples wherein sending a pull request comprises 

sending the pull request in response to obtaining the next available notification from the notification queue.

Example 13 is the computer implemented method of any or all previous examples wherein obtaining the next available notification comprises 

Example 14 is the computer implemented method of any or all previous examples wherein deploying the compliance policy update to the workload comprises 

receiving a compliance policy update definition at a compliance policy management system defining a compliance policy update for deployment to a workload 

sending a notification to the workload the notification indicating that the compliance policy update is available at the compliance policy management system for the workload 

Example 16 is the computer implemented method of any or all previous examples wherein receiving the compliance policy update definition comprises 

receiving a set of user definition inputs at the compliance policy management system defining the compliance policy update.

Example 17 is the computer implemented method of any or all previous examples wherein sending the notification comprises 

sending the notification to a plurality of different workloads indicating that the compliance policy update is available at the compliance policy management system for the plurality of different workloads.

Example 18 is the computer implemented method of any or all previous examples wherein receiving a pull request comprises 

Example 19 is the computer implemented method of any or all previous examples wherein sending the compliance policy update comprises 

in response to each pull request from the plurality of different workloads sending a unified representation of the compliance policy update to the corresponding workload the unified representation being a same representation of the compliance policy update regardless of which of the plurality of different workloads it is sent to.

Example 20 is the computer implemented method of any or all previous examples and further comprising 

receiving a status indicator from each of the different corresponding workloads indicative of a status of deployment of the compliance policy update to a corresponding workload and

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

