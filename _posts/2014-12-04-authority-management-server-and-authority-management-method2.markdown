---

title: Authority management server and authority management method
abstract: An API counting process that sets a limit number for an API used by a client, and when an access token is issued in response to a request from an authority delegation destination and a request to verify the issued access token is received, manages an API usage limit number on a client-by-client basis in accordance with the usage limit number for each API set for the authority delegation destination, is executed. The API usage number is incremented (S), compared with the usage limit number (S), and the access token verification is considered to have failed in the case where the limit has been exceeded.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09608990&OS=09608990&RS=09608990
owner: CANON KABUSHIKI KAISHA
number: 09608990
owner_city: Tokyo
owner_country: JP
publication_date: 20141204
---
The present invention relates to methods for managing API call limits for a client in an authorization delegation system and particularly relates to authority management servers and authority management methods regarding API calls from multiple clients in the same tenant.

Recent years have seen an increase in the use of what are known as cloud based services implemented over the Internet. It is becoming more and more common for businesses as well as individuals to manage customer relationships using a CRM Customer Relationship Management service distribute and collect information in real time using an SNS Social Networking Service and so on for example. Many of these cloud based services publicize individual web service APIs and it is now possible to use functions provided by such services from other applications cloud based services and so on via the APIs. As a result there is a continued increase in mashup functions in which multiple APIs publicized by multiple cloud based services are combined in order to configure a service that operates as if it were a single web service.

However the increase in opportunities to use mashup functions by which multiple cloud based services cooperate has also given rise to several problems. For example there is a risk that more information than a user intends to share will be exchanged among the multiple cloud based services heightening the risk of user data personal information and the like being leaked. It is generally preferable not to collect more user data personal information and so on than is required for each cloud based service and it is further necessary to prevent the user data personal information and so on from being provided to cloud based services that the user does not wish to cooperate. Meanwhile from the perspective of service providers it is preferable to make it easier to realize a system for cooperation of cloud based services. In light of such circumstances a standard protocol for cooperation of authorizations called OAuth 2.0 has been developed see The OAuth 2.0 Authorization Framework online D. Hardt May 2013 retrieved from http tools.ietf.org html rfc6749 .

According to OAuth 2.0 when for example there is an API that acquires the data of a user managed by a service A a service B that is authorized by that user can access the stated API. At this time a range that will be accessed by the service B is made clear whereupon the service A obtains explicit authorization from the user for the service B to access the API. The user carrying out this explicit authorization is referred to as an authorization operation.

When the user carries out the authorization operation the service B receives a token authorizing access from the service A called an access token hereinafter and the service B can subsequently access the service A s API by using that access token. The process by which the user s authorization operation allows a service to access user resources managed by a different service is referred to as the delegation of authorizations. When the access token is used the service B can access the service A s API under the authority of the user who made the authorization without needing that user s credentials. As such the service B that has been authorized by the user and that has obtained the access token has an obligation to manage the access token properly and with care.

According to OAuth 2.0 it is necessary for the service B to be authenticated in order to prevent spoofing of the service B. To authenticate the service B it is necessary for the service A to issue the service B s credentials in advance and specifically a client ID and a secret manage the credentials and furthermore set those credentials in the service B. Hereinafter the service A that provides a resource will be referred to as a resource server whereas from the perspective of the service A the service B or in other words the other service that uses the resource server under the authority delegated by the user of that service will be referred to as a client of that resource server . According to OAuth 2.0 it is possible to separately configure an authorization server that carries out the aforementioned user authorization operations the issuing of access tokens and the authentication of clients and a resource server that manages user data as resources and publicizes APIs as web services. In such a case the service B accepts the delegation of authority from the user obtains the access token from the authorization server and uses that access token to access the API of the resource server. The resource server is configured to request the authorization server to verify the obtained access token grant access to the resource only in the case where the access has been authorized and then return data to the service B.

Typically in a cloud based service an API publicized by a web service monitors a number of uses per unit of time for each client see Japanese Patent Laid Open No. 2007 328417 for example . This is done in order to prevent a drop in the overall quality of the service resulting from the API being used excessively by a specific client. In particular paid services that charge based on the amount the service is used often provide limits on the number of times the service can be used in a unit of time and reject access after the limit has been reached. This is because a paid service is basically made usable under a contract with a user and the operator of a paid service has an obligation to provide the service in a stable manner in accordance with the details of that contract. An SLA Service Level Agreement is known as an example of such a system for ensuring the quality of a service. An SLA defines such items as a minimum speed of the service being provided a limit on the amount of time for which the service can be used and so on. A user then pays a fee as compensation for the service quality defined in the SLA. The SLA also defines penalties for the service provider user guarantees such as reductions in usage fees and so on for cases where the promised quality is not provided. As such with a paid service it is extremely important for the quality defined in the SLA to be maintained which means that it is important to prevent drops in the service quality by setting limits on API usage amounts and rejecting access when the limits have been reached.

The following configuration can be considered for a situation in which a company s internal system namely multiple clients present in a tenant cooperates with a cloud based service. Tenant is a unit used to distinguish entities to which a resource is provided and is a unit by which users use and manage the cloud. For example in a case where multiple users utilize the same resource server the information of the users managed by the resource server is divided into independent units and these divided units correspond to tenants . In other words a configuration can be considered in which each client functions as a tenant client for a specific tenant in the cloud based service that is the resource server and multiple clients can use multiple services through the specific tenant. In this configuration a data upload client a form client and a print client for a cloud based service to which a tenant belongs are provided in that tenant for example. It is assumed that the API usage limit management is implemented as limit management through OAuth on a tenant by tenant basis.

However the aforementioned OAuth configuration or in other words a configuration including the authorization server that issues access tokens and the resource server that publicizes the API has the following problem. When there is an API usage limit number in a specific tenant and a client uses the API of the service A excessively and reaches the usage limit the API of the service B can no longer be called. In other words the number of times an API in a given service can be used is affected by the usage situation of an API in another service.

According to one aspect of the present invention there is provided an authority management server comprising a management unit that manages a user s access authority for a resource an issuing unit that in response to an authorization request from a client requesting delegation of the user s access authority for a resource verifies the authorization request and issuing an access token to the client in the case where the verification is successful and a verification unit that in the case where there is a resource request along with the access token verifies the access token and returning a verification response in the case where the verification is successful wherein both the authorization request verification performed by the issuing unit and the access token verification performed by the verification unit determine whether or not a number of accesses of the resource has exceeded a set access limit number and determine the access token to be valid in the case where the access limit number is not exceeded.

An authority management server comprising a management unit that manages a user s access authority for a resource an issuing unit that in response to an authorization request from a client requesting delegation of the user s access authority for a resource issues an access token to the client and a verification unit that in the case where there is a resource request along with the access token verifies the access token and returning a verification response in the case where the verification is successful wherein the access token verification performed by the verification unit determines whether or not a number of accesses of the requested resource has exceeded a set access limit number and determines the access token to be valid in the case where the access limit number is not exceeded.

According to the present invention in a single tenant usage limits for APIs in individual services are not affected by the usage situation of APIs in other services. This increases the usability of the services.

In addition in the case where multiple services operate in a cooperated manner an API usage limit can be set for a series of functions configured of the multiple services making it possible to execute the functions without errors and increase the usability of the services.

Further features of the present invention will become apparent from the following description of exemplary embodiments with reference to the attached drawings .

An authority delegation system having an API usage number limit management function according to the present embodiment is implemented over a network configured as shown in . Note that the authority delegation system is a system configured of servers and clients and is a system that provides services to authorized clients. The delegated authority corresponds to the authority to access resources provided by a resource server which will be mentioned later. Because the system is a system that provides resources the system according to the present embodiment can also be called a resource providing system.

In a wide area network WAN is a network for local area networks and the like to connect to each other and corresponds to the Internet for example. A World Wide Web WWW system for example is configured in the WAN . A local area network LAN connects network constituent elements such as computers for example. A public line is a public line that connects the WAN to constituent elements such as computers and is called an access line in the case where the WAN is the Internet.

An authorization server is a server for implementing OAuth 2.0 and is provided with an authorization server module. The authorization server is a server that manages user and client authorization to access resources and is also called an authority management server . A resource server is provided with resource server modules such as a user provisioning service a paid data conversion service a free data conversion service and so on. Note that one or more resource server modules may be provided in a single resource server. The resource server stores and manages resources for each user and provides the resources to authorized clients via service APIs. Resource refers to storage space processing capabilities or specific applications for example. A terminal is a device that executes an application program that accesses a resource provided by the resource server and is for example a mobile terminal such as a smartphone an image forming device or the like. One or more application modules are installed in the terminal . A user communicates with the resource server using the application module. A database server is connected to the authorization server via the LAN and stores data used by the authorization server module. The authorization server the resource server and the terminals are connected to each other via the WAN and the LAN . Note that the authorization server the resource server and the terminals may be provided on separate individual LANs or may be provided on the same LAN. In addition the authorization server the resource server and the database server may be configured within a single server.

The authority delegation system according to the present embodiment is implemented as a system including servers and terminals configured as indicated in . illustrates the hardware configuration of the authorization server the resource server the terminals and the database server . Note that the hardware block diagram shown in corresponds to a hardware block diagram for a typical information processing apparatus and the hardware configuration of such a typical information processing apparatus can be applied in the servers and terminals according to the present embodiment.

In a CPU executes programs such as an OS or applications that are stored in a program ROM within a ROM or loaded into a RAM from an external memory such as a hard disk HD and controls the respective blocks connected to a system bus . Here OS is an acronym for operating system which runs on a computer and the operating system will be referred to as an OS hereinafter. The processes of the sequences mentioned later are implemented by executing these programs. The RAM functions as the main memory a working area and so on for the CPU . A keyboard controller KBC controls key inputs from a keyboard a pointing device not shown or the like. A CRT controller CRTC controls displays in a CRT display . A disk controller DKC controls data access in the external memory such as a hard disk HD which stores various types of data. A network controller NC is connected via the WAN the LAN or the public line and executes communication control processes with the other devices.

Unless otherwise specified the following descriptions assume that the CPU is the main hardware entity that executes processes in the server and that the application program installed in the external memory is the main software entity.

In the authorization server includes an authorization server module and an HTTP server module . The HTTP server module is a module for carrying out as a server HTTP communication with an HTTP client for example a web browser in the terminal connected via the WAN . The module is configured to be capable of SSL TLS communication and has a certificate store not shown . In the present embodiment the configuration is such that at an end point where a client registration request is received which will be described later a request for authentication using an X.509 certificate is issued to the origin of the stated request. The authorization server module is a web application that runs on or in cooperation with the HTTP server module and accepts and processes requests from and returns responses to the terminal via the HTTP server module . The present embodiment is configured so that at this time when a client registration request is received and the origin of the request has been successfully authenticated in the HTTP server module the received certificate is communicated to the authorization server module .

The resource server includes a resource server module and an HTTP server module . The HTTP server module has the same functions as the HTTP server module . The resource server module is a web application that runs on or in cooperation with the HTTP server module and accepts and processes requests from and returns responses to the terminal via the HTTP server module .

The terminal includes an application management module and a web browser and furthermore has one or more application modules . The application management module has a function for managing the life cycle of the application module running on the terminal which is to be managed. Life cycle refers to an application state including installation launching closing and uninstalling. OSGI registered trademark defined by the OSGi Open Services Gateway initiative Alliance can be considered as an example of the application management module . The application module is an application that runs in an application execution environment provided by the terminal . The life cycle of this application is managed by the application management module . Here the application module may be provided in the terminal in advance or may be installed later via the application management module . The terminal further includes the web browser which is a user agent for accessing the world wide web. The application module holds an X.509 certificate for identifying itself and a private key for the certificate. These can be used when establishing communication with the HTTP server module which will be described later in order for the HTTP server module to authenticate that the request is from the application module.

The scope table includes a scope ID a scope type a scope description that is used in a screen example mentioned later and an authority ID . Here scope refers to a range that can be accessed by an authority delegation destination client in the authority delegation flow according to OAuth which will be mentioned later. Note that a resource owner referred to here differs depending on the flow in OAuth 2.0. More specifically in the present embodiment an access token obtainment flow according to a Client Credentials Grant is carried out. The resource owner is the client itself in the case of the access token obtainment flow according to the Client Credentials Grant. The authority ID in the scope table indicates authority required to access the scope indicated by the scope ID and zero or more authority IDs can be associated therewith. In the case where multiple authority IDs are associated the resources indicated by the scope can be accessed if at least one of the multiple authority IDs has the required authority. In the case where zero authority IDs are associated or in other words in the case where not even one authority ID is associated any subject authenticated for that scope is capable of access. The scope type indicates whether the scope corresponds to a single API or to a series of APIs serving as a group. An API group refers to a case where an application that uses a series of APIs such as data creation form processing and the printing thereof serves as a client. Although there is no difference in the processing between when there is a single API and when there is a group of APIs in the present embodiment the API usage limit number is handled differently in the second embodiment which will be described later.

A flowchart indicating an API limit number setting process performed by the authorization server module according to the present embodiment will be described using . This flowchart illustrates a flow carried out when a master user sets the API usage limit number in the authorization server module through the terminal . In steps S. S. S. and S. indicate processes involved in inputs to the terminal and sending information to a server whereas the other steps indicate processes performed by the authorization server including the authorization server module and the HTTP server module . Note that in the case where there is a separate authentication server an authentication procedure of step S. is carried out by that authentication server.

In S. the master user uses the web browser of the terminal to make a request to the HTTP server module of the authorization server for setting the API limit number. Note that a trigger for the web browser of the terminal making the API limit number setting request is as follows. The descriptions of the present embodiment assumes that the master user of the terminal uses the web browser to access a URL that provides an API limit number setting screen this URL is assumed to be already known . The API limit number setting screen is included in the authorization server module of the authorization server .

The HTTP server module that has accepted the API limit number setting request from the web browser receives an authorization request. Then in S. the HTTP server module returns a login screen for authenticating the user to the web browser . illustrates an example of the login screen returned by the HTTP server module . The screen in includes a user ID input field into which a user ID is input a password input field into which a password is input and a login button for executing the login operation.

In S. the user inputs the required information namely a user ID and password into the screen shown in that is displayed in the web browser and presses the login button whereupon the web browser sends the input information to the HTTP server module . In S. the HTTP server module obtains the user ID and the password from the web browser and authenticates the user by verifying whether or not there is a set of information that matches the user ID and the password in the user management table . In the case where the user authentication fails or in other words in the case where the information that has been obtained is not registered in the user management table the HTTP server module returns an authentication error screen not shown to the web browser in S.. It is possible to use another method for authenticating the user such as using an X.509 certificate multi step authentication in which multiple passwords are input or the like and the method for authenticating the user is not limited to the method described here.

In the case where the login is successful in S. in S. the authorization server module of the authorization server displays a service list screen shown in through the HTTP server module . The service list screen is an input screen that displays in a tenant user display region the tenant ID and user ID of the user that successfully logged in in S.. A list of services that can be used by the user that successfully logged in in S. is also displayed in an API limit number list display region . The API limit number list display region is configured of service names and API limit numbers . Of these the service names displays a list of the names of services that can be used by the tenant indicated by the tenant ID which belongs to the logged in user currently displayed in the tenant user display region . Specifically the API usage number management table is searched using the tenant ID of the logged in user and all of the service names corresponding to the matching tenant ID are displayed.

In S. the logged in user uses the web browser to select a service name for which the API limit number is to be set and using the user interface inputs an API limit number in the API limit number field in the same line as the service name. With respect to a range for values that can be set for the API limit number there is a maximum value defined by restrictions of computational resources such as the CPU memory and the like of the authorization server the number of tenants to which services are to be provided and so on and thus the user can set the limit number within a range that does not exceed the maximum setting value. Once the API limit numbers have been set for each service displayed in the service names the API limit number setting is finalized for the services by an OK button being pressed.

In S. the authorization server module of the authorization server determines whether the API limit number set by the user exceeds the maximum setting value. If the set API limit number does not exceed the maximum setting value in S. the authorization server module of the authorization server displays the setting value and ends the process. However if the set number exceeds the maximum setting value an error not shown indicating that the maximum setting value has been exceeded is displayed and the process then ends.

Note that the present embodiment assumes that the sum of the limit numbers set for individual services that is individual APIs for a given tenant is not allowed to exceed a maximum number for that tenant. Accordingly the maximum number is divided equally for each API and set and displayed as the default value in the API limit numbers for example. If an API limit number setting value has been input for a given service a difference between that setting value and the default value is allocated automatically to the other services set and displayed once again. The allocation to the other services is assumed to be almost uniform for example. By doing so the usage limit number for individual services are not affected by the usage situations of other services. Note that the sum of the limit numbers set for individual services in other words APIs for a given tenant may also be allowed to exceed the maximum number for that tenant. However if the limit numbers of the respective services are all set for the maximum number the same problem as with the related art will occur as a result. To avoid this the configuration may be such that a maximum value for the API limit number that can be set for each service called a service by service maximum number is provided or the sum of the API limit numbers that can be set for each service in a given tenant is allowed to exceed the maximum number of that tenant by a predetermined percentage or a predetermined value.

A limit is set for the API usage number on a service by service basis within a unit period through the procedure described above.

A sequence performed in the application module from client registration to resource obtainment according to the present embodiment will be described using . This sequence illustrates a flow carried out when a user uses the terminal to use an application module that is not yet registered in the authorization server module . The configuration can also be implemented so that for example client registration is only carried out the first time in the application module of the terminal and the process is subsequently executed from the sequence for obtaining an access token.

First a client registration sequence carried out in the application module will be described using . In S. the application module of the terminal makes a client registration request to the HTTP server module of the authorization server . Note that the present embodiment describes the user installing the application module and launching the application module for the first time in the terminal as a trigger for the application module to make the client registration request. Note that the timing at which the user selects a function in the application module and a resource request is issued to the resource server can be thought of as another trigger. The application module may be provided with an operation for explicitly starting and the timing at which the user carries out that operation using the terminal can be thought of as another trigger. Note that the client registration request includes a client name and a redirect URL for using an Authorization Code Grant. The configuration may be such that attribute information such as a character string for describing the client the URL of a site that provides a description or the like is included as other information. The Authorization Code Grant is a procedure whereby authority is delegated from a user having the authority to use a service so that a cooperating application client can use an API publicized by the service and is defined in OAuth 2.0. The Authorization Code Grant procedure will be described later with reference to and the like.

Having accepted the client registration request from the application module the HTTP server module starts negotiation for SSL TLS communication. At this time with respect to a device registration request a setting is made to request client authentication and thus a request for a certificate is issued to the application module . In S. using a certificate set in a certificate store not shown the HTTP server module verifies the certificate obtained from the application module and authenticates the application module as the source of the device registration request. Although the present embodiment describes an authentication method that uses an SSL TSL certificate as the method for authenticating the origin of the client registration request a method that uses an ID and a password such as Basic authentication and Digest authentication can be considered as well for example. Furthermore a configuration is also possible in which a means for authenticating these subjects is established a means for issuing an access token for registering the client to the authenticated subjects is provided and the client registration is accepted by verifying that access token. The HTTP server module returns an error to the application module in the case where the authentication fails.

In S. after the application module has been authenticated the HTTP server module communicates the client registration request received from the application module to the authorization server module . Information for identifying the authenticated application module is also communicated at this time. More specifically information of the obtained certificate is communicated.

In S. the authorization server module obtains the information of the certificate communicated from the HTTP server module . Next in S. the authorization server module specifies information of the certificate management table using the serial number issuer and owner of the obtained certificate as keys and obtains information of the tenant master DN . The configuration can also be such that the verification is carried out using the start date and the end date as a period of validity. Here in the case where there are no records in the certificate management table the validity period was not successfully verified or the like the authorization server module returns an error to the application module via the HTTP server module .

Next in S. the authorization server module obtains the tenant ID from the client management table using the obtained tenant master DN as a key. The default authority ID is then obtained from the default authority management table using the obtained tenant ID as a key. It may be the case that multiple default authority IDs are obtained. Meanwhile in the case where not even one ID is registered in the default authority management table nothing is registered in the client authority table which will be described later.

Next in S. the authorization server module newly registers the client in the client management table based on the obtained information. More specifically the client ID and the secret are issued the DN is created and these pieces of information are held in and respectively. The obtained client name redirect URL and tenant ID specified by the tenant master DN are then stored in and . The type is set to general at this time. Then in S. the authorization server module stores in the client authority table the client ID that has been issued and registered and the default authority ID obtained from the default authority management table . At this time multiple pieces of data are stored in the case where multiple default authority IDs have been obtained.

After the registration is complete in S. the authorization server module returns the issued client ID and secret to the application module via the HTTP server module .

The foregoing has described client registration. Through this sequence when a client is registered online the application module can be identified and the appropriate authority can be provided.

Next a sequence performed in the application module from the obtainment of the access token to the obtainment of a resource using the access token will be described using . Note that in Ref indicates a reference which will be described using a different diagram. Alt meanwhile indicates a branch and indicates branching based on conditions such as a result of a previous process. The process carried out after the branch is either of the processes denoted within the box labeled Alt .

In S. the application module starts the obtainment of the access token. Note that a case where the user uses the terminal to start the application module can be thought of as a trigger for the obtainment of the access token to start. The application module may be provided with an operation for explicitly starting and the timing at which the user carries out that operation using the terminal can be thought of as another trigger. Here the process for issuing the access token is carried out in accordance with the flow defined in OAuth 2.0. In the present embodiment the flow of S. includes two cases namely Authorization Code Grant and Client Credentials Grant and these respective processes will be described. The access token issuing process through the Authorization Code Grant flow will be described later using . Likewise the access token issuing process through the Client Credentials Grant flow will be described later using . The access token issuing process according to the present embodiment is carried out using one of these flows. In S. the application module obtains the access token through the corresponding access token obtainment flow. In S. the application module makes a resource request to the resource server module using the obtained access token. The resource request can be carried out by reading out the API corresponding to the resource. The resource server module receives the request and returns the response via the HTTP server module which is not shown in .

In the present embodiment the resource request corresponds to a service request through a REST API call. A configuration is also possible in which all API operations in the present embodiment are executed over SSL and mutual authentication is carried out using X.509 certificates.

The application module can access the various types of APIs provided by the resource server module by including the obtained access token in Authorization Bearer of the HTTP header. For example the following is obtained when calling a form creation API.

Meanwhile the REST API header is as follows when calling an API that uploads a CSV file and creates a data set for example.

With respect to the CSV file that is actually uploaded this API mimics the behavior of the user entering data into the form in the web browser and pressing a send button. That is POST data is sent as Content Type multipart form data in accordance with RFC 2388. Meanwhile the following is obtained when calling an API that prints the created data for example.

In S. the resource server module makes an access token verification request to the authorization server module . Although the present embodiment describes the communication between the resource server module and authorization server module as being carried out over the LAN a configuration in which this communication is carried out over the WAN is also possible. At this time the communication is carried out via the respective HTTP server modules and . The processing by which the authorization server module verifies that access token which is carried out upon the access token verification request being received will be described later using . In the case where the access token verification has resulted in the access token being verified as authentic the resource is allowed to be accessed without requesting the input of credentials.

In S. the resource server module receives an access token verification response from the authorization server module . In the case where the verification result indicates valid in S. a resource obtainment process is carried out in S.. Then in S. the obtained resource is returned to the application module and the process ends. On the other hand in the case where the access token verification response result indicates invalid or there is an API limit management error an error response is sent to the application module in S. after which the process ends.

The foregoing has described a sequence performed in the application module from the obtainment of the access token to the obtainment of a resource using the access token.

Next an access token issuing process in the case of an Authorization Code Grant according to OAuth 2.0 will be described using . In S. of the application module makes an authorization request to the HTTP server module via the web browser . In the HTTP server module the endpoint that accepts the authorization request is set to request a user authentication instead of a client authentication. Note that the authorization request includes at least a client ID obtained as a result of client registration and a registered redirect URL as well as one or more scope IDs including at least one owner scope indicating a range of resources expected to be obtained. The necessary scope IDs are known by the application module in advance.

In S. the HTTP server module receives the authorization request. Then in S. the HTTP server module returns a login screen for authenticating the user to the web browser . illustrates an example of the login screen returned by the HTTP server module . The screen in includes the user ID input field into which a user ID is input the password input field into which a password is input and the login button for executing the login operation.

In S. the user enters the required information into the screen shown in that is displayed in the web browser and presses the login button . In S. the web browser sends the entered information to the HTTP server module . In S. the HTTP server module obtains the user ID and the password from the web browser and authenticates the user by verifying whether or not there is a set of information that matches the user ID and the password in the user management table . The authentication is successful when there is a match. In the case where the user authentication fails or in other words in the case where the information that has been obtained is not registered in the user management table the HTTP server module returns an authentication error screen not shown to the web browser . In the case where the user authentication is successful the HTTP server module generates an authentication token. This authentication token is stored in a non volatile memory in the HTTP server module in association with the user ID. Then in S. the HTTP server module communicates the authorization request received from the application module to the authorization server module . At this time the generated authentication token is communicated as well. Although the present embodiment uses password authentication the method is not limited thereto and a configuration in which another method serving as a way to authenticate a user such as using an X.509 certificate multi step authentication in which multiple passwords are input or the like is used can be employed as well.

In S. the authorization server module verifies whether the set of the client ID and the redirect URL in the authorization request is correct. More specifically it is verified whether a set that matches the set of the client ID and the redirect URL registered in the client management table has been registered. In the case where there is no match the authorization server module returns an error screen not shown to the web browser via the HTTP server module . However in the case where there is a match in S. the authorization server module obtains user information. More specifically the associated user ID is obtained from the HTTP server module using the authentication token communicated from the HTTP server module . For example because the HTTP server module has received the login information including the user ID along with the access token the user ID associated with the access token is obtained from the HTTP server module . Based on this user ID the authority ID is obtained from the user authority table . At this time the obtained authority ID is not limited to a single ID and 0 or multiple authority IDs may be obtained. Although the present embodiment describes the obtainment of the user information as being carried out through a method that obtains the user ID based on the authentication token after which the authorization server module obtains the user information the method is not limited thereto. For example a configuration in which the required user information is communicated from the HTTP server module is also possible as is a configuration in which the required user information is obtained by passing the authentication token to the HTTP server module .

In S. the authorization server module obtains the authority ID of each scope from the scope table using the scope ID of the scope included in the authorization request as a key. Then in S. the authorization server module verifies whether the authority ID obtained for each scope is included in the authority ID corresponding to the user ID obtained in S. from the user authority table . The authorization request is accepted in the case where the all authorities belonging to the scope included in the authorization request from the user have been provided to that user and is rejected when such is not the case. Specifically the authority IDs associated with the scope ID included in the authorization request are obtained from the scope table and the authorization request is determined to be valid in the case where the authority IDs obtained in association with the user of the user authority table are set. Here in the case where there are multiple authority IDs associated with the scope ID in the scope table if at least one authority ID of those multiple authority IDs is set for the user in question the authorization request regarding that authority is considered to be valid.

Alternatively in the case where all of the authority IDs associated with the requested scope are set for the user in question the authorization request related to that authority may be considered to be valid for the first time. Meanwhile in the case where an authority ID associated with the scope ID is not set for that user the authorization request related to that authority is considered to be invalid regardless of the user s authority. In the case where at least one authority ID in the scope included in the authorization request is invalid in S. the authorization server module returns an authority error to the web browser . Then in S. the web browser returns the authority error to the application module . More specifically a redirect is returned to the web browser so that the web browser redirects to the redirect URL obtained at the time of the authorization request. In S. the application module returns an authority error screen an example of which is shown in to the web browser after which the process ends.

In the case where the authority IDs are valid for all the scopes included in the authorization request in S. the authorization server module returns an authorization confirmation screen to the web browser . illustrates an example of the authorization confirmation screen returned here. An authorization confirmation screen includes an access source display region which is a region that displays the client name obtained from the client management table using the client ID included in the authorization request as a key. The authorization confirmation screen also includes a scope display region which is a region that displays the description of the scope obtained from the scope table using the scope ID included in the authorization request as a key. Furthermore the authorization confirmation screen includes an allow button through which a user executes an authorization operation for the details of the aforementioned information and a reject button that executes a rejection. In the case where the user has pressed the reject button the authorization server module returns an authority error to the application module in S. in the same manner as when a result of verifying the owner authority indicates invalid . The configuration may be such that the authority error responses are displayed in a screen by the application module that receives the responses or text is changed so that the details of the error responses can be distinguished.

In S. in the case where the user has pressed the allow button in the authorization confirmation screen or in other words in the case where the authorization operation has been carried out the authorization server module is notified in S. that the authorization is successful via the web browser .

In S. the authorization server module issues an access code. More specifically an access token ID is issued the scope ID and client ID included in the authorization requests are authenticated and the user ID of the user for whom authorization has been obtained is registered in the access token management table as an owner ID . At this time the token type is used as the access code and a date until which the access code is valid is registered in the expiration date . Then in S. and S. the authorization server module sends to the application module an authorization response including the access token ID of the issued access code via the web browser . More specifically a redirect is returned to the web browser so that the web browser redirects to the redirect URL obtained at the time of the authorization request.

In S. the application module requests an access token from the authorization server module . This access token request includes at least the obtained access code client ID secret and the redirect URL sent at the time of the authorization request.

In S. the authorization server module uses a set including the obtained client ID and secret to authenticate the client. More specifically the authentication is carried out by verifying a match with a set of the client ID and the secret in the client management table . In the case where a client authentication has failed the application module returns an authentication error. In the case where the client authentication is successful the authorization server module verifies the obtained access code in S.. The access code is verified by determining whether the access token ID in the obtained access code is registered in the access token management table and verifying whether the expiration date has not yet been passed in the case where the access token ID is registered. In the case where the access token ID is not registered an authorization error is returned in S.. Furthermore it is verified whether the redirect URL obtained through the access token request matches the redirect URL registered in the client management table using the client ID associated with the access token ID as a key. In the case where the access code verification result indicates invalid the authorization server module returns a token invalid error to the application module . However in the case where the access code verification result indicates valid in S. the authorization server module obtains the client information. More specifically the authority ID is obtained from the client authority table using the authenticated client ID as a key. At this time zero or multiple authority IDs may be obtained.

In S. the authorization server module obtains the scope ID from the access token management table using the access token ID of the obtained access code as a key. Next the authority ID of each scope is obtained from the scope table using the scope ID of the obtained scope as a key. At this time in the case where the scope is not included in the scope ID obtained from the access token management table the client authority verification result indicates valid . However the standard processing carried out in step S. may be executed instead of treating this case as an exception. In such a situation the stated case will be determined to be invalid.

In S. the authorization server module verifies whether the authority ID for each scope obtained in S. is included in the authority ID obtained from the client authority table . The authorization request is accepted in the case where the all authorities belonging to the scope included in the access token requested by the client have been provided to that client and is rejected when such is not the case. Therefore to be more specific the authority ID corresponding to the scope ID associated with the requested access token is obtained from the scope table and in the case where the authority ID obtained in association with that client in the client authority table is set in that authority ID the authorization request is determined to be valid. Here in the case where there are multiple authority IDs associated with the scope ID in the scope table if at least one authority ID of those multiple authority IDs is set for the client the authorization request is considered to be valid. Alternatively in the case where all of the authority IDs associated with the requested scope are set for the client in question the authorization request related to that authority may be considered to be valid for the first time. In the case where an authority ID associated with the scope ID is not set however the authorization request is considered invalid regardless of the client authority. In the case where the verification indicates invalid for at least one authority ID in the scope associated with the access code in S. the authorization server module returns an authority error to the application module . Then in S. the application module returns the authority error screen an example of which is shown in to the web browser after which the process ends.

In the case where all of the scopes associated with the access code are valid the authorization server module executes an API counting process in S.. At this time the process is executed using the scope and the authenticated client ID. The API counting process is a process for determining whether the usage number of the API being used will exceed the limit value. The API counting process is carried out according to the procedure shown in which will be described in detail later. In the case where the API counting process has failed the authorization server module returns an error to the application module and ends the process.

However in the case where the API counting process is successful the authorization server module issues the access token in S.. More specifically the access token ID is issued and the scope ID owner ID and authenticated client ID associated with the access code are registered in the access token management table . At this time the token type is used as the access token and a date until which the access token is valid is registered in the expiration date . Then in S. the authorization server module returns the access token ID of the issued access token to the application module and ends the process. A configuration in which the expiration date of the access token is returned at this time can also be employed. Although the present embodiment describes an example in which a refresh token for updating the access token is not issued a configuration in which a refresh token ID and expiration date are managed in the access token management table can also be employed. Here a configuration in which the refresh token is issued at the same time as the access token and the ID of the refresh token that was issued is included in the response to the access token can be employed.

Next an access token issuing process in the case of the OAuth 2.0 Client Credentials Grant will be described using .

In S. the application module requests an access token from the authorization server module . This access token request includes one or more scope IDs that include at least the client ID secret and at least one scope indicating a range of resources expected to be obtained.

The scope in the present embodiment corresponds to an access API related to a resource that can be referred to by the scope or to a group including a series of access APIs. The scope and access API also correspond to various types of services in the present embodiment. An access token including a single scope ID is required when calling an API for a single resource and a single service. Meanwhile an access token including multiple scope IDs is required when calling an API for a series of services in which multiple services cooperate.

In S. the authorization server module uses a set including the obtained client ID and secret to authenticate the client. More specifically the authentication is carried out by verifying a match with a set of the client ID and the secret in the client management table . In the case where a client authentication has failed the application module returns an authentication error. In the case where the client authentication is successful the authorization server module obtains the client information in S.. More specifically the authority ID is obtained from the client authority table using the authenticated client ID as a key. At this time zero or multiple authority IDs may be obtained.

In S. the authorization server module obtains the authority ID of each scope from the scope table using the scope ID of the scope included in the access token request as a key. At this time in the case where the scope is not included in the scope ID included in the access token request the client authority verification result indicates valid . However the standard processing carried out in step S. may be executed instead of treating this case as an exception. In such a situation the stated case will be determined to be invalid.

In S. the authorization server module verifies whether the authority ID for each obtained scope is included in the authority ID obtained from the client authority table . At this time in the case where there are multiple authority IDs associated with the scope ID in the scope table if at least one authority ID of those multiple authority IDs is set for the client the authorization request is considered to be valid. In the case where an authority ID associated with the scope ID is not set however the authorization request is considered invalid regardless of the client authority.

The process moves to S. in the case where the verification result indicates invalid for at least one authority ID in the scopes included in the access token request. In S. the authorization server module returns an authority error to the application module and ends the process.

In the case where the verification indicates valid for all of the scopes included in the access token request the authorization server module executes the API counting process in S.. At this time the process is executed using the scope and the authenticated client ID. Details of the API counting process will be given later. In the case where the API counting process has failed the authorization server module returns an error to the application module and ends the process.

However in the case where the API counting process is successful the authorization server module issues the access token in S.. More specifically the access token ID is issued and the scope ID included in the access token request the client ID of the authenticated client the client ID serving as the owner ID are registered in the access token management table . At this time the token type is used as the access token and a date until which the access code is valid is registered in the expiration date . Then in S. the authorization server module returns the access token ID of the issued access token to the application module and ends the process. A configuration in which the expiration date of the access token is returned at this time can also be employed.

Next an access token verification process will be described using . illustrates the flow of an access token verification process executed by the authorization server module . In the flow shown in the application module makes a resource request API call at S. after obtaining the access token in S.. When a verification request is then issued to the authorization server module from the resource server module in response to the stated request the authorization server module carries out the access token verification process and furthermore manages the API usage number limit by carrying out the API counting process. The verification process that includes the API counting process will be described next.

In step S. the authorization server module receives an access token verification request from the resource server module . The access token verification request includes the access token ID of the access token to be verified and at least one scope ID. In step S. the authorization server module obtains the access token ID and the scope ID. Next in step S. the authorization server module obtains information of the access token based on the obtained access token ID. More specifically the expiration date is obtained from the access token management table using the access token ID and a token type of access token as keys. Then in step S. it is verified whether the access token is present or in other words whether the access token is present in the access token management table and whether the access token is still within the expiration date. In the case where the verification indicates that the access token is not present or is present but is not within the expiration date the access token is determined to be invalid a token invalid error is returned in step S. and the process ends. In the case where the verification result indicates that the access token is present and is within the expiration date the process continues.

In step S. the authorization server module obtains information of the scope included in the verification request. More specifically the type and authority ID of each scope is obtained from the scope table using the scope ID as a key.

Next in step S. the authorization server module determines whether at least one client scope is included in the type of the one or more scopes obtained in S.. The process moves to step S. in the case where there is not even one scope. However in the case where there is at least one scope the authorization server module obtains the client information in step S.. More specifically a client ID is obtained from the access token management table using the access token ID as a key and the authority ID is obtained from the client authority table using the obtained client ID as a key. At this time 0 or multiple authority IDs may be obtained.

Next in step S. the authorization server module carries out authority verification on the client scope obtained in step S.. More specifically the authority ID of each client scope is obtained from the scope table using the client scope ID obtained in S. as a key. It is then verified whether the authority ID for each obtained client scope is included in the authority ID obtained in step S.. The access token is accepted in the case where the all authorities belonging to the scope associated with the client of the access token to be verified have been provided to that access token and is rejected when such is not the case. Accordingly for example the authority ID corresponding to the scope ID associated with the access token to be verified is obtained from the scope table and in the case where the authority ID obtained in association with the client of that access token is set in that authority ID that authorization request is determined to be valid. Here in the case where there are multiple authority IDs associated with the client scope ID in the scope table if at least one authority ID of those multiple authority IDs is set for the client the authorization request is considered to be valid. In the case where an authority ID associated with the client scope ID is not set however the authorization request is considered invalid regardless of the client authority. In the case where the result of the verification indicates invalid for at least one authority ID the authorization server module returns an authority error to the resource server module in step S. and ends the process. In the case where the verification result indicates valid for all of the client scopes obtained in S. the authorization server module moves to step S..

In step S. the authorization server module carries out the API counting process which will be described later for managing the API usage limit number. In step S. it is determined whether the API counting process has succeeded or failed and in the case where the process has succeeded a response indicating that the API can be executed is returned to the resource server module in step S. after which the process ends. However if the API counting process has failed in step S. the authorization server module returns an API limit number management error to the resource server module after which the process ends.

Through these sequences the resource server module accepts only access from an application module having the proper authority and can prevent unintended authority errors from the application module . Furthermore in the present embodiment a call limit number for an access API or a group of a series of access APIs regarding a resource that can be referred to based on the scope can be managed on a tenant by tenant basis and can furthermore be managed on a service by service basis. Accordingly a drop in the quality of various types of services provided by the resource server module caused by the excessive use of services and APIs in a specific tenant can be prevented based on the QoS Quality of Service concept.

Furthermore the API counting process which determines whether or not the API usage number has exceeded a limit number within a set period is carried out by the authorization server module that receives the access token request during the access token obtainment process performed by the application module S. and S. . This does not depend on whether the protocol being used is Client Credentials Grant or Authorization Code Grant. Furthermore the API counting process is carried out in the access token verification process even after the access token has been obtained and even when a request for a resource is made to the resource server using that access token S. . Through this access tokens that cannot be used due to the limit on the usage number of the APIs included in the scope are no longer issued which makes it possible to conserve processing resources communication resources and so on.

When there is an API usage limit number at the service level scope level for a specific tenant and the client has used the API of a single service excessively and exceeded the limit it is possible that a series of functions that combine the stated service with other services will encounter an error partway through. DataSetService FormService PrintService and DataSetFormPrintService in the scope ID defined in the scope table shown in and described in the aforementioned embodiment can be considered. Assume that a given tenant makes an API call corresponding to these four scopes or in other words makes a service request. At this time the DataSetService scope corresponds to an API service in which the application module uploads a local CSV file to the resource server module and the resource server module builds the uploaded CSV file and converts the file into a data set. The FormService scope corresponds to an API service in which the application module specifies the data set in the resource server module and creates a form. PrintService corresponds to an API service in which the application module prints the form data in the resource server module . Furthermore the DataSetFormPrintService scope corresponds to an API service in which the application module consecutively calls the APIs of the DataSetService scope the FormService scope and the PrintService scope so as to upload a local CSV file create a form and print the form. The DataSetFormPrintService scope corresponds to a scope group according to the present embodiment. The scope group assigns a unique name to a combination of multiple scopes when a series of resources are obtained an API is called using an access token associated with the multiple scopes. The scope group configures the series of resource obtainments API calls . The access token request indicated in is issued in the issuing sequence as an access token including multiple scope IDs when the access token is actually issued. The scope group is defined in a scope group table within the authorization server module shown in and is not known on the client side such as the application module . Because the API specifies a service provided by that API API and service correspond to each other. Accordingly in the aforementioned embodiment the API and the service provided by the API are collectively called an API service. Accordingly the API service can also be referred to as a service and the API corresponding thereto.

When the application module calls an API that specifies multiple scopes corresponding to the DataSetFormPrintService in actuality access token verification is carried out according to the flowchart shown in for the DataSetService scope the FormService scope and the PrintService scope and furthermore the API counting indicated in is carried out. At this time if any of the three scopes reaches the API usage number limit it is possible that the DataSetFormPrintService scope configured by cooperation of the series of services which actually corresponds to multiple scopes being specified will stop partway through without the API call being completed. Meanwhile calling an API specifying multiple scopes can indicate a series of services by providing an ID of the scope group in the multiple scopes included in the series of services. The authorization server module can distinguish between an API call for individual scopes by managing the API limit numbers for the scope group and individual scopes separately and a call for a series of services indicated by multiple scopes. Through this the API call specifying multiple scopes configured by cooperation of the series of services can be prevented from stopping partway through without the API call being completed.

It is assumed that the scopes that configure a scope group are pre set in the system. A user may also be allowed to define the scope group. In the case where multiple scopes are specified in an access token request and the multiple specified tokens exactly match the scopes defined in the scope group the access token request for the multiple scopes is interpreted as specifying the scope group. With respect to the obtainment of resources API calls using an access token issued in response to the access token request specifying multiple scopes the authorization server module determines that the obtainment of resources API call specifies the scope group and carries out processing.

The second embodiment which solves the aforementioned problem will be described using . Note that the second embodiment is the same as the aforementioned embodiment with the exception of the processing from the access token obtainment in S. to the error response sequence in S. shown in and thus descriptions aside from those items will be omitted. Furthermore the same sequence numbers are appended to sequences that execute the same processes as those described with reference to and descriptions thereof will be omitted.

Note that the API usage limit number for the scope group is set by the user as indicated in . Meanwhile the group execution number indicates a number of executions as a group and thus a value obtained by dividing the set API usage limit number by the number of scope IDs included in that scope group discarding the remainder may be set for the group execution number . Conversely an execution number as a group may be set and that value may then be converted into individual API usage numbers and used as the API usage limit number . In either case it is necessary for the sum of the API usage number limit values to be no greater than the total usage number limit for the APIs in the tenant.

In the sequence shown in the application module requests an access token and obtains the access token in S.. When the application module specifies multiple scopes when obtaining the access token an access token corresponding to multiple scopes can be obtained based on the sequence shown in . At this time in the case where the multiple scopes exactly match the scope ID list defined in advance in the scope group table in the authorization server module the multiple scopes are recognized as a scope group in the authorization server module . The scope group is used when the application module obtains multiple resources calls APIs corresponding to the respective multiple scopes for the authorization server module to count up the series of resources being obtained API calls collectively rather than on an individual basis. The obtainment of resources API calls by the application module are differentiated in the authorization server module as cases associated with a single scope and cases associated with multiple scopes.

Specifically API calls associated with the single scope are realized as the following first second and third API calls.

The obtainment of resources using the access token associated with the DataSetService scope an upload service API call is as follows. The access token ID associated with the DataSetService scope is AT 0000001 in the access token ID of the access token management table . The application module carries out the API call by adding a Base64 encoded QVRfMDAwMDAwMQ after Authorization Bearer of the API call.

The obtainment of resources using the access token associated with the FormService scope a form service API call is as follows. The access token ID associated with the FormService scope is AT 0000002 in the access token ID of the access token management table . The application module carries out the API call by adding a Base64 encoded QVRfMDAwMDAwMg after Authorization Bearer of the API call.

The obtainment of resources using the access token associated with the PrintService scope a print service API call is as follows. The access token ID associated with the PrintService scope is AT 0000003 in the access token ID of the access token management table . The application module carries out the API call by adding a Base64 encoded QVRfMDAwMDAwMw after Authorization Bearer of the API call.

In response to the first second and third API calls mentioned above API calls associated with multiple scopes according to the present embodiment are as follows. That is the obtainment of resources API calls using the access token associated with the three scopes namely the DataSetService the FormService and the PrintService are implemented as the following fourth fifth and sixth API calls.

The obtainment of resources upload service API based on the access token associated with a group scope that has the aforementioned three scopes is as follows. The access token ID associated with the DataSetFormPrintService scope is AT 0000004 in the access token ID of the access token management table . The application module carries out the API call by adding a Base64 encoded QVRfMDAwMDAwNA after Authorization Bearer of the API call.

The obtainment of resources using the access token associated with a group scope that has the aforementioned three scopes a form service API is as follows. The access token ID associated with the DataSetFormPrintService scope is AT 0000004 in the access token ID of the access token management table . The application module carries out the API call by adding a Base64 encoded QVRfMDAwMDAwNA after Authorization Bearer of the API call.

The obtainment of resources print service API based on the access token associated with a group scope that has the aforementioned three scopes is as follows. The access token ID associated with the DataSetFormPrintService scope is AT 0000004 in the access token ID of the access token management table . The application module carries out the API call by adding a Base64 encoded QVRfMDAwMDAwNA after Authorization Bearer of the API call.

In the application module carries out the stated fourth fifth and sixth API calls. These corresponding to the upper level the middle level and the lower level in respectively. In other words the fourth API call is carried out from step S. to S. the fifth API call is carried out from step S. to S. and the sixth API call is carried out from step S. to S.. Aside from the API counting process in the access token verification process shown in the flowchart of these API call sequences are the same as S. to S. in and thus descriptions thereof will be omitted. In this manner services can be received according to individual scopes included in a single group scope by using an access token associated with the group scope.

The API counting process shown in performed in the access token verification process shown in the flowchart in will be described in detail using the flowchart shown in . illustrates a process executed in the present embodiment in place of described in the first embodiment.

In step S. the authorization server module obtains a tenant ID associated with the access token to be verified. Specifically the client ID of the access token corresponding to the access token ID in the access token management table is obtained. Furthermore a row in the client management table shown in corresponding to the client ID is referred to based on the client ID and the value of the corresponding tenant ID is obtained. Next in step S. the authorization server module refers to the access token management table and refers to the scope ID in a row matching the current access token ID to be verified. Next in step S. it is determined whether the scope ID referred to in step S. is a single scope ID or multiple scope IDs. Here if the scope ID indicates multiple scope IDs the authorization server module refers to a scope ID list in the scope group table in step S. and determines whether or not the multiple scope IDs are an exact match with the scope ID list . If however the scope ID does not indicate multiple IDs in step S. the process moves to step S.. Furthermore if in step S. the multiple scope IDs do not exactly match the scope ID list the process moves to step S.. If in step S. the multiple scope IDs being verified exactly match the scope ID list the authorization server module determines that the multiple scope IDs correspond to a scope group ID that matches the scope ID list in the scope group table .

In the case where the scope group is determined in step S. the tenant ID that matches the tenant ID obtained in step S. and the scope ID that matches the scope group ID are searched out from the scope group API management table and the API usage number in the same row is incremented by 1. Here in step S. the authorization server module determines whether or not the value of the API usage number in the scope group API management table exceeds the value of the group execution number . If the value of the API usage number exceeds the value of the group execution number the authorization server module returns the value of the API usage number to 0 and then moves to step S.. However if the value of the API usage number does not exceed the value of the group execution number the authorization server module returns success in S. after which the process ends. In step S. the authorization server module confirms the value of the API usage limit number in the column of the API usage number management table referred to earlier and compares the API usage number to the API usage limit number . If the API usage number has not exceeded the API usage limit number in step S. it is determined that the API usage is within the API usage number limit success is returned in step S. and the process ends. However if the API usage number has exceeded the API usage limit number in step S. it is determined that the API usage has exceeded the API usage number limit failure is returned in step S. and the process ends.

The foregoing has described API usage number limit management by scope and by scope group according to the second embodiment. Through this processing the authorization server module can receive from a client a request for a scope used when registering the client and can return a registration error at that point in time if there is insufficient authority. This makes it possible to avoid wasteful client registration.

Embodiment s of the present invention can also be realized by a computer of a system or apparatus that reads out and executes computer executable instructions e.g. one or more programs recorded on a storage medium which may also be referred to more fully as a non transitory computer readable storage medium to perform the functions of one or more of the above described embodiment s and or that includes one or more circuits e.g. application specific integrated circuit ASIC for performing the functions of one or more of the above described embodiment s and by a method performed by the computer of the system or apparatus by for example reading out and executing the computer executable instructions from the storage medium to perform the functions of one or more of the above described embodiment s and or controlling the one or more circuits to perform the functions of one or more of the above described embodiment s . The computer may comprise one or more processors e.g. central processing unit CPU micro processing unit MPU and may include a network of separate computers or separate processors to read out and execute the computer executable instructions. The computer executable instructions may be provided to the computer for example from a network or the storage medium. The storage medium may include for example one or more of a hard disk a random access memory RAM a read only memory ROM a storage of distributed computing systems an optical disk such as a compact disc CD digital versatile disc DVD or Blu ray Disc BD a flash memory device a memory card and the like.

While the present invention has been described with reference to exemplary embodiments it is to be understood that the invention is not limited to the disclosed exemplary embodiments. The scope of the following claims is to be accorded the broadest interpretation so as to encompass all such modifications and equivalent structures and functions.

This application claims the benefit of Japanese Patent Application No. 2013 268093 filed Dec. 25 2013 which is hereby incorporated by reference herein in its entirety.

