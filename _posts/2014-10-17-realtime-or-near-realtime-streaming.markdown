---

title: Real-time or near real-time streaming
abstract: Methods and apparatuses provide real-time or near real-time streaming of content, specified in one or more playlists, using transfer protocols such as an HTTP compliant protocol. In one embodiment, a method can execute a user application on a client device to present media files and to control presentation of the media files. The method can further run a media serving process on the client device to retrieve a playlist specifying the media files and a media source at which the media files are available, to retrieve the media files from the media source, and to decode the media files retrieved. The media serving process can call the user application to process a custom URL in order to obtain an object referred to by the custom URL.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09531779&OS=09531779&RS=09531779
owner: Apple Inc.
number: 09531779
owner_city: Cupertino
owner_country: US
publication_date: 20141017
---
This application is a continuation of U.S. application Ser. No. 13 082 324 filed on Apr. 7 2011 now issued as U.S. Pat. No. 8 892 691 which claims the benefit of the filing dates of the following U.S. provisional applications U.S. provisional application 61 321 767 filed on Apr. 7 2010 and U.S. provisional application 61 351 824 filed on Jun. 4 2010 and this application hereby incorporates by reference herein those provisional applications. This application is also related to the following patent applications 

 7 Application No. 61 320 213 filed on Apr. 1 2010. All of these U.S. provisional applications are incorporated herein by reference to the extent that they are consistent with this disclosure.

The present U.S. patent application is related to the following U.S. patent applications each of which is incorporated herein by reference to the extent they are consistent with this disclosure 

Embodiments of the invention relate to data transmission techniques. More particularly embodiments of the invention relate to techniques that allow streaming of data using non streaming protocols such as for example HyperText Transfer Protocol HTTP .

Streaming of content generally refers to multimedia content that is constantly transmitted from a server device and received by a client device. The content is usually presented to an end user while it is being delivered by the streaming server. The name refers to the delivery method of the medium rather than to the medium itself.

Current streaming services generally require specialized servers to distribute live content to end users. In any large scale deployment this can lead to great cost and requires specialized skills to set up and run. This results in a less than desirable library of content available for streaming.

In one embodiment a system can search for content based upon a date and time. For example in one implementation timestamped tags are created and each of the timestamped tags can be associated with a particular media file. The timestamp in a timestamped tag indicates a beginning date and time of the associated media file. Note that the media file may contain its own internal timestamps. A playlist file can be created with one or more timestamped tags. The playlist file can be distributed and made available for searching by date and time using the date and time in the timestamped tags. In one embodiment the timestamped tags can use a format known as ID2.

In one embodiment a method can execute a user application on a client device to present media files and to control presentation of the media files. The method can further run a media serving process on the client device to retrieve a playlist specifying the media files and a media source at which the media files are available to retrieve the media files from the media source and to decode the media files retrieved. The user application can be configured to communicate with one or more servers through a custom URL or custom protocol or both even though the media serving process is not configured to process the custom URL or custom protocol. The custom URL or custom protocol can specify or provide a decryption key for decrypting encrypted content in the media files.

Some embodiments include one or more application programming interfaces APIs in an environment with calling program code interacting with other program code being called through the one or more interfaces. Various function calls messages or other types of invocations which further may include various kinds of parameters can be transferred via the APIs between the calling program and the code being called. In addition an API may provide the calling program code the ability to use data types or classes defined in the API and implemented in the called program code.

At least certain embodiments include an environment with a calling software component interacting with a called software component through an API. A method for operating through an API in this environment includes transferring one or more function calls messages other types of invocations or parameters via the API.

Other methods are described herein and systems for performing these methods are described herein and machine readable non transitory storage media storing executable instructions which when executed can cause a data processing system to perform any one of these methods are also described herein.

In the following description numerous specific details are set forth. However embodiments of the invention may be practiced without these specific details. In other instances well known circuits structures and techniques have not been shown in detail in order not to obscure the understanding of this description.

The present description includes material protected by copyrights such as illustrations of graphical user interface images. The owners of the copyrights including the assignee of the present invention hereby reserve their rights including copyright in these materials. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office file or records but otherwise reserves all copyrights whatsoever. Copyright Apple Inc. 2009.

In one embodiment techniques and components described herein can include mechanisms to deliver streaming experience using non streaming protocols e.g. HTTP and other technologies e.g. Motion Picture Expert Group MPEG streams . For example near real time streaming experience can be provided using HTTP to broadcast a live musical or sporting event live news a Web camera feed etc. In one embodiment a protocol can segment incoming media data into multiple media files and store those segmented media files on a server. The protocol can also build a playlist file that includes Uniform Resource Identifiers URIs that direct the client to the segmented media files stored on a server. When the segmented media files are played back in accordance with the playlist file s the client can provide the user with a near real time broadcast of a live event. Pre recorded content can be provided in a similar manner.

In one embodiment the server can dynamically introduce supplementary or alternative media content e.g. advertisements statistics related to a sporting event additional media content to the main presentation into the broadcast event. For example during client playback of a media event the server can add additional URIs to the playlist file the URIs may identify a location from which a client can download a supplementary media file. The client can be instructed to periodically retrieve from the server one or more updated playlist file s in order to access any supplementary or additional or both media content the server has introduced.

In one embodiment the server can operate in either cumulative mode or in rolling mode. In cumulative mode the server can create a playlist file and append media file identifiers to the end of the playlist file. The client then has access to all parts of the stream from a single playlist file e.g. a user can start at the middle of a show when downloaded. In rolling mode the server may limit the availability of media files by removing media file identifiers from the beginning of the playlist file on a rolling basis thereby providing a sliding window of media content accessible to a client device. The server can also add media file identifiers to the playlist and in rolling mode the server can limit the availability of media files to those that have been most recently added to the playlist. The client then repeatedly downloads updated copies of the playlist file to continue viewing. The rolling basis for playlist downloading can be useful when the content is potentially unbounded in time e.g. content from a continuously operated web cam . The client can continue to repeatedly request the playlist in the rolling mode until it finds an end tag in the playlist.

In one embodiment the mechanism supports bit rate switching by providing variant streams of the same presentation. For example several versions of a presentation to be served can be stored on the server. Each version can have substantially the same content but be encoded at different bit rates. This can allow the client device to switch between bit rates depending on for example a detection of the available bandwidth without compromising continuity of playback.

In one embodiment protection features may be provided to protect content against unauthorized use. For example non sequential media file numbering may be used to prevent prediction. Encryption of media files may be used. Partial media file lists may be used. Additional and or different protection features may also be provided.

Network may be any type of network whether wired wireless e.g. IEEE 802.11 802.16 or any combination thereof. For example Network may be the Internet or an intranet. As another example network may be a cellular network e.g. 3G CDMA . In one embodiment client devices and may be capable of communicating over multiple network types e.g. each device can communicate over a WiFi wireless LAN and also over a wireless cellular telephone network . For example client devices and may be smart phones or cellular enabled personal digital assistants that can communicate over cellular radiotelephone networks as well as data networks. These devices may be able to utilize the streaming mechanisms described herein over either type of network or even switch between networks as necessary.

Server may operate as a HTTP server in any manner known in the art. That is server includes a HTTP server agent that provides content using HTTP protocols. While the example of is described in terms of HTTP other protocols can be utilized in a similar manner. Segmenter and indexer are agents that reside on server or multiple servers to provide content in media files with a playlist file as described herein. These media files and playlist files may be provided over network via HTTP server agent or via other servers using HTTP protocols. Agents as discussed herein can be implemented as hardware software firmware or a combination thereof.

Segmenter may function to divide the stream of media data into multiple media files that may be transmitted via HTTP protocols. Indexer may function to create a playlist file corresponding to the segmented media files so that client devices can reassemble the media files to provide real time or near real time transmission of the content provided by server . In response to one or more requests from a client device HTTP server agent or other servers may transmit one or more playlist files as generated by indexer and media files of content as generated by segmenter . Server may further include optional security agent that provides one or more of the security functions e.g. encryption discussed herein. Server may also include additional components not illustrated in .

Client devices and may receive the playlist files and media files from server over network . Client devices may be any type of electronic device that is capable of receiving data transmitted over a network and generate output utilizing the data received via the network for example wireless mobile devices PDAs entertainment devices consumer electronic devices etc. The output may be any media type of combination of media types including for example audio video or any combination thereof.

Client device can include assembler agent and output generator agent . Similarly client device can include assembler agent and output generator agent . Assembler agents and receive the playlist files from server and use the playlist files to access and download media files from server . Output generator agents and use the downloaded media files to generate output from client devices and respectively. The output may be provided by one or more speakers one or more display screens a combination of speakers and display screens or any other input or output device. The client devices can also include memory e.g. flash memory or DRAM etc. to act as a buffer to store the media files e.g. compressed media files or decompressed media files as they are received the buffer can provide many seconds worth of presentable content beyond the time of content currently being presented so that the buffered content can later be displayed while new content is being downloaded. This buffer can provide presentable content while the client device is attempting to retrieve content through an intermittently slow network connection and hence the buffer can hide network latency or connection problems.

Client devices and may further include optional security agents and respectively that provide one or more of the security functions discussed herein. Client devices and may also include additional components not illustrated in .

In one embodiment the techniques that are described in this application may be used to transmit an unbounded stream of multimedia data over a non streaming protocol e.g. HTTP . Embodiments can also include encryption of media data and or provision of alternate versions of a stream e.g. to provide alternate bit rates . Because media data can be transmitted soon after creation the data can be received in near real time. Example data formats for files as well as actions to be taken by a server sender and a client receiver of the stream of multimedia data are provided however other formats can also be supported.

A media presentation that can be transmitted as a simulated real time stream or near real time stream is specified by a Universal Resource Indicator URI that indicates a playlist file. In one embodiment the playlist file is an ordered list of additional URIs. Each URI in the playlist file refers to a media file that is a segment of a stream which may be a single contiguous stream of media data for a particular program.

In order to play the stream of media data the client device obtains the playlist file from the server. The client also obtains and plays each media data file indicated by the playlist file. In one embodiment the client can dynamically or repeatedly reload the playlist file to discover additional and or different media segments.

The playlist files may be for example Extended M3U Playlist files. In one embodiment additional tags that effectively extend the M3U format are used. M3U refers to Moving Picture Experts Group Audio Layer 3 Uniform Resource Locator MP3 URL and is a format used to store multimedia playlists. A M3U file is a text file that contains the locations of one or more media files for a media player to play.

The playlist file in one embodiment is an Extended M3U formatted text file that consists of individual lines. The lines can be terminated by either a single LF character or a CR character followed by a LF character. Each line can be a URI a blank line or start with a comment character e.g. . URIs identify media files to be played. Blank lines can be ignored.

Lines that start with the comment character can be either comments or tags. Tags can begin with EXT while comment lines can begin with . Comment lines are normally ignored by the server and client. In one embodiment playlist files are encoded in UTF 8 format. UTF 8 8 bit Unicode Transformation Format is a variable length character encoding format. In alternate embodiments other character encoding formats can be used.

In the examples that follow an Extended M3U format is utilized that includes two tags EXTM3U and EXTINF. An Extended M3U file may be distinguished from a basic M3U file by a first line that includes EXTM3U .

EXTINF is a record marker that describes the media file identified by the URI that follows the tag. In one embodiment each media file URI is preceded by an EXTINF tag for example 

where duration specifies the duration of the media file and title is the title of the target media file.

These tags will each be described in greater detail below. While specific formats and attributes are described with respect to each new tag alternative embodiments can also be supported with different attributes names formats etc.

The EXT X TARGETDURATION tag can indicate in one embodiment the approximate duration of the next media file that will be added to the presentation. It can be included in the playback file and the format can be 

where seconds indicates the duration of the media file. In one embodiment the actual duration may differ slightly from the target duration indicated by the tag. In one embodiment every URI indicating a segment will be associated with an approximate duration of the segment for example the URI for a segment may be prefixed with a tag indicating the approximate duration of that segment. In another embodiment the EXT X TARGETDURATION tag can specify the maximum media file duration the EXTINF duration of each media file in the playlist file should be less than or equal to the target duration and this tag which specifies the maximum media file duration can be specified just once in the playlist file and it applies to all media files in the playlist file and its format can be 

Each media file URI in a playlist file can have a unique sequence number. The sequence number if present of a URI is equal to the sequence number of the URI that preceded it plus one in one embodiment. The EXT X MEDIA SEQUENCE tag can indicate the sequence number of the first URI that appears in a playlist file and the format can be 

where number is the sequence number of the URI. If the playlist file does not include a EXT X MEDIA SEQUENCE tag the sequence number of the first URI in the playlist can be considered 1. A media file s sequence number is not required to appear in its URI in one embodiment and in one embodiment a playlist can contain only one EXT X MEDIA SEQUENCE tag. In one embodiment the sequence numbering can be non sequential for example non sequential sequence numbering such as 1 5 7 17 etc. can make it difficult to predict the next number in a sequence and this can help to protect the content from pirating. Another option to help protect the content is to reveal only parts of a playlist at any given time.

Some media files may be encrypted. The EXT X KEY tag provides information that can be used to decrypt media files that follow it and the format can be 

The METHOD parameter specifies the encryption method and the URI parameter if present specifies how to obtain the key and the IV Initialization Vector if present specifies an initialization vector used in the encryption method e.g. with the key .

An encryption method of NONE indicates no encryption and if NONE is indicated then in one embodiment the URI and IV parameters should not be present. Various encryption methods may be used for example AES 128 which indicates encryption using the Advance Encryption Standard encryption with a 128 bit key and PKCS7 padding see RFC3852 . A new EXT X KEY tag supersedes any prior EXT X KEY tags.

An EXT X KEY tag with a URI parameter identifies the key file. A key file may contain the cipher key that is to be used to decrypt subsequent media files listed in the playlist file. For example the AES 128 encryption method uses 16 octet keys. The format of the key file can be a packed array of 16 octets in binary format.

Use of AES 128 normally requires that the same 16 octet initialization vector IV be supplied when encrypting and decrypting. Varying the IV can be used to increase the strength of the cipher. When using AES 128 encryption the sequence number of the media file can be used as the IV when encrypting or decrypting media files.

The EXT X PROGRAM DATE TIME tag can associate the beginning of the next media file with an absolute date and or time and can include or indicate a time zone. In one embodiment the date time representation is ISO IEC 8601 2004. The value of the date and time in this tag can provide an informative mapping of the timeline of the media to an appropriate wall clock time which may be used as a basis for seeking for display or other purposes content for playback based on a date and time. In one embodiment if a server provides this mapping it should place an EXT X PROGRAM DATE TIME tag after every EXT X DISCONTINUITY tag in the playlist file. The tag format can be 

The EXT X ALLOW CACHE tag can be used to indicate whether the client may cache the downloaded media files for later playback. This tag can appear anywhere in the playlist file in one embodiment but in one embodiment should appear only once in the playlist file. The tag format can be 

The EXT X ENDLIST tag indicates in one embodiment that no more media files will be added to the playlist file. The tag format can be 

In one embodiment if a playlist contains the final segment or media file then the playlist will have the EXT X ENDLIST tag. This tag can appear in one embodiment anywhere in a playlist file and in one embodiment it can occur only once in the playlist file.

The EXT X STREAM INF tag can be used to indicate that the next URI in the playlist file identifies another playlist file. The tag format can be in one embodiment 

where the following attributes may be used. An attribute of the same type in one embodiment of this tag should not appear more than once in the same tag. The attribute BANDWIDTH is an approximate upper bound of the stream bit rate expressed as a number of bits per second. In one embodiment the attribute BANDWIDTH can be an upper bound of the overall bitrate of each media file calculated to include container overhead that appears or will appear in the playlist. The attribute PROGRAM ID is a number that uniquely identifies a particular presentation within the scope of the playlist file. A playlist file may include multiple EXT X STREAM INF URIs with the same PROGRAM ID to describe variant streams of the same presentation and these variant playlists can contain additional EXT X STREAM INF tags. Variant streams and variant playlists are described further in this disclosure e.g. see . The attribute CODECS format format can be used to specify a media sample type that is present in a media file in the playlist file where each format specifies a media sample type in one embodiment valid format identifiers can be those in the ISO File Format Name Space defined by RFC 4281. The attribute RESOLUTION can specify a resolution of video within the stream where N is the approximate encoded horizontal resolution of video within the stream which can be expressed as a number of pixels and M is the approximate encoded vertical resolution.

The EXT X DISCONTINUITY tag indicates an encoding discontinuity between the media file that follows it and the one that preceded it. The set of characteristics that MAY change is 

The EXT X VERSION tag indicates the compatibility version of the playlist file. The playlist file its associated media and its server should in one embodiment comply with all provisions of the most recent version of this document describing the protocol version indicated by the tag value.

A playlist file in one embodiment can contain no more than one EXT X VERSION tag. A playlist file that does not contain an EXT X VERSION tag should in one embodiment comply with version 1 of this protocol. If the playlist file has this tag then its value in one embodiment should be the lowest protocol version with which the server playlist file and associated media files all comply.

The foregoing tags and attributes can be used by the server device to organize transmit and process the media files that represent the original media content. The client devices use this information to reassemble and present the media files in a manner to provide a real time or near real time streaming experience e.g. viewing of a live broadcast such as a music or sporting event to a user of the client device.

Each media file URI in a playlist file identifies a media file that is a segment of the original presentation i.e. original media content . In one embodiment each media file is formatted as a MPEG 2 transport stream a MPEG 2 program stream or a MPEG 2 audio elementary stream. The format can be specified by specifying a CODEC and the playlist can specify a format by specifying a CODEC. In one embodiment all media files in a presentation have the same format however multiple formats may be supported in other embodiments. A transport stream file should in one embodiment contain a single MPEG 2 program and there should be a Program Association Table and a Program Map Table at the start of each file. A file that contains video SHOULD have at least one key frame and enough information to completely initialize a video decoder. A media file in a playlist MUST be the continuation of the encoded stream at the end of the media file with the previous sequence number unless it was the first media file to appear in the playlist file or if it is preceded by an EXT X DISCONTINUITY tag. Clients SHOULD be prepared to handle multiple tracks of a particular type e.g. audio or video by choosing a reasonable subset. Clients should in one embodiment ignore private streams inside Transport Streams that they do not recognize. The encoding parameters for samples within a stream inside a media file and between corresponding streams across multiple media files SHOULD remain consistent. However clients SHOULD deal with encoding changes as they are encountered for example by scaling video content to accommodate a resolution change.

The server device receives content to be provided in operation . The content may represent live audio and or video e.g. a sporting event live news a Web camera feed . The content may also represent pre recorded content e.g. a concert that has been recorded a training seminar etc. . The content may be received by the server according to any format and protocol known in the art whether streamed or not. In one embodiment the content is received by the server in the form of a MPEG 2 stream however other formats can also be supported.

The server may then store temporarily at least portions of the content in operation . The content or at least portions of the content may be stored temporarily for example on a storage device e.g. hard disk in a Storage Area Network etc. or in memory. Alternatively the content may be received as via a storage medium e.g. compact disc flash drive from which the content may be transferred to a storage device or memory. In one embodiment the server has an encoder that converts if necessary the content to one or more streams e.g. MPEG 2 . This conversion can occur without storing permanently the received content and in some embodiments the storage operation may be omitted or it may be a longer term storage e.g. an archival storage in other embodiments.

The content to be provided is segmented into multiple media files in operation . In one embodiment the server converts a stream into separate and distinct media files i.e. segments that can be distributed using a standard web server. In one embodiment the server segments the media stream at points that support effective decode of the individual media files e.g. on packet and key frame boundaries such as PES packet boundaries and i frame boundaries . The media files can be portions of the original stream with approximately equal duration. The server also creates a URI for each media file. These URIs allow client devices to access the media files.

Because the segments are served using HTTP servers which inherently deliver whole files the server should have a complete segmented media file available before it can be served to the clients. Thus the client may lag in time the broadcast by at least one media file length. In one embodiment media file size is based on a balance between lag time and having too many files.

In one embodiment two session types live session and event session are supported. For a live session only a fixed size portion of the stream is preserved. In one embodiment content media files that are out of date are removed from the program playlist file and can be removed from the server. The second type of session is an event session where the client can tune into any point of the broadcast e.g. start from the beginning start from a mid point . This type of session can be used for rebroadcast for example.

The media files are stored in the server memory in operation . The media files can be protected by a security feature such as encryption before storing the files in operation . The media files are stored as files that are ready to transmit using the network protocol e.g. HTTP or HTTPS supported by the Web server application on the server device or supported by another device which does the transmission .

One or more playlist files are generated to indicate the order in which the media files should be assembled to recreate the original content in operation . The playlist file s can utilize Extended M3U tags and the tags described herein to provide information for a client device to access and reassemble the media files to provide a streaming experience on the client device. A URI for each media file is included in the playlist file s in the order in which the media files are to be played. The server can also create one or more URIs for the playlist file s to allow the client devices to access the playlist file s .

The playlist file s can be stored on the server in operation . While the creation and storing of media files and playlist file s are presented in a particular order in a different order may also be used. For example the playlist file s may be created before the media files are created or stored. As another example the playlist file s and media files may be created before either are stored.

If media files are to be encrypted the playlist file s can define a URI that allows authorized client devices to obtain a key file containing an encryption key to decrypt the media files. An encryption key can be transmitted using a secure connection e.g. HTTPS . As another example the playlist file s may be transmitted using HTTPS. As a further example media files may be arranged in an unpredictable order so that the client cannot recreate the stream without the playlist file s .

If the encryption method is AES 128 AES 128 CBC encryption for example may be applied to individual media files. In one embodiment the entire file is encrypted. Cipher block chaining is normally not applied across media files in one embodiment. The sequence number of the media files can be used as the IV or the IV can be the value of the IV attribute of the EXT X KEY tag as described above. In one embodiment the server adds an EXT X KEY tag with the key URI to the end of the playlist file. The server then encrypts all subsequent media files with that key until a change in encryption configuration is made.

To switch to a new encryption key the server can make the new key available via a new URI that is distinct from all previous key URIs used in the presentation. The server also adds an EXT X KEY tag with the new key URI to the end of a playlist file and encrypts all subsequent media files with the new key.

To end encryption the server can add an EXT X KEY tag with the encryption method NONE at the end of the playlist file. The tag with NONE as the method does not include a URI parameter in one embodiment. All subsequent media files are not encrypted until a change in encryption configuration is made as described above. The server does not remove an EXT X KEY tag from a playlist file if the playlist file contains a URI to a media file encrypted with that key. The server can transmit the playlist file s and the media files over the network in response to client requests in operation as described in more detail with respect to .

In one embodiment a server transmits the playlist file to a client device in response to receiving a request from a client device for a playlist file. The client device may access request the playlist file using a URI that has been provided to the client device. The URI indicates the location of the playlist file on the server. In response the server may provide the playlist file to the client device. The client device may the utilize tags and URIs or other identifiers in the playlist file to access the multiple media files.

In one embodiment the server may limit the availability of media files to those that have been most recently added to the playlist file s . To do this each playlist file can include only one EXT X MEDIA SEQUENCE tag and the value can be incremented by one for every media file URI that is removed from the playlist file. Media file URIs can be removed from the playlist file s in the order in which they were added. In one embodiment when the server removes a media file URI from the playlist file s the media file remains available to clients for a period of time equal to the duration of the media file plus the duration of the longest playlist file in which the media file has appeared.

The duration of a playlist file is the sum of the durations of the media files within that playlist file. Other durations can also be used. In one embodiment the server can maintain at least three main presentation media files in the playlist at all times unless the EXT X ENDLIST tag is present.

The server device receives content to be provided in operation . The server may then temporarily store at least portions of the content in operation . Operation can be similar to operation in . The content to be provided is segmented into multiple media files in operation . The media files can be stored in the server memory in operation . The media files can be protected by a security feature such as encryption before storing the files in operation .

One or more playlist files are generated to indicate the order in which the media files should be assembled to recreate the original content in operation . The playlist file s can be stored on the server in operation . While the creation and storing of media files and playlist file s are presented in a particular order in a different order may also be used.

The server or another server can transmit the playlist file s and the media files over the network in response to client requests in operation as described in more detail with respect to .

The playlist file s may be updated by a server for various reasons. The server may receive additional data to be provided to the client devices in operation . The additional data can be received after the playlist file s are stored in operation . The additional data may be for example additional portions of a live presentation or additional information for an existing presentation. Additional data may include advertisements or statistics e.g. scores or data relating to a sporting event . The additional data could be overlaid through translucency on the presentation or be presented in a sidebar user interface. The additional data can be segmented in the same manner as the originally received data. If the additional data constitutes advertisements or other content to be inserted into the program represented by the playlist the additional data can be stored at least temporarily in operation segmented in operation and stored in operation prior to storage of the segmented additional data the segments of the additional data can be encrypted. Then in operation an updated playlist containing the program and the additional data would be generated. The playlist is updated based on the additional data and stored again in operation . Changes to the playlist file s should be made atomically from the perspective of the client device. The updated playlist replaces in one embodiment the previous playlist. As discussed below in greater detail client devices can request the playlist multiple times. These requests enable the client devices to utilize the most recent playlist. In one embodiment the additional data may be metadata in this case the playlist does not need to be updated but the segments can be updated to include metadata. For example the metadata may contain timestamps which can be matched with timestamps in the segments and the metadata can be added to segments having matching timestamps.

The updated playlist may also result in the removal of media files. In one embodiment a server should remove URIs for the media files from the playlist in the order in which they were added to the playlist. In one embodiment if the server removes an entire presentation it makes the playlist file s unavailable to client devices. In one embodiment the server maintains the media files and the playlist file s for the duration of the longest playlist file s containing a media file to be removed to allow current client devices to finish accessing the presentation. Accordingly every media file URI in the playlist file can be prefixed with an EXT X STREAM INF tag to indicate the approximate cumulative duration of the media files indicated by the playlist file. In alternate embodiments the media files and the playlist file s may be removed immediately.

Subsequent requests for the playlist from client devices result in the server providing the updated playlist in operation . In one embodiment playlists are updated on a regular basis for example a period of time related to the target duration. Periodic updates of the playlist file allow the server to provide access to servers to a dynamically changing presentation.

In one embodiment the server can offer multiple playlist files or a single playlist file with multiple media file lists in the single playlist file to provide different encodings of the same presentation. If different encodings are provided playlist file s may include each variant stream providing different bit rates to allow client devices to switch between encodings dynamically this is described further in connection with . Playlist files having variant streams can include an EXT X STREAM INF tag for each variant stream. Each EXT X STREAM INF tag for the same presentation can have the same PROGRAM ID attribute value. The PROGRAM ID value for each presentation is unique within the variant streams.

In one embodiment the server meets the following constraints when producing variant streams. Each variant stream can consist of the same content including optional content that is not part of the main presentation. The server can make the same period of content available for all variant streams within an accuracy of the smallest target duration of the streams. The media files of the variant streams are in one embodiment either MPEG 2 Transport Streams or MPEG 2 Program Streams with sample timestamps that match for corresponding content in all variant streams. Also all variant streams should in one embodiment contain the same audio encoding. This allows client devices to switch between variant streams without losing content.

Referring to the server device receives content to be provided in operation . The server may then at least temporarily store the content in operation . The content to be provided is segmented into multiple media files in operation . Each media file is encoded for a selected bit rate or a selected value of other encoding parameters and stored on the server in operation . For example the media files may be targeted for high medium and low bandwidth connections. The media files can be encrypted prior to storage. The encoding of the media files targeted for the various types of connections may be selected to provide a streaming experience at the target bandwidth level.

In one embodiment a variant playlist is generated in operation with tags as described herein that indicate various encoding levels. The tags may include for example an EXT X STREAM INF tag for each encoding level with a URI to a corresponding media playlist file.

This variant playlist can include URIs to media playlist files for the various encoding levels. Thus a client device can select a target bit rate from the alternatives provided in the variant playlist indicating the encoding levels and retrieve the corresponding playlist file. In one embodiment a client device may change between bit rates during playback e.g. as described with respect to . The variant playlist indicating the various encoding levels is stored on the server in operation . In operation each of the playlists referred to in the variant playlist can also be generated and then stored in operation .

In response to a request from a client device the server may transmit the variant playlist that indicates the various encoding levels in operation . The server may receive a request for one of the media playlists specified in the variant playlist corresponding to a selected bit rate in operation . In response to the request the server transmits the media playlist file corresponding to the request from the client device in operation . The client device may then use the media playlist to request media files from the server. The server provides the media files to the client device in response to requests in operation .

The client device may request a playlist file from a server in operation . In one embodiment the request is made according to an HTTP compliant protocol. The request utilizes a URI to an initial playlist file stored on the server. In alternate embodiments other non streaming protocols can be supported. In response to the request the server will transmit the corresponding playlist file to the client over a network. As discussed above the network can be wired or wireless and can be any combination of wired or wireless networks. Further the network may be a data network e.g. IEEE 802.11 IEEE 802.16 or a cellular telephone network e.g. 3G .

The client device can receive the playlist file in operation . The playlist file can be stored in a memory of the client device in operation . The memory can be for example a hard disk a flash memory a random access memory. In one embodiment each time a playlist file is loaded or reloaded from the playlist URI the client checks to determine that the playlist file begins with a EXTM3U tag and does not continue if the tag is absent. As discussed above the playlist file includes one or more tags as well as one or more URIs to media files.

The client device can include an assembler agent that uses the playlist file to reassemble the original content by requesting media files indicated by the URIs in the playlist file in operation . In one embodiment the assembler agent is a plug in module that is part of a standard Web browser application. In another embodiment the assembler agent may be a stand alone application that interacts with a Web browser to receive and assemble the media files using the playlist file s . As a further example the assembler agent may be a special purpose hardware or firmware component that is embedded in the client device.

The assembler causes media files from the playlist file to be downloaded from the server indicated by the URIs. If the playlist file contains the EXT X ENDLIST tag any media file indicated by the playlist file may be played first. If the EXT X ENDLIST tag is not present any media file except for the last and second to last media files may be played first. Once the first media file to play has been chosen subsequent media files in the playlist file are loaded in one embodiment in the order that they appear in the playlist file otherwise the content is presented out of order . In one embodiment the client device attempts to load media files in advance of when they are required and stores them in a buffer to provide uninterrupted playback and to compensate for temporary variations in network latency and throughput.

The downloaded media file s can be stored in a memory on the client device in operation . The memory in which the content can be stored may be any type of memory on the client device for example random access memory a hard disk or a video buffer. The storage may be temporary to allow playback or may be permanent. If the playlist file contains the EXT X ALLOW CACHE tag and its value is NO the client does not store the downloaded media files after they have been played. If the playlist contains the EXT X ALLOW CACHE tag and its value is YES the client device may store the media files indefinitely for later replay. The client device may use the value of the EXT X PROGRAM DATE TIME tag to display the program origination time to the user. In one embodiment the client can buffer multiple media files so that it is less susceptible to network jitter in order to provide a better user experience.

In one embodiment if the decryption method is AES 128 then AES 128 CBC decryption is applied to the individual media files. The entire file is decrypted. In one embodiment cipher block chaining is not applied across media files. The sequence number of the media file can be used as the initialization vector as described above.

From the memory the content can be output from the client device in operation . The output or presentation may be for example audio output via built in speakers or head phones. The output may include video that is output via a screen or projected from the client device. Any type of output known in the art may be utilized. In operation the client device determines whether there are any more media files in the stored current playlist which have not been played or otherwise presented. If such media files exist and if they have not been requested then processing returns to operation in which one or more media files are requested and the process repeats. If there are no such media files i.e. all media files in the current playlist have been played then processing proceeds to operation which determines whether the playlist file includes an end tag.

If the playlist includes an end tag e.g. EXT X ENDLIST in operation playback ceases when the media files indicated by the playlist file have been played. If the end tag is not in the playlist then the client device requests a playlist again from the server and reverts back to operation to obtain a further or updated playlist for the program.

As discussed in greater detail with respect to a server may update a playlist file to introduce supplementary content e.g. additional media file identifiers corresponding to additional media content in a live broadcast or additional content e.g. content further down the stream . To access the supplementary content or additional content a client can reload the updated playlist from the server. This can provide a mechanism by which playlist files can be dynamically updated even during playback of the media content associated with a playlist file. A client can request a reload of the playlist file based on a number of triggers. The lack of an end tag is one such trigger.

In one embodiment the client device periodically reloads the playlist file s unless the playlist file contains the EXT X ENDLIST tag. When the client device loads a playlist file for the first time or reloads a playlist file and finds that the playlist file has changed since the last time it was loaded the client can wait for a period of time before attempting to reload the playlist file again. This period is called the initial minimum reload delay. It is measured from the time that the client began loading the playlist file.

In one embodiment the initial minimum reload delay is the duration of the last media file in the playlist file or three times the target duration whichever is less. The media file duration is specified by the EXTINF tag. If the client reloads a playlist file and finds that it has not changed then the client can wait for a period of time before retrying. The minimum delay in one embodiment is three times the target duration or a multiple of the initial minimum reload delay whichever is less. In one embodiment this multiple is 0.5 for a first attempt 1.5 for a second attempt and 3.0 for subsequent attempts however other multiples may be used.

Each time a playlist file is loaded or reloaded the client device examines the playlist file to determine the next media file to load. The first file to load is the media file selected to play first as described above. If the first media file to be played has been loaded and the playlist file does not contain the EXT X MEDIA SEQUENCE tag then the client can verify that the current playlist file contains the URI of the last loaded media file at the offset where it was originally found halting playback if the file is not found. The next media file to load can be the first media file URI following the last loaded URI in the playlist file.

If the first file to be played has been loaded and the playlist file contains the EXT X MEDIA SEQUENCE tag then the next media file to load can be the one with the lowest sequence number that is greater than the sequence number of the last media file loaded. If the playlist file contains an EXT X KEY tag that specifies a key file URI the client device obtains the key file and uses the key inside the key file to decrypt the media files following the EXT X KEY tag until another EXT X KEY tag is encountered.

In one embodiment the client device utilizes the same URI as previously used to download the playlist file. Thus if changes have been made to the playlist file the client device may use the updated playlist file to retrieve media files and provide output based on the media files.

Changes to the playlist file may include for example deletion of a URI to a media file addition of a URI to a new media file replacement of a URI to a replacement media file. When changes are made to the playlist file one or more tags may be updated to reflect the change s . For example the duration tag may be updated if changes to the media files result in a change to the duration of the playback of the media files indicated by the playlist file.

The client device can request a playlist file in operation . As discussed above the playlist file may be retrieved utilizing a URI provided to the client device. In one embodiment the playlist file includes listings of variant streams of media files to provide the same content at different bit rates in other words a single playlist file includes URIs for the media files of each of the variant streams. The example shown in uses this embodiment. In another embodiment the variant streams may be represented by multiple distinct playlist files separately provided to the client that each provides the same content at different bit rates and a variant playlist can provide a URI for each of the distinct playlist files. This allows the client device to select the bit rate based on client conditions.

The playlist file s can be retrieved by the client device in operation . The playlist file s can be stored in the client device memory in operation . The client device may select the bit rate to be used in operation based upon current network connection speeds. Media files are requested from the server utilizing URIs included in the playlist file corresponding to the selected bit rate in operation . The retrieved media files can be stored in the client device memory. Output is provided by the client device utilizing the media files in operation and the client device determines whether to change the bit rate.

In one embodiment a client device selects the lowest available bit rate initially. While playing the media the client device can monitor available bandwidth e.g. current network connection bit rates to determine whether the available bandwidth can support use of a higher bit rate for playback. If so the client device can select a higher bit rate and access the media files indicated by the higher bit rate media playlist file. The reverse can also be supported. If the playback consumes too much bandwidth the client device can select a lower bit rate and access the media files indicated by the lower bit rate media playlist file.

If the client device changes the bit rate in operation for example in response to a change in available bandwidth or in response to user input the client device may select a different bit rate in operation . In one embodiment to select a different bit rate the client device may utilize a different list of URIs included in the playlist file that corresponds to the new selected bit rate. In one embodiment the client device may change bit rates during access of media files within a playlist.

If the bit rate does not change in operation then the client device determines whether there are any more unplayed media files in the current playlist which have not been retrieved and presented. If such media files exist then processing returns to operation and one or more media files are retrieved using the URIs for those files in the playlist. If there are no such media files i.e. all media files in the current playlist haven been played then processing proceeds to operation in which it is determined whether the playlist includes an end tag. If it does the playback of the program has ended and the process has completed if it does not then processing reverts to operation and the client device requests to reload the playlist for the program and the process repeats through the method shown in .

Server stream agent includes memory which represents a memory device or access to a memory resource for storing data or instructions. Memory may include memory local to server stream agent as well as or alternatively including memory of the host system on which server stream agent resides. Server stream agent also includes one or more interfaces which represent access interfaces to from an input output interface server stream agent with regard to entities electronic or human external to server stream agent .

Server stream agent also can include server stream engine which represents one or more functions that enable server stream agent to provide the real time or near real time streaming as described herein. The example of provides several components that may be included in server stream engine however different or additional components may also be included. Example components that may be involved in providing the streaming environment include segmenter indexer security and file server . Each of these components may further include other components to provide other functions. As used herein a component refers to routine a subsystem etc. whether implemented in hardware software firmware or some combination thereof.

Segmenter divides the content to be provided into media files that can be transmitted as files using a Web server protocol e.g. HTTP . For example segmenter may divide the content into predetermined fixed size blocks of data in a pre determined file format.

Indexer may provide one or more playlist files that provide an address or URI to the media files created by segmenter . Indexer may for example create one or more files with a listing of an order for identifiers corresponding to each file created by segmenter . The identifiers may be created or assigned by either segmenter or indexer . Indexer can also include one or more tags in the playlist files to support access and or utilization of the media files.

Security may provide security features e.g. encryption such as those discussed above. Web server may provide Web server functionality related to providing files stored on a host system to a remote client device. Web server may support for example HTTP compliant protocols.

Client stream agent includes memory which represents a memory device or access to a memory resource for storing data and or instructions. Memory may include memory local to client stream agent as well as or alternatively including memory of the host system on which client stream agent resides. Client stream agent also includes one or more interfaces which represent access interfaces to from an input output interface client stream agent with regard to entities electronic or human external to client stream agent .

Client stream agent also can include client stream engine which represents one or more functions that enable client stream agent to provide the real time or near real time streaming as described herein. The example of provides several components that may be included in client stream engine however different or additional components may also be included. Example components that may be involved in providing the streaming environment include assembler output generator and security . Each of these components may further include other components to provide other functions. As used herein a component refers to routine a subsystem etc. whether implemented in hardware software firmware or some combination thereof.

Assembler can utilize a playlist file received from a server to access the media files via Web server protocol e.g. HTTP from the server. In one embodiment assembler may cause to be downloaded media files as indicated by URIs in the playlist file. Assembler may respond to tags included in the playlist file.

Output generator may provide the received media files as audio or visual output or both audio and visual on the host system. Output generator may for example cause audio to be output to one or more speakers and video to be output to a display device. Security may provide security features such as those discussed above.

Begin tag can indicate the beginning of a playlist file. In one embodiment begin tag is a EXTM3U tag. Duration tag can indicate the duration of the playback list That is the duration of the playback of the media files indicated by playback list . In one embodiment duration tag is an EXT X TARGETDURATION tag however other tags can also be used.

Date Time tag can provide information related to the date and time of the content provided by the media files indicated by playback list . In one embodiment Date Time tag is an EXT X PROGRAM DATE TIME tag however other tags can also be used. Sequence tag can indicate the sequence of playlist file in a sequence of playlists. In one embodiment sequence tag is an EXT X MEDIA SEQUENCE tag however other tags can also be used.

Security tag can provide information related to security and or encryption applied to media files indicated by playlist file . For example the security tag can specify a decryption key to decrypt files specified by the media file indicators. In one embodiment security tag is an EXT X KEY tag however other tags can also be used. Variant list tag can indicate whether variant streams are provided by playlist as well as information related to the variant streams e.g. how many bit rate . In one embodiment variant list tag is an EXT X STREAM INF tag.

Media file indicators can provide information related to media files to be played. In one embodiment media file indicators include URIs to multiple media files to be played. In one embodiment the order of the URIs in playlist corresponds to the order in which the media files should be accessed and or played. Subsequent playlist indictors can provide information related to one or more playback files to be used after playback file . In one embodiment subsequent playlist indicators can include URIs to one or more playlist files to be used after the media files of playlist have been played.

Memory tag can indicate whether and or how long a client device may store media files after playback of the media file content. In one embodiment memory tag is an EXT X ALLOW CACHE tag. End tag indicates whether playlist file is the last playlist file for a presentation. In one embodiment end tag is an EXT X ENDLIST tag.

If control input is detected in operation the client device can determine if the input indicates a stop in operation . If the input is a stop the process concludes and playback stops. If the input indicates a rewind or forward request in operation the client device can generate output based on previously played media files still stored in memory in operation . If these files are no longer in a cache then processing reverts to operation to retrieve the media files and repeats the process. In an alternate embodiment playback can support a pause feature that halts playback without concluding playback as with a stop input.

Methods for transitioning from one stream to another stream are further described with reference to . One client device can perform each of these methods or the operations of each of these methods can be distributed across multiple client devices as described herein for example in the distributed case one client device can retrieve the variant playlist and the two media playlists and provide those to another client device which retrieves media files specified by the two media playlists and switches between the two streams provided by the retrieved media files. It will also be understood that in alternative embodiments the order of the operations shown may be modified or there can be more or fewer operations than shown in these figures. The methods can use a variant playlist to select different streams. A variant playlist can be retrieved and processed in operation to determine available streams for a program e.g. a sporting event . Operation can be done by a client device. A first stream can be selected from the variant playlist in operation and a client device can then retrieve a media playlist for the first stream. The client device can process the media playlist for the first stream in operation and also measure or otherwise determine a bit rate of the network connection for the first stream in operation . It will be appreciated that the sequence of operations may be performed in an order which is different than what is shown in for example operation may be performed during operation etc. In operation the client device selects an alternative media playlist from the variant playlist based on the measured bit rate from operation this alternative media playlist may be at a second bit rate that is higher than the existing bit rate of the first stream. This typically means that alternative stream will have a higher resolution than the first stream. The alternative media playlist can be selected if it is a better match than the current playlist for the first stream based on current conditions e.g. the bit rate measured in operation . In operation the alternative media playlist for an alternate stream is retrieved and processed. This typically means that the client device can be receiving and processing both the first stream and the alternative stream so both are available for presentation one is presented while the other is ready to be presented. The client device then selects a transition point to switch between the versions of the streams in operation and stops presenting the first stream and begins presenting the alternative stream. Examples of how this switch is accomplished are provided in conjunction with . In some embodiments the client device can stop receiving the first stream before making the switch.

The method shown in represents one embodiment for determining the transition point this embodiment relies upon a pattern matching on audio samples from the two streams and to determine the transition point. It will be appreciated that alternative embodiments can use pattern matching on video samples or can use the timestamps in the two streams etc. to determine the transition point. The method can include in operation storing content e.g. stream specified by the first media playlist in a buffer the buffer can be used for the presentation of the content and also for the pattern matching operation. The stream includes both audio samples A and video samples B. The video samples can use a compression technique which relies on i frames or key frames which have all necessary content to display a single video frame. The content in stream can include timestamps specifying a time e.g. time elapsed since the beginning of the program and these timestamps can mark the beginning of each of the samples e.g. the beginning of each of the audio samples A and the beginning of each of the video samples B . In some cases a comparison of the timestamps between the two streams may not be useful in determining a transition point because they may not be precise enough or because of the difference in the boundaries of the samples in the two streams however a comparison of the timestamps ranges can be used to verify there is an overlap in time between the two streams. In operation the client device stores in a buffer content specified by the second media playlist this content is for the same program as the content obtained from the first media playlist and it can include timestamps also. In one embodiment timestamps if not present in a stream can be added to a playlist for a stream for example in one embodiment an ID3 tag which includes one or more timestamps can be added to an entry in a playlist such as a variant playlist or a media playlist. The entry may for example be in a URI for a first sample of an audio stream. shows an example of content obtained from the second media playlist and this includes audio samples A and video samples B. In operation the client device can perform a pattern matching on the audio samples in the two streams and to select from the overlap the transition point which can be in one embodiment the next self contained video frame e.g. i frame after the matched audio segments e.g. segments . Beginning with i frame and its associated audio sample presentation of the program uses the second stream obtained from the second media playlist. The foregoing method can be used in one embodiment for both a change from a slower to a faster bit rate and for a change from a faster to a slower bit rate but in another embodiment the method can be used only for a change from a slower to a faster bit rate and another method e.g. do not attempt to locate a transition point but attempt to store and present content from the slower bit rate stream as soon as possible can be used for a change from a faster to a slower bit.

Note that the backup streams are intermixed with the primary streams in the playlist with the backup at each bandwidth is listed after the primary for that bandwidth. A client is not limited to a single backup stream set. In the example above ALPHA and BETA could be followed by GAMMA for instance. Similarly it is not necessary to provide a complete parallel set of streams. A single low bandwidth stream may be provided on a backup server for example.

In operation the client attempts to download playlist file s from a first URL using a first stream associated with the first server device or the first content distribution service. illustrates a network in which a client communicates bi directionally with one or more URLs server devices or content distribution services in accordance with one embodiment. The playlist file s may be transmitted from the first URL server device or content distribution service in operation to the client . If a client is unable to download the playlist file s from the first URL server device or content distribution service e.g. due to an error in reloading the index file for a stream the client attempts to switch to an alternate stream. In the event of a failure e.g. index load failure on one stream e.g. operation the client chooses the highest bandwidth alternate stream that the network connection supports in operation . If there are multiple alternates at the same bandwidth the client chooses among them in the order listed in the playlist. For example if the client is not able to successfully download from URL it may download from URL or another URL in which case the playlist file s are transmitted from the alternative URL to the client. This feature provides redundant streams that will allow media to reach clients even in the event of severe local failures such as a server crashing or a content distributor node going down.

The failover protection provides the ability to provide multiple redundant locations from which clients can retrieve playlists and media files. Thus if the client cannot retrieve a stream from a first location it can attempt to access the stream from a secondary tertiary etc. location.

In one embodiment to indicate the additional locations from which the client can retrieve a playlist the same variant playlist tag would be provided with the same bandwidth but a new URI of the redundant location. The client initially can attempt to access the first URL associated with the desired bandwidth. If it cannot download the playlist from the first URL it then can attempt to access the next URL presented for the bandwidth and so on until it has exhausted all the possibilities.

An example below includes 1 redundant location for the 2560000 bandwidth and 2 redundant locations for the 7680000 bandwidth.

Note that in this example both the filenames e.g. mid redundant2.m3u8 and the actual URL e.g. http example2.com http example3.com change. However in one embodiment a redundant location can be a change only to the filename or only to the website.

In one embodiment a playlist can be compressed by a server device and sent to a client device in a compressed form. The compressed playlist normally requires fewer bits to represent the playlist than an uncompressed playlist and hence a compressed playlist uses less available bandwidth of a network such as a wireless cellular telephone network when being transmitted or received. In one embodiment the playlist can be compressed by a web server according to a built in compression technique or facility that is used by a web server that is compliant with or compatible with a transfer protocol such as the HTTP 1.1 standard protocol an example of such a compression technique or facility is the deflate or the gzip compression facility of HTTP 1.1. Other standards based compression facilities which are part of a standards based transfer protocol can be used in other embodiments. The use of compressed playlists can be in one embodiment an optional feature of server devices and client devices. In one embodiment the playlist can be textual content e.g. a text file and be compressed efficiently with deflate or gzip by a standards based web server and then decompressed automatically by a client device. A description of a version of the gzip compression facility can be found at www.ietf.org rfc rfc1952.txt a version of the deflate compression facility can be found at www.ietf.org rfc rfc1951.txt. Many web servers and many web browsers on a client device can automatically support the deflate or the gzip facilities.

In one embodiment a client device can periodically request an updated playlist for example the client device can request from a server an updated playlist every few seconds e.g. every 10 20 or 30 seconds or some other period of time . A growing playlist such as a playlist for a live on going baseball game that allows a client to start viewing from the beginning of the live game at any time during the live game can become large enough that use of compression can limit the consumption of a network s bandwidth as the growing playlist is repeatedly sent through the network.

In one embodiment a client device can optionally specify when it requests a playlist such as an updated playlist what compression techniques it can support such as deflate or gzip support for these techniques means that the client device can decompress or decode the compressed or encoded content. The client device s request for a playlist with the optional specification of a compression technique is received by a web server which in one embodiment is not required to support a compression technique for a playlist but can send an uncompressed playlist. The web server can respond to the client device s request by sending to the client device an uncompressed playlist or a playlist compressed using one of the compression techniques specified in the client device s request for the playlist. The client device receives the playlist and uses it as described herein if the playlist is compressed it is decoded using a decoder on the client device such as a decoder in a web browser on the client device.

Referring now to operation can be used to establish a target duration as a maximum media file duration of each media file in a playlist if an endlist tag is not present in a next playlist file as determined in operation . Operation can be performed by a data processing system which is dividing a stream of data into multiple media files and storing those multiple media files as individual files. The process of dividing the stream can utilize the target duration e.g. the target duration of the current playlist file to ensure that each media file specified in the playlist file is less than the target duration or is less than the target duration plus or minus a small period of time . The data processing system which generates a playlist can also ensure that the duration of the playlist file can be at least a multiple of the target duration as shown in operation . In one embodiment the multiple can be three target durations or some other multiple of the target duration which is used as a minimum of a playlist duration wherein the duration of a playlist is defined by the cumulative durations of the media files specified within the playlist. A system e.g. a server that generates a playlist can comply with the minimum duration of the playlist by ensuring that each playlist specify at least a sufficient number of media files to satisfy the minimum duration for example if the minimum duration is 3 target durations then each playlist should include at least 3 target durations.

Operation can also be used as a further mechanism to ensure that a consistent and continuous stream is made available from a data processing system such as a server which is transmitting the media files. This further mechanism can reduce the amount of polling or pulling by a client device to determine whether there are changes to the playlist. In operation a server can be set up such that there is an earliest time and a latest time for the server to transmit the next playlist file. The earliest time and the latest time can be used as a time window that is based on or relative to the time that the previous playlist file which immediately precedes the new playlist file was made available. The earliest time can for example be based upon a time when an immediately previous playlist was first made available for transmission but not necessarily have been transmitted from the server. The latest time can for example also be based upon a time when that immediately previous playlist was first made available for transmission from the server but not necessarily have been transmitted . For example in one embodiment the earliest time may be specified as a time that is no earlier than a first predetermined percentage e.g. one half of the target duration e.g. the target duration set in operation from when the previous playlist file was first made available for transmission and the latest time can be set to be no later than a second predetermined percentage e.g. one and a half times of the target duration from when the immediately previous playlist file was first made available for transmission from the server. The time of when the playlist file was first made available for transmission could be in one embodiment the time of creation of the playlist file that time being recorded by a file system on the server . This example is shown in which includes a timeline . Target duration is a portion of the playlist duration which represents the duration of an immediately previous playlist that was first made available by one or more servers at time which is the time at which the previous playlist file was first made available for transmission. The media files specified in that playlist can begin their transmission at nearly time . According to the server timing model shown in a server should not transmit the next playlist file until the earliest time which is one half of a target duration after time and the server should not make available the next playlist file any later than time which has been specified to be one and a half target durations after time in the example shown in . This server timing model can be used to ensure that playlist files are made available to client devices to provide the client device with enough time to retrieve media files specified in the playlist and to then present those media files consistently and continuously without stalls in the presentation of the content during playback. In one embodiment these server timing models can be used when the content is a transmission of a live event and a stream of data from the live event is being divided into multiple media files and then those multiple media files are transmitted in near real time relative to the live event to client devices that receive the multiple media files shortly after they were divided out of the stream of data of the live event such as a baseball game etc.

Another aspect of the present invention relates to methods which can be used when switching between streams from two playlists e.g. two variant streams or other switching between two sets of media files. An example of a method for switching between streams from two different playlists has been provided in conjunction with . In that method an overlap in time between the two streams can be used to ensure a consistent and continuous playback such that a switch or transition between the streams can be seamless. As shown in the overlap represents a period in time in which media content from both streams is stored at a client device and capable of being played back at the client device thereby allowing a seamless switch between the two streams. In one embodiment the overlap may be a minimum number which never varies and is set within the client device. While this embodiment can work well there can be times when the overlap can be unnecessarily too long. In other words the overlap can prevent a switch or transition from occurring even though a device is ready to make the transition. For example when switching from a lower resolution to a higher resolution an unnecessarily long overlap can force the user to watch the lower resolution presentation for a period of time when the higher resolution presentation is already available and ready to be presented. Higher speed connections can for example provide the ability to quickly develop an overlap which can be shorter than an overlap required for a lower speed connection or type of connection. In an embodiment according to a client device can adapt to the connection speed or connection type and modify the minimum overlap required based upon the connection speed or connection type. For example if the connection speed or type is fast then the minimum overlap can be reduced relative to a minimum overlap required for a lower connection speed or connection type. As conditions change e.g. the client device loses a 3G connection and must rely upon a 2G or slower connection then the minimum overlap can be changed. Hence the client device can adapt the minimum overlap based upon the connection speed or type. Referring now to in operation a client device can determine a speed of or type of connection. Referring back to it can be seen that a second stream of data from a second playlist is a new source of data which is being received while the client device also receives the stream from a first playlist. At this time the client device can determine a speed of connection or a type of connection in order to determine in operation a minimum amount of overlap required based upon the current connection speed or connection type. As conditions change this minimum overlap can be adapted based upon the changing conditions such as wireless connections to cellular telephone towers WiFi basestations etc. This may be particularly advantageous when the client device is moving through a wireless cellular telephone network or other data network. After establishing that the minimum overlap for the current condition exists then the client device can in operation switch or transition from the stream from the first playlist or the old source to the new source which may be the stream from the second playlist. An example of this transition has been provided in connection with the description associated with .

Another aspect of the present invention can utilize an attribute defining a resolution of images. This attribute can allow a client device to decide that it should not switch resolutions or otherwise switch streams based upon the attribute. For example a client device can decide that it is already playing the maximum resolution which it can display and that there is no point in downloading a higher resolution which may be available to the device through a data network.

An embodiment of the invention can allow a system to search for content based upon a date and time. For example a user may want to see a home run hit on Apr. 9 2009 at about 5 PM or may want to see another event on a date and approximate time. An embodiment of the invention can provide this capability by timestamping through the use of an EXT X PROGRAM DATE TIME tag that is associated with the beginning of a corresponding media file the tag can be associated with its corresponding media file by having the tag appear before that media file in a playlist file. A system such as a server can store one or more playlists which can be retrieved e.g. downloaded by a client device and used to search for a date and time to find a desired media file alternatively a client device can request e.g. through a date and time search request the server to search through the one or more playlists to identify one or more media files that match the date and time search request and the server can respond by identifying the one or more media files. In one embodiment the tag indicates a substantially precise beginning of the media files and timestamps within the media file can be used to find a playback point with finer granularity in time. For example a tag s timestamp can indicate the media file began on Apr. 9 2009 at 5 03 PM and the timestamps or other indicators of time within a media file can specify time in increments of minutes or seconds etc. after 5 03 PM to allow a device to begin playback through a selection of a playback start point at for example 5 06 PM or 5 05 30 PM.

At box processing logic creates timestamped tags and associates each of the timestamped tags with one media file. The timestamp in a timestamped tag indicates a beginning date and time of the associated media file. Details of some embodiments of timestamped tags have been discussed above.

At box processing logic creates a playlist file with one or more timestamped tags e.g. EXT X PROGRAM DATE TIME tag each of which is associated with a particular media file. Note that the media file itself has internal timestamps as well. At box processing logic may distribute the playlist so that the playlist file is available for searching by date and time using the date and time in the timestamped tags. In some embodiments the playlist is stored in a repository from which client devices may download the playlist.

At box processing logic receives a user request for a segment of a program beginning at a particular date and time. For example the user may request a fourth inning of a baseball game that begins at 8 15 pm on Apr. 6 2010 instead of the entire baseball game. In response to the user request processing logic downloads one or more playlist files associated with the program from a media server at block . At block processing logic searches the playlist files downloaded using the date and time in the timestamp tags inside the playlist files for the date and time stamps closest to the date and time of the segment requested. Then processing logic subtracts its date and time from the date and time of the segment requested at block . This produces a duration. Processing logic then walks forward through the subsequent media file durations in the playlist file until processing logic locates a target media file about that much duration after the datestamped media file at block . Processing logic then downloads this target media file at block as it is the best guess about which file contains the requested segment.

In some embodiments all media files between the datestamped one and the target one are part of a single encoding that is no discontinuity tag in between them. If they are processing logic can subtract media file timestamps in the datestamped file from those in the target file to get precise durations which allows the location of the requested date and time precisely.

Using the dates and times in the timestamped tags in the playlist files processing logic does not have to download all media files of the entire program in order to search through the media files to find the requested segment. Because the client device does not have to download all media files of the entire program when the user does not request the entire program significant savings in bandwidth can be achieved. Furthermore many typical media files contain only arbitrary timestamps which often start at zero. Thus the dates and times of the timestamped tags discussed above may associate the arbitrary timestamps in the media files with a real date and or time. Using the timestamped tags the client device can locate the playlist element containing a particular date and or time more efficiently than scanning through each media file.

One embodiment of the invention allows insertion of timed metadata into a media stream in an ID3 format. The media stream may include video and or audio data encoded in a predetermined format. For example the media stream may include video and audio data encoded in MPEG 2 developed by the Moving Pictures Expert Group MPEG which is international standard ISO IEC 13818. Broadly speaking metadata includes information on data in the media stream and timed metadata referred to metadata associated with a particular time e.g. the time at which a goal was scored . Note that timed metadata may change over time. The timed metadata may be inserted into the media stream in a predetermined format for storing metadata such as ID3 format. In some embodiments the video data may be divided into a sequence of frames. Timed metadata of the video data may also be divided into containers associated with the sequence of frames. Each container may store both timed metadata of a corresponding frame and the time associated with the corresponding frame. Alternatively each container may store both timed metadata of a corresponding frame and frame number of the corresponding frame. In some embodiments the timed metadata of a frame may include a set of predetermined information of the frame. For example the timed metadata may include location information e.g. global positioning system GPS data of the location at which the corresponding frame of video data was recorded.

In one embodiment the following describes how ID3 metadata can be carried as timed metadata in MPEG 2 Transport Streams see ISO IEC 13818 1 2007 Information Technology Generic Coding of Moving Pictures and associated audio information systems which is hereinafter referred to as the MPEG 2 standard as used by the HTTP live streaming protocol described herein. Metadata can be carried in transport streams according to section 2.12 of the MPEG 2 standard. The metadata can be carried in an elementary stream PES rather than for example in a carousel. ID3 metadata is self describing and needs no configuration information so the provisions for metadata decoder configuration data do not need to be used. The metadata stream can be in the same program as the main program material i.e. the audio video content .

Tables S1 S2 S3 and S4 provide one embodiment of syntax that can be used. In the syntax tables below the syntax structure left column is shown with only the outline that is in effect and the names of fields. This means that if blocks for which the condition is false are omitted for clarity. The MPEG 2 standard can be consulted for the complete syntax the field sizes and the acceptable values. The right column indicates in a line with each field name the value needed in this context or contains an explanation of that line.

ID3 defines both a format and a semantic and so the same registered format identifier can be used for both metadata format identifier and metadata application format identifier. The registered value for these at the registration authority SMPTE Registration Authority see http www.smpte ra.org is ID3 ID3 space or 0x49 0x44 0x33 0x20 assignment pending . To indicate a registered value is used the fields metadata format and metadata application format can take the values 0xff and 0xffff respectively. In one embodiment this metadata can be carried in a private stream not a stream formatted as metadata Access Units MAUs as defined in 12.4 of the MPEG 2 standard. The stream id value used for the stream is therefore private stream id 1 0xbd as specified in 2.12.3 of the MPEG 2 standard. The stream type is set to 0x15 indicating carriage of metadata in a PES stream as specified in 2.12.9.1 of the MPEG 2 standard. Since only one metadata stream is normally carried the metadata service id is normally set to 0 however any suitable value can be used to distinguish this metadata stream from others if needed.

The format and content of the metadata descriptors is documented in sections 2.6.58 to 2.6.61 of the MPEG 2 standard.

To declare the presence of the metadata stream a metadata pointer descriptor 2.6.58 of the MPEG 2 standard can be placed in the PMT in the program info loop for the program. The metadata can be in the same program as the main program audio video content. In one embodiment the use of this descriptor to refer to another program is not supported.

To declare the format of the metadata stream a metadata descriptor 2.6.60 of the MPEG 2 standard can be placed in the PMT in the es info loop for the elementary stream.

ID3 metadata can be stored as a complete ID3v4 frame in a PES packet including a complete ID3 header stream. The ID3 tag can start immediately after the PES header this PES header can contain a PTS PTS DTS flags to 10 . The PTS can be on the same timeline as the audio and video frames. The data alignment bit can be set to 1. The PES header can contain a PES packet length that is non zero. If an ID3 tag is longer than 65535 bytes it can have more than 1 PES header. The second and following PES headers can have data alignment set to 0 and the PTS DTS flags set to 00 and hence no PTS . The PES header can be formatted as documented in 2.4.3.7 of the MPEG 2 standard.

The metadata stream can be incorporated into a transport stream in the same way as audio or video is. For example that means that in a transport packet see 2.4.3.2 of the MPEG 2 standard the payload unit start indicator can be set to 1 only when a PES header follows. The PES header in turn can indicate whether the start of the ID3 data follows or whether that has been divided into multiple PES packets as noted in the previous paragraph .

In one embodiment of the invention processing of media files e.g. retrieved of playlists and retrieved of media files specified in the playlist and decoding of the content in the media files can be done separately from a user interface that presents and controls the media being presented. For example a user application such as an application for watching live events e.g. as Major League Baseball MLB application for watching baseball games or other streams can provide the user interface for presenting and controlling e.g. receiving a selection of a media file the presentation while another software process e.g. a software process that serves media such as a daemon for serving media which can be referred to as mediaserverd can retrieve playlists and retrieve and decode media files. In some cases the media files can be encrypted and the encryption can be controlled by the user application e.g. the MLB application for example a user application can install a client certificate for example an X.509 certificate to provide authentication and chain of trust and revocability into their keychain either persistently or in memory only that can be used to answer a server challenge when an HTTP Secured Sockets Layer SSL connection is made to download a key that can be used to decrypt the media s content. In other cases a playlist can contain URLs for one or more keys that use a custom URL scheme that is used by the user application or a server that interacts with the user application in this case a user application can register URL protocol handlers for these custom URL schemes that can be invoked to obtain a key such as a new key and this can allow a user application to transport keys out of band e.g. hidden in their application binary or obtain a key from a server using a private protocol that is understood by both the user application and the server that interacts with the user application but is not understood by other systems.

In some embodiments EMP application further includes a core media stack which is a customized software stack for accessing a networking stack which in turns accesses an URL protocol handler EMP handler . EMP application can register EMP handler for a custom URL scheme that can be invoked to obtain one or more keys. Thus EMP application can transport keys out of band e.g. hidden in the application binary .

In general mediaserverd and EMP application can interact with each other to download and playback media files for live streaming content from a content provider s application which is EMP in the current example. Playback can be done in mediaserverd on the client device. In some embodiments mediaserverd can download keys for decryption of media files and if this fails mediaserverd may ask EMP application to download the key from a content provider server which is EMP server in the current example. EMP application running on the client device can sign up to get one or more keys. In one embodiment EMP application may have signed up and obtained the keys prior to downloading the media files. Details of some embodiments of the interactions between mediaserverd and EMP application are discussed below to further illustrate the concept.

Referring to EMP application in one embodiment sends a playlist with at least an URL and a key to mediaserverd . Using the key mediaserverd attempts to access a media source provided by EMP at the URL and to download media files specified in the playlist from the media source. The media files may be encoded or encrypted to prevent unauthorized viewing of the content of the media files. If mediaserverd fails to download the media files or it fails to decode or decrypt the media files downloaded mediaserverd reports the failure to EMP application .

In response to the failure report from mediaserverd EMP application uses its core media stack to access networking stack in order to request a new key which in turns accesses EMP handler for the new key . EMP handler connects to EMP server over a network e.g. Internet to request the new key from EMP server . In response to the request EMP server sends the new key to EMP handler . Then EMP handler passes the new key to core media stack which then passes the new key to mediaserverd .

When mediaserverd receives the new key from core media stack mediaserverd may try to download the media files again using the new key and then decode the media files downloaded using the new key . Alternatively if the media files were successfully downloaded previously but mediaserverd failed to decrypt the media files then mediaserverd may try to decrypt the media files previously downloaded using the new key. If mediaserverd successfully downloads and decodes the media files using the new key then EMP application may present the decoded media files on the client device.

Client device includes an operating system OS that can include a player service although in another embodiment the player service can be provided separately from the OS. The OS can maintain a registry which can be used to store information that is registered by applications such as AppX this information stored in the registry can include information that shows a relationship between a custom URL and the application that uses that custom URL so that the player service or the OS can call the application that uses that custom URL in order to obtain an object e.g. a decryption key from that custom URL. In other words the registry allows the OS or the player service to identify an application to call by using a custom URL found in a playlist to look up the associated application which can be identified by an identifier associated with the application in the registry. The custom URL can be specified in one embodiment by the EXT X KEY tag and the player service can be configured to accept as parameters of that tag URLs that are specified as one of http https and registered identifiers such as identifiers that have been registered in a registry such as registry . Client device can include one or more user applications such as AppX or for example a Major League Baseball MLB application or other applications that provide a user interface for streaming content obtained from one or more playlists such as the playlists described herein . These applications can be provided by the entities that provide the content e.g. MLB provides the content the baseball games that are streamed to a client and presented in the user interface of MLB s application that is executing on the client device or these applications can be provided by application developers that create user interfaces for players for general use with content created by others.

The client device and the one or more servers can operate according to the method shown in to resolve a custom URL that is not recognized by a player service such as player service . An application such as AppX can when installed or later cause a custom URL to be registered in a registry such as registry in operation in . In one embodiment the application can as part of its installation make a call to OS to cause its one or more custom URLs to be stored in registry along with an identifier that associates these one or more custom URLs with the application. After installation the application can be launched and used by a user which can occur in operation when the user makes a selection in the application to cause the application to present a selected HTTP stream. In response to this input the application in operation calls in call of player service to present e.g. display the HTTP stream. The player service in operation retrieves call the playlist specified by the user s input and determines that the playlist includes a custom URL that is not recognized or supported by the player service in the case of the custom URL is for a decryption key that is used by the player service to decrypt media files referred to in the playlist upon determining that the playlist includes a custom URL the player service calls OS call to cause registry to be examined to determine the application that should be requested to resolve or use the custom URL. In operation OS determines that the custom URL in the playlist is to be resolved by AppX and OS in turn calls call AppX to cause AppX to retrieve the object in this case a decryption key to be used to decrypt content for presentation by AppX using the custom URL. In operation AppX can receive the call from OS and in response can determine the URL to use and can call the OS call to retrieve the object in this case a decryption key using the URL determined by AppX . Then in operation OS receives the object and passes it to AppX which in turn passes the object to player service to allow the player service to use the object to process the playlist or the media files or both as in operation . In an alternative embodiment of operation the OS can pass the object once received directly to player service .

Another embodiment of the present invention can employ a distributed system which employs at least two devices to provide playback using the playlists and streaming techniques described herein. provide an example of such a distributed system in which one device can initiate a remote playback on another device which can drive or provide an output to a TV or other presentation device such as a stereo system etc. Referring to a first device can be configured to communicate with a second device through for example a wired network or wireless network or a direct connection such as a wired connection. In one embodiment the first device can be a tablet computer or a laptop computer or a smart phone and the second device can be a set top box or audio visual controller such as the Apple TV from Apple Inc. of Cupertino Calif. The first device in one embodiment can be an iPad from Apple Inc. of Cupertino Calif. Each of the devices and can be an electronic system such as the electronic system described in conjunction with and can include one or more processors and memory and peripheral devices such as input or output or input output interfaces. In one embodiment each of the devices and can include a wireless network interface which allows the devices to participate in a WiFi wireless network. In one embodiment the connection can be a connection to a WiFi network and in other embodiments other wireless connections or wired connections may be utilized to couple together the two devices and . The device includes an output to a presentation device such as a TV or stereo system and this output provides the remote presentation of the media which can be initiated by selecting the media through an app or application such as app on the device . The presentation device can be separate from the device when the device is a set top box and in an alternative embodiment the presentation device e.g. a TV can include device .

Device can include a plurality of software components including for example application or app which may be for example an application such as the Major League Baseball app used to present baseball games on the device or a Netflix application or app used to present movies or other content through the streaming techniques described herein. Device also includes a media server which can be similar to the player service shown in or the media server daemon shown in . The device can also include a remote playback service which is a software component that provides an interface between the first and the second device for allowing remote playback of content selected or initiated at the first device through the second device which then outputs the content to a presentation device such as a TV which can be coupled to the output of the second device . The remote playback service can be activated or selected by a user of the first device to cause it to communicate with the second device to cause remote playback through the second device onto the presentation device such as a TV which is coupled to the output of the second device. In one embodiment the remote playback service can be part of the AirPlay facility provided on iPads or iPhones from Apple Inc. The device can also include an operating system which provides the standard and known services of an operating system to allow the device to function with one or more applications as is known in the art.

The second device can also include a media server which can be similar to media server or player service or be similar to the media server daemon in . When a remote playback mode is selected in one embodiment the media server on the second device retrieves and processes playlists specified by the first device for display to an output of the second device. In this case the first device acts to control e.g. start stop pause fast forward select different media etc. the playback of the second device which is retrieving and processing the media in the playlist and is also processing the playlist as described herein. In effect the first device can act in this remote playback mode as a remote control for the second device and can present e.g. display a user interface on a display coupled to the first device for controlling the playback on the second device an example of such a user interface is described in U.S. Provisional Application No. 61 378 893 filed on Aug. 31 2010 which provisional application is incorporated herein by reference. In one embodiment even in this remote playback mode the first device can execute multiple applications concurrently e.g. a web browser application an email application a book reader application and other applications while also executing an application or other software to act as a remote control for the second device. Further the second device also includes an operating system and a remote playback daemon . In one embodiment the remote playback daemon is a daemon which is a background process which is launched at startup of the second device and which is configured to watch for certain commands such as a play URL command or a play URL call and then which is configured to provide that call to a media server such as the media server . The daemon can operate as a background process and launch itself at startup without requiring any interaction from the user of the second device . It will also be understood that the app can be similar to the app of .

In an alternative embodiment the media server and the remote playback portions of each device may be combined together so that there is no need for an exposed API call between the combined objects.

Referring now to a method can begin in operation in which a connection is established between two devices such as two wireless networking devices and one of the devices can be set up to allow it to play and control media on or through the second device. In one embodiment the first device can be a tablet computer or laptop computer or other data processing system which includes an application such as app which a user can use to select content to be presented remotely through the second device or on the second device. In one embodiment the first device may include an output such as a display to also display the same media while it is being presented through the second device on a presentation device such as a TV or another display of the second device. In one embodiment a user of the first device can select a remote playback mode such as an AirPlay mode on an iPad and in doing so set up the first device to allow it to control and play media on the second device similarly this setup can also establish the connection between the devices. It will be appreciated that the sequence of operations and can be reversed and that the connection can be established after selecting the media for playback after the application has been launched. In operation the system launches an application either at user request or automatically by the first device and receives a request to play back a video or other media. For example a user could launch a Netflix application on an iPad and then select within the Netflix application a particular video or other content to play back. In response to the selection of a particular video or other media to play back the app on the first device in operation calls the media server on the first device to play a URL for a playlist. This is shown as call in . In response the media server on the first device determines whether the remote playback mode has been selected or enabled. If it has not then playback occurs through the first device in the manner described in if a custom URL needs to be resolved. On the other hand if remote playback mode has been selected or enabled then the media server on the first device calls the remote playback service through call on . This call in effect passes the URL which may be a URL for the playlist or a URL for a key in the playlist to a remote playback daemon on the second device. This call is shown as call in . In operation the remote playback daemon such as remote playback daemon receives the URL from the first device and calls the media server on the second device to play the URL this call is shown as call in . In response media server on the second device determines that the URL is a custom URL that the media server cannot process. In one embodiment a custom URL is any URL that is not a standard URL scheme such as an HTTP scheme or an HTTPS scheme or a file scheme or a DAV scheme. The custom URL scheme will be understood by the application in terms of how to decode or process the custom URL to retrieve the data or content pointed to by the URL.

Then in operation the media server on the second device such as media server calls the remote playback daemon such as remote playback daemon on the second device to request resolution of the custom URL. In response the remote playback daemon calls the remote playback service through call shown in . Then in operation the remote playback service such as remote playback service on the first device receives the request to resolve the custom URL and calls in call the media server such as media server on the first device to resolve the custom URL. In turn in operation the media server receives the custom URL and calls the app such as app after in one embodiment consulting the registry to determine the appropriate app to call in order to resolve the custom URL. The call to the app is shown as call in . Next in operation the app resolves the URL and returns the content of the custom URL such as a key or a playlist or other content pointed to by the custom URL and this content is returned to the media server on the first device and is shown as return in . Then in operation the media server on the first device returns the content of the custom URL to the remote playback service such as remote playback service which in turn returns the content of the URL to the remote playback daemon on the second device which then returns the content of the URL to the media server on the second device. At this point in operation the media server on the second device can use the content of the URL which can be a key or a playlist to process the playback process and this process can repeat as necessary whenever the media server encounters a custom URL. In which case when encountering a custom URL it will repeat the process by beginning with the call shown in and begin with operation in which will continue through the resolution of the custom URL call ending again with operation .

It will be appreciated that in operation if the content of the URL is a key then the key will be used by the media server on the second device to decrypt the media file and to present the media file through the output of the second device and if the content is the playlist the media server on the second device will use the playlist as described in the rest of this disclosure to retrieve and then decode media files specified by the playlist and to present the media file through the output of the second device. If keys within that playlist are also specified by custom URLs then the process will again be repeated beginning in operation and ending in operation as described above. When the first device is in the remote playback mode the media server on the second device retrieves and processes the playlist that can be specified by the first device and the media server retrieves and processes and decodes and presents the media files in the playlist resulting in a presentation of media on an output of the second device.

Electronic system includes bus or other communication device to communicate information and processor coupled to bus that may process information. While electronic system is illustrated with a single processor electronic system may include multiple processors and or co processors. Electronic system further may include random access memory RAM or other dynamic storage device referred to as main memory coupled to bus and may store information and instructions that may be executed by processor . Main memory may also be used to store temporary variables or other intermediate information during execution of instructions by processor .

Electronic system may also include read only memory ROM and or other static storage device coupled to bus that may store static information and instructions for processor . Data storage device may be coupled to bus to store information and instructions. Data storage device such as flash memory or a magnetic disk or optical disc and corresponding drive may be coupled to electronic system .

Electronic system may also be coupled via bus to display device such as a cathode ray tube CRT or liquid crystal display LCD to display information to a user. Electronic system can also include an alphanumeric input device including alphanumeric and other keys which may be coupled to bus to communicate information and command selections to processor . Another type of user input device is cursor control such as a touchpad a mouse a trackball or cursor direction keys to communicate direction information and command selections to processor and to control cursor movement on display .

Electronic system further may include one or more network interface s to provide access to a network such as a local area network. Network interface s may include for example a wireless network interface having antenna which may represent one or more antenna e . Electronic system can include multiple wireless network interfaces such as a combination of WiFi Bluetooth and cellular telephony interfaces. Network interface s may also include for example a wired network interface to communicate with remote devices via network cable which may be for example an Ethernet cable a coaxial cable a fiber optic cable a serial cable or a parallel cable.

In one embodiment network interface s may provide access to a local area network for example by conforming to IEEE 802.11b and or IEEE 802.11g standards and or the wireless network interface may provide access to a personal area network for example by conforming to Bluetooth standards. Other wireless network interfaces and or protocols can also be supported.

In addition to or instead of communication via wireless LAN standards network interface s may provide wireless communications using for example Time Division Multiple Access TDMA protocols Global System for Mobile Communications GSM protocols Code Division Multiple Access CDMA protocols and or any other type of wireless communications protocol.

One or more Application Programming Interfaces APIs may be used in some embodiments. An API is an interface implemented by a program code component or hardware component hereinafter API implementing component that allows a different program code component or hardware component hereinafter API calling component to access and use one or more functions methods procedures data structures classes and or other services provided by the API implementing component. An API can define one or more parameters that are passed between the API calling component and the API implementing component.

An API allows a developer of an API calling component which may be a third party developer to leverage specified features provided by an API implementing component. There may be one API calling component or there may be more than one such component. An API can be a source code interface that a computer system or program library provides in order to support requests for services from an application. An operating system OS can have multiple APIs to allow applications running on the OS to call one or more of those APIs and a service such as a program library can have multiple APIs to allow an application that uses the service to call one or more of those APIs. An API can be specified in terms of a programming language that can be interpreted or compiled when an application is built.

In some embodiments the API implementing component may provide more than one API each providing a different view of or with different aspects that access different aspects of the functionality implemented by the API implementing component. For example one API of an API implementing component can provide a first set of functions and can be exposed to third party developers and another API of the API implementing component can be hidden not exposed and provide a subset of the first set of functions and also provide another set of functions such as testing or debugging functions which are not in the first set of functions. In other embodiments the API implementing component may itself call one or more other components via an underlying API and thus be both an API calling component and an API implementing component.

An API defines the language and parameters that API calling components use when accessing and using specified features of the API implementing component. For example an API calling component accesses the specified features of the API implementing component through one or more API calls or invocations embodied for example by function or method calls exposed by the API and passes data and control information using parameters via the API calls or invocations. The API implementing component may return a value through the API in response to an API call from an API calling component. While the API defines the syntax and result of an API call e.g. how to invoke the API call and what the API call does the API may not reveal how the API call accomplishes the function specified by the API call. Various API calls are transferred via the one or more application programming interfaces between the calling API calling component and an API implementing component. Transferring the API calls may include issuing initiating invoking calling receiving returning or responding to the function calls or messages in other words transferring can describe actions by either of the API calling component or the API implementing component. The function calls or other invocations of the API may send or receive one or more parameters through a parameter list or other structure. A parameter can be a constant key data structure object object class variable data type pointer array list or a pointer to a function or method or another way to reference a data or other item to be passed via the API.

Furthermore data types or classes may be provided by the API and implemented by the API implementing component. Thus the API calling component may declare variables use pointers to use or instantiate constant values of such types or classes by using definitions provided in the API.

Generally an API can be used to access a service or data provided by the API implementing component or to initiate performance of an operation or computation provided by the API implementing component. By way of example the API implementing component and the API calling component may each be any one of an operating system a library a device driver an API an application program or other module it should be understood that the API implementing component and the API calling component may be the same or different type of module from each other . API implementing components may in some cases be embodied at least in part in firmware microcode or other hardware logic. In some embodiments an API may allow a client program to use the services provided by a Software Development Kit SDK library. In other embodiments an application or other client program may use an API provided by an Application Framework. In these embodiments the application or client program may incorporate calls to functions or methods provided by the SDK and provided by the API or use data types or objects defined in the SDK and provided by the API. An Application Framework may in these embodiments provide a main event loop for a program that responds to various events defined by the Framework. The API allows the application to specify the events and the responses to the events using the Application Framework. In some implementations an API call can report to an application the capabilities or state of a hardware device including those related to aspects such as input capabilities and state output capabilities and state processing capability power state storage capacity and state communications capability etc. and the API may be implemented in part by firmware microcode or other low level logic that executes in part on the hardware component.

The API calling component may be a local component i.e. on the same data processing system as the API implementing component or a remote component i.e. on a different data processing system from the API implementing component that communicates with the API implementing component through the API over a network. It should be understood that an API implementing component may also act as an API calling component i.e. it may make API calls to an API exposed by a different API implementing component and an API calling component may also act as an API implementing component by implementing an API that is exposed to a different API calling component.

The API may allow multiple API calling components written in different programming languages to communicate with the API implementing component thus the API may include features for translating calls and returns between the API implementing component and the API calling component however the API may be implemented in terms of a specific programming language. An API calling component can in one embodiment call APIs from different providers such as a set of APIs from an OS provider and another set of APIs from a plug in provider and another set of APIs from another provider e.g. the provider of a software library or creator of the another set of APIs.

It will be appreciated that the API implementing component may include additional functions methods classes data structures and or other features that are not specified through the API and are not available to the API calling component . It should be understood that the API calling component may be on the same system as the API implementing component or may be located remotely and accesses the API implementing component using the API over a network. While illustrates a single API calling component interacting with the API it should be understood that other API calling components which may be written in different languages or the same language than the API calling component may use the API .

The API implementing component the API and the API calling component may be stored in a machine readable non transitory storage medium which includes any mechanism for storing information in a form readable by a machine e.g. a computer or other data processing system . For example a machine readable medium includes magnetic disks optical disks random access memory read only memory flash memory devices etc.

In Software Stack an exemplary embodiment applications can make calls to Services or using several Service APIs and to Operating System OS using several OS APIs. Services and can make calls to OS using several OS APIs.

Note that the Service has two APIs one of which Service API receives calls from and returns values to Application and the other Service API receives calls from and returns values to Application . Service which can be for example a software library makes calls to and receives returned values from OS API and Service which can be for example a software library makes calls to and receives returned values from both OS API and OS API . Application makes calls to and receives returned values from OS API .

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification are not necessarily all referring to the same embodiment.

In the foregoing specification the invention has been described with reference to specific embodiments thereof. It will however be evident that various modifications and changes can be made thereto without departing from the broader spirit and scope of the invention. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

