---

title: Speculative reads
abstract: Patterns of access and/or behavior can be analyzed and persisted for use in pre-fetching data from a physical storage device. In at least some embodiments, data can be aggregated across volumes, instances, users, applications, or other such entities, and that data can be analyzed to attempt to determine patterns for any of those entities. The patterns and/or analysis can be persisted such that the information is not lost in the event of a reboot or other such occurrence. Further, aspects such as load and availability across the network can be analyzed to determine where to send and/or store data that is pre-fetched from disk or other such storage in order to reduce latency while preventing bottlenecks or other such issues with resource availability.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09483407&OS=09483407&RS=09483407
owner: Amazon Technologies, Inc.
number: 09483407
owner_city: Reno
owner_country: US
publication_date: 20140825
---
This application is a continuation of U.S. application Ser. No. 13 794 616 filed Mar. 11 2013 and U.S. Pat. No. 8 539 163 filed as U.S. application Ser. No. 12 972 187 filed Dec. 17 2010 and entitled Speculative Reads which are hereby incorporated herein in their entirety for all purposes.

As an increasing amount of information processing is being performed electronically and as the speed of that processing increases there is a corresponding demand to improve the performance of the systems and services that manage the information being processed. A substantial amount of data is still stored on magnetic disk drives and similar devices due at least in part to the relative low cost of these devices but the time needed to read data to and write data from these devices is a significant source of latency. One approach to reducing latency is to pre fetch data from these devices and store the information in faster memory e.g. solid state memory but conventional computing systems utilizing locally attached disks typically must be conservative in issuing pre read commands as a read command utilizes bus bandwidth and there is a limited amount of solid state memory available to hold the pre fetched data. Further there are no existing approaches to accurately predict which data should be pre fetched which results in either a smaller amount of data being pre fetched than is needed which results in lesser latency improvements or a significant amount of data being pre fetched that is not needed which can result in a significant drain on available network resources.

Even where conventional systems look to recent read requests to determine data to be pre fetched these systems are typically limited in the amount of data they can access for the determinations. For example an operating system OS on a computer might look at certain processes and or a RAID controller might look at data at another level independent of the OS. A disk drive might also have some amount of cache and do some level of pre fetching as well. At each level a decision can be made based on read requests received in the recent past which can be limited in scope. For example the disk drive will have the least amount of information and the most narrow view but will not affect any other devices as the drive is only occupying its own cache and spindle time. Pre fetching reads at the RAID level also can reduce available RAID cache and moving up to the OS level can provide a broader view but can end up also filling OS memory. Thus as the amount of information increases the potential for negatively impacting performance of the network increases as well. Further such information typically is not persisted such that each time a device is rebooted a significant amount of time passes between reads or any other such action occurs the historical information is lost and the prediction has to start from scratch.

Systems and methods in accordance with various embodiments of the present disclosure may overcome one or more of the aforementioned and other deficiencies experienced in conventional approaches to managing input output I O operations in a computing environment. In particular various embodiments can analyze information such as user behavior and or read patterns in order to predict subsequent read requests i.e. for sequential reads . Various approaches can read the information e.g. blocks of data such that the data is readily available upon a subsequent request for that data. Further at least some embodiments can analyze current conditions of the computing system network or other such components to determine how to handle the data before that data is requested.

Usage patterns can be determined and utilized to predict behavior for a user application or other such entity in any appropriate environment. For example usage patterns can be monitored in a system where virtualized operating system instances utilize attached network storage. The underlying operating system hosting the instances can have visibility into information such as disk read patterns issued by the virtual instance. By analyzing these patterns the underlying operating system can predict subsequent reads and thus can issue speculative pre read instructions to a storage server or other such storage device in order to reduce the read latency of a subsequent read operation issued by the virtualized operating system. Such an approach provides for relatively inexpensive from a resource standpoint speculative read operations that are based upon the behavior of the respective user application etc.

The use of speculative reads as well as aspects such as when to use such reads and the extent of such usage can be balanced against the potential waste in resources. Since resources such as disk drives are major sources of latency for read requests the ability to pre fetch data from disk and store that data in memory can reduce the overall latency of the system. On the other hand incorrectly speculating on subsequent read requests can squander resources such as bus bandwidth available memory and spindle time.

Speculative read commands however can be relatively inexpensive as the commands can take the form of instructions to a storage server or other such storage device to read the data into local memory in preparation of sending that data across the network e.g. the local bus . Approaches in accordance with various embodiments can also analyze the current load on the system such as the workload on the storage server or traffic across the network and can use such analysis to determine whether to pause a speculative read process. In one embodiment a storage server might have a committed rate of I O operations for at least a period of time which prevents the storage server from performing speculative reads over that period. In systems with sufficient extra resource capacity however the tolerance for inaccurate speculations about data reads can be greater such that the amount of speculative reads can be increased even if the accuracy is not above a certain acceptance threshold in order to decrease latency and provide other such performance payoffs.

In at least some embodiments information about various read patterns and analysis can be stored such that the information is persistent across restarts or other such events. In conventional systems the operating system looks at recent disk I O patterns to make decisions. Any operations issued on a previous boot cycle will be lost because the data is stored in memory. In various embodiments however disk I O patterns and other such information can be persisted by the hosting operating system e.g. in the Dom 0 . Such an approach enables the patterns to be persisted across restarts such that an analyzing component can have data available at all relevant times even after a restart and thus can make more accurate predictions which result in better read performance etc.

In at least some embodiments a system or service can have a view into more than just the operations issued by the virtualized operating system. Such a broader view can provide improved optimization as an optimizer component can combine pattern data with data gathered from other optimizer components running on separate but related instances. Information that can be aggregated for such purposes can include time of day trends data from all instances owned by the same customer and data from all instances running a particular application e.g. a relational database management system .

In at least one embodiment the I O operations for an application or client can be monitored to attempt to determine read patterns. For example an application submitting a request for a first read bit might typically submit subsequent read requests for the next two adjacent read bits from a data storage device e.g. a disk drive data volume or other block storage . If the client or application requests three adjacent bits with a sufficient frequency rate or other such threshold or criterion an analysis module or other such component can determine to pre fetch the next two bits whenever a read request is received for that client or application. Such an approach minimizes the latency for read operations by performing certain tasks ahead of time thereby minimizing the time delay after a read request due to extra disk revolutions seek operations or other such actions.

The monitoring of usage patterns and pre fetching of data based on speculative reads can be utilized with a number of different systems and services. In many embodiments the speculation is driven by a storage node or storage entity in a data or network environment. For example a storage entity such as a block data storage service can utilize multiple server storage systems to reliably store block data that may be accessed and used over one or more networks by any of various users applications processes and or services. Users of the block data storage service may each create one or more block data storage volumes that each have a specified amount of block data storage space and may initiate use of such a block data storage volume also referred to as a volume herein by one or more executing programs with at least some such volumes having copies stored by two or more of the multiple server storage systems so as to enhance volume reliability and availability to the executing programs. As one example the multiple server block data storage systems that store block data may in some embodiments be organized into one or more pools or other groups that each have multiple physical server storage systems co located at a geographical location such as in each of one or more geographically distributed data centers and the program s that use a volume stored on a server block data storage system in a data center may execute on one or more other physical computing systems at that data center.

In addition in at least some embodiments applications that access and use one or more such non local block data storage volumes over one or more networks may each have an associated node manager that manages the access to those non local volumes by the program such as a node manager module that is provided by the block data storage service and or that operates in conjunction with one or more Block Data Service BDS System Manager modules. For example a first user who is a customer of the block data storage service may create a first block data storage volume and execute one or more program copies on one or more computing nodes that are instructed to access and use the first volume e.g. in a serial manner in a simultaneous or other overlapping manner etc. . When an application executing on a computing node initiates use of a non local volume the application may mount or otherwise be provided with a logical block data storage device that is local to the computing node and that represents the non local volume such as to allow the executing program to interact with the local logical block data storage device in the same manner as any other local hard drive or other physical block data storage device that is attached to the computing node e.g. to perform read and write data access requests to implement a file system or database or other higher level data structure on the volume etc. . For example in at least some embodiments a representative logical local block data storage device may be made available to an executing program via use of an appropriate technology such as GNBD Global Network Block Device technology. In addition when an application interacts with the representative local logical block data storage device the associated node manager may manage those interactions by communicating over one or more networks with at least one of the server block data storage systems that stores a copy of the associated non local volume e.g. in a manner transparent to the executing program and or computing node so as to perform the interactions on that stored volume copy on behalf of the executing program. Furthermore in at least some embodiments at least some of the described techniques for managing access of applications and services to non local block data storage volumes are automatically performed by embodiments of a node manager module.

In at least some embodiments block data storage volumes or portions of those volumes may further be stored on one or more remote archival storage systems that are distinct from the server block data storage systems used to store volume copies. In various embodiments the one or more remote archival storage systems may be provided by the block data storage service e.g. at a location remote from a data center or other geographical location that has a pool of co located server block data storage systems or instead may be provided by a remote long term storage service and used by the block data storage and in at least some embodiments the archival storage system may store data in a format other than block data e.g. may store one or more chunks or portions of a volume as distinct objects .

In some embodiments at least some of the described techniques are performed on behalf of a program execution service that manages execution of multiple programs on behalf of multiple users of the program execution service. In some embodiments the program execution service may have groups of multiple co located physical host computing systems and may execute users programs on those physical host computing systems such as under control of a program execution service PES system manager as discussed in greater detail below. In such embodiments users of the program execution service e.g. customers of the program execution service who pay fees to use the program execution service who are also users of the block data storage service may execute programs that access and use non local block data storage volumes provided via the block data storage service. In other embodiments a single organization may provide at least some of both program execution service capabilities and block data storage service capabilities e.g. in an integrated manner such as part of a single service while in yet other embodiments the block data storage service may be provided in environments that do not include a program execution service e.g. internally to a business or other organization to support operations of the organization .

In addition the host computing systems on which programs execute may have various forms in various embodiments. Multiple such host computing systems may for example be co located in a physical location e.g. a data center and may be managed by multiple node manager modules that are each associated with a subset of one or more of the host computing systems. At least some of the host computing systems may each include sufficient computing resources e.g. volatile memory CPU cycles or other CPU usage measure network bandwidth swap space etc. to execute multiple programs simultaneously and in at least some embodiments some or all of the computing systems may each have one or more physically attached local block data storage devices e.g. hard disks tape drives etc. that can be used to store local copies of programs to be executed and or data used by such programs. Furthermore at least some of the host computing systems in some such embodiments may each host multiple virtual machine computing nodes that each may execute one or more programs on behalf of a distinct user with each such host computing system having an executing hypervisor or other virtual machine monitor that manages the virtual machines for that host computing system. For host computing systems that execute multiple virtual machines the associated node manager module for the host computing system may in some embodiments execute on at least one of multiple hosted virtual machines e.g. as part of or in conjunction with the virtual machine monitor for the host computing system while in other situations a node manager may execute on a physical computing system distinct from one or more other host computing systems being managed.

The server block data storage systems on which volumes are stored may also have various forms in various embodiments. In at least some embodiments some or all of the server block data storage systems may be physical computing systems similar to the host computing systems that execute programs and in some such embodiments may each execute server storage system software to assist in the provision and maintenance of volumes on those server storage systems. For example in at least some embodiments one or more of such server block data storage computing systems may execute at least part of the BDS System Manager such as if one or more BDS System Manager modules are provided in a distributed peer to peer manner by multiple interacting server block data storage computing systems. In other embodiments at least some of the server block data storage systems may be network storage devices that may lack some I O components and or other components of physical computing systems such as if at least some of the provision and maintenance of volumes on those server storage systems is performed by other remote physical computing systems e.g. by a BDS System Manager module executing on one or more other computing systems . In addition in some embodiments at least some server block data storage systems each maintains multiple local hard disks and stripes at least some volumes across a portion of each of some or all of the local hard disks. Furthermore various types of techniques for creating and using volumes may be used including in some embodiments to use LVM Logical Volume Manager technology.

In at least some embodiments some or all block data storage volumes each have copies stored on two or more distinct server block data storage systems such as to enhance reliability and availability of the volumes. By doing so failure of a single server block data storage system may not cause access of executing programs to a volume to be lost as use of that volume by those executing programs may be switched to another available server block data storage system that has a copy of that volume. In such embodiments consistency may be maintained between the multiple copies of a volume on the multiple server block data storage systems in various ways. For example in some embodiments one of the server block data storage systems is designated as storing the primary copy of the volume and the other one or more server block data storage systems are designated as storing mirror copies of the volume in such embodiments the server block data storage system that has the primary volume copy referred to as the primary server block data storage system for the volume may receive and handle data access requests for the volume and in some such embodiments may further take action to maintain the consistency of the other mirror volume copies e.g. by sending update messages to the other server block data storage systems that provide the mirror volume copies when data in the primary volume copy is modified such as in a master slave computing relationship manner . Various types of volume consistency techniques may be used with additional details included below.

In addition to maintaining reliable and available access of executing programs to block data storage volumes by moving or otherwise replicating volume copies when server block data storage systems become unavailable the block data storage service may perform other actions in other situations to maintain access of executing programs to block data storage volumes. For example if a first executing program unexpectedly becomes unavailable in some embodiments the block data storage service and or program execution service may take actions to have a different second executing program e.g. a second copy of the same program that is executing on a different host computing system attach to some or all block data storage volumes that were in use by the unavailable first program so that the second program can quickly take over at least some operations of the unavailable first program. The second program may in some situations be a new program whose execution is initiated by the unavailability of the existing first program while in other situations the second program may already be executing e.g. if multiple program copies are concurrently executed to share an overall load of work such as multiple Web server programs that receive different incoming client requests as mediated by a load balancer with one of the multiple program copies being selected to be the second program if the second program is a standby copy of the program that is executing to allow a hot swap from the existing first program in the event of unavailability such as without the standby program copy being actively used until the unavailability of the existing first program occurs etc. . In addition in some embodiments a second program to which an existing volume s attachment and ongoing use is switched may be on another host physical computing system in the same geographical location e.g. the same data center as the first program while in other embodiments the second program may be at a different geographical location e.g. a different data center such as in conjunction with a copy of the volume that was previously or concurrently moved to that other data center and will be used by that second program . Furthermore in some embodiments other related actions may be taken to further facilitate the switch to the second program such as by redirecting some communications intended for the unavailable first program to the second program.

As previously noted in at least some embodiments some or all block data storage volumes each have copies stored on two or more distinct server block data storage systems at a single geographical location such as within the same data center in which executing programs will access the volume by locating all of the volume copies and executing programs at the same data center or other geographical location various desired data access characteristics may be maintained e.g. based on one or more internal networks at that data center or other geographical location such as latency and throughput. For example in at least some embodiments the described techniques may provide access to non local block data storage that has access characteristics that are similar to or better than access characteristics of local physical block data storage devices but with much greater reliability that is similar to or exceeds reliability characteristics of RAID Redundant Array of Independent or Inexpensive Disks systems and or dedicated SANs Storage Area Networks and at much lower cost. In other embodiments the primary and mirror copies for at least some volumes may instead be stored in other manners such as at different geographical locations e.g. different data centers such as to further maintain availability of a volume even if an entire data center becomes unavailable. In embodiments in which volume copies may be stored at different geographical locations a user may in some situations request that a particular program be executed proximate to a particular volume e.g. at the same data center at which the primary volume copy is located or that a particular volume be located proximate to a particular executing program such as to provide relatively high network bandwidth and low latency for communications between the executing program and primary volume copy.

Furthermore access to some or all of the described techniques may in some embodiments be provided in a fee based or other paid manner to at least some users. For example users may pay one time fees periodic e.g. monthly fees and or one or more types of usage based fees to use the block data storage service to store and access volumes to use the program execution service to execute programs and or to use archival storage systems e.g. provided by a remote long term storage service to store long term backups or other snapshot copies of volumes. Fees may be based on one or more factors and activities such as indicated in the following non exclusive list based on the size of a volume such as to create the volume e.g. as a one time fee to have ongoing storage and or use of the volume e.g. a monthly fee etc. based on non size characteristics of a volume such as a number of mirror copies characteristics of server block data storage systems e.g. data access rates storage sizes etc. on which the primary and or mirror volume copies are stored and or a manner in which the volume is created e.g. a new volume that is empty a new volume that is a copy of an existing volume a new volume that is a copy of a snapshot volume copy etc. based on the size of a snapshot volume copy such as to create the snapshot volume copy e.g. as a one time fee and or have ongoing storage of the volume e.g. a monthly fee based on the non size characteristics of one or more snapshot volume copies such as a number of snapshots of a single volume whether a snapshot copy is incremental with respect to one or more prior snapshot copies etc. based on usage of a volume such as the amount of data transferred to and or from a volume e.g. to reflect an amount of network bandwidth used a number of data access requests sent to a volume a number of executing programs that attach to and use a volume whether sequentially or concurrently etc. based on the amount of data transferred to and or from a snapshot such as in a manner similar to that for volumes etc. In addition the provided access may have various forms in various embodiments such as a onetime purchase fee an ongoing rental fee and or based on another ongoing subscription basis. Furthermore in at least some embodiments and situations a first group of one or more users may provide data to other users on a fee based basis such as to charge the other users for receiving access to current volumes and or historical snapshot volume copies created by one or more users of the first group e.g. by allowing them to make new volumes that are copies of volumes and or of snapshot volume copies by allowing them to use one or more created volumes etc. whether as a one time purchase fee an ongoing rental fee or on another ongoing subscription basis.

In some embodiments one or more application programming interfaces APIs may be provided by the block data storage service program execution service and or remote long term storage service such as to allow other programs to programmatically initiate various types of operations to be performed e.g. as directed by users of the other programs . Such operations may allow some or all of the previously described types of functionality to be invoked and include but are not limited to the following types of operations to create delete attach detach or describe volumes to create delete copy or describe snapshots to specify access rights or other metadata for volumes and or snapshots to manage execution of programs to provide payment to obtain other types of functionality to obtain reports and other information about use of capabilities of one or more of the services and or about fees paid or owed for such use etc. The operations provided by the API may be invoked by for example executing programs on host computing systems of the program execution service and or by computing systems of customers or other users that are external to the one or more geographical locations used by the block data storage service and or program execution service.

In this example a data center includes a number of racks each rack including a number of host computing devices as well as an optional rack support computing system in this example embodiment. The host computing systems on the illustrated rack each host one or more virtual machines in this example as well as a distinct node manager module associated with the virtual machines on that host computing system to manage those virtual machines. One or more other host computing systems may also each host one or more virtual machines in this example. Each virtual machine may act as an independent computing node for executing one or more program copies not shown for a user not shown such as a customer of the program execution service. In addition this example data center further includes additional host computing systems that do not include distinct virtual machines but may nonetheless each act as a computing node for one or more programs not shown being executed for a user. In this example a node manager module executing on a computing system not shown distinct from the host computing systems and is associated with those host computing systems to manage the computing nodes provided by those host computing systems such as in a manner similar to the node manager modules for the host computing systems . The rack support computing system may provide various utility services for other computing systems local to its rack e.g. long term program storage metering and other monitoring of program execution and or of non local block data storage access performed by other computing systems local to the rack etc. as well as possibly to other computing systems located in the data center. Each computing system may also have one or more local attached storage devices not shown such as to store local copies of programs and or data created by or otherwise used by the executing programs as well as various other components.

In this example an optional computing system is also illustrated that executes a PES System Manager module for the program execution service to assist in managing the execution of programs on the computing nodes provided by the host computing systems located within the data center or optionally on computing systems located in one or more other data centers or other remote computing systems external to the data center . As discussed in greater detail elsewhere a PES System Manager module may provide a variety of services in addition to managing execution of programs including the management of user accounts e.g. creation deletion billing etc. the registration storage and distribution of programs to be executed the collection and processing of performance and auditing data related to the execution of programs the obtaining of payment from customers or other users for the execution of programs etc. In some embodiments the PES System Manager module may coordinate with the node manager modules and to manage program execution on computing nodes associated with the node manager modules while in other embodiments the node manager modules may not assist in managing such execution of programs.

In this example the data center also includes a computing system that executes a Block Data Storage BDS system manager module for the block data storage service to assist in managing the availability of non local block data storage to programs executing on computing nodes provided by the host computing systems located within the data center or optionally on computing systems located in one or more other data centers or other remote computing systems external to the data center . In particular in this example the data center includes a pool of multiple server block data storage systems which each have local block storage for use in storing one or more volume copies . Access to the volume copies is provided over the internal network s to programs executing on various computing nodes and . As discussed in greater detail elsewhere a BDS System Manager module may provide a variety of services related to providing non local block data storage functionality including the management of user accounts e.g. creation deletion billing etc. the creation use and deletion of block data storage volumes and snapshot copies of those volumes the collection and processing of performance and auditing data related to the use of block data storage volumes and snapshot copies of those volumes the obtaining of payment from customers or other users for the use of block data storage volumes and snapshot copies of those volumes etc. In some embodiments the BDS System Manager module may coordinate with the node manager modules to manage use of volumes by programs executing on associated computing nodes while in other embodiments the node manager modules may not be used to manage such volume use. In addition in other embodiments one or more BDS System Manager modules may be structured in other manners such as to have multiple instances of the BDS System Manager executing in a single data center e.g. to share the management of non local block data storage by programs executing on the computing nodes provided by the host computing systems located within the data center and or such as to have at least some of the functionality of a BDS System Manager module being provided in a distributed manner by software executing on some or all of the server block data storage systems e.g. in a Peer to peer manner without any separate centralized BDS System Manager module on a computing system .

In this example the various host computing systems server block data storage systems and computing systems are interconnected via one or more internal networks of the data center which may include various networking devices e.g. routers switches gateways etc. that are not shown. In addition the internal networks are connected to an external network e.g. the Internet or other public network in this example and the data center may further include one or more optional devices not shown at the interconnect between the data center and an external network e.g. network proxies load balancers network address translation devices etc. . In this example the data center is connected via the external network to one or more other data centers that each may include some or all of the computing systems and storage systems illustrated with respect to data center as well as other remote computing systems external to the data center. The other computing systems may be operated by various parties for various purposes such as by the operator of the data center or third parties e.g. customers of the program execution service and or of the block data storage service . In addition one or more of the other computing systems may be archival storage systems e.g. as part of a remote network accessible storage service with which the block data storage service may interact such as under control of one or more archival manager modules not shown that execute on the one or more other computing systems or instead on one or more computing systems of the data center as described in greater detail elsewhere. Furthermore while not illustrated here in at least some embodiments at least some of the server block data storage systems may further be interconnected with one or more other networks or other connection mediums such as a high bandwidth connection over which the server storage systems may share volume data e.g. for purposes of replicating copies of volumes and or maintaining consistency between primary and mirror copies of volumes with such a high bandwidth connection not being available to the various host computing systems in at least some such embodiments.

An environment such as that illustrated with respect to can be used to provide and manage resources shared among various customers. In one embodiment a virtualized storage system can be provided using a number of data servers each having a number of storage devices e.g. storage disks attached thereto. The storage system can expose the storage to the customers as a Web service for example. Customers then can submit Web services requests or other appropriate requests or calls to allocate storage on those servers and or access that storage from the instances provisioned for those customers. In certain embodiments a user is able to access the data volumes of these storage devices as if those storage devices are conventional block devices. Since the data volumes will appear to the customer instances as if each volume is a disk drive or similar block device the volumes can be addressed with offsets lengths and other such conventional block device aspects. Further such a system can provide what will be referred to herein as read after write consistency wherein data is guaranteed to be able to be read from the data as soon as the data is written to one of these data volumes. Such a system can provide relatively low latency such as latencies less than about ten milliseconds. Such a system thus in many ways functions as a traditional storage area network SAN but with improved performance and scalability. A customer can make a Web service call into an appropriate API of a Web service layer of the system to provision a data volume and attach that volume to a data instance for that customer.

It will be appreciated that the example of has been simplified for the purposes of explanation and that the number and organization of host computing systems server block data storage systems and other devices may be much larger than what is depicted in . For example as one illustrative embodiment there may be approximately 4 000 computing systems per data center with at least some of those computing systems being host computing systems that may each host fifteen virtual machines and or with some of those computing systems being server block data storage systems that may each store several volume copies. If each hosted virtual machine executes one program then such a data center may execute as many as sixty thousand program copies at one time. Furthermore hundreds or thousands or more volumes may be stored on the server block data storage systems depending on the number of server storage systems size of the volumes and number of mirror copies per volume. It will be appreciated that in other embodiments other numbers of computing systems programs and volumes may be used.

The example environment also includes at least one database configured to store information about the access patterns for the client application and or other such entities. The database can include information for specific volumes stored on the server block data storage system as well as on any archival storage system e.g. for use in managing the volumes and may further store various other information not shown about users or other aspects of the block data storage service. In some embodiments each node manager module on a host computing system can store information about the current volumes attached to the host computing system and used by the executing application s on the host computing system such as to coordinate interactions with the server block data storage systems. While not illustrated here each host computing system may further include a distinct logical local block data storage device interface for each volume attached to the host computing system and used by a program executing on the computing system which may further appear to the executing programs as being indistinguishable from one or more other local physically attached storage devices that provide local storage.

Approaches in accordance with various embodiments can leverage the high visibility provided by the virtualized environment such as that illustrated in or to create improved read ahead optimizations and make those optimizations efficiently in order to reduce read latency and provide other such advantages. Further the information can be stored in such a way that the determined patterns and analysis are persistent across restarts or other such events.

For example illustrates an example of a set of data blocks that can be analyzed in accordance with various embodiments. As should be understood other types of data groupings in other types of arrangement can be used as well with various embodiments. In this example each black block indicates the initial block that was read in response to a request from a user for an application on a session or otherwise associated with a particular aspect entity etc. In this example a monitoring system tracks not only the position of the first read for a set of requests but also the position of each subsequent read. In this example it can be seen that for each initial read request for a particular user for example the following two blocks illustrated with a patterned fill were read by subsequent read requests in the set. Such information can be analyzed by a system manager or other such component to attempt to determine patterns in read requests. By analyzing the data from the example of it can be determined that when a user submits a read request for a block of data the following two blocks will likely be requested in at least one subsequent request.

Once a pattern is determined that pattern can be applied to future requests. Consider the example of which illustrates a similar example set of data blocks . A read request is received from a user for a particular block of data . Once the read request is received a system manager or other such component can analyze the stored information to determine whether a pattern matches an aspect of that request. For example there might be a pattern that matches a user or application associated with that request a volume on which the request is being executed or any other such aspect. In this example the analysis based on the information from indicates that a pattern matches the initial read request for the block of data . Since the pattern indicates that subsequent reads requests likely will request the next two blocks of data the system can go ahead and read those blocks from the block storage e.g. pull off disk and store in memory in order to perform time intensive portions before those subsequent read requests are received.

In some instances a user or application might submit read requests across multiple volumes instances block storage systems data centers or other such groupings of data. In at least some embodiments this information can be aggregated to improve upon pattern determination. For example illustrates an example wherein a user submits reads against two different sets of data blocks . In the first set only two of the three reads have the same subsequent read pattern which might not be sufficient to perform a speculative read in at least some embodiments. In the second set there are only two data points e.g. two initial reads with subsequent behavior which might not provide enough data points for an acceptable prediction. If a system is able to aggregate the behavior with respect to both sets however the data might provide enough certainty to enable a pattern to be determined and applied to future reads. In this example aggregating the data provides five data points which might be enough to be statistically significant or at least meet some other threshold in at least some embodiments. Further since four of the five instances exhibit similar behavior a minimum threshold frequency or other such criterion might be met to determine that it is likely advantageous to perform speculative reads according to that determined behavior. In this case the frequency with which a user reads the next two blocks after an initial read might be sufficient to cause a system to perform speculative reads of two subsequent blocks whenever a read is received for that user.

In at least some embodiments the threshold at which a pattern can be determined and or applied can be set by any appropriate entity such as a user provider or system and can be adjusted based on factors such as load and performance. For example if the system is under a heavy load then a higher frequency might be required in order to prevent a large number of speculative reads from being made that are not actually needed. Similarly if the load on the system is light then the system might perform speculative reads for any pattern that can reasonably be interpreted. Many other levels and determinations can be used as well within the scope of the various embodiments.

In some cases multiple users or applications can submit requests against a common data volume or other grouping of data. For example the set of data blocks in shows the behavior of two different users user A and user B. In some cases a system can attempt to determine patterns of usage for the data volume as a whole. In this case it can be seen that each user typically submits subsequent reads for at least the next two data blocks after an initial read request such that the system might perform speculative reads of the two subsequent blocks for any initial read request received on that volume. In other embodiments a system might instead attempt to optimize on the behaviors of individual users or applications with respect to that volume. In this example user A typically reads the next two blocks after an initial read while user B typically reads the next three blocks. If the system load allows for such optimization the system can attempt to perform a number of speculative reads for each user or application that is predicted based upon the respective behavior.

In some embodiments where behavior can be analyzed at the block storage system level patterns can be detected across many different instances. Behavior can be analyzed across different instances for a common customer assuming in at least some embodiments that the customer instances of a given class will exhibit similar patterns. In some embodiments an analyzing component of the block storage layer can test one or more strategies or patterns against a percentage of the customer s instances to determine which patterns provide accurate results performance enhancements or other such benefits. In certain embodiments such testing also can be done across customers or applications. For example certain customers might do a significant amount of online transaction processing with a specific type of database. Building up a set of behavior information for such users can enable the system to make accurate predictions for other customers doing similar types of things based upon the user performing a type of activity e.g. online transaction processing with respect to a certain type of resource e.g. type of database . In some embodiments patterns can be applied based at least in part upon other types of information as well such as information provided by customers about their volumes and or instances. Such an approach can at least provide a reasonable starting point for speculative reads which can then be optimized over time for specific users applications etc.

Further approaches in accordance with various embodiments can determine what to do with data for speculative reads based upon factors such as network load and resource capacity. For example consider again the example of . In this example the client might send a request to a host across an external network which might issue read requests to the block storage system . The block storage system might perform one or more speculative reads based upon at least one aspect associated with the read requests such as a session identifier or client identifier. Based on aspects of the block storage system internal network host or other such component the block storage system might decide to send the data for the speculative reads across the network to the host to be stored in cache or other such memory or might decide to perform the reads from the physical storage medium according to an I O controller for an instance but instead store the data in local cache at the data local instance instead of sending the data over the internal network . It should be understood that similar determinations can be used as to whether to send such data over an external network as well to one or more resources or devices external to the data provider system etc.

Such an approach can be utilized in various other embodiments as well. The server or device hosting a drive or other data storage mechanism can read the data for the speculative read s into memory and can determine whether to send that data to another destination or store that data locally. If a host is likely to request the data according to the usage pattern the host has available storage capacity and the network between the server and the host is not congested the server might go ahead and send the data for the speculative reads to the host or to the DOM 0 for the virtual instance etc. . If however the network is congested or the host does not have sufficient storage capacity for example the data server might instead store the data locally without sending the data across the network to the host. Since the time spent reading the data from disk into memory is a major source of latency performing the speculative read but storing locally can still provide a significant reduction in latency for subsequent read requests. When a subsequent read request is received to the data server for data that is already in memory the data server can quickly send the data to the host without having to wait to read that data from disk or other such storage. In other embodiments the system might decide to send the information to some intermediate storage or cache to reduce latency where possible.

In some embodiments a system administrator might configure discrete settings or otherwise adjust the level of aggressiveness of the speculations at different times for different situations or for any other appropriate reason. In any situation where a resource has excess capacity and a benefit can be gained by pre fetching data or otherwise speculating on user behavior a system or administrator can have the option or ability to utilize as much of that resource as possible while maintaining other functional aspects of the system.

Further such a system can provide for many types of read ahead operation as opposed to a binary read ahead or no read ahead as in conventional disk based systems. A number of different prediction algorithms can be used to determine which blocks to be pre fetched how far out to fetch the data reads for which to fetch data etc. In addition to pattern detection algorithms such as most recently used or most recently modified algorithms various other algorithms can be used as well that can take into account various other types of input. For example a system can perform Bayesian analysis or utilize another such statistical inference algorithm. In some embodiments multiple speculative read approaches can be attempted concurrently in order to determine an effectiveness of each approach under certain circumstances for certain aspects etc. In some embodiments the algorithms can be used to predict behavior but not actually applied until the results are analyzed and a level of performance or accuracy for each determined. For example the predictions and actual requests can be stored and then analyzed to determine the optimal approach for subsequent reads etc. Further unlike reads at the operating system or disk level such an approach can enable different read approaches to be made for different types or sources of traffic across the same virtual drive instance etc.

As discussed certain embodiments can implement the speculative nature in the DOM 0 which can provide a substantial amount of information at the host level. Further storing information in a location away from the block storage device enables the information to be recovered in the event of a failure or restart. The pattern information and analysis can be thought of as metadata associated with the block storage volume instead of being associated with the host. Having that information available also allows a volume to be attached to a different host or DOM 0 without losing the ability to leverage that information. Further such an approach enables the expanding of data volumes while still being able to rely on determined access patterns such as by using access patterns for similar boot volumes etc.

In some embodiments it also can be beneficial to know which applications are associated with a given data volume as a given volume might be accessed by multiple applications each using a different access pattern. Further it can be beneficial to know the snapshot from which a given volume was created as patterns for that snapshot also can be applied to each resulting volume. Thus it can be beneficial to persistently store metadata associated with a body of data and or associated with the instance type of the application that is going to use the data.

In this example the system or service also can analyze certain existing network conditions or resource state information . For example a system can determine whether a network path between a data volume and a host has excess available bandwidth and or whether the host has available excess memory to temporarily store data. Based at least upon whether there are favorable network conditions for sending data the system or service can determine to send the data across the network to a host running the application or an intermediate caching destination between the data source and the application or can determine to store the data at the data volume or host machine with the disk drive etc. . There are many places in various systems where the data can be cached or otherwise stored temporarily such as on any host device on a flash device for a data volume or on a device dedicated to handle caching etc. If a read request is subsequently received that requires the pre fetched blocks the application can obtain that data from the temporary storage location e.g. either host depending on the current location without having to wait for the data block s to be read from disk. Such an approach can also take into account information such as the bus constraints. By examining the load at the current time the system can determine whether or not to ship the pre fetched bits all the way across the respective network to the host machine. If shipping the bits will not affect any other work the system might decide to undertake that extra effort now even if it is not certain whether that extra effort will pay off in improved performance. In some embodiments the system can also determine how to send the data across the network such as to send in parallel or serialize segment into smaller packets wait to fill up an Ethernet frame etc.

While in many embodiments a storage entity e.g. a block data storage service or BDS manager can drive the speculation for multiple users applications hosts or storage entities for example in other embodiments an entity outside of the storage entity and any compute entity or node can perform the data analysis and or direct the speculation. Such an approach enables access patterns and functionality to be separated from the compute and storage entities such that the patterns and functionality can be shared among new or other such entities or nodes. Further the lifetime of the access patterns and other such information can extend beyond that of any individual entity and can be used to predict information for future entities.

The illustrative environment includes at least one application server and a data store . It should be understood that there can be several application servers layers or other elements processes or components which may be chained or otherwise configured which can interact to perform tasks such as obtaining data from an appropriate data store. As used herein the term data store refers to any device or combination of devices capable of storing accessing and retrieving data which may include any combination and number of data servers databases data storage devices and data storage media in any standard distributed or clustered environment. The application server can include any appropriate hardware and software for integrating with the data store as needed to execute aspects of one or more applications for the client device handling a majority of the data access and business logic for an application. The application server provides access control services in cooperation with the data store and is able to generate content such as text graphics audio and or video to be transferred to the user which may be served to the user by the Web server in the form of HTML XML or another appropriate structured language in this example. The handling of all requests and responses as well as the delivery of content between the client device and the application server can be handled by the Web server. It should be understood that the Web and application servers are not required and are merely example components as structured code discussed herein can be executed on any appropriate device or host machine as discussed elsewhere herein. Further the environment can be architected in such a way that a test automation framework can be provided as a service to which a user or application can subscribe. A test automation framework can be provided as an implementation of any of the various testing patterns discussed herein although various other implementations can be used as well as discussed or suggested herein.

The environment also includes a development and or testing side which includes a user device allowing a user such as a developer data administrator or tester to access the system. The user device can be any appropriate device or machine such as is described above with respect to the client device . The environment also includes a development server which functions similar to the application server but typically runs code during development and testing before the code is deployed and executed on the production side and is accessible to outside users for example. In some embodiments an application server can function as a development server and separate production and testing storage may not be used.

The data store can include several separate data tables databases or other data storage mechanisms and media for storing data relating to a particular aspect. For example the data store illustrated includes mechanisms for storing production data and user information which can be used to serve content for the production side. The data store also is shown to include a mechanism for storing testing data which can be used with the user information for the testing side. It should be understood that there can be many other aspects that may need to be stored in the data store such as for page image information and access right information which can be stored in any of the above listed mechanisms as appropriate or in additional mechanisms in the data store . The data store is operable through logic associated therewith to receive instructions from the application server or development server and obtain update or otherwise process data in response thereto. In one example a user might submit a search request for a certain type of item. In this case the data store might access the user information to verify the identity of the user and can access the catalog detail information to obtain information about items of that type. The information then can be returned to the user such as in a results listing on a Web page that the user is able to view via a browser on the user device . Information for a particular item of interest can be viewed in a dedicated page or window of the browser.

Each server typically will include an operating system that provides executable program instructions for the general administration and operation of that server and typically will include a computer readable medium storing instructions that when executed by a processor of the server allow the server to perform its intended functions. Suitable implementations for the operating system and general functionality of the servers are known or commercially available and are readily implemented by persons having ordinary skill in the art particularly in light of the disclosure herein.

The environment in one embodiment is a distributed computing environment utilizing several computer systems and components that are interconnected via communication links using one or more computer networks or direct connections. However it will be appreciated by those of ordinary skill in the art that such a system could operate equally well in a system having fewer or a greater number of components than are illustrated in . Thus the depiction of the system in should be taken as being illustrative in nature and not limiting to the scope of the disclosure.

An environment such as that illustrated in can be useful for a provider such as an electronic marketplace wherein multiple hosts might be used to perform tasks such as serving content authenticating users performing payment transactions or performing any of a number of other such tasks. Some of these hosts may be configured to offer the same functionality while other servers might be configured to perform at least some different functions. The electronic environment in such cases might include additional components and or other arrangements such as those illustrated in the configuration of discussed in detail above.

As discussed above the various embodiments can be implemented in a wide variety of operating environments which in some cases can include one or more user computers computing devices or processing devices which can be used to operate any of a number of applications. User or client devices can include any of a number of general purpose personal computers such as desktop or laptop computers running a standard operating system as well as cellular wireless and handheld devices running mobile software and capable of supporting a number of networking and messaging protocols. Such a system also can include a number of workstations running any of a variety of commercially available operating systems and other known applications for purposes such as development and database management. These devices also can include other electronic devices such as dummy terminals thin clients gaming systems and other devices capable of communicating via a network.

Various aspects also can be implemented as part of at least one service or Web service such as may be part of a service oriented architecture. Services such as Web services can communicate using any appropriate type of messaging such as by using messages in extensible markup language XML format and exchanged using an appropriate protocol such as SOAP derived from the Simple Object Access Protocol . Processes provided or executed by such services can be written in any appropriate language such as the Web Services Description Language WSDL . Using a language such as WSDL allows for functionality such as the automated generation of client side code in various SOAP frameworks.

Most embodiments utilize at least one network that would be familiar to those skilled in the art for supporting communications using any of a variety of commercially available protocols such as TCP IP OSI FTP UPnP NFS CIFS and AppleTalk. The network can be for example a local area network a wide area network a virtual private network the Internet an intranet an extranet a public switched telephone network an infrared network a wireless network and any combination thereof.

In embodiments utilizing a Web server the Web server can run any of a variety of server or mid tier applications including HTTP servers FTP servers CGI servers data servers Java servers and business application servers. The server s also may be capable of executing programs or scripts in response requests from user devices such as by executing one or more Web applications that may be implemented as one or more scripts or programs written in any programming language such as Java C C or C or any scripting language such as Perl Python or TCL as well as combinations thereof. The server s may also include database servers including without limitation those commercially available from Oracle Microsoft Sybase and IBM .

The environment can include a variety of data stores and other memory and storage media as discussed above. These can reside in a variety of locations such as on a storage medium local to and or resident in one or more of the computers or remote from any or all of the computers across the network. In a particular set of embodiments the information may reside in a storage area network SAN familiar to those skilled in the art. Similarly any necessary files for performing the functions attributed to the computers servers or other network devices may be stored locally and or remotely as appropriate. Where a system includes computerized devices each such device can include hardware elements that may be electrically coupled via a bus the elements including for example at least one central processing unit CPU at least one input device e.g. a mouse keyboard controller touch screen or keypad and at least one output device e.g. a display device printer or speaker . Such a system may also include one or more storage devices such as disk drives optical storage devices and solid state storage devices such as random access memory RAM or read only memory ROM as well as removable media devices memory cards flash cards etc.

Such devices also can include a computer readable storage media reader a communications device e.g. a modem a network card wireless or wired an infrared communication device etc. and working memory as described above. The computer readable storage media reader can be connected with or configured to receive a computer readable storage medium representing remote local fixed and or removable storage devices as well as storage media for temporarily and or more permanently containing storing transmitting and retrieving computer readable information. The system and various devices also typically will include a number of software applications modules services or other elements located within at least one working memory device including an operating system and application programs such as a client application or Web browser. It should be appreciated that alternate embodiments may have numerous variations from that described above. For example customized hardware might also be used and or particular elements might be implemented in hardware software including portable software such as applets or both. Further connection to other computing devices such as network input output devices may be employed.

Storage media and computer readable media for containing code or portions of code can include any appropriate media known or used in the art including storage media and communication media such as but not limited to volatile and non volatile removable and non removable media implemented in any method or technology for storage and or transmission of information such as computer readable instructions data structures program modules or other data including RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disk DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by the a system device. Based on the disclosure and teachings provided herein a person of ordinary skill in the art will appreciate other ways and or methods to implement the various embodiments.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims.

