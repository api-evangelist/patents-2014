---

title: System, method, and computer program product for bulk synchronous binary program translation and optimization
abstract: A system, method, and computer program product are provided for. The method includes the steps of executing a block of translated binary instructions by multiple threads and gathering profiling data during execution of the block of translated binary instructions. The multiple threads are then synchronized at a barrier instruction associated with the block of translated binary instructions and the block of translated binary instructions is replaced with optimized binary instructions, where the optimized binary instructions are produced based on the profiling data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09207919&OS=09207919&RS=09207919
owner: NVIDIA Corporation
number: 09207919
owner_city: Santa Clara
owner_country: US
publication_date: 20140117
---
This invention was made with Government support under LLNS subcontract B599861 awarded by DOE and with Government support under Agreement HR0011 13 3 0001 awarded by DARPA. The Government has certain rights in this invention.

The present invention relates to program optimization and more particularly to dynamic program optimization in a parallel system.

Conventional dynamic program optimization systems use profiling information to compile optimized regions of a program and direct program control flow to the optimized regions during execution of the program. Execution of the optimized regions typically results in higher performance for the program. While some program optimizations may be determined without profiling information the profiling information enables execution specific optimizations.

A specific example of a dynamic program optimization is trace scheduling. The profiling information may record the number of times that common paths through the program are taken by an execution thread. When trace scheduling is performed the most frequently executed paths are identified and optimized by placing the frequently executed paths in sequence and implementing instruction scheduling along the entire path rather than along any other path that might intersect the selected trace . Once the optimized trace is translated into binary instructions the binary instructions corresponding to the optimized trace may be executed instead of the original binary instructions.

To enable execution of the optimized trace the conventional dynamic program optimization system halts execution of the program and while the program is halted the region of the program may be replaced with the optimized representation of the region so that subsequently the optimized representation is executed for the region. Specifically the program may be patched so that branches to the original binary instructions are redirected to the binary instructions corresponding to the optimized trace.

The conventional dynamic program optimization process typically relies on switching back and forth between execution and optimization phases. The optimization phase requires exclusive access to the program that is being optimized so execution of the program is halted during the optimization phase. Halting execution of a program during optimization phases is not a large burden when the program is executed on a sequential processor such as a conventional central processing unit CPU that is single threaded because the sequential processor can only execute one thread at a time where the execution and optimization phases correspond to two different threads.

In contrast with the conventional CPUs parallel systems such as graphics processing units GPUs are implemented with a large number of cores arranged in a highly parallel architecture. These circuits are typically specialized to process large sets of data in parallel especially graphics data. For example a highly parallel GPU may be configured with eight or more cores and each core may be configured to simultaneously execute at least 32 threads so that the GPU may simultaneously execute at least 256 threads.

As previously explained in a sequential processor branches may be redirected to execute an optimized trace the next time that the original binary instructions are executed. However in parallel processors that execute multiple threads simultaneously at any time a thread may be executing a particular branch that will be redirected as a result of an optimization. To ensure that threads are not executing a branch while the branch is being modified to redirect the branch instruction memory pages that contain the branch instruction to be patched should be read protected. Read protecting the instruction memory pages causes threads that access the instruction memory pages to fault and be suspended by the system software until the modification is completed. Using read protection enables correct execution during dynamic program optimization but also introduces high overhead for parallel processors with a large number of threads because many threads may be suspended. Suspending execution of 256 or more threads to perform dynamic program optimization may result in a performance reduction that cannot be overcome by the optimization. Thus there is a need for addressing these issues and or other issues associated with the prior art.

A system method and computer program product are provided for dynamically optimizing a binary program. The method includes the steps of executing a block of translated binary instructions by multiple threads and gathering profiling data during execution of the block of translated binary instructions. The multiple threads are then synchronized at a barrier instruction associated with the block of translated binary instructions and the block of translated binary instructions is replaced with optimized binary instructions where the optimized binary instructions are produced based on the profiling data.

Programs executed by a highly parallel GPU may be configured to synchronize a group of threads at a barrier. The barrier functions to synchronize all of the threads in the group at the same binary program instruction. Hence the barrier performs a bulk synchronization operation. When the threads are synchronized communication operations may be performed to exchange information between the different threads in the group. For example a first one of the threads may have computed a value needed by other threads in the group. The first thread computes the value prior to reaching the barrier and the value is available to be read by the other threads following the barrier.

Once the threads are synchronized and before execution of translated binary instructions following the barrier begins the threads are not executing the translated binary instructions and a block of the translated binary instructions may be replaced with optimized binary instructions. The optimized binary instructions may be dynamically produced for a block of translated binary program instructions during execution of the block of binary program instructions by modifying a copy of the translated binary program instructions to minimize the number of clock cycles before execution resumes after the threads in the group are synchronized at the barrier. The optimized binary instructions may be further optimized and replaced by another set of optimized binary instructions that are dynamically produced when the optimized binary instructions are executed.

In one embodiment a block may correspond to a sub graph of a graph representation of the program e.g. directed acyclic graph and the block may be cyclic or acyclic. At step a block of translated binary instructions is executed by multiple threads. The multiple threads may be executed by one or more multithreaded processing cores that are included in a parallel processor. In one embodiment the parallel processor is a graphics processor. In the context of the present description different translated binary instructions are executed by the one or more threads during a single clock cycle. Separate program counters may be maintained for each thread. During execution individual threads included in the multiple threads may take different paths through the block of translated binary instructions.

In one embodiment an entire program is translated at one time to generate one or more blocks of translated binary instructions including the block of translated binary instructions. In one embodiment a set of instructions in the program is translated to generate the block of translated binary instructions. The entire program or the set of instructions may be translated by a CPU by the parallel processor or by a dedicated hardware unit as the program is loaded into a memory system. In one embodiment when the block of translated binary instructions will be executed each thread is configured to translate a set of instructions in the program to generate per thread instances of the block of translated binary instructions.

At step profiling data is gathered during execution of the block of translated binary instructions. In the context of the present description the profiling data represents various execution specific characteristics corresponding to the block of translated binary instructions. For example counts of the number of times a path through the program is taken violations of compiler assertions e.g. that specific memory operations are not dependent or that floating point operations are within a specific range branch taken not taken probabilities etc. In one embodiment additional instructions are inserted into the translated binary instructions to enable gathering of the profiling data i.e. the block of binary instructions is instrumented during translation .

At step the multiple threads are synchronized at a barrier. In one embodiment the barrier is represented by a barrier instruction and when each thread of the multiple threads reaches the barrier instruction the thread stops execution and waits until all of the threads in the multiple threads reach the barrier instruction.

At step the block of translated binary instructions is replaced with optimized binary instructions that are produced based on the profiling data. The optimized binary instructions may be generated by translating and optimizing the original binary instructions based on the profiling data or by optimizing the translated binary instructions based on the profiling data. The optimized binary instructions may be produced by a different processor such as a CPU or by a thread executing on the parallel processor. In one embodiment the thread may be a thread that is included in the multiple threads and reaches the barrier before one or more other threads in the multiple threads. In one embodiment the thread is not included in the multiple threads. The optimized binary instructions may be produced after step or may be produced in parallel with step and completed when all of the threads included in the multiple threads are synchronized at step .

The method steps shown in may be performed by a dynamic translation and optimization system. In one embodiment the dynamic translation and optimization system includes the parallel processor and a CPU and the translated binary instructions and the optimized binary instructions are produced by the CPU. In another embodiment the dynamic translation and optimization system includes the parallel processor and the CPU and the translated binary instructions are produced by the CPU and the optimized binary instructions are produced by the parallel processor. In another embodiment the dynamic translation and optimization system includes the parallel processor and the CPU and the translated binary instructions are produced by the parallel processor and the optimized binary instructions are produced by the CPU. In another embodiment the dynamic translation and optimization system includes only the parallel processor and the translated binary instructions and the optimized binary instructions are produced by the parallel processor.

More illustrative information will now be set forth regarding various optional architectures and features with which the foregoing framework may or may not be implemented per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

As shown in the PPU includes an Input Output I O unit a host interface unit a front end unit a compute scheduler unit CSU a compute work distribution unit CWDU a graphics primitive distribution unit GPDU a hub a crossbar Xbar one or more general processing clusters GPCs and one or more memory partition units . The PPU may be connected to a host processor or other peripheral devices via a system bus . The PPU may also be connected to a local memory comprising a number of memory devices . In one embodiment the local memory may comprise a number of dynamic random access memory DRAM devices.

The I O unit is configured to transmit and receive communications i.e. commands data etc. from a host processor not shown over the system bus . The I O unit may communicate with the host processor directly via the system bus or through one or more intermediate devices such as a memory bridge. In one embodiment the I O unit implements a Peripheral Component Interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the I O unit may implement other types of well known interfaces for communicating with external devices.

The I O unit is coupled to a host interface unit that decodes packets received via the system bus . In one embodiment the packets represent commands configured to cause the PPU to perform various operations. The host interface unit transmits the decoded commands to various other units of the PPU as the commands may specify. For example some commands may be transmitted to the front end unit . Other commands may be transmitted to the hub or other units of the PPU such as one or more copy engines a video encoder a video decoder a power management unit etc. not explicitly shown . In other words the host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program executed by the host processor encodes a command stream in a buffer that provides workloads to the PPU for processing. A workload may comprise a number of instructions and pointers to data to be processed by those instructions. The buffer is a region in a memory that is accessible i.e. read write by both the host processor and the PPU . For example the host interface unit may be configured to access the buffer in a system memory connected to the system bus via memory requests transmitted over the system bus by the I O unit . In one embodiment the host processor writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit manages the scheduling of instructions from one or more command streams written by the host processor i.e. channels on the various sub units of the PPU .

The front end unit receives instructions from the host interface unit from one or more command streams and forwards those instructions to the correct sub unit of the PPU . Instructions associated with a compute pipeline may be received by the front end unit . These compute instructions are then forwarded to a compute scheduler unit . The compute scheduler unit is configured to track state information related to the various tasks managed by the compute scheduler unit . The state may indicate which GPC a task is assigned to whether the task is active or inactive a priority level associated with the task and so forth. The compute scheduler unit manages the execution of a plurality of tasks on the one or more GPCs .

The compute scheduler unit is coupled to a compute work distribution unit that is configured to dispatch tasks for execution on the GPCs . The compute work distribution unit may track a number of scheduled tasks received from the compute scheduler unit . In one embodiment the compute work distribution unit manages a pending task pool and an active task pool for each of the GPCs . The pending task pool may comprise a number of slots e.g. 16 slots that contain tasks assigned to be processed by a particular GPC . The active task pool may comprise a number of slots e.g. 4 slots for tasks that are actively being processed by the GPCs . As a GPC finishes the execution of a task that task is evicted from the active task pool for the GPC and one of the other tasks from the pending task pool is selected and scheduled for execution on the GPC . If an active task has been idle on the GPC such as while waiting for a data dependency to be resolved then the active task may be evicted from the GPC and returned to the pending task pool while another task in the pending task pool is selected and scheduled for execution on the GPC .

Returning to the front end unit instructions associated with a graphics pipeline may be received by the front end unit . These graphics instructions are then forwarded to a graphics primitive distribution unit . The graphics primitive distribution unit fetches vertex data from the memory or the system memory via the system bus for various graphics primitives. Graphics primitives may include points lines triangles quads triangle strips and the like. The graphics primitive distribution unit groups the vertices into batches of primitives and dispatches tasks to the GPCs for processing the batches of primitives. Processing may involve executing a shader i.e. a Vertex Shader Tesselation Shader Geometry Shader etc. on a programmable processing unit as well as performing fixed function operations on the vertices such as clipping culling and viewport transformation using a fixed function unit.

The compute work distribution unit and the graphics primitive distribution unit communicate with the one or more GPCs via a XBar . The XBar is an interconnect network that couples many of the units of the PPU to other units of the PPU . For example the XBar may be configured to couple the compute work distribution unit to a particular GPC . Although not shown explicitly one or more other units of the PPU are coupled to the host unit . The other units may also be connected to the XBar via a hub .

The tasks associated with the compute pipeline are managed by the compute scheduler unit and dispatched to a GPC by the compute work distribution unit . The tasks associated with the graphics pipeline are managed and distributed to a GPC by the graphics primitive distribution unit . The GPC is configured to process the tasks and generate results. The results may be consumed by other tasks within the GPC routed to a different GPC via the XBar or stored in the memory . The results can be written to the memory via the memory partition units which implement a memory interface for reading and writing data to from the memory . In one embodiment the PPU includes a number U of memory partition units that is equal to the number of separate and distinct memory devices coupled to the PPU . A memory partition unit will be described in more detail below in conjunction with .

In one embodiment a host processor executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the host processor to schedule operations for execution on the PPU . An application may generate instructions i.e. API calls that cause the driver kernel to generate one or more tasks for execution by the PPU . The driver kernel outputs tasks to one or more streams being processed by the PPU . Each task may comprise one or more groups of related threads referred to herein as a warp. A thread block may refer to a plurality of groups of threads including instructions to perform the task. Threads in the same group of threads may exchange data through shared memory. In one embodiment a group of threads comprises 32 related threads.

In one embodiment the operation of the GPC is controlled by the pipeline manager . The pipeline manager manages the configuration of the one or more TPCs for processing tasks allocated to the GPC . In one embodiment the pipeline manager may configure at least one of the one or more TPCs to implement at least a portion of a graphics rendering pipeline. For example a TPC may be configured to execute a vertex shader program on the programmable streaming multiprocessor SM . The pipeline manager may also be configured to route packets received from the Xbar to the appropriate logical units within the GPC . For example some packets may be routed to fixed function hardware units in the PROP and or raster engine while other packets may be routed to the TPCs for processing by the primitive engine or the SM .

The PROP unit is configured to route data generated by the raster engine and the TPCs to a Raster Operations ROP unit in the memory partition unit described in more detail below. The PROP unit may also be configured to perform optimizations for color blending organize pixel data perform address translations and the like.

The raster engine includes a number of fixed function hardware units configured to perform various raster operations. In one embodiment the raster engine includes a setup engine a course raster engine a culling engine a clipping engine a fine raster engine and a tile coalescing engine. The setup engine receives transformed vertices and generates plane equations associated with the geometric primitive defined by the vertices. The plane equations are transmitted to the coarse raster engine to generate coverage information e.g. an x y coverage mask for a tile for the primitive. The output of the coarse raster engine may be transmitted to the culling engine where fragments associated with the primitive that fail a z test are culled and transmitted to a clipping engine where fragments lying outside a viewing frustum are clipped. Those fragments that survive clipping and culling may be passed to a fine raster engine to generate attributes for the pixel fragments based on the plane equations generated by the setup engine. The output of the raster engine comprises fragments to be processed for example by a fragment shader implemented within a TPC .

Each TPC included in the GPC includes an M Pipe Controller MPC a primitive engine an SM and one or more texture units . The MPC controls the operation of the TPC routing packets received from the pipeline manager to the appropriate units in the TPC . For example packets associated with a vertex may be routed to the primitive engine which is configured to fetch vertex attributes associated with the vertex from the memory . In contrast packets associated with a shader program may be transmitted to the SM .

In one embodiment the texture units are configured to load texture maps e.g. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs executed by the SM . The texture units implement texture operations such as filtering operations using mip maps i.e. texture maps of varying levels of detail . In one embodiment each TPC includes two 2 texture units .

The SM comprises a programmable streaming processor that is configured to process tasks represented by a number of threads. Each SM is multi threaded and configured to execute a plurality of threads e.g. threads from a particular group of threads concurrently. In one embodiment the SM implements a SIMD Single Instruction Multiple Data architecture where each thread in a group of threads i.e. a warp is configured to process a different set of data based on the same set of instructions. All threads in the group of threads execute the same instructions. In another embodiment the SM implements a SIMT Single Instruction Multiple Thread architecture where each thread in a group of threads is configured to process a different set of data based on the same set of instructions but where individual threads in the group of threads are allowed to diverge during execution. In other words when an instruction for the group of threads is dispatched for execution some threads in the group of threads may be active thereby executing the instruction while other threads in the group of threads may be inactive thereby performing a no operation NOP instead of executing the instruction. The SM may be described in more detail below in conjunction with .

The MMU provides an interface between the GPC and the memory partition unit . The MMU may provide translation of virtual addresses into physical addresses memory protection and arbitration of memory requests. In one embodiment the MMU provides one or more translation lookaside buffers TLBs for improving translation of virtual addresses into physical addresses in the memory .

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the PPU . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various GPCs . As shown each memory partition unit includes a portion of the L2 cache associated with a corresponding memory device . Lower level caches may then be implemented in various units within the GPCs . For example each of the SMs may implement a level one L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs . The L2 cache is coupled to the memory interface and the XBar .

The ROP unit includes a ROP Manager a Color ROP CROP unit and a Z ROP ZROP unit . The CROP unit performs raster operations related to pixel color such as color compression pixel blending and the like. The ZROP unit implements depth testing in conjunction with the raster engine . The ZROP unit receives a depth for a sample location associated with a pixel fragment from the culling engine of the raster engine . The ZROP unit tests the depth against a corresponding depth in a depth buffer for a sample location associated with the fragment. If the fragment passes the depth test for the sample location then the ZROP unit updates the depth buffer and transmits a result of the depth test to the raster engine . The ROP Manager controls the operation of the ROP unit . It will be appreciated that the number of memory partition units may be different than the number of GPCs and therefore each ROP unit may be coupled to each of the GPCs . Therefore the ROP Manager tracks packets received from the different GPCs and determines which GPC that a result generated by the ROP unit is routed to. The CROP unit and the ZROP unit are coupled to the L2 cache via an L2 XBar .

As described above the compute work distribution unit and the graphics primitive distribution unit dispatch tasks for execution on the GPCs of the PPU . The tasks are allocated to a particular TPC within a GPC and if the task is associated with a shader program the task may be allocated to an SM . A scheduler unit receives the tasks from the compute work distribution unit and the graphics primitive distribution unit and manages instruction scheduling for one or more groups of threads i.e. warps assigned to the SM . Each SM may include K scheduler units i.e. . . . K 1 . The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different warps scheduling the warps for execution and then dispatching instructions from the plurality of different warps to the various functional units i.e. cores SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores i.e. . . . L 1 . In one embodiment the SM includes a large number e.g. 192 etc. of distinct processing cores . Each core may include a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. The core may also include a double precision processing unit including a floating point arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M SFUs i.e. . . . M 1 that perform special functions e.g. pixel blending operations and the like and N LSUs i.e. . . . N 1 that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 192 cores 32 SFUs and 32 LSUs .

Each SM includes an interconnect network that connects each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

The shared memory L1 cache is an array of on chip memory that in one embodiment may be configured as either shared memory or an L1 cache or a combination of both as the application demands. For example the shared memory L1 cache may comprise 64 kB of storage capacity. The shared memory L1 cache may be configured as 64 kB of either shared memory or L1 cache or a combination of the two such as 16 kB of L1 cache and 48 kB of shared memory.

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

In one embodiment the PPU comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes associated with each vertex of the primitive. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display .

An application writes model data for a scene i.e. a collection of vertices and attributes to a memory such as a system memory or memory . The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to the one or more streams to perform operations to process the model data. The commands may reference different shader programs to be implemented on the SMs of the PPU including one or more of a vertex shader hull shader domain shader geometry shader and a pixel shader. For example one or more of the SMs may be configured to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the different SMs may be configured to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA a digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PPU may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPU may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

The profiling data may be gathered through hardware performance counters or using software instrumentation. The counters may be configured to record profiling data for each thread in parallel and then encode the profiling data for a particular characteristic as a value. The values corresponding to one or more characteristics may be used to perform the dynamic program optimization and produce the optimized binary instructions .

In one embodiment the optimized binary instructions are produced during the operation based on the profiling data and the original binary instructions . A block of the original binary instructions that corresponds to the block of translated binary instructions being executed should be indicated in the original binary instructions . During the dynamic translation and optimization process the block of the original binary instructions is translated and optimized. When the original binary instructions are not stored in a bytecode format i.e. are stored in a machine executable binary format the original binary instructions are converted into bytecode as part of the dynamic translation and optimization process and all subsequent optimizations start from the bytecode representation. Optimizations may be more easily applied to a bytecode format compared with a machine executable binary format.

In another embodiment the optimized binary instructions are produced during the operation based on the profiling data and the translated binary instructions . The optimized binary instructions may be produced by a dynamic translation and optimization system comprising a program executed by a thread on the parallel processor or on another processor such as a CPU. Furthermore in one embodiment the translated binary instructions may be generated by the dynamic translation and optimization system. The translated binary instructions may be copied by the dynamic translation and optimization system and optimized to produce the optimized binary instructions .

In another embodiment translation of the original binary instructions is distributed and a per thread instance of the translated binary instructions is generated by each thread just before the thread executes the block of translated binary instructions at operation . The per thread instances should be identical and one of the per thread instances may be copied by the dynamic translation and optimization system for optimization to produce the optimized binary instructions .

In one embodiment the optimized binary instructions are produced after the operation . As previously described the optimized binary instructions may be produced based on the profiling data and the original binary instructions or based on the profiling data and the translated binary instructions . The optimized binary instructions may be produced by a thread on the parallel processor or on another processor such as a CPU.

In one embodiment the optimized binary instructions are produced after the operation . As previously described the optimized binary instructions may be produced based on the profiling data and the original binary instructions or based on the profiling data and the translated binary instructions . The optimized binary instructions may be produced by a thread on the parallel processor or on another processor such as a CPU.

When each thread of the multiple threads reaches a barrier synchronization instruction at operation the thread stops execution of the block of translated binary instructions and waits for all of the threads of the multiple threads to reach the barrier synchronization instruction at operation . The threads may take different paths through the block of translated binary instructions and may reach the barrier synchronization instruction at operation through different paths. However the block of translated binary instructions should be defined such that all of the threads in the multiple threads will reach the barrier synchronization instruction at operation .

When all of the threads have reached the barrier synchronization instruction at operation optimized binary instructions may replace the translated binary instructions . In one embodiment the barrier synchronization instruction may specify a branch instruction and the branch address may be modified to correspond to the optimized binary instructions instead of the translated binary instructions . For example a barrier synchronization instruction not shown that specified a branch to the block of translated binary instructions that are executed at operation may be modified to point to the optimized binary instructions so that subsequently executed threads will execute the optimized binary instructions instead of the translated binary instructions .

To ensure that the optimized binary instructions correctly replace the translated binary instructions the instruction memory hierarchy should be synchronized. The instruction memory hierarchy includes any memory in which the binary instructions may be stored and accessed by the multiple threads e.g. one or more of the instruction cache the shared memory L1 cache the L2 and the memory . In one embodiment the memory hierarchy may be synchronized by invalidating cache entries that store translated or optimized binary instructions.

Once the barrier synchronization instruction operation is completed the multiple threads resume execution and the translated binary instructions may be discarded. The multiple threads may return to execute the optimized binary instructions or the multiple threads may execute a different block of translated or optimized binary instructions. At some point during execution of the program as shown in the multiple threads may execute the optimized binary instructions at operation . When each thread executes the optimized binary instructions the translation operation is not performed.

During execution of the optimized binary instructions profiling data is generated. The profiling data is specific to execution of the optimized binary instructions and therefore may differ compared with the profiling data . When the profiling data substantially matches the profiling data the dynamic translation and optimization system may determine that further optimization is not needed and the optimized binary instructions are not replaced. In one embodiment when corresponding counter values in the profiling data and the profiling data are each within a threshold amount i.e. an integer greater than or equal to zero of each other the profiling data is determined to substantially match the profiling data .

When the profiling data does not substantially match the profiling data the dynamic translation and optimization system may determine that further optimization is needed and the dynamic translation and optimization system may replace the optimized binary instructions with optimized binary instructions . In one embodiment the dynamic translation and optimization system copies the optimized binary instructions and produces the optimized binary instructions based on the profiling data . In another embodiment the dynamic translation and optimization system copies the original binary instructions or the translated binary instructions and produces the optimized binary instructions based on the profiling data . In yet another embodiment the dynamic translation and optimization system uses a combination of the original binary instructions and the optimized binary instructions to produce the optimized binary instructions based on the profiling data . For example if the profiling data differs significantly compared with the profiling data the dynamic translation and optimization system may start optimization from one of the original binary instructions r the translated binary instructions or the optimized binary instructions . The optimized binary instructions may be produced by a thread on the parallel processor or on another processor such as a CPU.

At step the dynamic translation and optimization system invalidates at least the instruction cache that is accessed by the multiple threads. In one embodiment the instruction memory hierarchy is synchronized by invalidating or otherwise updating additional memory and or storage resources in the instruction memory hierarchy. At step the dynamic translation and optimization system generates the optimized binary instructions based on the profiling data. Step may be performed in parallel with steps and . At step the block of translated binary instructions is replaced with the optimized binary instructions.

As previously explained the block of translated binary instructions or a block of optimized binary instructions should only be replaced when no threads are accessing the instructions. Therefore if a first set of multiple threads and a second set of multiple threads are executing simultaneously and both of the sets may access the translated binary instructions both of the sets should be synchronized at step . Alternatively a separate copy of the block of translated or optimized binary instructions may be associated with each one of the sets of multiple threads.

In one embodiment barriers may be implemented at the warp level so that all threads in the same warp are synchronized and a thread that is not in the same warp is not synchronized with the threads that are in the warp. A barrier hierarchy may be supported so that threads may be synchronized at one or more of a warp level a multi warp SM level a TPC level a GPC level and a top PPU level. A synchronization level of a barrier may be specified by the barrier. As previously explained the scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. The scheduler unit may manage a plurality of different warps scheduling the warps for execution and determining when all of the threads in a warp are synchronized at a barrier. When a warp level barrier is specified the scheduler unit within an SM enforces synchronization for all of threads within the warp. When a SM level barrier is specified the scheduler units within an SM enforce synchronization for the warps being executed by the SM so that all of the threads being executed by the SM are synchronized at the SM level barrier. Similarly when a GPC level barrier is specified the scheduler units within a GPC enforce synchronization for the warps being executed by the GPC . Finally when a PPU level barrier is specified all of the scheduler units within a PPU enforce synchronization for the warps being executed by the PPU so that all of the threads are synchronized.

When synchronization is performed at a level other than the top level a version of the optimized binary instructions may be produced and stored at the lower level at which the barrier is enforced. Convergence between the potentially different versions at a lower level may be achieved by merging the versions to produce a single version of the optimized binary instructions at the top level. Over time different versions of optimized binary instructions for each block of a program may be produced at one or more lower levels and successively merged at each higher level to produce an optimized program of optimized blocks of binary instructions at the top level or at level between the top level and the warp level. When lower level versions of optimized binary instructions may be produced the dynamic program optimization may be performed in a distributed manner.

As shown in a SM level barrier synchronizes four warps warps A B C and D. In other embodiments more or fewer warps may be synchronized by a SM level barrier. When versions A B C and D for a first block are merged a version that is the merged version for the first block is stored at the SM level and the versions A B C and D may be removed. When the first block is subsequently executed in the SM by a thread the thread executes the version stored at the SM level . The merged version at the SM level may be compared with other versions of the optimized binary instructions for the first block that are stored at the SM level for other SMs so that the SM level versions may be merged to produce a higher level version for the first block and so on.

At step the dynamic translation and optimization system determines if a lower level barrier is supported and if so at step the dynamic translation and optimization system merges versions at the lower barrier level to produce a version at the specified level. The dynamic translation and optimization system may successively merge versions at each lower level until a merged version is generated at the specified level. Versions for a block can be merged at any level up to the specified level because the threads that may access the versions for the block are synchronized at the specified level and levels that are lower than the specified level. In one embodiment as each thread reaches the barrier the thread begins the merging operation by comparing the version executed by the thread with other versions for the same block so that the merging may be performed while one or more threads are still executing the version translated binary instructions or previously optimized binary instructions for the block.

For example a first thread included in warp A that has reached an SM level barrier may atomically store a newly produced version A produced at step to the next highest level of the program e.g. the SM level . In one embodiment the version A is described by a structure in the form block id pointer to block data optimization level. The warp A is able to successfully store the version A because there is no entry for the block. When warps B C and D reach the SM level barrier each warp attempts to atomically store a structure describing a respective version of . If any of the versions B C and D have higher optimization levels compared with the version A the warps B C and or D perform an atomic store operation to replace the version at the SM level . If the versions B C and D have lower optimization levels the version may be discarded. At the end of the SM level barrier warps A B C and D will all use the updated version from the SM level .

If at step the dynamic translation and optimization system determines that a lower level barrier is not supported i.e. the warp level was specified for the barrier and if so at step the dynamic translation and optimization system proceeds directly to step . At step the block of translated binary instructions is replaced with the optimized binary instructions.

At step the dynamic translation and optimization system generates the optimized binary instructions based on the profiling data. Step may be performed in parallel with steps and . At step the memory system storing instructions that are accessed by the multiple threads is synchronized. The memory system should be synchronized at a level corresponding to level specified for the barrier. For example when the barrier is specified at the warp level at least the instruction cache should be invalidated.

Dynamic generation of optimized binary code for blocks of a program may be distributed between different threads and versions of the optimized binary code may be merged to produce an optimized binary code for the program. Support for versions of the optimized binary code enables execution of the threads without requiring synchronization of all threads executing in a processor to replace a block of the program with dynamically optimized binary code. Instead the threads may be synchronized using barriers at different levels of a barrier hierarchy to replace a block of binary instructions with optimized binary instructions.

The system also includes input devices a graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit GPU .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk DVD drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner. Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. The memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor a chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit board system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant PDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

