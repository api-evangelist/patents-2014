---

title: High performance locks
abstract: Systems and methods of enhancing computing performance may provide for detecting a request to acquire a lock associated with a shared resource in a multi-threaded execution environment. A determination may be made as to whether to grant the request based on a context-based lock condition. In one example, the context-based lock condition includes a lock redundancy component and an execution context component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09424104&OS=09424104&RS=09424104
owner: International Business Machines Corporation
number: 09424104
owner_city: Armonk
owner_country: US
publication_date: 20141105
---
The present application is a continuation of U.S. patent application Ser. No. 13 421 205 filed Mar. 15 2012 which is a continuation of U.S. patent application Ser. No. 12 847 666 filed on Jul. 30 2010.

The present application is related to U.S. patent application Ser. No. 11 617 621 filed Dec. 28 2006 and issued as U.S. Pat. No. 8 332 858.

Embodiments of the present invention generally relate to the use of locks in multi threaded execution environments. More particularly embodiments relate to the use of context based lock conditions to enhance performance in such environments.

Computing system thread safety measures may include the use of synchronization objects e.g. locks to control access to resources that are shared between running threads. These measures could negatively impact software performance however particularly in modern multi core computing environments. While lock acquisition scheduling techniques might aid in mitigating lock related performance concerns there still remains considerable room for improvement. For example scheduling techniques may fail to take into consideration whether locks actually need to be acquired in the context in which a given thread is running

Embodiments may provide for a computer implemented method in which a request to acquire a lock is detected wherein the lock is associated with a shared resource in a multi threaded execution environment. The method may also provide for determining whether to grant the request based on a context based lock condition.

In addition embodiments can include a computer program product having a computer readable storage medium and computer usable code stored on the computer readable storage medium. If executed by a processor the computer usable code may cause a computer to detect a request to acquire a lock associated with a shared resource in a multi threaded execution environment and determine whether to grant the request based on a context based lock condition.

Embodiments may also provide for a computer implemented method in which a runtime analysis of a multi threaded execution environment is conducted and a context based lock condition is identified based on the runtime analysis and a threshold. The threshold can include at least one of a wait time threshold and an occurrence threshold. The context based lock condition may include a lock redundancy component and an execution context component. The method can also provide for detecting a request to acquire a lock associated with a shared resource in the multi threaded execution environment. If both the lock redundancy component and the execution context component of the context based lock condition are satisfied the request may be denied. In addition if both the lock redundancy component and the execution context component are not satisfied the request can be granted.

Other embodiments may include a computer program product having a computer readable storage medium and computer usable code stored on the computer readable storage medium wherein if executed by a processor the computer usable code can cause a computer to conduct a runtime analysis of a multi threaded execution environment and identify a context based lock condition based on the runtime analysis and a threshold. The threshold may include at least one of a wait time threshold and an occurrence threshold and the context based lock condition may include a lock redundancy component and an execution context component. The computer usable code can also detect a request to acquire a lock associated with a shared resource in the multi threaded execution environment. If both the lock redundancy component and the execution context component of the context based lock condition are satisfied the computer usable code may deny the request. If both the lock redundancy component and the execution context component are not satisfied the computer usable code can grant the request.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

Referring now to a scheme of leveraging context based lock e.g. synchronization object conditions is shown. In the illustrated example a thread executing on a computing system attempts to access a shared resource of the system wherein the shared resource is protected by an associated e.g. but not dedicated lock Lock . Thus the illustrated thread might be configured to acquire e.g. engage the lock before being permitted access to the shared resource wherein if the lock is held by another thread not shown in the system the thread could be forced to wait until the lock is available. Moreover each of the other threads in line for the shared resource might also be forced to wait until the lock is available to the thread in question.

It may be determined however that each time the thread as well as the other threads in the system accesses the shared resource that another lock Lock 1 is also acquired by the thread in question. An example of such a case might be a call chain in which the content of another resource not shown associated with the lock is recomputed based on the content of the shared resource . Thus an effective lock redundancy may exist with regard to the locks in the context of the particular call chain. The illustrated scheme identifies a context based lock condition based on such an execution context and lock redundancy and uses the context based lock condition to selectively permit access to the shared resource without also requiring acquisition of the associated lock . In one example the programmatically designed behavior of the thread is dynamically modified so that the thread achieves such access. Simply put the scheme can enable the thread to bypass the lock associated with the shared resource along execution path if the context based lock condition is met. Accordingly the wait time associated with obtaining the lock may be eliminated which can significantly enhance system performance.

Processing block provides for conducting a runtime analysis of a multi threaded execution environment for a deployed system i.e. a system not under test . The runtime analysis might take into consideration program threads synchronization objects functions methods etc. present in the runtime architecture. If it is determined at block that a lock redundancy or other basis for constructing a context based lock condition is present the execution context can be determined at block . Illustrated block provides for determining whether a threshold is reached. One example of a threshold might be a wait time threshold that establishes an amount of accumulated time that threads spend waiting for one or more of the locks corresponding to the lock redundancy. Thus the wait time threshold could enable a severity metric to be built into the system wherein if threads are spending a relatively long amount of time waiting for a redundant lock the issue may be addressed via the generation and use of an appropriate context based lock condition. Another example of a threshold could include an occurrence threshold in which lock redundancies that are encountered often can be mitigated through the generation and use of a context based lock condition. Other thresholds and or combinations of thresholds may also be used.

If the threshold is reached at block a context based lock condition can be established at block based on the lock redundancy and the execution context. In particular the context based lock condition could include a lock redundancy component that identifies two or more locks e.g. Lock 1 and Lock 2 and an execution context component that that identifies a function call chain e.g. Function B Function A . If it is determined that either a lock redundancy or other basis for constructing a context based lock condition is not detected at block or the appropriate threshold has not been reached at block illustrated block provides for determining whether the method should be exited.

Whether or not it is determined at block that the code that acquired the lock was not previously identified as apparently unsuitable method may update the synchronization object tracking list at block to indicate that the subject lock is disengaged.

Turning now to a method of determining whether to grant a request to acquire a lock associated with a shared resource is shown. The method which may be associated with the method already discussed of identifying context based lock conditions could be implemented in executable software as a set of logic instructions stored in a machine or computer readable storage medium such as RAM ROM PROM flash memory etc. as a set of functions explicitly invoked in place of standard OS provided API functions as a software component that dynamically intercepts such API functions and so on.

Processing block provides for detecting a request to acquire a lock associated with a shared resource. If it is determined at block that the requested lock has an associated context based lock condition block provides for determining whether a lock redundancy component of the condition is satisfied. As already noted in addition to lock redundancies other events parameters and or operating characteristics could be used as a basis for permitting access to the shared resource without acquisition of the associated lock. Block provides for determining whether the execution context component of the context based lock condition is satisfied. In other words the illustrated approach confirms that the attempt to acquire the lock is made within the proper context before deploying the above described bypass mechanism. Thus if a formerly irrelevant e.g. redundant lock suddenly becomes relevant the method can restore the programmatic lock acquisition as intended by the thread code. If both the lock redundancy component and the execution context component are satisfied block provides for denying the request and permitting the requesting thread to access the shared resource without acquiring the lock associated with the shared resource. Otherwise the thread may wait until the lock is available and the request is granted at block .

Consider for example a program that includes three threads T T and T and three resources R R and R each thought to be protected by an associated lock L L and L. Also suppose certain content of R sometimes is recomputed based on the content of R and sometimes the content of R is recomputed based on the content of R and R. One of the resources R might always be accessed via an accessor function R acc that ensures thread safety by making sure lock L is held by any thread accessing R wherein lock L could be used to protect other resources as well. Access to resources R and R might involve code from a library that accesses resource R in a less modular fashion where design constraints or historical considerations may not allow for R accessor functions.

The threads may make the following function calls shown in Table I on separate processor cores approximately at the times described in a situation where R will depend on R 

In the above situation though the threads are running on independent processors thread T waits about 20 ms for a shared resource R to become available and thread T waits along with T for its chance to access R. Meanwhile no thread ever accesses resource R without acquiring both locks L and L.

An approach as described herein could observe the above situation and learn to not acquire lock L within R acc . The lock acquisition coded into R acc could therefore be denied once the lock is satisfactorily found to be unnecessary as the run progresses. An example of the associated performance enhancement is shown below in Table II.

Thus by considering whether lock L actually needs to be acquired in the context in which thread T is running the illustrated approach can significantly reduce wait times and may provide substantially improved performance.

Turning now to a method of detecting engagement of a synchronization object by a thread is shown. The method may generally be associated with the method already discussed of using a suitability metric. In the illustrated example method may detect an attempt to acquire a lock at block . Once detected block may provide for tracking the lines of code that attempted to acquire the lock within the synchronization object tracking list described above with respect to . The elements included within the synchronization object tracking list may include suitability and unsuitability counters wherein these suitability and unsuitability counters may apply to the overall acquisition of the lock for an entire set of resources. Each list element within the synchronization object tracking list may be associated with a call chain that may indicate the means by which execution has reached the line of code that has acquired the lock. When the user of a lock suitability analysis method requests a report defining the unnecessary use of locks the call chains for the list elements included within the synchronization object tracking list that are associated with apparently unnecessary lock protection may be of interest to the software developer.

A determination can be made at block as to whether the line of code has been found apparently unsuitable for protection by the lock on at least the threshold number of occasions and never been found definitely suitable . If so the illustrated method continues running at block without acquiring the lock.

Otherwise a determination may be made at block as to whether another thread has already acquired the subject lock. If another thread has not already acquired the subject lock the synchronization object tracking list for the subject lock may be updated at block to indicate that the subject lock is acquired e.g. engaged by the current thread and that this acquisition has not caused a task switch.

Task switching can refer to the situation in which a computer system executes one thread and prior to completing execution of that thread switches contexts to begin executing a different thread. Task switching may occur under several different circumstances. For example one situation in which task switching may occur is when a thread runs out of time. As a multitasking operating system typically allots a predetermined amount of continuous time during which each otherwise runnable thread may execute in turn when that time period expires the operating system may switch to begin executing another task. While task switching allows for parallel execution of multiple threads overly frequent task switching may cause execution of thread management tasks to consume a large percentage of processing time which may degrade performance.

Another situation in which a computer system switches tasks may be attributable to a blocking condition . A blocking condition occurs when a thread needs access to a resource that is protected by a lock acquired by another thread. So long as that resource is thus protected the blocked thread is not given the opportunity to run. A blocking condition may result in delay of threads to perform actual work which may degrade performance.

Once the synchronization object tracking list is updated at block method may determine if a call chain i.e. that defines the means by which the line of code that engaged the subject lock was reached during execution of the system had been previously collected. If not block may collect the call chain. When collecting the call chain method may walk the call chain in a manner similar to a debugger updating its call stack display. Alternatively the scheme may include methods by which a thread stack list element is recorded at each function entry including the starting address of the function and by which that list element is removed when the function exits. Thus a call chain may be obtained that includes the intercepted functions of the system at any time by walking the recorded list.

Alternatively if it is determined at block that another thread had already acquired the subject lock the synchronization object tracking list for the subject lock may be updated at block to indicate that the intercepted attempt to acquire the subject lock has caused a task switch i.e. from the subject thread to another runnable thread .

In addition a detect resource allocation routine not shown can be used so that the above described counters and tracking structures are allocated and listed. Moreover a detect resource deallocation routine not shown may be called in order to clean up the above described counters and tracking structures when resources are freed.

The cores may be configured to execute various OS s and or applications with multiple threads according to the particular circumstances. Moreover the threads may share the internal cache s not shown of the processor the system memory the memory space of the HDD and other resources such as an SSD solid state disk not shown network resource etc. wherein locks can be used to protect the shared resources. Accordingly the system may be configured to detect requests to access locks associated with shared resources and determine whether to grant the requests based on context based lock conditions while the system is deployed i.e. not under test .

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions. In addition the terms first second etc. may be used herein only to facilitate discussion and carry no particular temporal or chronological significance unless otherwise indicated.

Those skilled in the art will appreciate from the foregoing description that the broad techniques of the embodiments of the present invention can be implemented in a variety of forms. Therefore while the embodiments of this invention have been described in connection with particular examples thereof the true scope of the embodiments of the invention should not be so limited since other modifications will become apparent to the skilled practitioner upon a study of the drawings specification and following claims.

