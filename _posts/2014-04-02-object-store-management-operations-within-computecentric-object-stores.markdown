---

title: Object store management operations within compute-centric object stores
abstract: Object store management operations within compute-centric object stores are provided herein. An exemplary method may include transforming an object storage dump into an object store table by a table generator container, wherein the object storage dump includes at least objects within an object store that are marked for deletion, transmitting records for objects from the object store table to reducer containers, such that each reducer container receives object records for at least one object, the object records comprising all object records for the at least one object, generating a set of cleanup tasks by the reducer containers, and executing the cleanup tasks by a cleanup agents.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09075818&OS=09075818&RS=09075818
owner: Joyent, Inc.
number: 09075818
owner_city: San Francisco
owner_country: US
publication_date: 20140402
---
This non provisional patent application claims the benefit of and is a continuation of U.S. patent application Ser. No. 13 836 599 titled Object Store Management Operations Within Compute Centric Object Stores filed Mar. 15 2013 now U.S. Pat. No. 8 775 485 issued on Jul. 8 2014 which is hereby incorporated by reference herein in its entirety including all references cited therein.

The present technology relates generally to the execution of object store management operations within a compute centric object store. The present technology leverages compute operations within a compute centric object store to facilitate management operations such as garbage collection resource metering and so forth.

Various methods and systems for providing multitenant computing systems such as cloud computing have been attempted. In general a cloud based computing environment is a resource that typically combines the computational power of a large model of processors and or that combines the storage capacity of a large model of computer memories or storage devices. For example systems that provide a cloud resource may be utilized exclusively by their owners or such systems may be accessible to outside users who deploy applications within the computing infrastructure to obtain the benefit of large computational or storage resources.

The cloud may be formed for example by a network of servers with each server or at least a plurality thereof providing processor and or storage resources. These servers may manage workloads provided by multiple users e.g. cloud resource consumers or other users . Typically each user places workload demands upon the cloud that vary in real time sometimes dramatically. The nature and extent of these variations typically depend on the type of business associated with the user.

Management operations within these systems comprise for example garbage collection where the system cleans up object stores by deleting consolidating or otherwise processing user deleted data. Garbage collection may include deleting or updating dependencies between objects namely objects that were deleted by users that were formerly associated with other objects in the object store. Other management operations comprise usage metering where the system generates reports that are indicative of system resource utilization. These reports may be generated to provide system administrators with empirical data regarding object store usage even down to the user level. Unfortunately object storage systems that utilize these management functions often leverage third party tools which are not specifically designed for the object store itself. Thus administrators may struggle with compatibility issues and other similar drawbacks.

According to some embodiments the present technology may be directed to methods that comprise a transforming an object storage dump into an object store table by a table generator container wherein the object storage dump includes at least objects within an object store that are marked for deletion b transmitting records for objects from the object store table to reducer containers such that each reducer container receives object records for at least one object the object records comprising all object records for the at least one object c generating a set of cleanup tasks by the reducer containers and d executing the cleanup tasks by a cleanup agents.

According to some embodiments the present technology may be directed to systems that comprise a one or more processors and b logic encoded in one or more tangible media for execution by the one or more processors the logic comprising i a table generator container that transforms an object storage dump into an object store table wherein the object storage dump includes at least objects within an object store that are marked for deletion ii a set of reducer containers that receive records for objects from the object store table from the table generator such that each reducer container receives object records for at least one object the object records comprising all object records for the at least one object iii generate a set of cleanup tasks and iv cleanup agents that execute the cleanup tasks.

According to some embodiments the present technology may be directed to methods that comprise a partitioning raw usage records by a map phase container b grouping the partitioned records by user type and an identifier via a first set of reducer containers c deduplicating the grouped usage records via a second set of reducer containers d aggregating the deduplicated usage records for a user for a namespace into namespace records via the second set of reducer containers and e summing namespace records for each namespace associated with the user into a usage report via a third set of reducer containers.

According to some embodiments the present technology may be directed to systems that comprise a one or more processors and b logic encoded in one or more tangible media for execution by the one or more processors the logic comprising i a map phase container that partitions raw usage records ii a first set of reducer containers that groups partitioned records by user type and an identifier iii a second set of reducer containers that deduplicate the grouped usage records iv the second set of reducer containers aggregating the deduplicated usage records for a user for a namespace into namespace records and iv a third set of reducer containers that each sum the namespace records for each namespace associated with a user into usage reports.

While this technology is susceptible of embodiment in many different forms there is shown in the drawings and will herein be described in detail several specific embodiments with the understanding that the present disclosure is to be considered as an exemplification of the principles of the technology and is not intended to limit the technology to the embodiments illustrated.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the present technology. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

It will be understood that like or analogous elements and or components referred to herein may be identified throughout the drawings with like reference characters. It will be further understood that several of the figures are merely schematic representations of the present technology. As such some of the components may have been distorted from their actual scale for pictorial clarity.

In general the system comprises an object store A that provides compute as a first class citizen of an object store A. More specifically compute operations e.g. instructing the system to compute on objects in the object store of the present technology resemble a top level API function similar to processes like storing or fetching objects in the object store A.

It will be understood that the terms object store comprise a network service for storing unstructured arbitrary sized chunks of data objects . It will be further understood that the object store may not support modifications to existing objects but supports full object replacement operations although systems that support both object modification and full object replacement operations may also utilize the features of the present technology to perform compute operations directly on e.g. in situ objects within the object store.

In some embodiments the system may be configured to receive a request to perform a compute operation on at least a portion of an object store from a first user. Again the user may be associated with one of the client devices. The request identifies parameters of the compute operation as well as objects against which the compute operation is executed.

In some instances the system may assign virtual operating system containers to a user based upon a request. The system may map objects to the containers that are associated with the user. Typically these objects are identified by the user in the request. A virtual operating system container performs the compute operation on an object according to the identified parameters of the request. The system may then clear the virtual operating system containers and return the virtual operating system containers to a pool of virtual operating system containers. Additional aspects of the system will be described in greater detail below.

It will be understood that a compute centric object store may be created to operate without the user of virtual operating system global kernel or virtual operating system containers. While such an object store would provide advantages such as in situ computation of data where objects are processed directly on the object store the object store may not isolate tenants in the similarly to systems that utilize a virtual operating system and or virtual operating system containers.

In these instances the compute centric object store may be configured to receiving a request to perform a compute operation on at least a portion of an object store from a first user via a network service the request identifying parameters of the compute operation. The object store may also execute an operating system process for the objects identified in the request. The operating system process may perform the compute operation on the object according to the identified parameters of the request. Additionally once the compute operation has been executed the operating system process may be terminated by the virtual operating system.

The terms in situ computation will be understood to include the execution of compute operations against objects in an object store where the objects not moved or copied from or within the object store.

In some embodiments the system is comprised of a hardware layer that provides a logical interface with at least one or more processors and a memory which stores logic that is executed by the one or more processors. Generally the hardware layer controls one or more of the hardware components of a computing system such as the computing system of which will be described in greater detail below. By way of non limiting example the hardware layer may manage the hardware components of a server blade or another similar device. The hardware layer provides access to the physical hardware that services a global operating system kernel that cooperates with the hardware layer . The global operating system kernel may also be referred to as a host operating system kernel.

Generally the global operating system kernel is configured to administer and manage a pool of guest virtual operating system containers such as containers A N. The containers A N may operate on a distributed object store in a multitenant manner where multiple containers can operate on the same object store simultaneously. It will be understood that each user is assigned container from the pool on an as needed basis. When a container is applied to an object store the container is referred to as a tenant.

According to some embodiments the system kernel may be utilized to setup the pool of guest virtual operating system containers. The system kernel may also be configured to provide a command line interpreter interface that allows users to request jobs execute other operating system implemented applications and interact with a virtual operating system in a manner that is substantially indistinguishable relative to an operating system executing on a bare metal device.

Generally a job may be input by a user via a command line interpreter such as a Unix shell terminal. More specifically the user may express a computation using the same language as the language used by a Unix shell terminal. The actual request is submitted to the network service B. Indeed a request may be submitted as an HTTP request to the network service B. The body of the request describes the computation to perform in terms of what commands are input into the command line interpreter which is running within a container. Contrastingly systems that utilize multiple VMs that each comprises an operating system kernel which are managed by a hypervisor often require users to construct complex programs or scripts to perform compute operations. Compute operations for traditional VM systems require complex programming due to a complex framework that is used by the hypervisor to coordinate hardware emulation for each of the VMs.

Using the command line interpreter interface the user may specify one or more desired compute operations that are to be executed against objects such as object within an object store A see . It is noteworthy that the object store A may include for example a local or distributed object store that maintains contiguous blobs blocks or chunks of data. It will be understood that the objects stored in the object store A are complete objects such as files or other similar data structures. Moreover the compute operations executed against the object store A may be performed in such a way that partial stores of data are avoided.

In order to perform compute operations on objects for multiple users the system kernel may collocate containers A N onto the object store A and execute the containers A N simultaneously. In a plurality of containers such as container A has been placed onto each of a plurality of objects within the object store A. Thus a virtual operating system container is assigned to each of the plurality of objects specified in the user request. Most frequently the assignment of a single container to a single object occurs when the system executes a map phase operation. The details of map and reduce phases provide by the system will be described in greater detail below.

Broadly speaking a virtual operating system container may be a lightweight virtualization solution offering a complete and secure user environment that operates on a single global kernel system kernel providing performance characteristics that are similar to operating systems that operate on bare metal devices. That is a virtual machine operates on emulated hardware and is subject to control by a hypervisor which produces computing inefficiencies. A virtual operating system container may operate without the computing inefficiencies of a typical virtual machine.

In some instances the system kernel may utilize a KVM Kernel Virtual Machine that improves the efficiency of the a virtual operating system such as the global operating system kernel by leveraging CPU virtualization extensions to eliminate a substantial majority of the binary translation i.e. hardware emulation that are frequently required by VMs.

Turning to an exemplary virtual operating system container A is shown as comprising a quick emulator layer QEMU a virtual guest operating system and a compute application that is managed by the virtual guest operating system . The QEMU provides hardware emulation and is also VMM virtual machine monitor . It is noteworthy that in some embodiments the QEMU is not a strict hypervisor layer but rather each QEMU may be independent in some exemplary embodiments. That is there may be one QEMU one per container instead of a single QEMU supporting several VMs. Advantageously the operations of both a VM and a VMM may be combined into the QEMU .

According to some embodiments the compute application that is executed may include a primitive O S compute operation. Exemplary compute operations may include operating system primitive operations such as query word count send receive and so forth. Additionally the operations may comprise more sophisticated operations such as operations that include audio or video transcoding. Additionally in some instances users may store programs or applications in the object store itself. Users may then execute the programs as a part of a compute operation.

In some instances the compute operations may include one or more phases such as a map phase followed by a reduce phase. Generally a map phase may include an operation that is executed against each of a plurality of objects individually by a plurality of containers. In some instances a unique container is assigned to each object that is to be processed.

In contrast a reduce phase may be executed by a single container against a plurality of objects in a batch manner. Using an example such as word count it will be assumed that the objects of the object store A may comprise text files. The compute application may execute a map phase to count the words in each of the text files. The output of the compute application may be stored in a plurality of output objects that are stored in the object store A. A compute application of another container may execute a reduce phase that sums the output objects of the map phase and generates a word count for all objects within the object store A.

It will be understood that the system kernel may schedule and coordinate various compute operations and phases performed by the compute applications of all containers. In sum the system kernel may act similarly to a hypervisor that manages the compute operations of the various active containers. Based upon the request input by the user the system kernel may instruct the containers to perform a series of map functions as well as a reduce functions. The map and reduce functions may be coordinated to produce the desired output specified in the request.

Turning to after receiving a request from a user the system kernel may select a first set of containers which includes container A from the pool of containers. This container A is assigned to a user. In response to receiving a request from a second user the system kernel may also select a second set of containers from the pool of containers.

Based upon the request received from the first tenant the system kernel may map the first set of containers to a plurality of objects such as object stored in the object store A. Likewise the system kernel may map a second set of containers to a plurality of different objects stored in the object store A for the second user. The objects and containers for the first user may be referred to as a compute zone of the first user while the objects mapped to the container N may be referred to as a compute zone of the second user. The maintenance of compute zones allows the system kernel to provide multitenant access to the object store A even when the first and second users are potentially adversarial. For example the first and second users may be commercial competitors. For security the system kernel maintains compute zones in order to balkanize object storage and prevent access to objects of other users. Additionally the balkanization of object storage also ensures fair distribution of resources between users.

It will be understood that the system kernel may maintain as many containers and compute zones as allowed by the processor s of the hardware layer . Additionally the system kernel assigns a container to a user on an as needed basis meaning that containers may not be assigned permanently to a user which would result in a monopolization of resources when the user is not performing compute operations.

Additionally because the container is placed onto the object store the system kernel need not transfer objects from the object store A into the container for processing in some exemplary embodiments. Advantageously the container operates directly on the objects of the object store A.

According to some embodiments the containers A N managed by the system kernel are empty when the containers A N are in the pool. After objects are mapped to the container compute operations may be executed by the container on the objects and a desired output is generated the system kernel may clear the container and return the container to the pool.

In some instances the system kernel may not generate containers until a request is received from a user. That is the system kernel may spin up or launch containers when a request is received from the user. This allows for minimum impact to the bare metal resources such as the CPU as the system kernel need not even maintain a pool of virtual operating system containers which are awaiting user requests. That is maintaining a pool of containers requires CPU and memory resources. When the compute operations have been completed the system kernel may terminate the containers rather than clearing the containers and returning the containers to a pool.

In accordance with the present disclosure an instruction set architecture may be implemented within the system . In some embodiments the instruction set architecture may specify an application programming interface that allows the system to interact with the distributed object store.

According to some embodiments the system communicatively couples with the object store A using a services related application programming interface SAPI which provides features such as automatic discovery of object stores dynamic configuration of object stores and an API for a user portal. In sum the SAPI allows users to configure deploy and upgrade applications using a set of loosely coupled federated services. In some embodiments the SAPI may include an underlying API and an autoconfig agent also referred to as a daemon . A SAPI client may also be disseminated to clients. It will be understood that the daemon may be associated with a physical node of the object store A.

In accordance with some embodiments according to the present disclosure various object stores such as object store A of comprise a single SAPI zone. It will be understood that the SAPI zone may be stateless and the SAPI zone may be configured to write objects into the object store A. In addition to storing objects the SAPI zone may also communicatively couple with a VM API to provision zones and a network API NAPI to reserve network interface controllers NIC and lookup network universal unique identifiers UUID .

It will be understood that the SAPI may comprise three main object types such as applications services and instances. It is noteworthy that an application may comprise one or more services and each service may comprise one or more instances. Moreover instances may represent actual object store zones and such zones inherit zone parameters and metadata from their associated applications and services.

Also the application service and instance information may be used by the compute application of a virtual operating system container that is placed onto an object store. The daemon may control the operation of the containers operating on the daemon s object store.

Each application service and instance may include three sets of properties. For example params may comprise zone parameters like a zone s RAM size disk quota image UUID and so forth. These parameters are evaluated when a zone is provisioned. Another property comprises metadata which defines metadata available to the daemon . These metadata keys and values form the input of a script template in a configuration manifest described below . As these values are updated the daemon may rewrite any configuration and make reference to changed metadata values. Yet another property comprises manifests that define a set of configuration manifests are indexed by name to facilitate inheriting manifest from parent objects.

It is noteworthy that creating applications and services have no effect on running zones. When an instance is created a zone is provisioned using the above information from its associated application service and instance. Stated otherwise applications and services e.g. a job or request may be defined separate from the objects that the applications and services are to be executed against. Thus a job may be thought of abstractly as a workflow template. Advantageously when the user requests the execution of a job objects need only be defined by the user. The workflow template is then applied against the objects.

In some embodiments the daemon of a zone may be tasked with maintaining configuration inside that zone. The daemon queries the SAPI directly to determine which files to write and where to write them within the object store A.

The daemon uses objects called configuration manifests those objects describe the contents location and semantics of configuration files for a zone. Those manifests contain a script template which is rendered using the metadata from the associated application service and instance.

When a user provides a request to the system the system kernel may coordinate a compute flow of compute operations which are managed by the daemon . That is the system kernel may receive a request or job from a user via a command line interpreter. The request identifies parameters of a compute operation that is to be executed against objects in a distributed object store. For example a request may include performing a word count operation on a file.

To facilitate compute flow during the compute process the system kernel may assign an identifier for the request. This identifier provides a unique identifier that allows objects and outputs of compute operations to be correlated to the user. Objects previously stored in the object store may be correlated to the user utilizing a unique identifier. According to some embodiments the identifier comprises the name of an input object or job name. This name may be specified by an end user submitting a job request to the system or may be generated by the system from the request.

The user may also identify objects for the compute operation using for example the command line interpreter. An exemplary find object command may include Find User Object Store Location where the Object Store Location defines the object store that includes the object s which are necessary for execution of the compute operation.

In some instances the system kernel may query various daemons of object stores to locate the objects within the distributed object store. After the object have been located the system kernel may generate a set of tasks e.g. an instruction set that defines the various compute operations that are to be performed by the daemon of the located object store. In the example provided above the set of tasks may include only one word count task that is provided to a single daemon of an object store e.g. physical node . This relatively simple compute operation does not require coordination or scheduling of operations of multiple objects.

The daemon may provide instructions to one or more virtual operating system containers that are placed onto the object store by the system kernel . That is the instruction sets provided to the containers is based upon the task assigned to the daemon from the system kernel .

In some instances the set of tasks may include a more complex arrangement of operations that are executed against a plurality of objects stores. The system kernel may interact with the daemon to coordinate processing of these objects in a specified order.

Additionally the set of tasks may define various map phases that are to be executed on the objects of the object store as well as various reduce phases that are executed on the outputs of the map phases. It will be understood that objects within the workflow may be tracked and correlated together using the identifier. For example if an instruction set passed to a daemon requires performing a word count compute operation on 100 text files each of the objects of the compute operation would be correlated using the identifier. Thus the objects of the compute operation would comprise 100 objects that each includes a word count value for their corresponding text file. The identifier may be appended to the object as metadata.

It will also be understood that a map phase may result in multiple outputs which are generated from a single input object. For example assume that usage logs for a computing device are stored for a 24 hour time period. To determine hourly usage rates the 24 hour log object may be separated into 24 distinct objects. Thus the map phase may receive the 24 hour log object and may split the same into constituent output objects to complete the map phase.

It will be understood that a more complex request may require a more complicated set of tasks e.g. phases . For example if the user desires to look at all 11 p.m. to 12 p.m. user logs for a plurality of computing devices the set of tasks may require not only the map task where a single input object is processed into multiple objects but also a reduce phase that sums a plurality of 11 p.m. to 12 p.m. user logs for a plurality of devices.

In sum the system kernel will provide a daemon with tasks that include a map phase for generating the hour increment logs from various input objects. Additionally the tasks also inform the daemon to return the output objects which may be stored as an aggregate 11 p.m. to 12 p.m. log object within the object store.

It will be understood that the daemon of a physical node e.g. object store may control execution of compute operations by the one or more virtual operating system containers that are placed onto the object store via the system kernel .

Thus it is appreciated with that intermediate output objects may not be output to the user directly but may be fed back into the system for additional processing such as with the map and reduce phases described above. Moreover the set of tasks generated by the system kernel may include any number of map phases and or reduce phases which vary according to the steps required to produce the desired output.

According to some embodiments the system may leverage virtual operating system containers or compute zones to execute object store management functions within the compute centric object store. Generally these management functions comprise garbage collection usage metering and so forth. While many other management functions may be implemented the following examples will further describe the execution of garbage collection and usage metering. One of ordinary skill in the art will appreciate that other object store management functions may also likewise be implemented using the frameworks described below but configured to execute the desired function.

Broadly speaking garbage collection refers to processes utilized to clean up an object store after a series of garbage creation events. A garbage creation event may include for example when a user deletes an object or when a user overwrites an object that is linked to one or more dependent objects. Garbage created by these events may include the deleted object as well as any orphan links created by the deletion where an orphan link includes a link between the deleted object and one or more dependent objects.

The following definitions provide context for the following discussion. A storage node is a physical server that stores actual user data and has at least one virtual operating system container pooled collocated with the storage node.

An internal metadata system is a place attributes about data ownership sizes free space and so forth are stored. This internal metadata system is comprised of shards. These shards comprise data structures that have been partitioned in such a way that the system can add more partitions to the shared as the system grows.

Turning to the garbage collection process it will be understood that each time a user uploads and subsequently deletes data within an object store garbage is left over in the system in the form of files on storage nodes. If not dealt with the system may generate enough garbage to cause the system to run out of room for new data within a short period of time.

As background the system may utilize an indexing tier e.g. authoritative store which is an authoritative source that tracks which objects within the system of object stores and informs the system as to which objects are live. Objects are live in the sense that the objects are accessible for retrieval through a system API Application Programming Interface . Since the indexing tier is an authoritative store the indexing tier is consulted to determine if a particular object should be collected. The indexing tier is actually composed of many shards with each shard being responsible for a slice of one or more live objects. References for files in the storage node can exist on any of the shards. When an object is associated with multiple shards each of the associated shards is consulted. Due to the nature of distributed systems all shards cannot be consulted at the same instant in time. Due to this limitation garbage collection is implemented as a job post processing the set of shards.

The table generator container may transmit records for each object to a set of reducers in such a way that each reducer is provided all records for at least one given object. It will be understood that a reducer may receive all object records for a plurality of objects. The reducers sort the set of rows so that records for objects are grouped together and ordered by time. Each reducer may walk the history of an object review records in chronological order and decide if the object should be garbage collected. An object is garbage collected if the only record of that object is a deletion record that has passed a system wide grace period. In addition deletion records are cleaned up if records for the object referenced in the deletion record have later records.

The output of the reducers is a set of cleanup tasks for shards and object storage nodes. Cleanup tasks may then be processed by uploaded the tasks to a directory within the object store. Additionally an operations file is uploaded with the set of commands to run to link the cleanup files into the correct locations for a set of crons. These commands may be uploaded to another specified task directory within the object store.

Generally speaking a cron is a basic Unix facility for executing arbitrary programs periodically e.g. usually hourly daily weekly etc. . A cronjob is process which is set up to run periodically with cron. Cronjobs may gather and upload a component s last hour s log files to the object store itself both for long term log storage or immediate processing using a compute component. In some instances the crons include cleanup agents that run within a compute zone. Specifically the compute zone is referred to as a cleanup zone when the cron is a cleanup agent.

Cleanup agents will periodically look in a directory where cleanup tasks are stored and the cleanup agents will periodically execute the cleanup tasks. The cleanup agents look for files in specified directories downloads the files and processes each line of the file to delete objects from the object store. The cleanup agents execute within a cleanup zone so that it can reach out directly to each shard.

A cleanup agent will execute on each node and the cleanup agent will look for objects in a specified location on the node. The cleanup agent will then download the task for the object and processes each line of the object to delete object off the local disk.

Next the method may include a step B of generating cleanup tasks for each deleted object from the object store table via a set of reducers. Each deleted object may include a separate record within the object store table. Additionally the method may include a step C of executing the cleanup tasks via a set of cleanup agents. A cleanup agent may be assigned for each deleted object. The cleanup agent processes the cleanup task for the object by evaluating each line of the object to delete the objects from the object store.

With regard to storage daily storage metering sums up the usage from every hour on the given calendar day and monthly storage metering sums up the usage from every day on the given calendar month. This means daily and monthly storage metering represent unit hours of usage i.e. byte hours key count hours .

Storage hourly metering consists of a map phase and three reduce phases. Storage raw data consists of dumps of data to each shard. The first line contains a table name and describes the schema for each entry.

The map phase container takes extracts a  value field and emits it as output. These records are partitioned and sent to a first set of reducer containers grouped by owner type and objectId such that all identifiers that point to the same object for a single owner are collocated on a single reducer. Each reducer container deduplicates any keys that point to the same object and aggregates usage per owner by namespace. ObjectIds are indexed in memory and any keys that point to the same object only increment a user s number of keys. The reducer containers output deduplicated records .

The second set of reducer containers sums up all of a user s usage for a single namespace. The output format is the same as the output format of the first reduce phase. Results are partitioned by owner. Cardinality of data is number of users multiplied by the number of namespaces. Once aggregation is finished one aggregated record is emitted per owner per namespace partitioned to that reducer.

The third set of reducer containers combines a usage across different namespaces for a single user into a single record. If a user has no usage for a namespace zero usage is added to the record for that namespace at this time. The third set of reducer containers delivers reports to each user s reports namespace.

The components shown in are depicted as being connected via a single bus . The components may be connected through one or more data transport means. Processor and main memory may be connected via a local microprocessor bus and the mass storage device peripheral device s portable storage device and display system may be connected via one or more input output I O buses.

Mass storage device which may be implemented with a magnetic disk drive or an optical disk drive is a non volatile storage device for storing data and instructions for use by processor . Mass storage device may store the system software for implementing embodiments of the present technology for purposes of loading that software into main memory .

Portable storage device operates in conjunction with a portable non volatile storage medium such as a floppy disk compact disk digital video disc or USB storage device to input and output data and code to and from the computing system of . The system software for implementing embodiments of the present technology may be stored on such a portable medium and input to the computing system via the portable storage device .

User input devices provide a portion of a user interface. User input devices may include an alphanumeric keypad such as a keyboard for inputting alpha numeric and other information or a pointing device such as a mouse a trackball stylus or cursor direction keys. Additional user input devices may comprise but are not limited to devices such as speech recognition systems facial recognition systems motion based input systems gesture based systems and so forth. For example user input devices may include a touchscreen. Additionally the computing system as shown in includes output devices . Suitable output devices include speakers printers network interfaces and monitors.

Display system may include a liquid crystal display LCD or other suitable display device. Display system receives textual and graphical information and processes the information for output to the display device.

Peripherals device s may include any type of computer support device to add additional functionality to the computer system. Peripheral device s may include a modem or a router.

The components provided in the computing system of are those typically found in computer systems that may be suitable for use with embodiments of the present technology and are intended to represent a broad category of such computer components that are well known in the art. Thus the computing system of may be a personal computer hand held computing system telephone mobile computing system workstation server minicomputer mainframe computer or any other computing system. The computer may also include different bus configurations networked platforms multi processor platforms etc. Various operating systems may be used including Unix Linux Windows Mac OS Palm OS Android iOS known as iPhone OS before June 2010 QNX and other suitable operating systems.

It is noteworthy that any hardware platform suitable for performing the processing described herein is suitable for use with the systems and methods provided herein. Computer readable storage media refer to any medium or media that participate in providing instructions to a central processing unit CPU a processor a microcontroller or the like. Such media may take forms including but not limited to non volatile and volatile media such as optical or magnetic disks and dynamic memory respectively. Common forms of computer readable storage media include a floppy disk a flexible disk a hard disk magnetic tape any other magnetic storage medium a CD ROM disk digital video disk DVD any other optical storage medium RAM PROM EPROM a FLASHEPROM any other memory chip or cartridge.

Computer program code for carrying out operations for aspects of the present technology may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be coupled with the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present technology has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the present technology in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the present technology. Exemplary embodiments were chosen and described in order to best explain the principles of the present technology and its practical application and to enable others of ordinary skill in the art to understand the present technology for various embodiments with various modifications as are suited to the particular use contemplated.

Aspects of the present technology are described above with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the present technology. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present technology. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. The descriptions are not intended to limit the scope of the technology to the particular forms set forth herein. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments. It should be understood that the above description is illustrative and not restrictive. To the contrary the present descriptions are intended to cover such alternatives modifications and equivalents as may be included within the spirit and scope of the technology as defined by the appended claims and otherwise appreciated by one of ordinary skill in the art. The scope of the technology should therefore be determined not with reference to the above description but instead should be determined with reference to the appended claims along with their full scope of equivalents.

