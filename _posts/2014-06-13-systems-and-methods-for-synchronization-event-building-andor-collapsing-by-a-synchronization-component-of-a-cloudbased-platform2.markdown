---

title: Systems and methods for synchronization event building and/or collapsing by a synchronization component of a cloud-based platform
abstract: Techniques for monitoring local and/or remote file systems by a synchronization component (e.g., client/server) of a cloud-based platform are disclosed. In some embodiments, a method of building synchronization events by a synchronization component (e.g., a synchronization server/client) includes obtaining a set of items that have been changed and their new states and retrieving last known states of the set of items that are stored in a reference snapshot inside a filesystem scanner. The method further includes generating differences between the new states and the last known states of the set of items as item changes and utilizing information provided by the item changes to translate the item changes into synchronization events for execution on the opposing file system. A method of handling failed synchronization events by a synchronization component of the cloud-based platform by collapsing a subsequent event with the failed synchronization event is also disclosed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09633037&OS=09633037&RS=09633037
owner: Box, Inc
number: 09633037
owner_city: Radwood City
owner_country: US
publication_date: 20140613
---
This application claims priority to and benefit from U.S. Provisional Application Ser. No. 61 834 756 titled SYSTEMS AND METHODS FOR EVENT BUILDING COLLAPSING OR MONITORING BY A SYNCHRONIZATION CLIENT OF A CLOUD BASED PLATFORM filed on Jun. 13 2013 the entire content of which is expressly incorporated by reference herein.

In a sharing and collaboration environment multiple users share access and otherwise perform actions or tasks on content and files in a shared workspace where any number of users may have access to a given file or may want to or need to perform an action on the file at any given time. Content such as audio video files documents or email messages on a user device can be synced with a cloud server and content from the cloud server can be synced with a user device. The syncing occurs when a new content arrives at the server or when a user makes a request. Syncing can result in new content updated content and or deleted content.

The same reference numbers and any acronyms identify elements or acts with the same or similar structure or functionality throughout the drawings and specification for ease of understanding and convenience.

The following description and drawings are illustrative and are not to be construed as limiting. Numerous specific details are described to provide a thorough understanding of the disclosure. However in certain instances well known or conventional details are not described in order to avoid obscuring the description. References to one or an embodiment in the present disclosure can be but not necessarily are references to the same embodiment and such references mean at least one of the embodiments.

Reference in this specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the disclosure. The appearances of the phrase in one embodiment in various places in the specification are not necessarily all referring to the same embodiment nor are separate or alternative embodiments mutually exclusive of other embodiments. Moreover various features are described which may be exhibited by some embodiments and not by others. Similarly various requirements are described which may be requirements for some embodiments but not other embodiments.

The terms used in this specification generally have their ordinary meanings in the art within the context of the disclosure and in the specific context where each term is used. Certain terms that are used to describe the disclosure are discussed below or elsewhere in the specification to provide additional guidance to the practitioner regarding the description of the disclosure. For convenience certain terms may be highlighted for example using italics and or quotation marks. The use of highlighting has no influence on the scope and meaning of a term the scope and meaning of a term is the same in the same context whether or not it is highlighted. It will be appreciated that same thing can be said in more than one way.

Consequently alternative language and synonyms may be used for any one or more of the terms discussed herein nor is any special significance to be placed upon whether or not a term is elaborated or discussed herein. Synonyms for certain terms are provided. A recital of one or more synonyms does not exclude the use of other synonyms. The use of examples anywhere in this specification including examples of any terms discussed herein is illustrative only and is not intended to further limit the scope and meaning of the disclosure or of any exemplified term. Likewise the disclosure is not limited to various embodiments given in this specification.

Without intent to limit the scope of the disclosure examples of instruments apparatus methods and their related results according to the embodiments of the present disclosure are given below. Note that titles or subtitles may be used in the examples for convenience of a reader which in no way should limit the scope of the disclosure. Unless otherwise defined all technical and scientific terms used herein have the same meaning as commonly understood by one of ordinary skill in the art to which this disclosure pertains. In the case of conflict the present document including definitions will control.

The present disclosure includes technology for event building by a synchronization client sync client of a cloud based collaboration and or storage service cloud based platform .

Local event monitoring by the synchronization client sync client in some embodiments can be performed in multiple modes. For example in a full scan mode the synchronization client examines the entire sync directory and generates differences between what is present in file system and what is in the local database. In the listen mode a third party library e.g. watchdog is used to turn file system changed notifications into events.

Events generated by the listen mode and full scan mode have different information which can break a contract required in event processing that events from both generators are the same and may weaken the system s abstractions. The process of converting a file system change notification to an actual event may require that watchdog perform a full scan of a synchronization directory making the code less DRY don t repeat yourself principal and making bug fixing and optimizations far more complicated. Finally the logic for switching between the full scan and listen modes can be complicated error prone and or difficult to test.

These challenges can be compounded in some embodiments when local event monitoring is considered alongside the cloud based platform server event monitoring. For example the situation of turning a set of differences between trees into a set of events that can be consistently applied has been solved both for the server side and the local side in totally different ways in some embodiments. In addition to algorithmic or process differences there can also be differences in the data structures used to represent various stages of processing and in the architecture of how events are generated in some embodiments.

The process and architectural differences may not be reflective of true differences between the cloud based platform e.g. cloud based collaboration and or storage services server and local storage of which there are some and serve to reduce the leveragability of and maintainability of the synchronization codebase.

Various embodiments of the disclosed technology refactors i.e. applies behavior preserving code transformations that improve source code event monitoring event generation and the filter pipeline systems and methods to address these problems. Some embodiments can maximize code maintainability through encapsulation and reuse. Specifically various embodiments of the disclosed technology can quickly and incrementally implement critical pieces of the refactoring without delay while deferring implementation of the less critical pieces for later.

Event monitoring is the process of turning file system notifications from the file system observers into synchronization events that are suitable for executing on the opposite file system e.g. remote cloud based storage or local storage . This can be done in some embodiments through a series of transformations on data structures that are outlined here.

In some embodiments file system notifications can be generated by file system observers and contain information about the file or folder that changed. In some embodiments on the cloud based platform server action log framework ALF events can include information about the new item state and minimal information about the type of change that occurred. On the local side in some embodiments notifications can contain only the parent folder of the item that has changed. Accordingly these notifications may need to be processed in order to be useable.

In some embodiments an item change represents that a specific item changes and can contain the full new state of the item. In some embodiments on the local filesystem item changes can be generated by taking a consistent snapshot of the folder whose children have changed and comparing the new snapshot with a reference snapshot. In some embodiments on the cloud based platform e.g. cloud based collaboration and or storage services the item changes can be generated either in a similar manner during full scans or by directly passing through the ALF event. These changes can contain only information about the state of the item and do not convey any information about the order in which the changes must be applied in some embodiments.

Raw events can be generated in some embodiments by ordering item changes and producing a set of executable actions that will bring the reference into sync with the new state of the file system. Raw events can be defined relative to the file system identifier of the item. In some embodiments there is no guarantee that produced events will actually be executed.

In some embodiments synchronization events can be generated by mapping filesystem specific identifiers to logical identifiers so that the event can be executed directly on the opposite filesystem. In some embodiments once a sync event is produced synchronization is committed to either executing the sync event action or marking the item as a problem item.

On both the remote cloud based platform and the local storage the process for item change generation in some embodiments is to obtain a set of dirty items and to then difference the new state of those items against their last known state which is stored in a reference snapshot inside the filesystem scanner. A dirty item is generally an item e.g. file folder directory etc. that has been written to or modified and the modifications are yet to be written to the underlying file system. In some embodiments on the remote file system the list of dirty items can be obtained by listening to the ALF stream which either directly provides dirty items and their new states or provides notifications that specific folders are recursively dirty requiring a scan of the affected folder to obtain the resulting dirty items. On the local system in some embodiments the filesystem observer may only provide notifications about dirty folders. Accordingly the local system may have to perform a partial scan in order to determine the full set of dirty items. On startup both sides can be initialized with an event marking the root folder as recursively dirty in some embodiments.

a. On the cloud based platform this can be achieved through the folders endpoint with transactional GAT get account tree .

b. On the local storage or device a snapshot can be built by walking or traversing the directory and recording all entries. If there are no dirty folders added to the queue for a certain period of time e.g. 100 ms the snapshot can be called consistent. If there is a new file system notification a snapshot can be built for that notification and a new snapshot is built by merging the snapshot for the dirty folder on top of the original snapshot.

b. Loop through all elements in the current snapshot and yield item changes for everything that has a different item state in the reference snapshot. Further remove all observed items from the all item id list.

In some embodiments item changes can be fed by the monitor into the filter pipeline using the same rules about flushing buffers as before. In some embodiments however there are no state transitions in the monitor as there is no difference between full scan and listening mode.

In some embodiments the reference snapshot used for determining which items have changed during the partial scan must reflect not only the changes detected during the last partial scan but also any changes made by the sync executors on the monitored file system. This may be necessary in some embodiments because it is possible for the changes performed by the sync executors to be undone by other operations on the monitored filesystem before they can be detected by a scan. For example a newly created item can be immediately deleted or a newly renamed item can be immediately renamed back to its original name. If the reference snapshot is not aware of the change made by the sync executors it will not know to generate an item change for these items since nothing has changed about the item since the last scan. As a result the file systems will fall out of sync. Another benefit of pushing the most up to date information about the monitored filesystem into the scanners is that it gives a completely state based means of handling echoback events. Because the scanner already has the information about the changes made to the monitored filesystem by the sync executors it will not pick up those changes during its next partial scan.

An example pseudo code for building a reference snapshot for the file system and on a new notification generating item changes using a diffing algorithm. In some embodiments the algorithm for the cloud based platform uses ALF instead of file system observers and has no requirement for a settle time.

An example pseudo code for building a snapshot of the file system at a point in time is provided below. Whether or not the snapshot is consistent can be left to the caller to deal with in some embodiments.

In some embodiments the item changes emitted by the filesystem scanners will occur in order per item but will not have a well defined inter item ordering. In some embodiments it is the responsibility of the item change re orderer to detect inter item event dependencies and re order the changes as necessary. It can do this by checking each change against a snapshot of the monitored filesystem to see if the new state brought about by the change is consistent with the rest of the filesystem. If it is the change can be passed on to the rest of the filter pipeline and the snapshot can be updated to reflect the change. Otherwise the change can be buffered until another item change alters the snapshot in such a way as to make the buffered change consistent. In some embodiments if an item change remains buffered for longer than a filesystem specific timeout then it is assumed that either a change has been missed by the filesystem scanner or the filesystem scanner has returned corrupt changes and in either case an assertion is raised and the application is taken down.

For each change the re orderer can perform the following checks in some embodiments to determine if the change is consistent with the existing snapshot 

In addition to performing these checks in some embodiments the re orderer can also be capable of detecting and handling circular renames by manufacturing an item change for one of the items that moves the item to a temporary location.

Like the filesystem snapshot used in the scanner for generating raw events the filesystem snapshot used when re ordering the raw events can reflect both the changes made by raw events emitted from the generator as well as the changes made by the sync executors on the monitored filesystem in some embodiments. This can be performed because the re orderer will now no longer receive information about echoback events from the scanner and so it needs to get that information directly from the executor in order to have a full picture of the monitored filesystem.

Following the item change ordering raw events can be produced by diffing the new item state in the item change against the old state in the re orderer s snapshot i.e. comparing the new item state with the old state to determine how and whether the two items differ . This can include detecting when an item has transitioned from syncable to unsyncable or vice versa and generating create and delete events as appropriate. The raw events produced can have the following properties in some embodiments 

In some embodiments raw events can then be processed into sync events suitable for execution. On the cloud based platform this can be a straight translation in some embodiments since the filesystem id on the cloud based platform can be suitable for use as a logical id for the item. On the local storage system or the local device the filesystem id can change while the item remains logically the same and so the atomic save filter can be necessary in order to maintain the mapping between logical ids and their underlying filesystem ids. No other filters may be required on the local storage system to do this conversion in some embodiments. Sync events can have the following properties in some embodiments 

The present disclosure also includes technology for event collapsing by a sync client and or a sync server of a cloud based platform.

In some embodiments event collapsing can be part of how the Sync Event Queue handles the failed events that are not intermittent e.g. the create event which failed due to a name conflict on the opposite file system . For those kinds of failures simply repeating the same event does not solve the problem in some embodiments. Instead it relies on some later event either from the user or from the sync client to succeed. For example Create A which fails due to name conflict has to be collapsed with Rename A to A copy which is generated by Conflict Recovery Manager before Sync Event Queue retries this event.

Embodiments of the sync event collapsing system can include the following features in some embodiments 

In some embodiments this may require that the system should only do the collapsing if it is necessary. For example the system should not collapse two edit events.

The present disclosure also includes technology for local event monitoring refactor by a sync client of a cloud based platform.

The local event monitoring can be either in for example the listening or full scan mode in some embodiments. In the listening mode the system receives events for items that are changing on the filesystem. On Mac OS based clients the OS can notify the sync client about directories that have changes. The sync client can re scan the directories to manufacture or generate the events. On Windows OS based clients for example the OS gives the sync clients the actual or real events except for moves and renames which are reported as delete create events.

In the full scan mode the system can compare the state of the filesystem with the Last Sync Item Store LSIS to manufacture or generate events for the changes that have occurred. The raw events that are generated by the listener full scanner can be fed into a filter pipeline that normalizes the stream of raw events and produces sync events that then the rest of the system can apply on the other filesystem in some embodiments. Because of the difference in the way the events are generated on each platform for example the delete create for moves the filter pipeline configuration can vary based on the platform.

With the above described state there are two implementations of full scan and both operate with different sets of data. Each implementation can manufacture a different set of events bug duplication code duplication etc. The events can also be different across different platforms. This can have cascading effects e.g. the filter pipeline may be different. The event generator on a MAC platform has the filesystem information but on Windows platform it does not and so it may be necessary to have one filter to collect the filesystem information and add it to the raw events which can introduces race condition because the item may have changed . Accordingly some embodiments refactor the Local Event Monitor so that the system only has one full scanner implementation. Some embodiments always use full scan mode for all platforms.

In the listening mode example embodiments use a third party library called Watchdog. Some embodiments merge the two full scanner implementations with the system in one of two ways 

The client devices can be any system and or device and or any combination of devices systems that is able to establish a communication or a connection including wired wireless cellular connections with another device a server and or other systems such as host server the sync server and or a notification server . Client devices typically include a display and or other output functionalities to present information and data exchanged between among the devices the notification server and or the host server .

For example the client devices can include mobile hand held or portable devices or non portable devices and can be any of but not limited to a server desktop a desktop computer a computer cluster or portable devices including a notebook a laptop computer a handheld computer a palmtop computer a mobile phone a cell phone a PDA a smart phone e.g. a BlackBerry device such as BlackBerry Z10 Q10 an iPhone Nexus 4 etc. a Treo a handheld tablet e.g. an iPad iPad Mini a Galaxy Note Galaxy Note II Xoom Tablet Microsoft Surface Blackberry PlayBook Nexus 7 10 etc. a phablet e.g. HTC Droid DNA etc. a tablet PC a thin client a hand held console a hand held gaming device or console e.g. XBOX live Nintendo DS Sony PlayStation Portable etc. mobile enabled powered watch e.g. iOS Android or other platform based Google Glass a Chromebook and or any other portable mobile hand held devices etc. running on any platform or any operating system e.g. Mac based OS OS X iOS etc. Windows based OS Windows Mobile Windows 7 Windows 8 etc. Android Blackberry OS Embedded Linux platforms Palm OS Symbian platform Google Chrome OS and the like. In one embodiment the client devices host server and or the notification server e.g. a server hosting application are coupled via a network . In some embodiments the devices and host server and or notification server may be directly connected to one another.

The input mechanism on client devices can include touch screen keypad including single touch multi touch gesture sensing in 2D or 3D etc. a physical keypad a mouse a pointer a track pad motion detector e.g. including 1 axis 2 axis 3 axis accelerometer etc. a light sensor capacitance sensor resistance sensor temperature sensor proximity sensor a piezoelectric device device orientation detector e.g. electronic compass tilt sensor rotation sensor gyroscope accelerometer or a combination of the above.

Signals received or detected indicating user activity at client devices through one or more of the above input mechanism or others can be used by various users or collaborators e.g. collaborators for accessing through network a web based collaboration environment or online collaboration platform e.g. hosted by the host server . The collaboration environment or platform can have one or more collective settings for an enterprise or an organization that the users belong and can provide an user interface for the users to access such platform under the settings .

The collaboration platform or environment hosts workspaces with work items that one or more users can access e.g. view edit update revise comment download preview tag or otherwise manipulate etc. . A work item can generally include any type of digital or electronic content that can be viewed or accessed via an electronic device e.g. device . The digital content can include .pdf files .doc slides e.g. PowerPoint slides images audio files multimedia content web pages blogs etc. A workspace can generally refer to any grouping of a set of digital content in the collaboration platform. The grouping can be created identified or specified by a user or through other means. This user may be a creator user or administrative user for example.

In general a workspace can be associated with a set of users or collaborators e.g. collaborators which have access to the content included therein. The levels of access e.g. based on permissions or rules of each user or collaborator to access the content in a given workspace may be the same or may vary among the users. Each user may have their own set of access rights to every piece of content in the workspace or each user may be different access rights to different pieces of content. Access rights may be specified by a user associated with a workspace and or a user who created uploaded a particular piece of content to the workspace or any other designated user or collaborator.

In general the collaboration platform allows multiple users or collaborators to access or collaborate efforts on work items such each user can see remotely edits revisions comments or annotations being made to specific work items through their own user devices. For example a user can upload a document to a workspace for other users to access e.g. for viewing editing commenting signing off or otherwise manipulating . The user can login to the online platform and upload the document or any other type of work item to an existing workspace or to a new workspace. The document can be shared with existing users or collaborators in a workspace.

In general network over which the client devices and the host server communicate may be a cellular network a telephonic network an open network such as the Internet or a private network such as an intranet and or the extranet or any combination or variation thereof. For example the Internet can provide file transfer remote log in email news RSS cloud based services instant messaging visual voicemail push mail VoIP and other services through any known or convenient protocol such as but is not limited to the TCP IP protocol Open System Interconnections OSI FTP UPnP iSCSI NSF ISDN PDH RS 232 SDH SONET etc.

The network can be any collection of distinct networks operating wholly or partially in conjunction to provide connectivity to the client devices and the host server and may appear as one or more networks to the serviced systems and devices. In one embodiment communications to and from the client devices can be achieved by an open network such as the Internet or a private network such as an intranet and or the extranet. In one embodiment communications can be achieved by a secure communications protocol such as secure sockets layer SSL or transport layer security TLS .

In addition communications can be achieved via one or more networks such as but are not limited to one or more of WiMax a Local Area Network LAN Wireless Local Area Network WLAN a Personal area network PAN a Campus area network CAN a Metropolitan area network MAN a Wide area network WAN a Wireless wide area network WWAN or any broadband network and further enabled with technologies such as by way of example Global System for Mobile Communications GSM Personal Communications Service PCS Bluetooth WiFi Fixed Wireless Data 2G 2.5G 3G e.g. WCDMA UMTS based 3G networks 4G IMT Advanced pre 4G LTE Advanced mobile WiMax WiMax 2 WirelessMAN Advanced networks enhanced data rates for GSM evolution EDGE General packet radio service GPRS enhanced GPRS iBurst UMTS HSPDA HSUPA HSPA HSPA UMTS TDD 1xRTT EV DO messaging protocols such as TCP IP SMS MMS extensible messaging and presence protocol XMPP real time messaging protocol RTMP instant messaging and presence protocol IMPP instant messaging USSD IRC or any other wireless data networks broadband networks or messaging protocols.

A diagrammatic illustration of the cloud based environment e.g. collaboration environment and the relationships between workspaces and users collaborators are illustrated with further reference to the example of . A diagrammatic illustration of a workspace having multiple work items with which collaborators can access through multiple devices is illustrated with further reference to the example of .

Embodiments of the present disclosure provide event building collapsing or monitoring by a synchronization component e.g. sync client or a sync server of a cloud based platform hosted by the host server .

In general multiple users collaborate in the cloud based environment hosted by server and the user devices of these users need to be appropriately updated such that the most current versions of data content are synchronized with the relevant user devices and that notification of events are sent to the relevant devices users in a timely and orderly fashion. Any given user can utilize any number and types of clients e.g. synchronization client real time web client mobile synchronization client mobile application email client server synchronization client etc. at any given time. Thus the host server and the remote synchronization clients described herein together can implement the disclosed techniques in facilitating the orderly synchronizing or updating of the remote clients which a given user collaborator may use to access the cloud platform via any number of user devices .

In general when a user action takes place the user action is processed e.g. as described in below to become a plurality of event entries each corresponding to a collaborator and each event entry can be read by a remote client of the collaborator to reflect the user action.

Various embodiments of the synchronization client e.g. client can ensure the correctness of the synchronized tree and other synchronized items e.g. folders or files completely independent from the order in which the client receives events from the action log framework ALF system. In other words so long as the ALF system correctly delivers all events to the synchronization client the synchronization client can end up in the correct final state.

More implementation details regarding the synchronization clients the host server the repository distributed data cluster and various techniques in implementing event building collapsing and monitoring by a sync client and or a sync server are discussed below.

The web based platform for collaborating on projects or jointly working on documents can be used by individual users and shared among collaborators. In addition the collaboration platform can be deployed in an organized setting including but not limited to a company e.g. an enterprise setting a department in a company an academic institution a department in an academic institution a class or course setting or any other types of organizations or organized setting.

When deployed in an organizational setting multiple workspaces e.g. workspace A B C can be created to support different projects or a variety of work flows. Each workspace can have its own associate work items. For example workspace A can be associated with work items workspace B can be associated with work items and workspace N can be associated with work items . The work items and can be unique to each workspace but need not be. For example a particular word document can be associated with only one workspace e.g. workspace A or it can be associated with multiple workspaces e.g. Workspace A and workspace B etc. .

In general each workspace has a set of users or collaborators associated with it. For example workspace A is associated with multiple users or collaborators . In some instances workspaces deployed in an enterprise can be department specific. For example workspace B can be associated with department and some users shown as example user A and workspace N can be associated with departments and and users shown as example user B .

Each user associated with a workspace can generally access the work items associated with the workspace. The level of access depends on permissions associated with the specific workspace and or with a specific work item. Permissions can be set for the workspace or set individually on a per work item basis. For example the creator of a workspace e.g. one of user A who creates workspace B can set one permission setting applicable to all work items for other associated users and or users associated with the affiliate department for example. Creator user A can also set different permission settings for each work item which can be the same for different users or varying for different users.

In each workspace A B . . . N when an action is performed on a work item by a given user or any other activity is detected in the workspace other users in the same workspace can be notified e.g. in real time or in near real time or not in real time . Activities which trigger real time notifications can include by way of example but not limitation adding deleting or modifying collaborators in the workspace uploading downloading adding deleting a work item in the workspace creating a discussion topic in the workspace.

In some embodiments items or content downloaded or edited can cause notifications to be generated. Such notifications can be sent to relevant users to notify them of actions surrounding a download an edit a change a modification a new file a conflicting version an upload of an edited or modified file.

In one embodiment in a user interface to the web based collaboration platform where notifications are presented users can via the same interface create action items e.g. tasks and delegate the action items to other users including collaborators pertaining to a work item for example. The collaborators can be in the same workspace A or the user can include a newly invited collaborator. Similarly in the same user interface where discussion topics can be created in a workspace e.g. workspace A B or N etc. actionable events on work items can be created and or delegated assigned to other users such as collaborators of a given workspace or other users. Through the same user interface task status and updates from multiple users or collaborators can be indicated and reflected. In some instances the users can perform the tasks e.g. review or approve or reject etc. via the same user interface.

Each of users and can individually use multiple different devices to access and or manipulate work items in the workspace with which they are associated with. For example users can be collaborators on a project to which work items are relevant. Since the work items are hosted by the collaboration environment e.g. a cloud based environment each user can access the work items anytime and from any physical location using any device e.g. including devices they own or any shared public loaner device .

Work items to be edited or viewed can be accessed from the workspace . Users can also be notified of access edit modification and or upload related actions performed on work items by other users or any other types of activities detected in the workspace . For example if user modifies a document one or both of the other collaborators and can be notified of the modification in real time or near real time or not in real time. The notifications can be sent through any of all of the devices associated with a given user in various formats including one or more of email SMS or via a pop up window in a user interface in which the user uses to access the collaboration platform. In the event of multiple notifications each notification can be depicted preferentially e.g. ordering in the user interface based on user preferences and or relevance to the user e.g. implicit or explicit .

For example a notification of a download access read write edit or uploaded related activities can be presented in a feed stream among other notifications through a user interface on the user device according to relevancy to the user determined based on current or recent activity of the user in the web based collaboration environment.

In one embodiment the notification feed stream further enables users to create or generate actionable events e.g. as task which are or can be performed by other users or collaborators e.g. including admin users or other users not in the same workspace either in the same workspace or in some other workspace. The actionable events such as tasks can also be assigned or delegated to other users via the same user interface.

For example a given notification regarding a work item can be associated with user interface features allowing a user to assign a task related to the work item e.g. to another user admin user creator user or another user . In one embodiment a commenting user interface or a comment action associated with a notification can be used in conjunction with user interface features to enable task assignment delegation and or management of the relevant work item or work items in the relevant workspaces in the same user interface.

Further in some of the present embodiments the synchronization state of a folder can be i synchronized ii partially synchronized or iii unsynchronized. For purposes of discussion herein a folder is synchronized when all items e.g. folders and files under the folder are synchronized. Likewise a folder is unsynchronized when all items e.g. folders and files under the folder are unsynchronized. A folder is partially synchronized when it is neither synchronized nor unsynchronized.

The server side includes front end components A N a database a dispatcher one or more processors A N and a second database e.g. HBase . The front end components A N can interface with client devices end user devices to detect identify actions or transactions or events. The data or file change that occur as a result of the event is effectuated in the database of the cloud based platform e.g. the relevant changes are made in the file table of the database .

Depending on the type of action or event an action log entry can be created and stored in the action log table or action log . In general the front end determines whether an action log entry is created from a given action or transaction. In general an action log entry can be created for an action or event if certain durability requirements are to be met. The dispatcher reads the action log entries from the action log and sends them to the processors A N where the fan out or collaborators to be notified of the event or to receive the file data change as a result of the event is determined. Based on the computed fan out or identified collaborators the processors A N writes the events transactions to the relevant queues in the second database from which remote clients can read.

It is noted also that the action log the dispatcher the processors A N the HBase and one or more real time clients A N see are generally referred to as an action log framework ALF . More specifically HBase is a primary data repository of the ALF . User actions initiated e.g. via the web application or the API result in rows or action log entries being written to the action log or action log table . Then in some embodiments the action log entries are read from action log by the ALF dispatcher de normalized into separate entries per user that needs to be notified of the action by an ALF processor e.g. processor A and written to the HBase . The HBase is in turn read e.g. via an API web service call by real time clients A N to notify a collaborator of the new change.

The queues in the database e.g. the distributed database cluster are usually client type specific. For example each queue is for a given client type for one given user. So a user A may have a synchronization client queue that all of the synchronization clients that user A uses reads from since user A may have multiple devices on which synchronization clients are installed. In general the queues for clients in the database are read only queues such that multiple clients can read from the same queue without making modifications. In this manner if a user utilizes multiple synchronization clients each client can still receive and detect the respective updates such that multiple devices can be synchronized. The remote clients also typically individually track the location in the queue from which they last read such that only the most recent events are updated at the client and that the events read from a queue is specific to a given client dependent on what has previously been synchronized or read.

In one embodiment synchronization clients connect to both real time and API front end machines. The real time machines can notify a synchronization client when there has been an update in a user s account. The synchronization client can then connect to API front end machine to obtain the actual change content. Alternatively in some instances the synchronization clients can also obtain the changes content updates from the real time machines simultaneous with the notification or after being notified.

The front ends A N detect identify or receive the various actions or events on data or content performed by users or collaborators in a cloud based environment. For example events actions can include by way of example but not limitation file renames file uploads downloads file edits comments etc. Based on the type of event the front end determines whether the action event is to be created into a log entry to be stored in the action log . In creating a log entry each action event is recorded as a transaction with the file system change for asynchronous processing. In recording the transaction the relevant file folder row in the file of the database is inserted updated deleted or otherwise modified according to the action. In one embodiment the row is inserted in to the action log table simultaneously with the write to the file and also with the performance of action itself. Note that each entry includes an owner ID in the file and in the action log to represent the owner of the item upon which an action occurred.

In one embodiment action log entries are created in the same database as the file table such that file content rollback can be performed if the file data content change results in an error or failure. As such the action log entry creation in the action log table can be created in part to meet durability e.g. longevity requirements of a given event transaction e.g. write events or other edit events typically have higher durability requirements than a comment event or a share event etc. .

Action log entries can be created for select types of events or all events. For example events transactions such as file renames file uploads may have higher durability requirements than a comment event or a share event in a sense that the changes from a file rename file upload need to be maintained and updated at various respective clients for the relevant collaborators and the implication for missing a file rename or file upload is potentially more severe than missing a comment event or a share event etc.

In general action log entries are generally created for actions events with higher durability requirements. Such a determination can be made by the front ends as to whether a given event type is to be writing into the action log table . Action log entries may also be created for all events with durability requirements carried out downstream at event queues stored in the second database e.g. the database of . Table shows the action log entries created from the events stored in the file table .

The action log entries can be identified by the action ID . In addition each action log entry can be associated with a user e.g. owner identifier a data entry and or a revision identifier . The user identifier can identify a user who is to a recipient as a result of an event e.g. upload file to User . The owner identifier represents the owner of the item upon which an action e.g. represented by action ID occurred and in general each work item has no more than one owner. The data field can identify the type of action event e.g. rename upload edit comment share send download etc. .

The revision identifier can indicate the version of any change made to a given file e.g. edit rename upload etc. . In one embodiment the revision identifier is derived from version tracking mechanisms e.g. via revision ID inherent to the database . The revision identifier can be used by remote clients to resolve conflicts in view of potentially conflicting events transactions. For example if a file is re named twice and both events are synchronized updated at a remote client the client can use the rename event associated with the latest revision ID to make the necessary updates. This can ensure that the client is updated with the most current change regardless of when the events are read from the queue. Thus even if the two rename events are writing to the queue for the client out of order the client can still make the correct update using the revision ID in case of conflicting changes.

In the full scan mode the local event monitor can compare the state of the filesystem with the Last Sync Item Store LSIS to manufacture or generate events for the changes that have occurred. The raw events that are generated by the listener or the full scanner can be fed into a filter pipeline that normalizes the stream of raw events and produces sync events that the rest of the system can apply on the opposite filesystem in some embodiments. Because of the difference in the way the events are generated on each platform for example the delete create for moves the filter pipeline configuration can vary based on the platform e.g. Windows Mac .

With the above described state there are in effect two implementations of full scan and both operate with different sets of data. Each implementation can manufacture a different set of events bug duplication code duplication etc. The events can also be different across different platforms. This can have cascading effects e.g. the filter pipeline may be different. The event generator on a Mac platform has the filesystem information but on Windows platform it does not and so it may be necessary to have one filter to collect the filesystem information and add it to the raw events which can introduce race condition because the item may have changed . Accordingly some embodiments refactor the Local Event Monitor so that only one full scanner is implemented i.e. the listening mode or the full scan mode . Other embodiments can use the full scan mode for all platforms. For example in some embodiments a watchdog used by the listening mode can be used and the full scanner can be removed. Alternately the watchdog can be removed and the full scanner can be implemented.

On the local file system the file system scanning mode as part of the event monitoring process turns file system notifications about files or folders that have changed from file system observers into raw events by determining item changes and ordering the item changes. On the cloud based platform the file system scanning mode listens to the ALF stream which can directly provide a list of files or folders that have changed or notifications about the files or folders that have changed determines item changes and orders the item changes to produce raw events that are then processed by the filter pipeline into sync events suitable for execution on the opposing file system.

The device can include for example a bus and a memory among other components. The memory can include among others a sync client and a communication module . The communication module facilitates communication among the device the host server and other components discussed herein e.g. the ALF system using any of the communication protocols that are supported. The memory may also include other device modules not shown in for simplicity such as a GPS module for determining and providing location information text input module for accepting and processing inputs provided using different input mechanisms of the mobile device and the like for handling various functions of the device . It is noted that the aforementioned modules are intended for purposes of enabling the present embodiments rather than limiting. As such a person of ordinary skill in the art will understand that the present disclosure covers apparent alternatives modifications and equivalents e.g. combining or separating the modules made to the techniques described herein. Additional or less components modules engines can be included in the device and each illustrated component.

As used herein a module a manager an interface observer builder scanner pipeline filter detector generator re orderer or an engine includes a general purpose dedicated or shared processor and typically firmware or software modules that are executed by the processor. Depending upon implementation specific or other considerations the module manager interface or engine can be centralized or its functionality distributed. The module manager interface observer builder scanner pipeline filter detector generator re orderer or engine can include general or special purpose hardware firmware or software embodied in a computer readable storage medium for execution by the processor. As used herein a computer readable medium or computer readable storage medium is intended to include all media that are statutory e.g. in the United States under 35 U.S.C. 101 and to specifically exclude all media that are non statutory in nature to the extent that the exclusion is necessary for a claim that includes the computer readable storage medium to be valid. Known statutory computer readable mediums include hardware e.g. registers random access memory RAM non volatile NV storage to name a few but may or may not be limited to hardware.

The bus is a subsystem for transferring data between the components of the mobile device . For example the bus facilitates the transfer of data between the memory and other components of the device such as the processor and or the input output components that utilize the data.

Example components of the sync client are illustrated in the block diagram of . In some embodiments the sync client can include a local event monitor or raw event processor having a local file system scanner including a partial scanner a file system observer an item change generator a file system snapshot builder a file system snapshot differ module and a re orderer among others. The local event monitor can also include an event filter pipeline having an atomic save filter and an item change buffer . The sync client can also include a sync execution controller a sync event queue manager and a conflict manager having a conflict detector and a conflict recovery manager having an event collapsing module . Other embodiments may include more or less components.

In one embodiment of the present disclosure during normal operations the sync client can operate in a single mode. The file system observers can generate file system notifications when a file or folder changes on the local file system. The file system notifications can include information about the changed file or folder i.e. dirty file or folder . Generally the file system observer provides notifications about dirty folders. The local event monitor then triggers the partial scanner to perform a partial scan of the local file system to obtain the full set of dirty items.

In some embodiments the partial scanner performs partial scanning of the affected or dirty folder by leverage the item change generator . The item change generator generates a consistent snapshot e.g. via the file system snapshot builder and compares the consistent snapshot with a reference snapshot to generate differences between the two snapshots e.g. file system snapshot differ . In other words the item change generator can determine item changes based on a consistent snapshot of a folder whose children have changed and a reference snapshot of the folder in response to the file system notifications. The partial scanner then updates the reference snapshot by applying the new consistent snapshot on top. In some embodiments a snapshot can be built or generated by walking or traversing the directory or dirty folder tree and recording all entries. If there are no dirty folders added to the queue for a settle time e.g. 100 ms the snapshot is called consistent. If there is a new file system notification a snapshot is built for that notification and a new snapshot is built by merging the snapshot for the dirty folder on top of the original snapshot. In some embodiments the differences between a reference snapshot and the current snapshot are obtained by the file system snapshot differ . The reference snapshot can pertain to the last known state of the dirty folder. It should be noted that for the first run the reference snapshot is built from the persisted LSIS. Via the partial scanning process the differences between the reference and current snapshots can be determined by generating a list of all item ids that are in the reference snapshot and in the domain of the current snapshot. The process loops through all elements in the current snapshot and obtains item changes for everything that has a different item state in the reference snapshot. All the observed items are then removed from the all item id list. The process then yields item changes with delete set to true for all items remaining in the all item id list. The process then updates the reference snapshot by applying the new snapshot on top of it.

In some embodiments the re orderer can detect inter item event dependencies and re order the changes as necessary before feeding the item changes to the filter pipeline . The re orderer can reorder items by checking each change against a snapshot of the monitored filesystem to see if the new state brought about by the change is consistent with the rest of the filesystem. If it is the change is passed on to the event filter pipeline and the snapshot is updated to reflect the change. Otherwise the change is buffered e.g. in the item change buffer until another item change alters the snapshot in such a way as to make the buffered change consistent. If an item change remains buffered for longer than a filesystem specific timeout which can be configurable in some embodiments then it is assumed that either a change has been missed by the filesystem scanner or the filesystem scanner has returned corrupt changes. In such instances a notification can be generated for error handling the change can be dropped or other process can be initiated to resolve the inconsistency. In one example embodiment the re orderer can perform a number of checks to determine if the change is consistent with the existing snapshot.

For example if the change is for a deleted folder the re orderer can check the snapshot to see that the folder does not contain any children. If the change is for a non deleted item the re orderer can check the snapshot to see that the parent folder of the item exists and that no other item with the same name exists in the parent folder. If the change represents a move the re orderer can check the snapshot to see that the item is not an ancestor of its new parent. In some embodiments the re orderer can also detect and handle circular renames by manufacturing an item change for one of the items that moves the item to a temporary location.

Raw events are produced by the local file system scanner by ordering the item changes and producing a set of executable actions like create delete etc. The raw events are processed by the event filter pipeline into sync events that can be executed directly on the opposite file system i.e. the cloud based platform file system . In some embodiments processing the raw events into sync events include translating the file system identifiers of items to logical identifiers so that the events can be executed directly on the opposite file system. An atomic save filter can maintain the mapping between the logical identifiers and the underlying file system identifiers. The mapping and translation of file system identifiers into logical identifiers is needed as the raw events refer to the file system identifier rather than the logical identifier and on the local file system the file system identifier of an item can change while the item remains logically the same. The sync events describe executable actions like create delete etc. and the sync client is committed to at least attempting to execute the sync events as the sync events are produced in an order that can be consistently applied to the opposite file system.

Some embodiments of the sync client include a sync event queue manager that places sync events on a sync event queue for serialized execution. The sync execution controller gets the next event to execute from the sync event queue. The execution controller can have a list based or priority based implementation. For example in the list based implementation the next event candidate is checked against the items that are in progress and if the item already has an in progress sync event the next event candidate is skipped. In the priority based implementation unprocessed events are managed in a priority queue of sync event containers. A sync event container is a set of all unprocessed sync events for a given item weighted by the lowest weight sync event in the container. When one sync event from this sync event container is executed then all sync events for that item are no longer in the priority queue and so the remaining sync events in the sync event container will not be executed on subsequent get next sync event calls. When the in process sync event is completed it is removed from the sync event container which is returned back into the priority queue if not empty.

Some embodiments of the sync client include a conflict manager . The conflict manager via the conflict detector can identify when a sync has failed or when a conflict has occurred e.g. a file or work item folder has been changed at both the server sync folder and the local sync folder which caused the sync to fail. A sync event can fail for various reasons which may be conflict related or unrelated. Example failure reasons that are related to conflict include but are not limited to item not found item name in use item name not valid item name too long item locked version mismatch or the like. Other failure reasons can include for example communication failure e.g. network goes down authentication failure e.g. auth token expired quota failure or the like. Some of these sync failures are local to a particular sync event e.g. item not found is local to a sync event relating to the item while others are global e.g. communication failure can impact all sync events . The conflict detector can in general detect sync failures that are conflict related or unrelated.

The conflict manager includes a conflict recovery manager to determine how to resolve the conflict resolve the conflict using the determined strategy and try to sync again when one or more retry conditions are met. The conflict recovery manager can include several conflict resolvers to resolve various conflict cases. The conflict recovery manager selects a conflict resolver that is mapped to the event type file system and or failure reason triple to resolve a conflict related to a sync event. A conflict resolver resolves the conflict by calling a rules engine to determine what action to take to resolve the conflict. When the specified action or actions is taken the file system is restored back to its consistent state.

In some embodiments one example conflict resolver includes an event collapsing module . The event collapsing module can collapse a failed event into a later event to successfully execute the original event. When the conflict detector detects name conflict as the failure reason for a sync event the event collapsing module can use a later rename event to collapse into the original event before retrying the failed event. Similarly when the conflict detector detects as the item not found on the source filesystem during execution as a reason for failure of a sync event the event collapsing module collapses a later delete event into the failed event before retrying the failed event. By way of another example when the conflict detector detects an item change when deleting the item on the opposite file system as a reason for failure of a sync event the event collapsing module collapses a later create event into the failed event before retrying the failed event. After collapsing a failed event into a later or subsequent event the resulting event is placed in the sync event queue for execution.

The ALF listener in some embodiments can detect ALF events. The ALF events can include information about a new item state and minimal information about the type of change that occurred on an item. In some embodiments the ALF listener by listening to ALF stream can directly obtain items that have been changed and their new states. Alternatively the ALF listener can obtain notifications that specific folders are recursively dirty. The partial scanner can then be invoked to scan the affected folders to obtain the items that have been changed. The partial scanner employs a method substantially similar to the method employed by the partial scanner to generate differences between a reference snapshot and a current snapshot to obtain item changes and update the reference snapshot by applying the new snapshot on top of it. In some embodiments the file system snapshot builder of the sync server can use an application programming interface API call to obtain an account tree and using the account tree data obtained as a response to generate a consistent snapshot of a folder that has been changed or is dirty .

In some embodiments the file system identifier of an item on the cloud based platform is suitable for use as a logical identifier for the item. This enables the event filter pipeline to generate sync events from raw events without requiring a translation between the logical identifiers and the file system identifiers.

At block the sync component retrieves a reference snapshot of the dirty folder. The reference snapshot inside a file system scanner stores the last known states of the dirty items. At block the sync component generates differences between the reference snapshot and the new snapshot to determine item changes. In some embodiments generating the differences between the two snapshots includes generating a list of all item identifiers that are in the reference snapshot all item ID list . The sync component then processes each item identifier in the new snapshot to determine item changes for all item identifiers in the new snap shot that have a different item state in the reference snapshot. All the item identifiers that have been observed or evaluated are then removed from the all item ID list. The sync client further determines item changes with delete set to true for all item identifiers remaining in the all item ID list. At block the sync client updates the reference snapshot using the new snapshot. In some embodiments the reference snapshot is updated using not only the changes detected from the partial scan but also from any changes made by sync executors on the monitored file system.

Some embodiments of the present disclosure include a method of building synchronization events by a synchronization component associated with a cloud based platform. The method can obtain a set of items that have been changed and new states of the set of items and retrieve last known states of the set of items. The last known states of the set of items are stored in a reference snapshot inside a filesystem scanner. The method can generate differences between the new states and the last known states of the set of items as item changes and utilize information provided by the item changes to translate the item changes into synchronization events.

The synchronization component can receive a notification of a change in a folder e.g. the file system observer and in response scan the folder to obtain the set of items that have been changed e.g. partial scanner item change generator . In some implementations event dependencies between the item changes can be detected and the item changes can be ordered based on the detected event dependencies to allow the new state brought about by applying each item change is consistent with a filesystem e.g. re orderer . In some implementations the synchronization component e.g. re orderer can check each item change against a snapshot of a filesystem monitored by the synchronization component to determine if the new state brought about by the item change is consistent with the filesystem. If the new state brought about by the item change is not consistent with the filesystem the synchronization component e.g. item change buffer can buffer the item change until another item change alters the snapshot of the filesystem. Similarly if the new state brought about by the item change is consistent with the filesystem the synchronization component can provide the item change to a filter pipeline e.g. filter pipeline for generating the synchronization events. In some implementations the synchronization events include actions arranged in a predetermined order for execution on an opposing file system and the predetermined order allows the synchronization events to be executed without generating any inconsistencies. The synchronization component can be one of a synchronization client on a device or a synchronization server remote from the device and each can have an associated filesystem.

Some embodiments of the present disclosure includes a method of generating synchronization events associated with a synchronization component of a cloud based platform. The method includes detecting that a folder on a filesystem has been changed generating a new snapshot of the filesystem that is consistent retrieving a reference snapshot of the filesystem generating item changes by differencing the new snapshot from the reference snapshot and using the item changes to generate the synchronization events for execution on an opposing file system. The method can also include updating the reference snapshot using the new snapshot. In some implementations the method includes checking each item change against a current snapshot of the filesystem to determine an order for executing the item changes and generating raw events in the determined order as executable actions to be applied to the opposing filesystem without generating inconsistencies. In some implementations the method includes processing the raw events to generate the synchronization events for execution. Processing the raw events can include translating file system identifiers of items associated with the item changes to logical identifiers. In some implementations differencing the new snapshot from the reference snapshot can further comprise generating a list of all item identifiers that are in the reference snapshot processing each item in the new snapshot to obtain item changes for items that have different item states in the reference snapshot removing all items involved in the processing from the list and obtaining item changes with delete set to true for all items remaining in the list.

Some embodiments of the present disclosure include a method of handling failed synchronization events by a synchronization component of a cloud based platform. The method includes detecting a failed synchronization event associated with a synchronization item identifying a subsequent synchronization event associated with the synchronization item to collapse with the failed synchronization event and re executing the collapsed synchronization event on an opposing file system. In some implementations the method can include determining a failure reason associated with the failed synchronization event and identifying the subsequent synchronization event based on the failure reason. In some implementations when the failure reason includes name conflict the subsequent synchronization event includes a rename event. Similarly when the failure reason includes missing synchronization item on a source filesystem the subsequent synchronization event includes a delete event. In some implementations when the failure reason includes change in the synchronization item when deleting the synchronization item on the opposing file system the subsequent synchronization event includes a create event. In some implementations collapsing the subsequent synchronization event with the failed synchronization event can result in a single operation or no operation. The single operation can include a create operation a rename operation a move operation or a delete operation.

In alternative embodiments the machine operates as a standalone device or can be connected e.g. networked to other machines. In a networked deployment the machine can operate in the capacity of a server or a client machine in a client server network environment or as a peer machine in a peer to peer or distributed network environment.

The machine can be a server computer a client computer a personal computer PC a user device a tablet a phablet a laptop computer a set top box STB a personal digital assistant PDA a thin client device a cellular telephone an iPhone an iPad a Blackberry a processor a telephone a web appliance a network router switch or bridge a console a hand held console a hand held gaming device a music player any portable mobile hand held device or any machine capable of executing a set of instructions sequential or otherwise that specify actions to be taken by that machine.

While the machine readable medium or machine readable storage medium is shown in an exemplary embodiment to be a single medium the term machine readable medium and machine readable storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine readable medium and machine readable storage medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the presently disclosed technique and innovation.

In general the routines executed to implement the embodiments of the disclosure can be implemented as part of an operating system or a specific application component program object module or sequence of instructions referred to as computer programs. The computer programs typically comprise one or more instructions set at various times in various memory and storage devices in a computer and that when read and executed by one or more processing units or processors in a computer cause the computer to perform operations to execute elements involving the various aspects of the disclosure.

Moreover while embodiments have been described in the context of fully functioning computers and computer systems those skilled in the art will appreciate that the various embodiments are capable of being distributed as a program product in a variety of forms and that the disclosure applies equally regardless of the particular type of machine or computer readable media used to actually effect the distribution.

Further examples of machine readable storage media machine readable media or computer readable storage media include but are not limited to recordable type media such as volatile and non volatile memory devices floppy and other removable disks hard disk drives optical disks e.g. Compact Disk Read Only Memory CD ROMS Digital Versatile Disks DVDs etc. among others and transmission type media such as digital and analog communication links.

The network interface device enables the machine to mediate data in a network with an entity that is external to the host server through any known and or convenient communications protocol supported by the host and the external entity. The network interface device can include one or more of a network adaptor card a wireless network interface card a router an access point a wireless router a switch a multilayer switch a protocol converter a gateway a bridge bridge router a hub a digital media receiver and or a repeater.

The network interface device can include a firewall which can in some embodiments govern and or manage permission to access proxy data in a computer network and track varying levels of trust between different machines and or applications. The firewall can be any number of modules having any combination of hardware and or software components able to enforce a predetermined set of access rights between a particular set of machines and applications machines and machines and or applications and applications for example to regulate the flow of traffic and resource sharing between these varying entities. The firewall can additionally manage and or have access to an access control list which details permissions including for example the access and operation rights of an object by an individual a machine and or an application and the circumstances under which the permission rights stand.

Other network security functions can be performed or included in the functions of the firewall can be for example but are not limited to intrusion prevention intrusion detection next generation firewall personal firewall etc. without deviating from the novel art of this disclosure.

Unless the context clearly requires otherwise throughout the description and the claims the words comprise comprising and the like are to be construed in an inclusive sense as opposed to an exclusive or exhaustive sense that is to say in the sense of including but not limited to. As used herein the terms connected coupled or any variant thereof means any connection or coupling either direct or indirect between two or more elements the coupling of connection between the elements can be physical logical or a combination thereof. Additionally the words herein above below and words of similar import when used in this application shall refer to this application as a whole and not to any particular portions of this application. Where the context permits words in the above Detailed Description using the singular or plural number can also include the plural or singular number respectively. The word or in reference to a list of two or more items covers all of the following interpretations of the word any of the items in the list all of the items in the list and any combination of the items in the list.

The above detailed description of embodiments of the disclosure is not intended to be exhaustive or to limit the teachings to the precise form disclosed above. While specific embodiments of and examples for the disclosure are described above for illustrative purposes various equivalent modifications are possible within the scope of the disclosure as those skilled in the relevant art will recognize. For example while processes or blocks are presented in a given order alternative embodiments can perform routines having steps or employ systems having blocks in a different order and some processes or blocks can be deleted moved added subdivided combined and or modified to provide alternative or subcombinations. Each of these processes or blocks can be implemented in a variety of different ways. Also while processes or blocks are at times shown as being performed in series these processes or blocks can instead be performed in parallel or can be performed at different times. Further any specific numbers noted herein are only examples alternative implementations can employ differing values or ranges.

The teachings of the disclosure provided herein can be applied to other systems not necessarily the system described above. The elements and acts of the various embodiments described above can be combined to provide further embodiments.

Any patents and applications and other references noted above including any that can be listed in accompanying filing papers are incorporated herein by reference. Aspects of the disclosure can be modified if necessary to employ the systems functions and concepts of the various references described above to provide yet further embodiments of the disclosure.

These and other changes can be made to the disclosure in light of the above Detailed Description. While the above description describes certain embodiments of the disclosure and describes the best mode contemplated no matter how detailed the above appears in text the teachings can be practiced in many ways. Details of the system can vary considerably in its implementation details while still being encompassed by the subject matter disclosed herein. As noted above particular terminology used when describing certain features or aspects of the disclosure should not be taken to imply that the terminology is being redefined herein to be restricted to any specific characteristics features or aspects of the disclosure with which that terminology is associated. In general the terms used in the following claims should not be construed to limit the disclosure to the specific embodiments disclosed in the specification unless the above Detailed Description section explicitly defines such terms. Accordingly the actual scope of the disclosure encompasses not only the disclosed embodiments but also all equivalent ways of practicing or implementing the disclosure under the claims.

While certain aspects of the disclosure are presented below in certain claim forms the inventors contemplate the various aspects of the disclosure in any number of claim forms. For example while only one aspect of the disclosure is recited as a means plus function claim under 35 U.S.C. 112 6 other aspects can likewise be embodied as a means plus function claim or in other forms such as being embodied in a computer readable medium. Any claim intended to be treated under 35 U.S.C. 112 6 begins with the words means for . Accordingly the applicant reserves the right to add additional claims after filing the application to pursue such additional claim forms for other aspects of the disclosure.

