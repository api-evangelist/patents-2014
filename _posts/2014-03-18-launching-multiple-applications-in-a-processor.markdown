---

title: Launching multiple applications in a processor
abstract: A supervisor module manages multiple user selected applications. A first one of the multiple applications is launched in a first container. Allocation of a first process identifier by the first one of the multiple applications in the first container is detected. The first process identifier is unique within the first container. A first unique identifier is allocated to the first one of the multiple applications. The launch of a second one of the multiple applications is delayed but subsequently launched if the first unique identifier has been allocated to the first one of the multiple applications. A second unique identifier is allocated to the second one of the multiple applications. The first and second unique identifiers uniquely identify the respective first and second ones of the multiple applications within the supervisor module.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09317304&OS=09317304&RS=09317304
owner: STMicroelectronics Asia Pacific Pte, Ltd.
number: 09317304
owner_city: Singapore
owner_country: SG
publication_date: 20140318
---
There are many computer devices available nowadays including for example tablets and smartphones wherein a user can install and launch applications at their selection. Where multiple applications are launched a processor in the device needs to keep track of the identity for managing those applications within a processor system. One mechanism for doing this is the use of process identifiers. As each application is launched a process identifier is obtained by the application and is used to identify itself to the system.

This mechanism is simple and effective. However it can only be utilized in certain circumstances where the process identifiers which are obtained by the applications on launch are safely unique across the whole processor system. In any environment where for any reason the process identifiers obtained by the applications may not be unique this method can no longer safely be utilized.

According to the present disclosure there is provided a method of managing multiple user selected applications in a processor when a user selects multiple applications substantially simultaneously the method comprising at a supervisor module 

To take account of errors and faults the process can include detecting that no process identifier has been allocated by the first application and launching the second application after a time out period.

The second application can be trusted or untrusted. If the second application is untrusted the second application is launched in a second container wherein a process identifier is allocated by the second application in the second container the process identifier being unique only within the second container.

The step of detecting that a user has selected multiple applications can comprise detecting whether each application has a trusted or untrusted status and wherein launch of the second one of the applications is prevented regardless of whether the second one of the applications is trusted or untrusted.

An application can launch a number of processes. In that case the first application provides a plurality of sequentially incremented process identifiers the sequentially incremented process identifiers being associated with the first unique identifier at the supervisor module.

Similarly the second application can provide a sequence of sequentially incremented process identifiers wherein said sequentially incremented process identifiers being associated with the second unique identifier at the supervisor module regardless of whether the second one of the applications has a trusted or untrusted status.

Embodiments provide a computer program product in the form of transitory or non transitory e.g. volatile or non volatile media comprising computer program instructions which when executed by a processor implement the steps of the predefined method.

There is a set of trusted applications and a set of untrusted applications. Among trusted applications there are the supervisor application and also the broadcast middleware. One example of an untrusted application could be a browser because it has access to the web. Each application has its own window which is managed by a window manager described later . The supervisor is the master of the window manager whereas other applications are slaves. Each application communicates with the supervisor and window manager using a mechanism based on a unique identifier for each application.

The application manager is responsible for maintaining an application list and providing an interface to access this list to the core . The concept of trusted untrusted will be explained in more detail hereinafter.

A resource manager defines the various shared resources an application can use. These can for example be physical resources such as the communication resource e.g. territorial satellite cable tuner video instances graphics display ports e.g. GDP etc. In any physical system access to resources is inherently limited and it is the responsibility of the resource manager to manage the limited resources so that each application can function effectively. Before launching an application will acquire the resources that it needs for its proper operation before it can be launched. This is accomplished through the resource manager. The resource manager maintains the resource list and provides an interface to the core to access this list.

A windows manager is connected to the core and communicates directly with a frame buffer which forms part of the window manager . In the window manager is shown as two separate components a manager and a frame buffer . The window manager and its components can be a known window manager system cooperating with the kernel in a known way to control a display. The windows manager which forms part of the supervisor application provides a special display control function which will be described more fully later. In brief it maintains and draws four separate windows on a display screen via the frame buffer . It also provides an interface to display text for warning messages and displays a CPU status. A user interface module operates under the control of the core and can control the browser environment to draw an application launch bar.

In an alternative embodiment shown in a mechanism creates a hole in a window and handles the display inside the window by some hardware components. A hardware compositor component manages the composition between the output of the frame buffer and those components. Two frame buffers can be mixed together by this hardware compositor. A video plan can also be mixed in. Thus the four separate windows are not necessarily managed only by the frame buffer.

A CPU monitoring module is responsible for grabbing the CPU status periodically and that status can be displayed through the windows manager . A wrapper module is executed on top of the manager of the window manager . It provides a linking interface between code executed in the manager and in the core . This allows different computing environments to be interconnected through the wrapper.

A command module is similarly provided as an interfacing module between the core and applications executing in an application environment as shown in volume . As described in more detail later volume can be considered to comprise containers for untrusted applications.

As mentioned earlier a hardware compositor can drive the display with two frame buffer and two video plans mixed together.

Each application constitutes a program or code sequence which is executed by a CPU forming part of the processor system. The architecture described herein provides a secure run time environment for multiple applications which in particular allow advantage to be taken of a variety of different application frameworks. The architecture does not itself provide a new application framework but provides the infrastructure and tools to facilitate the build of such a framework and or to make it easier to integrate legacy middleware along with an existing application framework. A first concept supported by the architecture described herein is to denote an application as trusted or untrusted. This is determined during installation of an application. On installation the application manager checks the application certificate. If the certificate is valid the application is regarded as trusted else it is regarded as untrusted. Trusted applications are loaded and executed normally that is directly between the supervisor application and the window manager . They have access privileges to directly access resources required for their execution these resources are managed by the resource manager which also manages resources for untrusted applications but through the supervisor application. In contrast untrusted applications are started in a container which provides an environment that is capable of isolating processes from the main system and limiting the resources usage thus providing a certain level of security from malicious programs. The concept of a container is known from the open source environment of Linux where untrusted applications are started in a

Linux container as a non root user. Resource usage is provided in the Linux context via the c group mechanism where c group is a control group representing a collection of processes bound by the same criteria . An alternative construction is offered by UNIX in the form of Logical Domains LDOMs .

The processor system described herein uses the concept of containers. A container identifier identifies the container itself. An application identifier identifies the application. By hosting untrusted applications in a respective container a first level of security is provided. The architecture allows a number of different application environments to be hosted. When the manager detects that a user has selected an application to be launched at the display the wrapper intercepts the launch process and advises the core to determine the status of the application that has been selected. All selected applications are considered in the first place to be trusted and so have an identifier which would denote a trusted status. When the core in conjunction with the application manager detects that the application is not trusted it sets a container identifier to a non trusted identifier and allocates an application identifier associated with the container identifier. Moreover the browser executable is not called directly with a start command. There are two possibilities mentioned herein for allowing the application to access resources even though it is untrusted. In a first possibility a script file is called to run a container for the browser noting that the container identifier is untrusted. The script file calls a client before running the browser executable. Although the container is started as untrusted the client needs trusted privileges to obtain resources for example an IP address or dynamic access to hardware resources like audio and video decoders. This can be achieved by setting an application identifier bit for the client beforehand indicating a trusted status for the client even if not for the browser executable or the application which will be run behind the client . This allows the browser executable to be started as untrusted in the container and able to obtain an IP address dynamically using the client. According to the second possibility which is more secure the core can run a check for available IP addresses prior to starting the container. It can then use this IP address and statically configure the container before starting it. In this case it removes the requirement to run the client with trusted privileges within a container and is therefore more secure.

Note that for applications run inside a container process identifiers which are allocated within a container are unique only within the container itself This can create a difficulty when applications are launched substantially simultaneously. Under usual circumstances if a user launches trusted applications A and B together both applications A and B will start at their own pace in a common environment. The manager will detect that the applications are required to be launched trigger the launch function and the new process identifiers are captured together with a unique application identifier. This identifier is the identifier which is used for applications to communicate with one another. It is also used to identify applications in the frame buffer. As the process identifier is unique in the common environment for each newly captured process identifier it can determine whether the process identifier belongs to application A or application B and update the application manager for future references.

However if a user launches untrusted application A which will launch in a container and untrusted application B which will launch in a container both applications A and B will again start at their own pace. When an application starts to execute it obtains a process identifier from its operating environment in this case a container and supplies it to the manager . However in this case when the launch process is triggered at the manager based on the newly captured process identifier the core is unable to determine whether the new process identifier belongs to application A or application B as the process identifier is unique only within the container itself and not between containers .

This difficulty is overcome in the following way. Applications which are selected more or less simultaneously by a user are sequentially launched by restricting user control in the following manner. If a user launches an application A any application B will not be allowed to start regardless whether it is trusted or untrusted until a launch command for application A implemented at the manager causes a new process identifier value to be captured. As at this time it is sure that the process is for application A the process identifier is updated in the application manager accordingly. A unique application ID is stored as well. So in any future reference in subsequent launch commands the unique ID is used as the identifier.

An application can launch multiple processes each having a process identifier sequentially generated by the application unique within a container for untrusted applications . These process identifiers are held in association with the unique identifier at the superior module.

If no launch command which captures a new process identifier value occurs within ten seconds it is assumed that an error has occurred and application A will be stopped. This will allow the user to launch any application B.

Utilizing the architecture described earlier in the embodiment of the resource manager within system A does not manage the resources applicable for system A. Instead these are managed by the resource manager of system B. Thus system B represents an architecture similar to that described in . A virtual frame buffer is implemented by dedicated memory space which interacts directly with the kernel. The virtual frame buffer has a memory space dedicated to the management of the screen on the display as governed by system A. This memory space is isolated from the rest of the system and is controlled in a dedicated fashion by the supervisor application . The operation of the supervisor module allows the display of system A to be controlled using the hardware resources available to system B. This is accomplished through the resource manager . Using the windows manager and hardware compositor the display output from system A can be drawn into one of the four windows on the display as shown in even though system A considers that it is operating in full screen mode.

The window manager creates a hole in a window. Then the display is managed by the hardware compositor as an overlay solution. The supervisor is responsible to create the window and the hole then to program the hardware compositor through the virtual frame buffer and it is transparent for system A. System A acts as if it is displaying on a single window of a frame buffer.

System A then drives the virtual frame buffer as allocated to it by the supervisor application. The virtual frame buffer FB is below FB so the final output which drives the display via the kernel is the composite of the contents of FB and FB as managed by the hardware compositor . The supervisor application allocates the virtual frame buffer resource FB to system A when an application is launched in system A that will access to the display as a resource. The supervisor application can also be configured to monitor the application and to detect when the size of the application has changed. The application can then drive the kernel to change the size of the virtual frame buffer.

Optionally at detecting that the user has selected multiple ones of the multiple applications includes the act of detecting whether each selected application has a trusted or untrusted status and in some embodiments launch of the second one of the multiple applications is delayed regardless of whether the second one of the multiple applications is trusted or untrusted. Optionally at the first one of the multiple applications may provide a plurality of sequentially incremented process identifiers the sequentially incremented process identifiers associated with the first unique identifier of the supervisor module.

At it is determined if the first unique identifier has been allocated to the first one of the multiple applications and if so processing advances to . At acts of the supervisor module method include subsequently launching the second one of the multiple applications and allocating a second unique identifier to the second one of the multiple applications. The first and second unique identifiers uniquely identify the respective first and second ones of the multiple applications within the supervisor module.

Optionally at the second one of the multiple applications is launched in a second container wherein a second process identifier is allocated by the second one of the multiple applications in the second container the second process identifier being unique within the second container. Optionally at the second one of the multiple applications is launched as a trusted application. Optionally at the second one of the multiple applications provides a sequence of sequentially incremented process identifiers which are associated with the second unique identifier of the supervisor module regardless of whether the second one of the multiple applications has a trusted or untrusted status.

After processing at or after determining at that the first unique identifier has not been allocated to the first one of the multiple applications processing advances to . At acts of the supervisor module method include detecting that no first process identifier has been allocated by the first one of the multiple applications and launching the second one of the multiple applications after a time out period.

The above described embodiments of the present disclosure provide a processor system which delivers a toolbox that improves time to market allowing different stack porting for dedicated applications. The toolbox gives the flexibility to run concurrently several applications and interface frameworks for example the different frameworks as shown in volume . The toolbox further provides support for secure content between applications based on the unique application identifier.

It will be appreciate that the embodiments have been described only by way of example. Other variants may be implemented by a person skilled in the art given the disclosure herein. The scope of the invention is not limited by the described embodiments.

The various embodiments described above can be combined to provide further embodiments. These and other changes can be made to the embodiments in light of the above detailed description. In general in the following claims the terms used should not be construed to limit the claims to the specific embodiments disclosed in the specification and the claims but should be construed to include all possible embodiments along with the full scope of equivalents to which such claims are entitled. Accordingly the claims are not limited by the disclosure.

