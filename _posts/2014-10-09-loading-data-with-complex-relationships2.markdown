---

title: Loading data with complex relationships
abstract: Data to be loaded into a target system includes entities having corresponding unique primary data value and secondary data values. The secondary data values have associated foreign key relationships, which links the secondary data value to the primary data value of another entity. In loading the data, the entities are split into insertion leaf groups by execution of an iteration process, each iteration involving generation of a respective set of insertion leaf groups containing entities whose secondary data values have no foreign key relationships or only foreign key relationships with the primary data values of entities of the insertion leaf groups generated during any prior iteration. The iteration process is executed until there are no such entities are left. A sequence of generation of the sets of insertion leaf groups is recorded, and the sets of insertion leaf groups are consecutively loaded into the target system according to the sequence.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09607021&OS=09607021&RS=09607021
owner: International Business Machines Corporation
number: 09607021
owner_city: Armonk
owner_country: US
publication_date: 20141009
---
Effective processing of data having complex relationships is an everlasting task of the computer science. For instance one of typical tasks in this field is migrating objects from one or more computer applications or databases to a single target computer application or database e.g. in the context of a consolidation or harmonization project wherein a number of existing systems are replaced by a new system. This also includes incorporating additional source systems comprising the objects into an already existing target. This problem gets further complicated when the objects comprise instances linked by relationships. Thus migrating of the objects from one computer application to another requires not only transfer of the instances but transfer and update of their relationships.

The present invention relates to a computer system for loading of data or objects with complex relationships into a target system a method for migration of data or objects with complex relationships to a target system a computer program product and a computer system for loading of data or objects with complex relationships into a target system wherein data entities or objects are converted into a directional graph.

The present invention provides for embodiments that provide for an improved effective migration of data or objects to a target computer application or a target system. The data or objects comprise instances linked by foreign key relationships. It should be appreciated that the present invention can be implemented in numerous ways including as a method for loading data into a target system a computer system for loading of data into a target system or a computer program product carrying computer executable code for execution by a processor controlling an apparatus. Several inventive embodiments are described below.

One embodiment provides a computer implemented method for loading data into a target system. The data comprises entities. Each entity has a corresponding unique primary data value and one or more corresponding secondary data values. At least a portion of the secondary data values has associated foreign key relationships. Each foreign key relationship links the corresponding secondary data value to the corresponding primary data value of another entity. The method comprises the following steps.

The entities are split into insertion leaf groups by execution of an iteration process comprising execution of consecutive iterations. Execution of each iteration involves generation of a respective set of the insertion leaf groups. The respective set of the insertion leaf groups comprises all entities whose secondary data values have either no foreign key relationships or only one or more foreign key relationships with the primary data values of the entities of the insertion leaf groups generated during execution of any prior iteration. The iteration process is executed until there are no entities left whose secondary data values have either no foreign key relationships or only one or more foreign key relationships with the primary data values of the one or more entities of the insertion leaf groups generated during execution of any previous iteration. A sequence of generation of the sets of the insertion leaf groups is recorded.

The sets of the insertion leaf groups of the entities and the foreign key relationships linking their secondary data values with the corresponding primary data values are consecutively uploaded into the target system according to the sequence.

This method may have an advantage that each insertion leaf group and the foreign key relationships linking its secondary data values with the corresponding primary data values is loaded into the target system in a single step. No additional steps are needed for updating foreign key relationships after upload of all insertion leaf groups.

In accordance with another embodiment of the present invention at least a portion of the foreign key relationships may be cyclic foreign key relationships. The cyclic foreign key relationships link entities comprising the corresponding primary and secondary data values linked by the cyclic foreign key relationships into one or more loops. The entities linked into the one or more loops comprise one or more cycle entities. When all cycle entities and the foreign key relationships linking the primary data values of all cycle entities with the corresponding secondary data values are considered being deleted from the data the data comprises no loops of the entities any more. Further information regarding description and identification of the cyclic foreign key relationships is published in a book Handbook of combinatorial optimization Supplement vol. A Kluwer Academic Publishers pp. 209 259.

A set of the insertion cycle groups is generated. The set of the insertion cycle groups comprises all cycle entities. All cycle entities and the foreign key relationships linking primary data values of the all cycle entities with the corresponding secondary data values are considered being deleted from the data during a splitting of the entities into insertion leaf groups.

Before the consecutive insertion of the insertion of the sets of the leaf groups of the entities and the foreign key relationships linking their secondary data values with the corresponding primary data values into the target system the entities of the set of the insertion cycle groups are inserted into the target system.

After the consecutive insertion of the sets of the insertion leaf groups of the entities and the foreign key relationships linking their secondary data values with the corresponding primary data values into the target system the foreign key relationships linking the secondary data values of the entities of the set of the insertion cycle groups with the corresponding primary data values are inserted into the target system.

The method of this embodiment may have an advantage of automated and straightforward processing of the insertion cycle group. This way of data processing does not require any case sensitive tuning and or optimization.

In accordance with yet another embodiment of the present invention the generating of the set of the insertion cycle leaf groups is performed before the splitting of the entities into the insertion leaf groups.

This way of data processing may enable a reduction in a number of the insertion leaf groups in comparison with the previous embodiment where the splitting of the entities into the insertion leaf groups is started first.

In accordance with yet another embodiment after the splitting of the entities into the insertion leaf groups and before the loading of the entities of the set of the insertion cycle groups into the target system the generating of the set of the insertion cycle groups using the entities not yet split into the insertion leaf groups is performed wherein after the generating of the set of the insertion cycle groups and before the consecutively loading of the sets of the insertion leaf groups of the entities and the foreign key relationships linking their secondary data values with the corresponding primary data values into the target system the splitting of the entities into the insertion leaf groups and the recoding of the sequence of generation of the sets of the insertion leaf groups are further performed.

This way of data processing may have an advantage when there is no prior knowledge regarding presence or absence of the cycle entities in the data available. In a case when there are no cycle entities in the data the entities are split in the insertion leaf groups in a single non interrupted iteration process.

In accordance with yet another embodiment of the present invention after the splitting of the entities into the insertion leaf groups and before the loading of the entities of the set of the insertion cycle groups into the target system the generating of the set of the insertion cycle groups using the entities not yet split into the insertion leaf groups is performed wherein after the generating of the set of the insertion cycle groups and before the consecutively loading of the sets of the insertion leaf groups of the entities and the foreign key relationships linking their secondary data values with the corresponding primary data values into the target system the following is performed deleting the sequence after the deleting of the sequence restarting of the splitting of the entities into the insertion leaf groups by execution of the iteration process comprising execution of the consecutive iterations.

This way of data processing may have an advantage of reduction in the number of the insertion leaf groups in comparison with the process when a portion of the entities is split into one or more insertion leaf groups before the insertion cycle group is generated.

In accordance with yet another embodiment of the present invention the consecutively loading of the sets of the entities of the insertion leaf groups into the target system comprises splitting the entities of the set of the insertion leaf groups into at least two leaf group portions and loading each of the at least two leaf group portions into the target database by concurrent execution of loading of entities of the each of the at least two leaf group portions and the foreign key relationships linking their secondary data values with the corresponding primary data values into the target system.

This way of data processing may enable acceleration of data upload in a case when parallel data processing is enabled.

In accordance with yet another embodiment of the present invention the loading of the entities of the set of the insertion cycle groups into the target system comprises splitting the entities of the set of the insertion cycle groups in at least two cycle group portions and loading each of the at least two cycle group portions into the target data base by concurrent execution of loading of entities of the each of the at least two cycle group portions into the target system.

This way of data processing may enable acceleration of data upload in a case when parallel data processing is enabled.

In accordance with yet another embodiment of the present invention the loading of the foreign key relationships linking the secondary data values of the entities of the set of the insertion cycle groups with the corresponding primary data values into the target system comprises splitting the foreign key relationships linking the secondary data values of the entities of the set of the insertion cycle groups with the corresponding primary data values into at least two relationship group portions and loading each of the at least two relationship group portions into the target system by concurrent execution of loading of the foreign key relationships of the each of the at least two relationship group portions into the target system.

This way of data processing may enable acceleration of data upload in a case when parallel data processing is enabled.

In accordance with yet another embodiment of the present invention the computer implemented method comprises the following.

A directional graph is generated. Each entity corresponds to a unique node of the graph. Each foreign key relationship corresponds to a unique edge of the graph. For a given foreign key relationship linking the respective secondary data value with the respective primary data value the graph edge begins at the node corresponding to the entity comprising the respective secondary data value and ends at the node corresponding to the entity comprising the respective primary data value.

Utilization of the directional graphs may enable usage of various previously developed software libraries for graph processing. Moreover it provides for a better demonstrativeness understanding and applicability of the computer implemented method.

Another embodiment provides a computer program product in particular a computer readable medium. The computer program product carries computer executable code for execution by a processor controlling an apparatus. Execution of the instructions cause the processor to perform a portion or all steps of the aforementioned computer implemented method for loading the data into the target system.

Yet another embodiment provides a computer system for loading data into the target system. The computer system is operable for performing a portion or all steps of the aforementioned computer implemented method for loading the data into the target system.

As usual object instances comprise data being stored in one or multiple tables. The tables and the object instances can be linked by relationships. Relationships between the data of the same object instance being stored in multiple tables are simple to deal with when they have to be loaded into a target system. Target systems offer as usual a capability to upload the contents of all related data of the object instances in a single step and the target system automatically establishes all relationships between the data of the same object instance stored in multiple tables. An example for such an interface is an intermediate document IDoc interface of a Systems Applications and Products in Data Processing SAP application system.

Uploading of the object instances is more complicated when their tables comprise entities or records belonging to different object instances that are linked by foreign key relationships. The foreign key relationships may link entities within one table and or entities within different tables. An application system like a SAP enterprise resource planning ERP can process such cases. This application system performs the upload in several steps. First all instances are uploaded with empty foreign key relationships. Afterwards all newly assigned identifiers or primary keys or primary values are extracted from the target system. The extracted identifiers are updated in the target system in accordance with the original foreign key relationships between the entities.

This approach has the following drawbacks. Each instance has to be processed twice causing a longer elapsed time of the upload. Depending on a project type this might not only lead to latency issues but for example also to longer business blackout periods. Further two different interfaces have to be implemented i.e. a first interface for data upload and a second interface for foreign key relationship update. In SAP the IDOC interface is used as the first interface and a business application programming interface BAPI is used as the second interface. This requires a lot of effort in terms of man hours in order to implement and to test a logic feeding of the two different interfaces. Moreover special optimization of the second interface is required when the object instances have the foreign key relationships linking them in one or more loops. The uploaded instances cannot be used before their foreign key relationships are not yet updated. As a result the target system has to be blocked in order to avoid inconsistencies and improper usage.

As it will be clearly seen from the following description the present invention does not have the aforementioned drawbacks and have the following advantages. The upload can be performed in a sequence of steps which do not require update of the foreign key relationships after loading of data into a target system. The foreign key relationships linking the entities in one or more loops can be processed in a straightforward automated way. Each entity is processed just once during the upload. The upload can be executed using parallel processing and or portions of the entities can be concurrently uploaded.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device. A computer readable storage medium as used herein is not to be construed as being transitory signals per se such as radio waves or other freely propagating electromagnetic waves electromagnetic waves propagating through a waveguide or other transmission media e.g. light pulses passing through a fiber optic cable or electrical signals transmitted through a wire.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wire line optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

It will also be noted that each process block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

In the following a procedure for data loading into a target system will be discussed by using the flowchart diagram of the the example data depicted on the the example target database depicted on the and system depicted on the .

Upon receiving a request for loading of the data in the Tables of the first database to the second database the data migration computer causes the source adapter to download the data from the first database to the data migration computer . Afterwards the tuple reordering unit performs process blocks and of the flowchart depicted on the .

In the process block the entities are split into insertion leaf groups by execution of an iteration process comprising execution of consecutive iterations. Execution of each iteration involves generation of a respective set of the insertion leaf groups. The respective set of the leaf groups comprises all entities whose secondary data values have either no foreign key relationships or only one or more foreign key relationship with the primary data values of the entities of the insertion leaf groups generated during execution of any prior iteration. The iteration process is executed until there are no entities left whose secondary data values have either no foreign key relationships or only one or more foreign key relationships with the primary data values of the one or more entities of the insertion leaf groups generated during execution of any previous iteration. A sequence of generation of the sets of the insertion leaf groups is recorded. The numbers of the insertion leaf groups in the sets may be arbitrary alternatively they may be chosen in accordance with specifications of computers used for performing the procedure for data loading into the target system.

Processing of the example data depicted on the according to the process block will result in a generation of a first set of the insertion leaf groups. The first set of the insertion leaf groups comprises all entities of the Table because their secondary values do not have any foreign key relationships. Further generation of the sets of the insertion leaf groups is not possible because the entities in the Tables are linked by the foreign key relationships in loops.

In a decision process block the number of entities split into the insertion leaf groups is compared against the overall number of entities. In a case when all entities are split into the insertion leaf groups then a process block is performed otherwise process blocks and are performed.

In a case of processing of the example data depicted on the it is detected that not all entities are split into the insertion leaf groups in the decision process block . Thus further processing of the example data is performed in the process blocks and .

In the process block a set of the insertion cycle groups is generated. The set of the insertion cycle groups comprises all cycle entities. The entities which are not yet split in the one or more insertion leaf groups may be used for generation of the set of the cycle insertion groups. All cycle entities and the foreign key relationships linking primary data values of all cycle entities with the corresponding secondary data values are considered being deleted from the data during the splitting of the entities into insertion leaf groups. The number of the insertion cycle groups in the set of the insertion cycle groups may be arbitrary alternatively it may be chosen in accordance with specifications of computers used for performing the procedure for data loading into the target system.

Processing of the example data depicted on the according to the process block will result in a generation of a Set of insertion cycle groups. This set comprises all entities of the Table because each entity of the Table is in two corresponding loops of entities. For instance the first loop comprising cycle entity having ID 1 in the Table consists of the entity having ID 1 in the Table and the entity having ID John in the Table wherein the entity having ID 1 in the table comprises secondary data value John linked by the foreign key relationship with the primary data values of the entity having ID John in the Table and the entity having ID John in the Table comprises the secondary value 1 linked by the foreign key relationship with the primary data value of the entity having ID 1 in the Table . The second loop comprising cycle entity having ID 1 in the table consists of the entity having ID 1 in the table the entity having ID 23 in the Table and the entity having ID John in the table linked by the corresponding foreign key relationships wherein the entity having ID 1 in the table comprises the secondary data value 23 linked by the foreign key relationship with the primary data value of the entity having ID 23 in the table the entity having ID 23 in the table comprises the secondary data value John linked by the foreign key relationship with the primary data value of the entity having ID John in the table and the entity having ID John in the Table comprises the secondary value 1 linked by the foreign key relationship with the primary data value of the entity having ID 1 in the Table .

Processing of the example data depicted on the according to the process block will result in a generation of a second third and fourth insertion Set of the insertion leaf groups. Since all entities of the previously generated insertion leaf and cycle groups are excluded from further processing execution of the process block will result in generation of another three Sets of the insertion leaf groups. Each set of the insertion leaf groups comprises a unique portion of the entities. The second Set comprises all entities of the Table . The third set comprises entities of having ID 23 and ID 56 in the Table . The fourth set comprises entity having ID 98 in the table .

In the process block the entities of the set of the insertion cycle groups are loaded into the target system. The entities of each cycle group may be loaded concurrently with each other. Alternatively the entities of the set of the insertion cycle groups may be split into several insertion cycle subgroups and each insertion cycle subgroup may be loaded concurrently with the other ones.

In the process block the Sets of the insertion leaf groups of the entities and the foreign key relationships linking their secondary data values with the corresponding primary data values into the target system are consecutively loaded into the target system according to the sequence. The insertion leaf groups of each set may be loaded concurrently with each other. Alternatively the entities of each set of the insertion leaf groups and the foreign key relationships linking their secondary data values with the corresponding primary data values may be split into several insertion leaf subgroups and each insertion leaf subgroup may be loaded concurrently with the other ones.

In the process block the foreign key relationships linking the secondary data values of the entities of the set of the insertion cycle groups with the corresponding primary data values into the target system are loaded. The foreign key relationships linking the secondary data values of the entities of each insertion cycle group may be uploaded concurrently with each other. Alternatively the foreign key relationships linking the secondary data values of the entities of the set of the insertion cycle groups may be split in foreign key relationship subgroups and each foreign key relationship subgroup may be uploaded concurrently with the other ones.

Those skilled in the art will clearly understand that the process blocks and may be executed concurrently or in a reversed order with respect to each other.

The process blocks and are performed by the insertion unit of the data migration system depicted on the .

Execution of the process block of the flowchart depicted in using the example data depicted on the results in a generation of a set of the insertion cycle groups. The set of the insertion cycle groups comprises all entities of the Table .

The process block is performed after the process block . The process block is performed as described above.

Execution of the process block of the flowchart depicted in using the example data depicted on the results in generation of a first second and third Set of the insertion leaf groups. The first Set of the insertion leaf group comprises all entities of the tables and . The second Set of the insertion leaf groups comprises entities of having ID 23 and ID 56 in the table . The third Set of the insertion leaf groups comprises entity having ID 98 in the table . Thus execution of the flowchart of the process blocks depicted on the results in generation of fewer amount of the Sets of the insertion leaf groups in comparison with the flowchart of the process blocks depicted on the

Process blocks and depicted on the are performed in the same way as process blocks and depicted on the .

Those skilled in the art will clearly understand that the process blocks and may be executed concurrently or in a reversed order with respect to each other.

In a case when the entities are not linked in one or more loops the data can be loaded into the target system by performing only process blocks and .

Each flowchart depicted on the has its own advantages. The choice of each flowchart may be determined by a structure of the data to be loaded into the target system. For instance if it is known upfront that the data comprises cycle entities then utilization of the flowchart depicted on the may be an optimum choice since the flowchart depicted on the begins with generation of the insertion cycle group. Moreover generation of the insertion cycle group before the splitting of the entities into the insertion leaf groups may result in a fewer amount of the generated insertion leaf groups in comparison to the flowchart of the .

If the prior knowledge regarding the structure of the data is absent then utilization of the flowchart depicted on the may be an optimum choice. In a case when the data do not comprise any cycle entities no computation time and or computer resources will be wasted for searching cycle entities in the database and the processing algorithm is reduced to an execution of the process blocks and .

Since identification of the Set of the insertion cycle groups may require much more computing time and or computer resources than splitting of the entities in the insertion leaf groups it may be beneficial to reduce a volume of data wherein the cycle group is identified. This concept lies behind the flowchart of the . First in the process block all possible insertion leaf groups are generated. Afterwards the insertion cycle group is generated using the entities not yet split into the insertion leaf groups.

Alternatively the nodes and their adjacent edges selected into the insertion groups are marked instead of being deleted. The marking is performed in the process blocks and . In the decision process block execution of the algorithm is stopped when all nodes are marked. In the process block the unmarked nodes having no outgoing unmarked edges are selected into the selection set S.

