---

title: Class loading device for a java runtime environment, cluster system and method of executing a function
abstract: A class loading device for a Java runtime environment, wherein the class loading device is configured to load predetermined source code written in R programming language to parse the R source code and, based on the parsed R source code, generate corresponding bytecode at least of a first Java class and transfer same to the Java runtime environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09207956&OS=09207956&RS=09207956
owner: Fujitsu Technology Solutions Intellectual Property GmbH
number: 09207956
owner_city: 
owner_country: DE
publication_date: 20141014
---
This disclosure relates to devices and methods of processing extensive data in particular to devices and methods of efficiently executing algorithms to process so called big data problems.

According to the online encyclopedia Wikipedia the term big data refers to the use of large amounts of data from multiple sources with a high processing speed to produce an economic benefit. Problems include primarily the capture storing searching distribution statistical analysis and display of large amounts of data. The volume of these amounts of data is in the terabyte petabyte and exabyte ranges.

Due to the range of data to be processed conventional electronic data processing systems are often not suitable or are only suitable to a limited extent to usefully process such extensive data. For example relational database systems which use for data storage an individual local mass storage device and a schema which is identical for all data sets are generally unsuitable for storing or processing such extensive data. Likewise in the statistical evaluation of data many programming languages are unsuitable because they do not have sufficiently specialized libraries for this purpose.

The R programming language is known inter alia from the book R in a Nutshell 2edition O Reilly 2012. The R programming language is particularly suitable for statistical calculations based on extensive data. Therefore the R programming language is suitable in principle for processing big data problems e.g. for implementing so called reduction functions as used in the so called MapReduce approach for processing big data problems.

One problem with the R programming language resides in the fact that the runtime environment used to execute it interprets the source code written in the programming language R. Due to the complexity associated with the interpretation inter alia parsing of the source code interpreted programming languages have a reduced running speed compared with programs written in other programming languages.

It could therefore be helpful to provide devices and methods which can accelerate the processing of extensive data in particular the processing of big data problems using the R programming language. Preferably existing components should be built on as far as possible to reduce the costs of developing new components.

I provide a class loading device for a Java runtime environment wherein the class loading device is configured to load predetermined source code written in R programming language to parse the R source code and based on the parsed R source code generate corresponding bytecode at least of a first Java class and transfer same to the Java runtime environment.

I also provide a cluster system having a plurality of mutually coupled cluster nodes that process extensive data wherein each of the cluster nodes has a Java runtime environment at least one Java runtime environment has the class loading device and is configured to compile R source code of at least one function using the class loading device in corresponding bytecode of a first Java class.

I further provide a method of executing a function written in R programming language including at least one Java class loading device compiling R source code written in the R programming language of the function in bytecode at least of a first Java class with a method corresponding to the function and executing the function within the Java runtime environment by calling the bytecode of the corresponding method of the first Java class.

I provide a class loading device for a Java runtime environment. The class loading device may be configured to load predetermined source code written in the R programming language hereinafter R source code to parse the R source code and based on the parsed R source code to generate corresponding bytecode at least of a first Java class and transfer same to the Java runtime environment.

By using a modified class loading device for a Java runtime environment it is possible to convert source code written in the R programming language from programs or functions into compiled executable Java classes. Executable Java class is understood herein essentially to mean a representation of the Java class as bytecode executable by a so called Java virtual machine. Since parsing only has to be performed once when compiling the R source code the subsequent execution of methods of the thus produced Java class is quicker than the interpretation of the original R source code which means that in particular when performing extensive statistical calculations data processing is accelerated.

Advantageously once compiled Java classes based on corresponding R source code may be stored in a library and are again transferred to the Java runtime environment as required. By way of the buffering and if applicable the re retrieval the outlay involved in the re parsing and translation of the R source code can be avoided.

Further advantageously the class loading device may further be configured to compile at least some functions of an R system library of an R runtime environment into corresponding executable Java classes or retrieve corresponding already compiled Java classes from a library. By compiling or holding compiled functions of an R system library of an R runtime environment execution of R program code within the Java runtime environment can be further accelerated. For example many R system libraries can be freely downloaded via the CRAN website. The free availability of many very good libraries means that the R programming language is particularly suitable for the above mentioned tasks.

Still further advantageously the class loading device may provide at least a second and a third Java class. Instances of the second Java class represent a current state of an R runtime environment and instances of the third Java class represent objects of the R runtime environment. A plurality of instances of the third Java class can be allocated to one instance of the second Java class. By providing Java classes to model an R runtime environment and R objects contained therein rapid and efficient data exchange between Java classes of the Java runtime environment and Java classes provided by the class loading device based on R program code can be performed in the storage device.

For example extensive information can be transferred as transfer parameters to the first Java class or can be returned from the first Java class as a result type. Alternatively a reference to an R environment can also be transferred to the first class to allow access to state variables of the R environment.

I also provide a cluster system having a plurality of mutually coupled cluster nodes to process extensive data in particular big data problems. Each of the cluster nodes has a Java runtime environment. At least one Java runtime environment has a class loading device as previously described and is configured to compile R source code of at least one function using the class loading device in corresponding bytecode of a first Java class.

By using the cluster system in this second context functions or programs written in the R programming language can be executed in a cluster system in a distributed manner. By compiling R source code in a Java class and executing same in a Java runtime environment of a cluster node the execution speed of the executed functions or programs can be accelerated. A complete runtime environment does not have to be installed on each cluster node. In particular the typically provided R interpreter can be replaced by a modified class loading device to execute R program code of a function and or associated R system libraries on individual cluster nodes or all cluster nodes.

Advantageously each cluster node further comprises a Java framework to implement a MapReduce algorithm and access a distributed file system to store data on the plurality of cluster nodes. For example the Hadoop framework having the associated Hadoop Distributed File System HDFS can be installed on each of the cluster nodes. By using such a Java framework tasks which relate to the distributed processing of data in a cluster system can easily be handled by the Java runtime environments of the plurality of cluster nodes. Therefore a developer can concentrate on the provision of the actual functionality by the R source code.

Further advantageously the Java runtime environment is configured to inject a Java method of accessing the distributed file system into the corresponding executable first Java class during execution of the at least one function of the R runtime environment. By injecting Java classes to access the distributed file system access to data stored in a distributed manner can easily be integrated into the R source code.

I further provide a method of executing a function written in the R programming language. The method includes a Java class loading device compiling R source code written in the R programming language of the function into bytecode at least of a first Java class with a method corresponding to the function. The method further includes executing the function within the Java runtime environment by calling the bytecode of the corresponding method of the first Java class.

By way of those steps the execution of typically interpreted R program code can be accelerated. Compiling can be performed for example by the class loading device in accordance with the first context described above.

My systems devices and methods will be explained in detail hereinafter with the aid of examples and with reference to the figures. In the figures instances of identical or similar components are designed with alphabetic suffixes. If no suffix is provided the examples relate to all instances.

In addition to the simple exchange of messages between the data processing devices of the different cluster nodes to the data network is also used to provide a virtual distributed file system via which some of the data stored on the mass storage devices are made accessible for all cluster nodes . In the example the distributed file system is the so called Hadoop File System HDFS which ensures not only the access but also the storage of data which is failsafe and distributed over the cluster system .

The Java runtime environment is used to execute methods of Java classes which together form at least one Java application . In the example the Java application is present on the Hadoop framework . The Hadoop framework from the Apache Software Foundation allows the distributed processing of large amounts of data over a plurality of cluster nodes using simple programming models and is thus particularly suitable in solving big data problems. The Hadoop framework is itself implemented in Java and thus runs within the Java runtime environment . The Java application and the Hadoop framework load the Java classes necessary for the execution thereof via a class loading device or Java class loader e.g. from a library . In the example the library includes inter alia executable bytecode previously translated by a Java compiler of different Java classes.

In the R runtime environment includes one or more documents with R source code . Individual functions or complete programs are implemented by the R source code . In this respect the R source code can be based inter alia on standard functions of an R system library .

The R source code is interpreted in a conventional manner. For this purpose in conventional R runtime environments a separate interpreter having a parser for R source code is required. The parser analyzes the R source code step by step before it is executed by the interpreter. It is fundamentally also possible that parts of programs written in the R programming language are themselves written in other programming languages such as C or Fortran. Such program parts themselves then run partly at a higher speed.

It is known to call R source code of a function from a Java application . For this purpose an input output loop is generally provided from the Java application to the R runtime environment . Within the R runtime environment the R program code is then interpreted as described above. This approach is problematic in that the Java application can be executed only at a comparatively low speed due to the interpretation of the called R source code .

To circumvent this and other problems the class loading device of the cluster node of the described example was expanded to the effect that it was able to resolve function calls to the R source code . In particular the class loading device is suitable to load corresponding R source code in accordance with a class call and generate Java bytecode of a corresponding Java class in the background based on the read in R source code which Java class can subsequently be returned to the calling Java application . Methods corresponding to the function of the R source code of the compiled Java class can be executed as Java bytecode within the Java runtime environment . Program parts in other programming languages such as the C or Fortran languages incorporated in the R source code can be called within the Java application via suitable interfaces without a loss of speed in particular via the so called Java Native Interface JNI Application Programming Interface API . In this case it is no longer necessary to provide an R interpreter for the R runtime environment .

Preferably the thus generated executable Java class is additionally stored in the library so that in the event of a subsequent call of the corresponding R source code no renewed dynamic generation of the Java class is necessary. Instead the class loading device then loads the Java class already stored in the library and makes this class available for use in the Java runtime environment .

The buffering of previously compiled R source code is particularly suitable for the standard functions of the R system library . Accordingly in one example executable Java classes which correspond to the standard functions in terms of their functional scope are stored in the library .

The modified class loading device thus permits the direct calling of functions present as R source code within the Java runtime environment . By using this approach the execution of programs in part comprising Java code and in part comprising R source code can be accelerated. In the example the class loading device thus assumes the function of checking as to whether a corresponding Java class is already contained in the library and also if such a corresponding class is not contained in the library the dynamic generation of a corresponding Java class . Alternatively these two functions can also be assumed by separate software components.

In addition the extensive integration of functions of the R programming language into the Java runtime environment also permits an improved transfer of parameters between the Java application and the function of the R source code . In particular this no longer needs to be effected using a relatively slow and error prone looping of inputs and outputs between the two runtime environments and . Instead parameters to be transferred to the R source code can be transferred directly in the storage device in the form of Java objects. Conversely results of the R source code can be transferred back to the Java application in the form of Java objects.

In the example the Java object having the Java objects contained therein as a parameter is transferred to the Java class corresponding to the R source code as a parameter. In this manner the data of the first Java object and the access function of the second Java object to access the HDFS file system of the corresponding Java class are available. Therefore the access function is effectively injected into the function of the R source code . By injecting the Java object into the R source code program parts contained therein can easily access data stored in a distributed manner of the cluster system via Java methods provided by the Hadoop framework . It is not required to write the program code which is required for access itself in the R programming language. Instead corresponding functions encapsulated as methods of the Java object can be transferred as parameters to the corresponding R source code . Results generated by the function implemented by the R source code can be returned as further Java objects to the calling Java application .

Before the actual calling of a function of the R source code a check is made in a first step whether parameters are to be transferred to the calling function. If this is the case a Java object e.g. an instance of a container class is initially generated in a step and represents the R runtime environment . Subsequently in one or a plurality of steps associated primitive parameter values or Java objects are generated and represent parameters to be transferred to the R runtime environment . For example data to be transferred or access methods also written in Java for data access can be allocated to the Java object . Step is repeated until it is established in step that no further parameters are to be transferred.

Alternatively a link to an R environment can be set as a parameter for an instance of the corresponding Java class . The R environment contains all the current state variables. Methods of the corresponding Java class can access these variables. The R environment thus forms a part of the R runtime environment and can be stored on a storage medium for subsequent use.

If the parameters to be transferred have been generated accordingly as Java objects or have been made accessible via a link to an R environment or there is no intention to transfer parameters then the desired function of the R program code can be called in a step . For example an instance of a Java class is generated and a method contained therein is called. In a Java runtime environment this causes a class loading device to check in a step whether a class with the corresponding name exists. If so the corresponding Java class is loaded as bytecode and the called method is executed in the Java runtime environment in step .

Otherwise that is to say if no corresponding Java class can be found in the library in step the modified class loading device checks in a step whether corresponding R source code exists in the R runtime environment . For example a search can be made for an R object or an R function having the name of the called class. In one example a differentiation is made between real Java classes and Java classes corresponding to R functions by suitable namespaces. If the desired R source code exists it is loaded in step and compiled into a corresponding Java class . For this purpose the R source code is initially analyzed by a parser and subsequently converted into corresponding executable Java bytecode. Subsequently an instance of the Java class can be generated or static methods of the Java class can be directly called.

In an optional step the corresponding Java class is stored in a library for subsequent use. Subsequently the Java class dynamically generated in this manner can be executed as bytecode within the Java runtime environment in step .

The cluster system and the method are suitable to solve a wide variety of big data problems. The analysis of data from stock exchange trading will be used hereinafter as a specific example. Such data for example can be detected and stored in a decentralized manner for different trading centers. It is assumed hereinafter that one file generated in different cluster nodes is stored per trading day location in each case.

In the example initially an evaluation function is developed to perform an analysis of an individual share value e.g. based on a regression or other statistical analysis. The R programming language is particularly suitable for the development of this evaluation function having the statistical functions available therein or therefor e.g. the standard functions of the R system library . The developed evaluation function is thus initially present as R source code .

To be able to effectively evaluate all the available data the object is achieved using the MapReduce approach in accordance with the Java Hadoop framework . For this purpose Java code is written which selects the share value to be analyzed. By the map function of the Hadoop framework all the data relevant for this share value from the different cluster nodes are collected. The associated reduce function uses the evaluation function written in R to perform the actual analysis. For this purpose a class corresponding to the evaluation function is instantiated within the Hadoop framework .

The class loading device recognizes that the evaluation function is to be called as per the R source code and accordingly loads the R source code . The R source code is parsed and is compiled in executable Java bytecode. The corresponding Java class resulting therefrom is then instantiated within the Java runtime environment and the generated instance is supplied back to the calling Java class of the Java application or of the Hadoop framework .

Within the reduce function the actual evaluation function can then be called as a method of the instance of the Java class generated by the class loading device . As described above data can be transferred to the method as parameters. The data are transferred in the form of Java objects between parts of the Java application or the Hadoop framework and the evaluation function in the storage device. Any objects can be transferred e.g. Java objects with methods for direct access to the HDFS. In this manner the evaluation function written in R can also directly access data in the HDFS.

With the execution of the evaluation function as compiled Java bytecode the execution speed is considerably greater than in the case of interpreting the R source code within the R runtime environment .

