---

title: Client-server input method editor architecture
abstract: In general, one innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of receiving a key event at an input method editor (IME) server transmitted to the IME server from an IME client that is in communication with the IME server, wherein the IME server is a stateful server that stores both requests and responses of a communication session between the IME server and the IME client, and the IME client is a stateless IME client that issues a request to the IME server based on the key event, identifying, by the IME server, one or more logographic characters based on the key event, generating, by the IME server, rendering information corresponding to the one or more logographic characters, and transmitting the rendering information from the IME server to the IME client to display the one or more logographic characters.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09635138&OS=09635138&RS=09635138
owner: Google Inc.
number: 09635138
owner_city: Mountain View
owner_country: US
publication_date: 20141201
---
This application is a continuation of U.S. patent application Ser. No. 12 953 896 entitled Client Server Input Method Editor Architecture filed on Nov. 24 2010 which claims priority to U.S. Provisional Application Ser. No. 61 264 714 entitled Client Server Input Method Editor Architecture filed on Nov. 27 2009 the disclosures of which are expressly incorporated herein by reference in their entirety.

Languages that use a logographic script in which one or two characters correspond roughly to one word or meaning have more characters than keys on a standard input device such as a computer keyboard or a mobile device keypad. For example the Japanese language contains hundreds of characters in both katakana and hiragana. The mapping of these potentially many to one associations can be implemented by input method editors that facilitate entry of characters and symbols not found on input devices. Accordingly a Western style keyboard can be used to input Japanese characters. Likewise input methods can be used for using a Western style keyboard or some other input device to input many other languages that include ideograms such as the Chinese language the Korean language and other languages.

To implement an input method a user typically must install a client side software application program and a library. However such installations can be inconvenient when a user is working on computer devices that do not belong to the user e.g. a public computer device or a second computer in a work environment etc. Further the client side software application program can be memory and processor intensive and thus cumbersome for the client and can be language dependent requiring an application program for each desired language.

This specification describes technologies relating to input method editors and input method editors having a client server architecture in particular.

In general one innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of receiving an input method editor IME server request the IME server request including one or more tokens and requesting that an IME server be instantiated the IME server executing one or more IME functions based on a key event sent from an IME client wherein the IME server is a stateful server that stores both requests and responses of a communication session between the IME server and the IME client determining that the IME server can be instantiated in a restrictive environment based on the one or more tokens and instantiating the IME server in the restrictive environment. Other embodiments of this aspect include corresponding systems apparatus and computer programs configured to perform the actions of the methods encoded on computer storage devices.

In general another aspect of the subject matter described in this specification can be embodied in methods that include the actions of receiving an input method editor IME server request the IME server request including one or more tokens and requesting that an IME server be instantiated the IME server executing one or more IME functions based on a key event sent from an IME client wherein the IME server is a stateful server that stores both requests and responses of a communication session between the IME server and the IME client processing the one or more tokens determining that the IME server can be instantiated based on the processing instantiating the IME server in a restrictive environment the restrictive environment limiting the functionality of the IME server determining that the IME server is not executing in the restrictive environment and halting the IME server in response to the determining. Other embodiments of this aspect include corresponding systems apparatus and computer programs configured to perform the actions of the methods encoded on computer storage devices.

In general another aspect of the subject matter described in this specification can be embodied in methods that include the actions of establishing a first session between a first input method editor IME client and a first IME server requesting a second session between a second IME client and the first server determining that a version of the first IME server is different than a version of the second IME client halting the first server in response to determining that the version of the first IME server is different than the version of the second IME client and instantiating a second IME server the second IME server having a version that is the same as the version of the second client. Other embodiments of this aspect include corresponding systems apparatus and computer programs configured to perform the actions of the methods encoded on computer storage devices.

In general another aspect of the subject matter described in this specification can be embodied in methods that include the actions of establishing a first session between a first input method editor IME client and a first IME server requesting a second session between a second IME client and the first IME server determining that a version of the first IME server is the same as a version of the second IME client establishing a second session between the second IME client and the first IME server in response to the determining and executing the first session and the second session. Other embodiments of this aspect include corresponding systems apparatus and computer programs configured to perform the actions of the methods encoded on computer storage devices.

In general another aspect of the subject matter described in this specification can be embodied in methods that include the actions of receiving an input method editor IME server request the IME server request being transmitted by a first IME client instantiating a first IME server based on the IME server request establishing a first session between the first IME client and the first IME server requesting a second session between a second IME client and the first IME server determining that a version of the first IME server is different than a version of the second IME client halting the first IME server in response to determining that a version of the first IME server is different than a version of the second IME client instantiating a second IME server the second IME server having a version that is the same as the version of the second IME client and establishing a second session between the second IME client and the second IME server. Other embodiments of this aspect include corresponding systems apparatus and computer programs configured to perform the actions of the methods encoded on computer storage devices.

In general another aspect of the subject matter described in this specification can be embodied in methods that include the actions of receiving a key event at an input method editor IME server transmitted to the IME server from an IME client that is in communication with the IME server wherein the IME server is a stateful server that stores both requests and responses of a communication session between the IME server and the IME client and the IME client is a stateless IME client that issues a request to the IME server based on the key event identifying by the IME server one or more logographic characters based on a key event generating by the IME server rendering information corresponding to the one or more logographic characters and transmitting the rendering information from the IME server to the IME client to display the one or more logographic characters. Other embodiments of this aspect include corresponding systems apparatus and computer programs configured to perform the actions of the methods encoded on computer storage devices.

In general another aspect of the subject matter described in this specification can be embodied in methods that include the actions of receiving a request from an input method editor IME client that is stateless instantiating an IME server based on the request the IME server being stateful generating a communication path between the IME client and the IME server the communication path having a corresponding path name providing the path name to the IME client receiving a key event at the IME server the key event being transmitted to the IME server through the communication path from the IME client identifying one or more logographic characters based on the key event generating rendering information corresponding to the one or more logographic characters and transmitting the rendering information from the IME server to the IME client to display the one or more logographic characters. Other embodiments of this aspect include corresponding systems apparatus and computer programs configured to perform the actions of the methods encoded on computer storage devices.

In general another aspect of the subject matter described in this specification can be embodied in methods that include the actions of generating a key event at an input method editor IME client the IME client being a stateless IME client that stores only requests that it issues to the IME server and that issues a request to an IME server for each key event recording by the IME client the key event in a key event sequence the key event sequence storing the key event and at least one or more previous key events that were previously transmitted to the IME server transmitting the key event to an IME server that is in communication with the IME client the IME server being a state full server that stores both requests and responses of a communication session between the IME server and the IME client determining at the IME client that the IME server has stopped functioning establishing a session with a second IME server in response to the determination that the IME server has stopped functioning the second IME server being a state full server and transmitting the recorded key event sequence to the second server after establishing the session. Other embodiments of this aspect include corresponding systems apparatus and computer programs configured to perform the actions of the methods encoded on computer storage devices.

In general another aspect of the subject matter described in this specification can be embodied in methods that include the actions of instantiating an input method editor IME client on a device the IME client being a stateless IME client receiving user input to the device generating a key event based on the user input the key event being generated by the IME client recording the key event in a key event sequence that is stored in a computer readable storage medium of the device transmitting the key event to an IME server that is in communication with the IME client and that is a stateful IME server determining that the IME server has stopped functioning instantiating a second IME server in response to the determining the second IME server being a stateful IME server establishing a session between the IME client and the second IME server and transmitting the key event sequence to the second IME server after establishing the session. Other embodiments of this aspect include corresponding systems apparatus and computer programs configured to perform the actions of the methods encoded on computer storage devices.

The details of one or more embodiments of the subject matter described in this specification are set forth in the accompanying drawings and the description below. Other features aspects and advantages of the subject matter will become apparent from the description the drawings and the claims. Further aspects of the subject matter described in this specification including the aspects described above can be combined in one or more combinations.

This specification describes technologies related to an input method editor IME that includes a client server architecture. Although example embodiments will be described in the exemplar context of the Japanese language the present disclosure is readily applicable to other languages that use logographic scripts including Chinese Korean and or Indic languages.

Embodiments of the client server architecture include a stateless client that interfaces with a stateful server. As used herein the term client refers to an application program or system that accesses a service provided by a service provider. The term server refers to a service provider that provides a service to a client. The terms client and server do not necessarily refer to separate computer devices as the client and server as those terms are used herein can be implemented on a single computer device. The server is stateful in the sense that the server can store both requests and responses of the communication session between the server and the client. In this manner the server is aware of the full history of communications between the client and server for a particular session. The client is stateless in the sense that it can store requests issued to the server but does not store the server responses. Consequently the client does not store the full history of communications between the client and server for a particular session.

In accordance with aspects of the client server IME architecture provided herein a session is established between a client and a server. A session is a semi permanent information interchange between the IME client and the IME server. The information interchange is semi permanent in that it is achieved through one or more connections that can be opened or closed during the lifetime of a session. In short the lifetime of a session is longer than the lifetimes of connections that occur during the session. The server can coordinate concurrent sessions with a plurality of clients. The server however can only communicate with one client at a time. Consequently a connection between the client and server is opened to enable the exchange of information and is subsequently closed to enable another client to communicate with the server.

The client receives user input the server executes functionality based on the user input and generates rendering information based thereon and the client renders or displays characters based on the rendering information. Using the stateless client and the stateful server the client server architecture provides a portable and language independent solution that can be implemented across any of various operating systems or platforms.

Embodiments of the client server architecture include the server executing in a restrictive environment or sandbox which limits the functionality of the server. In this manner a malicious client or user that somehow establishes a session with the server is not able to access sensitive information through the server.

Embodiments of the client server architecture enable the client and or server as well as the communications protocol between the client and server to be updated e.g. from a current version to a new version without requiring the system on which they are executing to be rebooted. A connection between the IME client and the IME server is maintained when different versions of the IME client and IME server have compatible protocols. Only when the IME client is an older version than the IME server and the protocols are incompatible is the connection stopped.

Embodiments of the client server architecture also enable a session to be recovered in the event that the stateful server crashes aborts freezes or otherwise ceases to function properly and a new server is instantiated. For example the IME client sends each input key event as they occur to the IME server and maintains the each input key event of a session. When the IME server is rebooted e.g. due to a crash update etc. the IME client will send the entire input sequence of key events to the IME server.

The features described above can be combined in various combinations. For example the sandboxed features can be combined with the feature that enables the client and or server as well as the communications protocol between the client and server to be updated without rebooting. Likewise these features can be combined singularly or in combination with the feature that enables a session to be recovered in the event that the stateful server crashes aborts freezes or otherwise ceases to function properly.

The client provides a user interface and a renderer while the server executes the core IME functionality. This core IME functionality includes management of text composition and text conversion from a first syllabary e.g. Hiragana to a second syllabary e.g. Kanji .

The client is implemented using the IME framework provided by the particular operating system of the device on which the client is executed. The functions of the client include receiving user input e.g. a is input by the user generating a key event based on the user input transmitting the key event to the server receiving rendering information provided by the server and providing the rendering information for display to the user. As discussed in further detail below a corresponding character based on the key event can be displayed e.g. in response to the a key event and or a list of candidate characters can be presented from which the user can choose an appropriate candidate. The client can use any implementation for the displaying the list. In the exemplar case of a web browser Ajax and javascript can be used.

The client can be provided as an application program that is executed on a device and one or more clients can communicate with a particular server. Such application programs receive text inputs from an input device e.g. mouse keyboard touchpad and can include but are not limited to web browsers presentation programs word processors and or spreadsheet programs. Unlike the server the client does not manage any states. Because the role of client is stateless the dependencies to the IME framework of the particular operating system are much smaller than those of traditional IMEs.

In some embodiments communication between the client and server can be established using inter process communication IPC . IPC provides a set of techniques for the exchange of data among multiple threads in one or more processes e.g. client process and server process . In some embodiments these processes can be running on one device. In other embodiments these processes can be running on multiple devices connected by a network. IPC method techniques can include remote procedure call RPC . RPC enables a subroutine or procedure e.g. the server to execute in another address space that is different from the address space of the calling program application e.g. the client .

In some embodiments the server does not need to be instantiated using an IME framework of the corresponding operating system. This makes the server process platform independent and portable. For example different IMEs running on different platforms can connect to the same server. The server handles all key events received from the client generates rendering information and transmits the rendering information to the client. The rendering information includes the current and or partially converted text to be displayed on the client application as well as the contents for any candidate window.

As noted above one or more clients can communicate with the server . In the case where the client s and server are executed on a common device discussed in further detail below a user typically only interfaces with one client at a time. However the user can quickly switch between clients even while in the middle of interfacing with one client. For example a user inputting text into first client e.g. a client instantiated for a word processor application on a particular device could switch their attention to a second client e.g. a client instantiated for a web browser application on the particular device while in the middle of typing text into the first client. Consequently the input state for the client associated with the word processor application needs to be preserved. The server can accept and keep track of key events from different clients by establishing a unique session with each client as discussed in further detail below.

During a session multiple connections between the client and server can be opened and closed. A session can remain active even when the connection between the client and server has been closed. For example a connection can be opened to enable a key event to be transmitted to the server from the client or to enable rendering information to be transmitted to the client from the server . The individual connections however can have a short lifespan within a session timeframe. In other words the lifespan of a connection is shorter than the lifespan of its associated session. For example the client opens a connection to the server sends a key event to the server receives a response from the server and then the connection is closed. Consequently each transmitted key event is accompanied by a session identification SID . The SID enables the server to keep track of which key events were received from which clients . More specifically an SID corresponding to a session between one client and the server is unique to the SID corresponding to a session between another client and the server . One exception is a command transmitted by the client to create a session e.g. CreateSession . When the client calls this command without an SID the server creates a session generates a corresponding SID and transmits the SID to the client . Examples of this process are provided below.

As introduced above the client is implemented using an operating system specific or platform specific IME framework. Exemplar IME frameworks can include the text service framework TSF or IMM32 for Microsoft Windows. The IME framework is an application programming interface API that enables advanced source independent text input. Applications that are unaware of particular IME frameworks e.g. are IME framework neutral can be supported by enabling an unaware application support UAS including Cicero Unaware Application Support CUAS .

By way of non limiting example embodiments using TSF will be described. In a TSF environment ImeTextService handles session requests key inputs by users and responses from the server . When the IME is initially activated at the client the client opens an IME user interface IME UI establishes a connection to the server and starts the session in ImeTextService Activate. The IME UI can be provided as a portal or window within the current application e.g. an IME UI window pop up in a word processing application . ImeTextService OnTestKeyDown is called each time a user inputs a character e.g. with each key event . The client key event sent to the server includes key code and modifiers and the client receives rendering information from the server in response.

 ImeTextService HandleKey is called when the server moves to process the key input. The rendering information sent from the server is applied to the IME UI in the client application. More specifically the client draws preedit text and adds attributes of segments to the text if appropriate. If the response from the server includes multiple candidates the client displays the candidates in a candidate list in the IME UI. ImeCandidateWindow is called to render candidate data. The client can offer several functions through a language bar. Such functions can include but are not limited to configuration displaying input state and showing a help document. These functions are implemented in ImeButtonMenu. 

The server can be executed as a component object model COM out of process server. The COM interface is used to invoke methods of the server and to send and receive data. ConverterSession is a class that implements functions called from the client . If not yet existing a COM instance of ConverterSession is created by CoCreateInstance and the client establishes a connection with the server through the instance. The server implements methods including but not limited to ConverterSession CreateSession which requests a new session be created ConverterSession DeleteSession which ends a session and ConverterSession SendKey ULONG key code ULONG key modifiers VARIANT response which sends key events from the client to the server and receives rendering information from the server .

Although the above described embodiments have been provided in the context of a Windows operating system the client server IME architecture are readily applicable to other operating systems. For example the client server IME architecture can be implemented using IMKit for the Leopard operating system.

Various types of architectures can be used to implement the system of examples of which are shown in . is a block diagram illustrating an exemplar client server IME architecture. In the client server IME architecture of the clients and the server are executed on the same device. As used herein the term device refers to a processing or computer device that can include but is not limited to a desktop computer a laptop computer a tablet computer a server system a personal digital assistant PDA and or a mobile telephone. The clients are provided as application programs APP1 APP2 . . . APPn each of which includes an IME dynamic link library DLL and a corresponding IME UI . Each client is instantiated for a corresponding user program e.g. the three clients shown may have been respectively instantiated for a word processing program a browser program and an e mail program. The server includes a stateful session manager a conversion engine core and resources . In some embodiments the server can be executed within a sandbox . The stateful session manager coordinates multiple connections from a plurality of clients e.g. an email applications and a web browser application .

The client server architectures can be implemented using a single thread and single connection model such as IPC. The server opens only one port and handles multiple connections from clients . The single thread and single connection model provides simplicity and portability. Almost all platforms support single thread and single connection IPC.

As described above the client connects to the server with every key event e.g. pushing A button and obtains from the server rendering information corresponding to the key event e.g. A should be displayed as Japanese . The connection is stateless in that it is not kept alive and is independent of any other connection between the client and server . In general the lifetime of each IPC connection is very short. For example after the server transmits the rendering information to the client it immediately closes the connection and waits for other connections.

In some instances the server could be blocked if for example a malicious user connects to the server and does nothing. In other instances the client could be blocked if for example a malicious server does not send any response to the client . To prevent such situations a timeout is implemented for each connection. More specifically if the client or server does not send a message within a predetermined time period e.g. 500 msec the current connection is closed.

Once the server has been instantiated the server generates a connection path name for communication between the client and server. Some embodiments for example employ a named pipe path name that is unique with respect to named pipe path names used for other sessions. By using a unique named pipe path name a malicious user is inhibited from generating a fake named pipe server before a valid server is instantiated. Accordingly the path name is provided by generating a random multi bit path name e.g. 128 bit randomly generated path name . The server stores the path name in the user profile directory. After the server is instantiated but before sending the first key event the client retrieves the path name from the user profile directory and transmits the key event using the retrieved path name.

Another exploit can occur when a malicious application saves a fake path name in the user profile before the server launches i.e. before the server is able to save the actual path name to the user profile . In such an instance and if the client used the fake path name to connect the client could connect to a malicious or fake server. For example a malicious application saves a path name to the user profile which path name would result in the client sending key event information to a malicious server and not the intended server.

The client server architecture however can implement techniques that enable the client to know that it is connecting to a valid server. One exemplar technique can include the server locking the file that holds path name. Other exemplar techniques can include the operating system providing the peer s process ID PID of the path providing an API that knows the peer s PID and or sending the PID via the connection. Further the path name should only be accessible by valid users. Consequently a valid security token can be provided to the corresponding API. The security token enables access by the local system administrators and current users. Other users are denied access.

The PID is a unique ID that is assigned by the operating system to each process. The server or client can identify its peer s ID by using an API that the operating system provides. Once a process determines its peer s PID the process knows various information related to the PID including the owner e.g. username corresponding to the PID. By checking the owner the server or client process can know its peer s user ID. If the username is different than what is expected the server or client process can refuse the connection.

As discussed above the server can be executed within a sandbox. A sandbox is a restrictive environment in which a program runs and it typically facilitated by a library that enables processes such as the server process to execute within the restrictive environment. When sandboxed the server process has limited functionality. In some embodiments the server process can only access CPU cycles and memory. In such embodiments the sandboxed server process cannot write to disk or display its own window for example. The allowed functionality of the server process is regulated by an explicit policy. The sandbox library is included in the server process code. In some embodiments the code is not executed inside a virtual machine and thus the server process operates at native speed and has direct access to the operating system API.

The sandbox leverages the security provided by the particular operating system to allow code execution that cannot make persistent changes to the computer or access information that is confidential. The architecture and exact assurances that the sandbox provides are dependent on the operating system. In Windows for example code cannot perform any form of I O without making a system call. In most system calls Windows performs a security check. The sandbox ensures that the security checks fail for the particular actions that the server process is prohibited from performing as defined in the corresponding policy.

In some embodiments the sandbox relies on the protection provided by operating system mechanisms that can include but are not limited to tokens objects and or integrity levels. These exemplar mechanisms are highly effective at protecting the operating system its configuration and user data. The actual restrictions are configured by the policy which is a programmatic interface that can be called to define the restrictions and allowances of the server process. In some embodiments exemplar mechanisms that control the restrictions include a main token an impersonate token and a job token. Some embodiments further include an integrity level e.g. embodiments including the Windows Vista operating system .

Once the server has been instantiated a series of checks can be executed to ensure that the server is not being executed as a normal process i.e. a non sandboxed process . These checks can include checking the values of one or more tokens that are set by the client. The server can process the one or more tokens and can compare resultant values to expected values. If the resultant values are not equal to the expected values the server is not sandboxed and the server is halted. Another check can include comparing an identification provided by the operating system to an expected identification. If the provided identification is equivalent to the expected identification the server is sandboxed and the client server connection is executed as provided herein.

The key map table and the converter table are data tables and the key map module and the converter module are modules that access the data stored in the respective data tables. The key map table provides data for converting from a pair to a command. Each pair includes an input state and an input event e.g. keyboard event . For example a pair of composition state and space key event is bound to a StartConversion command a pair of conversion and space is bound to SelectNextCandidate command and a pair of conversion and enter is bound to a CommitCurrentCandidate command. The key map module performs such conversions based on the key map table . The converter table is a table for conversion Romaji to Hiragana for example e.g. a to ka to . An exemplar converter table is discussed below with reference to . The converter module performs such conversions based on the converter table .

The session layer handles all stateful tasks and interprets the received key events. More specifically the session layer receives all key events from users and interprets them to commands. Using Japanese as an exemplar language a key event corresponding to the user inputting a is translated to and or also a key event corresponding to the user pressing a space bar space is translated into a conversion command. The converter layer is responsible for all conversion and performs the core functionalities of the IME. The converter module is provides the conversion functionality for converting a query string to a lattice of candidate strings. For example when a query is ainouta a lattice of candidate strings can be provided as . . . see . The storage layer manages dictionary access. The storage layer is the bottom layer and manages various kinds of dictionary data and is immutable. The system dictionary includes sets of a Hiragana key a Japanese word value part of speech etc. Exemplar sets provided by the system dictionary can include ai ai love noun no no particle uta uta song noun. The user dictionary also provides such set but is mutable and modifiable by the user.

As discussed in further detail below an exemplar process implemented in the session layer can include the server layer receiving a key event from the client UI interpreting the event to a command sending a query to the converter layer if necessary receiving results of the query from the converter layer generating rendering information based on the results and sending the rendering information to the client UI. For example and using Japanese as an exemplar language the interpreter module can interpret a key event as an insert character InsertCharacter command to insert a Japanese Hiragana character e.g. in place of a corresponding Romaji character e.g. a .

With particular reference to the session layer can compose a string of Hiragana characters from key events. The string is called a preedit. The preedit is provided to the converter layer as a query that is processed to provide conversion as discussed in further detail below. This conversion can be described by a deterministic finite automaton DFA and a rule. illustrates an exemplar snippet of a DFA in the form of a Romaji to Hiragana converter table and illustrates its corresponding rule .

The exemplar converter table of supports Romaji to Hiragana conversion. For example if a is pressed is inserted. The rule kk includes a pending field. More specifically when rendering information is output to a client the DFA state is reset. However when the pending is specified the current DFA state is written with the pending state. For example if the user inputs kk is first provided to the client and the IME assumes that k is input after that. If the user types kki the output becomes .

Referring now to the converter layer provides the core functionality of the client server IME of the present disclosure. If the interpreter module interprets a subsequent key event as a conversion Convert command to convert a preedit e.g. to one or more corresponding Japanese Kanji characters the preedit is generated at the session layer and is provided as a query to the converter layer . The converter layer processes the preedit and generates one of more results that include word segments. Each word segment is provided as a set of candidates each of which includes a sequence of words. Each candidate includes an associated score and the candidates are listed in a candidate list based on the order of the scores.

As noted above the converter layer includes one or more rewriter modules . The rewriter module performs supplemental processing that can include re ranking candidates based on a user s history e.g. determined from the user history record . The rewriter is called after the main conversion process and after the user has submitted the result. The rewriter module can adjust the main converter s result and can record the candidate selected by the user. Exemplar rewriter routines can include but are not limited to user history learning e.g. adjusting segment boundary and re ranking candidates single Kanji dictionary e.g. adding single Kanji characters to candidates symbol dictionary e.g. adding symbol characters to candidates date e.g. adding a date string to a candidate collocation dictionary e.g. re rank candidates based on word collocation and number e.g. extend number candidates .

User history learning is a particularly useful rewriter routine because it adjusts the converter results based on the user s input history as determined from the user history record . When the user submits a result with either or both of segment boundary modification and candidates of segments the user history learning rewriter records a pair that includes the query and the user s modification. The next time the user inputs the recorded query the rewriter modifies the default boundary and the order of candidates based on the recorded pair. The user history learning rewriter uses a caching algorithm to record the user s history. The caching algorithm can include but is not limited to least recently used LRU .

The storage layer is the bottom layer and manages various kind of immutable dictionary data. The storage layer provides a plurality of dictionary look ups including common prefix match e.g. key abc result a ab abc exact match e.g. key abc result abc and predictive match e.g. key abc result abc abed abcef . . . . The common prefix match is used for normal conversion. The predictive match is namely used for prediction and suggestion and the exact match is used for debugging.

The storage layer supports a plurality of dictionary types that can include but is not limited to TX Darts and User. The TX dictionary is provided as the main dictionary and can be structured by TX using a level order unary degree sequence LOUDS library. The user dictionary is provided as a user registered plain text dictionary.

Embodiments of the present disclosure can employ LOUDS for the data structure of the main dictionary. LOUDS is a data structure algorithm taking advantage of TRIE which is an ordered tree data structure for storing an associative array having keys provided as strings. Using the LOUDS data structure the data is stored as a bit sequence making the data size very compact. The main dictionary includes a key index in LOUDS word attributes in array and word values in LOUDS. The key index points to word attributes and each word attribute either points to the corresponding leaf of the word value or the word attribute has a special bit of transliteration.

Referring now to an exemplar process for establishing a client server IME session is illustrated. The process can be implemented for example in a single computer device using the client server architecture above in which steps can be performed by the operating system steps can be performed on the client side and steps can be performed on the server side.

The process determines whether a client server session is requested . For example the operating system can receive a session request from a client and determine that a client server session has been requested. As discussed above the request can be automatically generated and issued upon instantiation of an IME within a client application e.g. instantiating the IME within a web browser application . If a session has not been requested the process loops back.

If the session has been requested a server executable program e.g. IMEserver.exe can be initiated and one or more tokens is referenced by the server executable program. For example the request can include one or more tokens and the server executable program can reference the tokens. The process determines whether a server can be instantiated within a sandbox based on the referenced tokens . For example the server executable program can process the tokens and if the tokens expected authorization values the can be instantiated within the sandbox. If the server cannot be instantiated within a sandbox the process issues an error and ends. Conversely if the server can be instantiated within a sandbox the process instantiates the server . For example the operating systems continue execution of the server executable program to fully instantiate the server.

The process determines whether the instantiated server is actually sand boxed . By way of non limiting example the server can perform the one or more of the following checks checking the values of one or more tokens that are set by the client and if the values are not equal to expected values the server is not sandboxed comparing an identification provided by the operating system to an expected identification and if the provided identification is equivalent to the expected identification the server is sand boxed. If the server is not sandboxed i.e. the server is operating as a normal process the process issues an error and ends. For example the operating system can issue and error based on a server response to the checks. If the server is sand boxed the process determines the user ID of the user associated with the requesting application . By way of non limiting example the user ID can be provided with the session request.

The process generates a path name for the communications channel between the client and server . For example the server generates the path name as a randomly generated 128 bit path name. The process stores the path name to a user profile that corresponds to the user ID . For example the server can store the path name to a user profile in local memory. In such a case although the server may be sandboxed the policy allows the server to write to local memory. In this manner the client can subsequently access the user profile to determine the path name that was generated by the server. The process issues a session ID SID for the current session and transmits the SID to the client . For example the server issues a unique SID for a session with a particular server and transmits the SID to the server using a connection that is established based on the generated path name.

The session is executed . An exemplar process that can be performed as part of the session execution is described in further detail below with reference to .

The process determines whether the session is to be ended . For example an end session request can be generated on the client side if the user closes client application and or the IME UI within the application. In some implementations the server receives an end session request deletes all resources and or objects allocated for the particular session and the session ends. If the session is not to be ended the process loops back to step . If the session is to be ended the session is terminated and the process ends.

The process determines whether a user input has been detected . For example the client monitors for user inputs e.g. key presses mouse clicks screen touches . If a user input has not been detected the process loops back. If a user input has been detected the process generates a corresponding key event and sends the key event and SID to the server . For example the client generates a key event based on the user input and sends the key event and SID to the server.

At the server the process interprets the key event and determines whether the key event corresponds to a character insert command . If the key event does not correspond to a character insert command the process continues at . If the key event corresponds to a character insert command the process continues at .

If the key event corresponds to a character insert command the process determines a corresponding character based on the key event and generates rendering information . For example the server determines the corresponding character based on the key event and generates the rendering information. The process sends the rendering information to the client . For example the server sends the rendering information to the client over a connection.

The client in response to receiving the rendering information displays the corresponding character on the client display or in an environment associated with the client such as a word processing program and ends.

At the server if the key event does not correspond to a character insert command the process determines whether the key event corresponds to a convert command . If the key event corresponds to a convert command the process continues at . If the key event does not correspond to a convert command the process continues at . At the process determines a preedit based on the key events received from the client device since the last conversion execution. Because the server is stateful the server is aware of the key events and commands for the particular session. The process provides the preedit as a query for conversion generates corresponding rendering information sends the rendering information to the client . The client in response to receiving the rendering information displays the corresponding character on the client display or in an environment associated with the client such as a word processing program and ends.

At if the key event does not correspond to a character insert command another command is indicated. Other commands can include a move cursor command and a text select command. The process processes the indicated command at the server . The processor generates rendering information sends the rendering information to the client . The client in response to receiving the rendering information displays the corresponding character on the client display or in an environment associated with the client such as a word processing program and ends.

An exemplar client server session will now be described. The exemplar client server session is provided as a non limiting illustration of embodiments of the present disclosure. The exemplar client server session includes the following key sequence a i space space and enter . More specifically the client receives an input indicating that a has been input e.g. the a key has been pressed on the keyboard see of . The client generates a key event and transmits the key event and the SID to the server see and of . Upon receiving the key event the session layer interprets the key event to an InsertCharacter command see and of and sends the command with a to the preedit. The preedit converts a Japanese Romaji to Japanese Hiragana . The preedit returns the result a to the session layer. Corresponding rendering information is generated and is transmitted to the client see and of and the client displays to the user see of .

The client receives an input from the user indicating that i has been input e.g. the i key has been pressed on the keyboard and determines a key input is detected see of . The client generates a key event and transmits the key event and the SID to the server see and of . Upon receiving the key event the session layer interprets the key event to an InsertCharacter command see and of and sends the command with i to the preedit. The preedit converts i Japanese Romaji to Japanese Hiragana . Because the server is stateful it is aware that the previous conversion included a to . Consequently the preedit now returns the result ai to the session layer. Corresponding rendering information is generated and is transmitted to the client see and of and the client displays to the user see of .

The client then receives an input from the user indicating that space has been input e.g. the spacebar has been pressed on the keyboard see of . The client generates a key event and transmits the key event and the SID to the server see and of . Upon receiving the key event the session layer interprets the key event to a Convert command see and of . Because the server is stateful the server is aware that the previous character sequence was ai and sends the comment with ai to the converter. The converter converts Japanese Hirigana to Japanese Kanji . The converter returns the result to the session layer see and of . Corresponding rendering information is generated and is transmitted to the client see and of and the client displays to the user see of .

The client then receives an input from the user indicating that space has again been input e.g. the spacebar has been pressed on the keyboard see of . The client generates a key event and transmits the key event and the SID to the server see and of . Upon receiving the key event the session layer interprets the key event to a Convert command see and of . Because the server is stateful the server is aware of the previous conversion from Japanese Hirigana to Japanese Kanji . This information is provided to the converter which determines one or more candidate conversions to Japanese Katakana from Japanese Hirigana . More specifically a candidate list is generated and includes one or more Japanese Katakana candidates that correspond to . In this example the candidate list can include . . . Japanese Kanji Katakana or Hiragana . The candidate list is returned to the session layer and rendering information is generated based thereon see and of . The rendering information is transmitted to the client see of and the client displays the candidate list . . . to the user with the first candidate highlighted or otherwise indicated as the currently selected candidate see of .

To select a different candidate from the candidate list the user can input a key event e.g. depress the down key . In response to the user input the client generates a key event and transmits the key event and the SID to the server see and of . Upon receiving the key event the session layer interprets the key event as a SelectNextCandidate command and processes the command see and of . Corresponding rendering information is generated and is transmitted to the client see and of . The client displays the candidate list . . . to the user with the second candidate highlighted or otherwise indicated as the currently selected candidate see of .

To choose the currently selected candidate from the candidate list the user provides a corresponding input e.g. pressing enter . In response to the user input the client generates a key event and transmits the key event and the SID to the server see and of . Upon receiving the key event the session layer generates a corresponding response for submitting the selected candidate e.g. to the client. The response is received by the client which presents the selected candidate e.g. in the application. If no further text is to be entered or converted the client can send a cancel session message to the server with the SID. In response the server ends the client s session.

Referring now to embodiments of the client server architecture enable the server to be updated without a restarting the client. For example the server can be updated without having to shutdown and restart the client application program that may be communicating with the server. More specifically an update can be executed silently i.e. without alerting the user when a newly connected client has a communication protocol that is compatible with the current server. As a result of the update the current server is halted and a new server is instantiated. In the event that the version of the communication protocol of the client is not compatible with the version of the communication protocol of the new server this condition is detected and the user is prompted.

The new server is installed by an auto update process which is a process that checks for the latest server version and automatically installs it. An infrastructure can be provided to perform this function which infrastructure includes a program to install requested software and keep it up to date. For example an update service can be implemented on a computer device and can request necessary updates from a remote IME support server over an Internet connection. The program can overwrite the current server executable file. In some embodiments the program can rename the current server executable file to a temporary file and install a new server binary to the default server path. In this scenario the current server is running while the executable file is already replaced with a new one.

At time period b it is determined whether the communication protocol of the current client and of the new server are compatible. More specifically the protocol includes a special field for storing a protocol version value. When the new server is initialized the server s protocol version value is stored to a local file. The current client loads the file and checks whether the server s protocol version is the same as the client s protocol version. In some embodiments a table of compatible protocols can be provided and can be implemented to whether the server s protocol version is the same as the client s protocol version.

If the communication protocols are compatible a session is established between the current client and the new server . In this case the server version of the current client is older than the server version of the new server . Accordingly a new server version can be backwards compatible to older server versions. If the communication protocols are not compatible the session between the current client and the new server remains closed and the user is alerted to the error on the client side. For example an alert can be generated instructing the user to restart the particular client application.

With particular reference to an exemplar process for providing a version and protocol check is illustrated. The process of presumes that a current client and a current server are communicating through a current session.

The process determines whether a session has been requested from a new client . For example the operating system can determine whether a client has generated a session request. If a session has not been requested from a new client the process loops back. If a session has been requested for a new client the process determines whether a current server version is older than the new client version . More specifically a special field is provided for storing a server version value. When the current server is initialized the server s version value is also stored to a local file. If the current server version is not older than the new client version the process continues at . For example the operating system can compare the server version values.

If the current server version is older than the new client version the process halts the current server and the current session with the current client ends. For example the operating system can halt the current server. The process instantiates a new server . The process connects the new server and the new client . The process determines whether the current client protocol is compatible with the new server protocol . For example the operating system can determine whether the protocols are compatible.

If the current client protocol is compatible with the new server protocol the process continues at . The process connects the current client to the new server and a session is established therebetween . For example the server generates the path name and issues the SID to the current client. The process processes the current client and new client events using the new server and the ends.

Returning to if the current client protocol is not compatible with the new server protocol the process only processes the new client events using the new server . The process generates an error at the current client and ends. For example the operating system can generate an error at the current client instructing the user to restart the client.

Returning to the process determines whether the new client protocol is compatible with the current server protocol . For example the operating system can compare the protocols. If the new client protocol is compatible with the current server protocol the current client events and the new client events are processed using the current server and the process ends. If the new client protocol is not compatible with the current server protocol an error is issued at the new client . The current client events are processed using the current server and the process ends.

As discussed in detail above the client server IME architecture includes a stateless client that sends each key event to the server and that receives rendering information from the server. If during an input session the server is aborted and rebooted unintended rendering information can be provided to the client. To deal with such scenarios the client server IME of the present disclosure provides for rebooting of an aborted server detecting the reboot of the server and sending a recorded key event sequence to the server to bring the new session current. The key event sequence can be stored for a short period of time. For example the key event sequence can be stored for the lifespan of the current session and then cleared upon ending of the session. As another example the key event sequence can be stored for the lifespan of a connection within the current session. As discussed above the connection can be terminated after the server has transmitted the rendering information corresponding to the last key event sequence to the client.

The client server IME architecture infinite loops caused by sending key event sequence which may repeatedly crash the server and enables such crashing key event sequences to be identified and recorded. For example the server may be caused to crash as a consequence of a particular key event sequence. Upon reboot of the server that same key event sequence could be transmitted back to the newly instantiated server in an effort to bring the state of the new server current to the previous session. However and because the particular key event sequence may be an erroneous key event sequence the new server may also be caused to crash.

Referring now to an exemplar process for reestablishing a client server IME session is illustrated. The process determines whether an event is generated at the client . For example the client can monitor for a key event based on a user input.

If an event is not generated at the client the process loops back. If an event is generated at the client the process records the event in an event sequence . More specifically the client can store the event in an event sequence in a local memory of the device on which the client process executes. The event is transmitted to the server and the process determines whether the server aborted . For example a client an IME support framework or a computer operating system can determine whether the server has stopped functioning.

If the server did not abort the process continues at where rendering information corresponding to the event is received at the client from the server . The process determines whether the session is to be ended . If the session is not to be ended the process loops back to . If the session is to be ended the process ends.

Returning to if the server aborted the process determines whether the abort was a consecutive abort e.g. second third or fourth consecutive abort . For example after each server abort a counter can be incremented by the IME client the IME support framework or the operating system. If the abort was a consecutive abort an error is generated and the process ends. The error can be generated at the client and can be displayed to the user. The error prohibits in infinite loop of servers instantiations and aborts.

If the abort was not a consecutive abort the process instantiates a new server . More specifically the operating system can instantiate a new server as discussed in detail above. The client connects to the new server and the process establishes a new session . The recorded event sequence is transmitted from the client to the new server . Using the event sequence the server can instantiate a session for the client that is at the same state as the previous session for the client when the server aborted. The process then loops back to .

Embodiments of the disclosure and all of the functional operations described in this specification can be implemented in digital electronic circuitry or in computer software firmware or hardware including the structures disclosed in this specification and their structural equivalents or in combinations of one or more of them. Embodiments of the disclosure can be implemented as one or more computer program products i.e. one or more modules of computer program instructions encoded on a computer readable medium for execution by or to control the operation of data processing apparatus. The computer readable medium can be a machine readable storage device a machine readable storage substrate a memory device a composition of matter effecting a machine readable propagated signal or a combination of one or more of them. The term data processing apparatus encompasses all apparatus devices and machines for processing data including by way of example a programmable processor a computer or multiple processors or computers. The apparatus can include in addition to hardware code that creates an execution environment for the computer program in question e.g. code that constitutes processor firmware a protocol stack a database management system an operating system or a combination of one or more of them. A propagated signal is an artificially generated signal e.g. a machine generated electrical optical or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus.

A computer program also known as a program software software application script or code can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data e.g. one or more scripts stored in a markup language document in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code . A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.

The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus can also be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data. Generally a computer will also include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. However a computer need not have such devices. Moreover a computer can be embedded in another device e.g. a mobile telephone a personal digital assistant PDA a mobile audio player a Global Positioning System GPS receiver to name just a few. Computer readable media suitable for storing computer program instructions and data include all forms of non volatile memory media and memory devices including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user embodiments of the disclosure can be implemented on a computer having a display device e.g. a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input.

Embodiments of the disclosure can be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an embodiment of the disclosure or any combination of one or more such back end middleware or front end components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN and a wide area network WAN e.g. the Internet.

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

While this specification contains many specifics these should not be construed as limitations on the scope of the disclosure or of what may be claimed but rather as descriptions of features specific to particular embodiments of the disclosure. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover although features may be described above as acting in certain combinations and even initially claimed as such one or more features from a claimed combination can in some cases be excised from the combination and the claimed combination may be directed to a subcombination or variation of a subcombination.

Similarly while operations are depicted in the drawings in a particular order this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order or that all illustrated operations be performed to achieve desirable results. In certain circumstances multitasking and parallel processing may be advantageous. Moreover the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.

A number of embodiments of the present disclosure have been described. Nevertheless it will be understood that various modifications may be made without departing from the spirit and scope of the present disclosure. Accordingly other embodiments are within the scope of the following claims.

