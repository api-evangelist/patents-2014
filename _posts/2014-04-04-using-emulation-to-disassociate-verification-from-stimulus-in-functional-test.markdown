---

title: Using emulation to disassociate verification from stimulus in functional test
abstract: Techniques for using emulation to disassociate verification from stimulus in functional test are described. In one approach, a computer stores first data representing an initial state of an application and second data representing the same initial state of a model application, wherein the model application models expected behavior of the application. The computer selects actions for the application to perform and causes both the application and the model application to perform the actions. The computer updates the first and second data to represent the state of both the application and the model application after performing the actions. The computer then compares the first and second data to determine whether both refer to the same state. In response to a determination that the first data and the second data do not refer to the same state, the computer stores data indicating a test failure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09329985&OS=09329985&RS=09329985
owner: XOOM CORPORATION
number: 09329985
owner_city: San Francisco
owner_country: US
publication_date: 20140404
---
The present disclosure generally relates to computer implemented software testing and relates more particularly to computer implemented techniques for using emulation to disassociate verification from stimulus in functional test operations.

The approaches described in this section are approaches that could be pursued but not necessarily approaches that have been previously conceived or pursued. Therefore unless otherwise indicated it should not be assumed that any of the approaches described in this section qualify as prior art merely by virtue of their inclusion in this section.

Traditional software testing is constrained in its efficacy maintainability and modularity by the coupling of the test traversal steps with the expected behavior and checks performed on the system under test. For example the test cases may be hard coded to perform a select number of handcrafted scenarios which if performed successfully would indicate that the system is working properly. However for any sufficiently large software project even the best attempt at crafting varied and thorough test cases will fail to catch every edge case to which the software will eventually be subjected. Thus traditional testing misses cases which the testers did not anticipate as potentially causing the system to exhibit unexpected behavior or did not think to check. Consequently software is often released to the public with programming errors which should have been caught during the quality assurance stage of software development.

Due to the foregoing there is a need in the industry for a randomized testing methodology that is randomized over either or both flow and data. Because randomized tests cannot be expressed or represented before execution as a series of actions and data and their associated expected outcomes because actions and data are not pre determined a randomized test flow necessitates a software testing methodology that can separate test steps or stimulus from the checks performed on the system under test. By separating test stimulus from checks stimulus may be selected randomly during the test progression and checks may be invoked and performed in response to the steps selected. In this way since a randomized test generated by a system with separated stimulus and emulation checking tests an arbitrarily lengthy complex and interesting set of scenarios generated on the fly the test bypasses the limitations of premeditated case generation and checks every possible element of the system at each step of the test. As test writers will never premeditate all interesting cases and thousands of checks can never practically be programmed into every test by hand efficacy and power of software testing can be significantly increased.

In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.

In an approach in order to separate stimulus from emulation a context object is used and instantiated twice in two forms. The first form is the Actual context object and the second form is the Model context object. Each context object represents the current design context under test. Each context object is aware of the functional elements within that context the constraints on the functional elements how the functional elements are accessed and how the constraints interact with the functional elements. For example a given web or application page may be a context and represented by a context object. In this case the buttons and functionality within the page could be considered the functional elements contained within the context object.

The distinct instantiations of the Actual context object and the Model context object allow the separation of concerns between stimulus and checking. The Actual context object is used to perform actions on the actual or stimulus context under test. For example in the case of a web page the Actual context may call or perform actions on the actual web page itself. The resulting state of the Actual context object is updated to reflect the actual result observed. As a result the Actual context object represents the state of the actual context under test when subjected to the stimulus. In parallel the same set of actions is performed against the Model page object. However the resulting state of the Model context object is derived from emulation of the context s cascading expected correct behavior in response to stimulus. For example the emulation may update the state of the Model context object to indicate how the state theoretically should appear after being subjected to the stimulus. After each action that is performed in parallel on the Actual and Model objects the states of the Actual and Model objects are then compared. Any difference represents a test failure. Furthermore in addition to the comparison checks additional absolute checks may be performed on the Actual context object at any functional juncture regardless of the test state. For example if a field in a web page is only valid for a certain range of values the field being set to an invalid value may result in a test failure regardless of whether or not the comparison test is performed.

In some embodiments context objects make random flow and data selection during the test by referencing an independent Weighted Constraint Driver. For example the Weighted Constraint Driver may be a class that is compiled on the fly prior to each test session that provides randomized values for the context objects to use during the test. In some embodiments the Weighted Constraint Driver provides randomized values according to a custom grammar configured to associate values and weights with labels which the context object can request. For example the grammar may specify that for the label Country the potential values are USA with a 50 probability Canada with a 30 probability and Mexico with a 20 probability. Thus if the context object requests a value for the label Country the Weighted Constraint would respond by returning one of the values based on the aforementioned distribution. Similarly the grammar may specify potential actions that can be taken within the given context and the probability of performing each action during the test. Thus the flow and data of a test can be determined by the relative weights and values specified in the weighted constraint grammar. In some embodiments the Weighted Constraint Driver selects values based on a random numbered generator initialized with a value referred to as a seed . Thus given the same series of requests and the same seed the Weighted Constraint Driver produces the same outputs. One situation in which using the same seed is useful is to repeat tests after the subject has been updated to resolve failures discovered during previous tests to determine if the debugging was successful. Another situation in which using the same seed is useful is to repeat test failures to instrument the failed code to gain more information about the failure. On the other hand if the seed value is changed a different test can be generated based on the same series of requests to try to discover test failures which may not have been generated by previous seed values. In this way a seed based test reproduction approach is useful to easily generate a different test with different random data and or flow decisions by using the same code and varying only the seed value in the new test run.

In an embodiment a method comprises storing first data representing an initial state of an application to be tested and second data representing the same initial state of a model application wherein the model application models expected behavior of the application to be tested selecting one or more actions for the application to perform causing the application to perform the one or more actions and updating the first data to represent a state of the application that results from the application performing the one or more actions causing the model application to perform the one or more actions and updating the second data to represent a state of the model application that results from the model application performing the one or more actions comparing the first data and the second data to determine whether the first data and the second data refers to a same state in response to a determination that the first data and the second data do not refer to the same state storing data indicating a test failure wherein the method is performed by one or more computing devices.

In an embodiment the method further comprising storing data representing a set of potential actions that the application can perform wherein selecting the one or more actions for the application to perform involves randomly selecting the one or more actions from the set of potential actions.

In an embodiment the method further comprises storing data representing a set of potential initial states of the application and randomly selecting the initial state of the application from the set of potential initial states.

In an embodiment at least a particular action of the one or more actions requires one or more input values and further comprising storing data representing a set of potential input values for the particular action and randomly selecting the one or more input values to use for the particular action from the set of potential input values.

In an embodiment the method further comprises storing a constraint specification which specifies for one or more labels a set of values for each of the one or more labels and selection data indicating a likelihood that each value of the set of values will be selected and wherein at least one of the randomly selecting the one or more actions randomly selecting the initial state or randomly selecting the one or more input values involves requesting one or more values for a particular label and randomly selecting the one or more values from among the set of values for the particular label based on the selection data.

In an embodiment the application to be tested is a web site and the initial state of the application represents a state of an initially accessed web page of the web site.

In an embodiment the first data and the second data specify one or more widgets contained in the initially accessed web page.

In an embodiment causing the application to perform the one or more actions involves accessing a browser loaded with the initially accessed website via an application programming interface and instructing the browser to perform the one or more actions on the initially accessed website.

In an embodiment updating the first data involves scanning the initially accessed website via the browser and updating the first data to represent any changes to elements of the initially accessed website that occurred due to performing the one or more actions on the initially accessed website.

In an embodiment the method further comprises in response to a determination that the first data and the second data do refer to the same state selecting a second one or more actions for the application to perform.

In other embodiments the invention encompasses a system computer apparatus and a computer readable medium configured to carry out the foregoing steps.

For brevity certain components such as the application test platform or weighted constraint platform may be described as performing an action such as invoking other components manipulating data and so forth. However in some implementations such as when the components are implemented as executable code the aforementioned performance should be understood as shorthand for one or more processors of the computer performing the action in response to executing the code. For example in the case where the application represents a web site a browser or test emulator loading a page from the web site may be described as clicking a widget but in actuality it is the computer running the browser which performs the aforementioned action.

In an embodiment computer comprises an individual computing device such as personal computer workstation laptop netbook tablet computer or smartphone. For example the computer may implement any or all of the components described below in the Hardware Overview .

In an embodiment memory represents one or more storage devices for example RAM solid state drives RAIDs etc. upon which the application under test test platform and constraint platform are stored for access by the computer .

In an embodiment the application represents a software module that will be tested. For example the application may represent a software application a service a web server program a web site a database program or any other type of software program. The exact context of the application is not critical to the techniques described herein. In an embodiment the test platform interacts with the application by utilizing an inter process communication mechanism such as an Application Programming Interface API to cause the application to perform one or more specified actions which will be monitored during the testing process. In other embodiments the test platform may interact with the application through an intermediary. For example the application may be a web site which is accessed and manipulated by a web browser which is controlled by the test platform through an API or other communication mechanism. In other embodiments the application represents specialized hardware components or a combination of hardware and software components. For the purpose of illustrating clear examples the following descriptions will assume that the testing is in the context of ensuring the proper functionality of a web site. However while testing a web site is used as a representative example the techniques described herein are not limited to the context of testing a website.

In an embodiment the test platform represents a software module that drives the testing of the application . In some embodiments the test platform comprises instructions or code which drives the test. However in other embodiments the test platform may comprise specialized hardware components or a combination of software and hardware components which are configured to perform the test. For the purpose of illustrating clear examples it will be assumed that the test platform is implemented by code structured according to the principles of object oriented programming. Thus the structure of the test platform will be described with references to multiple classes each representing a particular concept and interrelated through association inheritance or any other object oriented structural concept. In such embodiments the classes of the test platform may be written in any number of one or more object oriented programming languages such as Java C Ruby Python C and so forth. However the exact language used to code the test platform is not critical to the techniques described herein. In embodiments which are implemented in hardware or through a combination of hardware and software each class or combination of classes may be represented by hardware components which perform the same functions.

In an embodiment the test platform performs the test by maintaining a context object which represents the state of both the actual application the actual context object under test and a model of the application the model context object which represents the expected behavior. The test platform then chooses an action that the application will perform and causes both the actual application and a model of the application to perform the chosen action. The test platform then determines whether the action resulted in any differences between the actual application and the model which would indicate a test failure. For example in the context of testing a web page the test platform may perform the action on the actual web page via API calls to a browser and perform the same action on the model representation of the web page using instructions which simulate how the web page should perform in response to the action. The test platform then compares the states of the actual web page and the model. For instance the test platform may determine that the information fields widgets frames or other information displayed by the web site have been set to the correct values and is consistent between the actual and model representations. For the purpose of the following discussion a widget refers to an element of a page that is configured to be interacted with by a user to supply input. Thus state as used in the context of testing a web site may represent one or more features of the active web page. However in other embodiments state may also include features of the web page or web site that are not explicitly displayed by the browser such as cookies or other information that is not typically displayed.

In an embodiment the weighted constraint platform comprises a weighted constraint compiler and a constraint specification . In an embodiment the weighted constraint compiler represents instructions configured to translate a constraint specification into one or more classes that can be utilized by the test platform to generate random values during the testing of the application . For example if the test platform represents a collection of Java class files the weighted constraint compiler may transform the constraint specification into a collection of Java classes or a jar package which can be incorporated into the test platform to provide randomized values. In an embodiment the constraint specification is a document which defines potential values and the likelihood that a potential value will be chosen referred to as a weight when the test platform performs a decision relating to the value of a variable a starting state to begin the test and or the actions performed at various junctures during the test. For example the constraint specification may be established to mimic the distribution of values that is expected to be input by users of the application under test or may be configured to test edge cases that would rarely be encountered in practice. Thus for instance if the test platform decides to perform an action which requires a Country field to be filled out the constraint specification may define the probability with which each country will be selected and the code generated by the weighted constraint compiler may be a class method function module or other construct that returns a country value to the test platform based on the specified probabilities. In other embodiments rather than relying on a static constraint specification the constraint compiler may periodically obtain updated metrics from a metric server which tracks the aforementioned information dynamically and regenerates the code used to supply metrics to the test platform to keep the tests up to date. The weighted constraint compiler and the constraint specification will be described in more detail below in the Weighted Constraint Overview . In other embodiments the weighted constraint platform may be implemented by specialized hardware components or a combination of software and hardware components.

The classes illustrated in and assume that the test platform is being used in the context of testing a web site. Since a web site often comprises many different web pages the class structure may contain a generic page class which is inherited by multiple specialized classes representing individual web pages SignUpPage class LoginPage class and so forth of the website. However for the sake of brevity the class structure will be described in relation to the generic classes which may be specialized through techniques such as inheritance to include the features and functionality of specific pages.

In reference to the page class represents the structure of a particular web page. Thus the page class defines the elements such as the fields information boxes widgets and so forth that are displayed when the web page is interpreted by a browser. The page class inherits the page element container class which defines the data structure used to store and access the individual elements of the page. For example the page element container class may define an array linked list or other data structure which organizes and stores the elements of the page and functions providing access to the aforementioned data structure.

In the page element class defines the individual page elements. The page element class may be inherited by specialized classes which represent the state and functionality of specific page elements such as a clickable button a field for entering information a dropdown menu radio selection buttons and so forth. For example the page element class may model the state of a dropdown menu by defining the options presented in the dropdown menu and storing a reference indicating the currently selected option. The page element class contains one or more instantiations of the action class which defines the specific actions that may be taken with regard to the particular page element. For example a dropdown menu may contain a select N action which selects the Nth option in the menu a field may contain a type in text action for filling in the field and so forth. In some embodiments the action class in addition to defining the functionality of a particular page also specifies the cascading behavior of actions performed on the page element. For example a button that is part of an accordion of data elements may cause the accordion to open close but also cause changes to other widgets such as causing certain fields to be added or removed from the page.

In other embodiments the page class may be substituted for a class pertaining to the state of an alternative context. For example the alternative context may be the testing of a database mining application which monitors user signups to a particular website. Thus the page class may be replaced with a class that identifies the structure of the database utilized by the database mining application. Consequently other classes such as the page element container class and the page element class may be substituted to define context specific data types such as individual tables database objects records etc. Thus one skilled in the art would recognize how to apply the structure described herein to testing performed in virtually any context.

In some embodiments the page under test may be utilized in multiple sub contexts. For example the page may be displayed differently depending on the type of browser or platform used to access the page. As another example the website may support both traditional web pages along with specialized display screens for mobile devices. As a result the page class may be inherited by specialized classes within the class structure which pertain to each sub context. For example if the test context includes both webpages and mobile application display screens the test platform may include a specialized class for each which directly or indirectly inherits the page class and defines the unique functionality and testing models for their respective contexts. Furthermore other classes in the class structure may also be modified in the same fashion to account for the functionality of the application in the different sub contexts.

In an embodiment the page class is inherited by the actual page class and the model page class . The actual page class represents the state and functionality of the actual page being tested. An implementation of the actual page class may invoke the actual page being tested for instance via an API a browser or simulation program to perform a requested action and track how the actual page changed as a result of that action. For example if the selected action is to click a button the actual page class may make an API call to a browser to perform the action on the page and then perform another API call to extract the browser s new state and update the state of the actual page class accordingly. The model page class represents the state and functionality of the model page intended to simulate the expected behavior of the page being tested. Thus an implementation of the model page class may contain test code which simulates how the actual page under test should function when performing the action.

For example the page class may define an interface which specifies the elements that a particular page contains. The actual page class and the model page class inherit the interface and implement the functionality of the page elements. The actual page class implements the functionality by invoking the application and tracking the state of the actual page. The model page class implements the functionality using model test code that simulates the expected behavior of the action. For example assuming the action is to click a button the model page class may manipulate the appropriate data structures to simulate the expected state after the button is clicked. The actual page class on the other hand would apply the stimuli to the actual page determine the changes which occurred on the actual page and update the data structures accordingly. The bifurcation of the page class into actual page class and model page class allows for parallel stimulus of actual and model pages and the separation of concern between stimulus and emulation checking. Taken together the actual page class and model page class along with the inherited and or associated classes constitute a context object representing the testing state. In another embodiment the actual and model classes may be the same class containing the required functionality for both model and actual behaviors. For example the class may have one or more instantiations configured at run time for actual behavior and the others configured at run time for model behavior.

For organizational purposes the aforementioned actions may be implemented in the class structure by using the same bifurcation for each page element resulting in an actual page element class and a model page element class . Similar bifurcation may also be performed for other classes in the class structure such as the page element container class . Thus the actual page class stores objects of the actual page element class in the data structure inherited from the page element container class and the model page class stores objects of the model page element class within its respective data structure.

In an embodiment the action class implementation of the actual page element class contains the instructions which invoke the actual page to perform the action and the action class implementation of the model page element class contains instructions which simulate the expected behavior of the action. For example in the case selecting an item from a dropdown menu which causes the web page to update a text box the implementation of the action for the actual page element class may invoke an API of a browser which has the page loaded to cause the browser to select the menu item. The test platform then scans the webpage and updates the data structures in the actual page class associated with any elements which have changed. If the action was performed correctly the data structure representing the text box will be updated with the correct text. If the application under test did not perform the action correctly it updates its state regardless according to the incorrect action. The implementation for the model page element class simulates the performance of the action and may perform the action by executing instructions which modify the data structure representing the text box to contain the expected text. In other words the model page element class updates the state of the model page to result in what the state should be after the action is performed whereas the actual page element class determines the state of the page based on what is actually performed on the page under test. As a result the test platform is able to compare the data structures representing the states of the elements of the actual and model page to check for discrepancies.

In an embodiment the test class represents the driver that runs the test. In an embodiment the test class invokes the weighted constraint class to determine a starting page for the test. The weighted constraint class returns data specifying the page where the test should begin. The test class then creates an instantiation of the page controller class for the starting page and repeatedly instructs the page controller class to perform one or more actions on the page. The page object data class defines the actions that can be performed on any given page and the probabilities with which those actions are taken. The page controller class instantiates a context object for the starting page determines an action via a request to the page object data class and causes both the actual and model page to perform the action. In some embodiments the actions defined by the page controller class may be individual actions taken on particular widgets or collections of actions that perform a related function. For example for a signup page the SignUp action may perform multiple separate actions such as filling in the appropriate fields name address screen name password etc. clicking a submit button updating one or more widgets and so forth which are defined in the action class for the individual widgets. In an embodiment the page controller class as a result of performing an action returns a reference of the page controller class for the current page of the website to the test class . For example if performing a particular action changes the page of the website that is being displayed the page controller class may instantiate a page controller object for the new page and return that object to the test class . As a result the test class begins sending instructions to the new page controller class to perform an action for testing. Otherwise the page controller class returns a reference to itself and the test continues with the same page. In some embodiments the resources required to maintain the old page controller instantiation may be released by the computer when the test switches to a new web page.

In an embodiment the weighted constraint class and the page object data class are produced by the weighted constraint compiler to provide flow and data decisions to any requesting agent or component. In an embodiment the weighted constraint class acts as a randomization engine for supplying random values and the page object data class acts as a wrapper around the weighted constraint class . However since the page object data class is a structure used to simplify the organization of the class structure other embodiments may omit the wrapper class and use only the weighted constraint class instead.

The classes produced by the weighted constraint compiler are used by the test platform to acquire constrained random values such as strings Booleans integers etc. to use as input to actions which will be tested on the application under test or to select the next action to perform during the test. In an embodiment the constraint specification is a document which specifies one or more labels one or more potential values or value ranges for each label and the probability weight with which each of the potential values will be chosen for the label.

For example a portion of the constraint specification defining random string values may appear as follows 

which means that the label EmailDomain can be one of three potential values gmail.com with a weight of 3 yahoo.com with a weight of 4 or hotmail.com with a weight of 2. Thus when the weighted constraint class generated based on the example specification is asked for a value relating to an email domain the weighted constraint class will return one of the aforementioned values with a probability based on the value s associated weight. For example the weighted constraint class may return gmail.com 3 out of 9 times yahoo.com 4 out of 9 times and gmail.com 2 out of 9 times individual weight divided by total weight . In an embodiment if a weight is omitted for a potential value in the constraint specification the weight is assumed to be 1.

As another example a portion of the constraint specification defining random integers may appear as follows 

which means that the value of the label SendAmount will be randomly selected from the range of 1 49 with a weight of 1 or randomly selected from the range of 50 2999 with a weight of 49. Thus 1 out of 50 times the weighted constraint class will return a value between 1 and 49 and 49 out of 50 times the weighted constraint class will return a value between 50 and 2999.

In an embodiment the labels and their associated values are structured in the weighted constraint class as a playlist . For example the playlist for the label EmailDomain described above may consist of nine slots the sum of the weights where gmail.com occupies three of the slots yahoo.com occupies four of the slots and hotmail.com occupies two of the slots. A constrained value is selected from the playlist by choosing a random slot within the playlist and returning the value associated with the chosen slot. In some embodiments the function used by the weighted constraint class to determine the random slot is based on random number generator seeded with an initial value the seed . In some embodiments the weighted constraint compiler is configured to produce a weighted constraint class that uses the received seed value as the seed for the aforementioned random number generator. As a result the values produced during a given test can be reproduced by reusing the same seed value . For example after testing has discovered a bug within the application the application developers may wish to debug the application and run the same exact test on the new version to determine whether the bug has been fixed.

In an embodiment the weighted constraint compiler is executed by the computer before compiling and running the test platform . For example certain modern build tools such as Maven and Gradle in the context of Java apply the notion of a software build lifecycle. When a software project is built with this type of tool the tool performs the compilation process in a well defined order. For example when invoking the build the tool may execute the weighted constraint compiler to produce the classes for the test platform compile the test platform and then run the tests.

In some embodiments the weighted constraint compiler comprises a lexical analyzer and parser which ensure that the constraint specification adheres to a particular grammar. For example tools such as ANTLR for Java can be used to automatically generate code that will parse and perform lexical analysis on the constraint specification based on a grammar file.

In some embodiments the weighted constraint class and the page controller class are configured to take advantage of reflection to facilitate the performance of randomized actions. Reflection is the ability of a computer program to examine and modify the structure and behavior of an object at runtime. For example in the context of Java reflectivity may be implemented using Java Annotations to add syntactic metadata to be added to source code. As described above the test class which constitutes the logical main entry point for the test will request a starting page from the weighted constraint compiler . The constraint specification corresponding to the request may be in the form 

Thus the SignUpPageController is annotated with the name SignUpPage . At runtime the test class can query for an object which corresponds to the class whose name attribute is SignUpPage . Furthermore when page controller class invokes the page object data class to determine which action to perform reflectivity can be used again to translate the returned value of the label into the method corresponding with the returned action. For example the signUp method is annotated the name attribute SignUp and can be referenced in the constraint specification by that value. As a result by utilizing reflectivity the test platform can properly translate the values returned by the weighted constraint class without the weighted constraint platform even being aware of the actual names of the classes and interfaces in the test platform . However the use of reflectivity to select randomized starting pages and actions does not necessarily need to be performed via reflection and instead the weighted constraint platform may be hardcoded with the classes interface names of the page controller class .

For the following example it will be assumed that the computer performs the steps via executing instructions represented by test platform . Furthermore it will be assumed that the weighted constraint compiler has already been invoked to transform the constraint specification into the weighted constraint class and page object data class for use by the test platform . For brevity the steps will be described as being performed by the corresponding classes of the test platform which provide the instructions for performing said steps according the example embodiment. However in a practical environment many of the steps may in fact be performed by objects instantiated from specialized classes which derive from generic classes depicted in and and implement the particular functionality for a given context such as a particular web page.

At step the test class selects a random page controller representing the starting page of the test. In an embodiment the test class selects a weighted random page controller by requesting a starting page from the weighted constraint class which returns data identifying the starting page. The test class then instantiates an object of the page controller class corresponding to the starting page. For example the test class may request a random starting page from the weighted constraint class and instantiate a page controller according to any of the techniques described above in Section 4.0 Weighted Constraint Overview.

At step the test class invokes the page controller class for the selected page and instructs the page controller class to perform a randomized action. In an embodiment the page controller class maintains a function or method which when invoked causes the page controller class to select and perform a randomized action.

At step the page controller class selects a randomized action to perform on the starting page. In an embodiment the page controller class selects a randomized action by invoking the page object data class and receiving a randomized value which corresponds to an action to perform. Furthermore in the event that the selected action requires one or more inputs the page controller class makes additional requests to the page object data class to select randomized values for those inputs. For example the page controller class may obtain randomized actions and input values from the page object data class according to any of the techniques described above in Section 4.0 Weighted Constraint Overview.

At step the page controller class invokes the actual page class to perform the selected action. For example the page controller class may create an instantiation of the actual page class for the corresponding page and invoke a method or function which corresponds to the selected action. In some cases the action selected by the page controller class may involve multiple sub actions. In such cases the page controller class may invoke the actual page class separately for each individual sub action. For example if the action involves filing out a field then selecting a submit widget the page controller class may invoke the method or function corresponding to filing out the field then invoke the method or function corresponding to selecting the submit widget.

At step the actual page class performs the action on the actual page under test. In an embodiment the actual page controller class causes the action to be performed on the actual page under test via a communication mechanism such as an API. For example if the action involves clicking a button the actual page class may invoke the action class of the actual page element class corresponding to the button. The action class may then respond by calling a browser or simulated browser through an API which causes the application to perform the action.

At step the actual page class updates the data structures corresponding to changes resulting from the action. In an embodiment the actual page class scans the application to determine which page elements have been modified removed or added as a result of performing the action. The actual page class then updates the data structures representing the state of the page. For instance the actual page class may update the instantiations of the page container class and or page element class classes to reflect the current state of the application under test. In some cases the performance of the action may cause the application to update to a new page. For instance performing the action of clicking a link may cause the browser to load a new page. In such events the actual page class returns data to the page controller class identifying the new page.

At step the page controller class invokes the model page class to perform the selected action on a model of page. For example the page controller class may create an instantiation of the model page class for the corresponding page and invoke a method or function which corresponds to the selected action. In some cases the action selected by the page controller class may involve multiple sub actions. In such cases the page controller class may invoke the actual page class separately for each individual sub action.

At step the model page class performs the action on a model of the page. In an embodiment the model page class includes test code which represents the expected behavior of the page after each action is performed. For example the test code may directly update the data structures representing the affected page elements to how the state of the page should appear after the action is performed.

At step the model page class performs any cascading actions that result from the performance of the action selected by the page controller class . In an embodiment performance of certain types of actions may trigger additional actions affecting the state of the page. For example the selection of an expand button of an accordion widget may cause additional fields or widgets to appear. As a result at step the model page class updates the instantiation of the page element container class to add or remove page elements accordingly. In some cases performance of an action may cause the application to switch to a new page. In such cases the model page class returns data to the page controller class identifying the new page.

At step the page controller class compares the states of the actual page class and the model page class . In an embodiment the page controller class scans the page elements contained in the page element container class of both representations and determines if there are any differences. For example the page controller class may determine whether both representations contain the same page elements and or whether the data structures of the page elements indicate that the state is equivalent. As another example the page controller class may determine whether the action caused both representations application to resolve to the same page. In some embodiments any difference represents a test failure which causes the test platform to record the differences for later review and analysis. In other embodiments the page controller class may be configured to produce a failure only on certain conditions such as the difference is the value of a field of a page element between the actual and model representations differing by a threshold amount. In addition to the comparison test the page controller class may perform other error checking functions at step as well. For example the page controller class may determine if the actual or model representation sets a field to an invalid value and if so trigger a test failure. As another example the test may check the actual vs. model representation of application or other persisted e.g. database state to determine if they differ and if so trigger a test failure. In an embodiment in the event that both the actual page class and model page class interpret the action as loading a new page the page controller class instantiates a new page controller for the new page and returns that instantiation to the test class . Otherwise the page controller class returns a reference to itself.

In an embodiment if the test has not failed by the end of step control returns to the test class which performs another test iteration by restarting at step . For example the test class may be configured to perform a specific number of iterations run for a specified length of time run until test failure or run until a different condition has been fulfilled.

According to one embodiment the techniques described herein are implemented by one or more special purpose computing devices. The special purpose computing devices may be hard wired to perform the techniques or may include digital electronic devices such as one or more application specific integrated circuits ASICs or field programmable gate arrays FPGAs that are persistently programmed to perform the techniques or may include one or more general purpose hardware processors programmed to perform the techniques pursuant to program instructions in firmware memory other storage or a combination. Such special purpose computing devices may also combine custom hard wired logic ASICs or FPGAs with custom programming to accomplish the techniques. The special purpose computing devices may be desktop computer systems portable computer systems handheld devices networking devices or any other device that incorporates hard wired and or program logic to implement the techniques.

For example is a block diagram that illustrates a computer system upon which an embodiment of the invention may be implemented. Computer system includes a bus or other communication mechanism for communicating information and a hardware processor coupled with bus for processing information. Hardware processor may be for example a general purpose microprocessor.

Computer system also includes a main memory such as a random access memory RAM or other dynamic storage device coupled to bus for storing information and instructions to be executed by processor . Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor . Such instructions when stored in non transitory storage media accessible to processor render computer system into a special purpose machine that is customized to perform the operations specified in the instructions.

Computer system further includes a read only memory ROM or other static storage device coupled to bus for storing static information and instructions for processor . A storage device such as a magnetic disk or optical disk is provided and coupled to bus for storing information and instructions.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis for example x and a second axis for example y that allows the device to specify positions in a plane.

Computer system may implement the techniques described herein using customized hard wired logic one or more ASICs or FPGAs firmware and or program logic which in combination with the computer system causes or programs computer system to be a special purpose machine. According to one embodiment the techniques herein are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another storage medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions.

The term storage media as used herein refers to any non transitory media that store data and or instructions that cause a machine to operation in a specific fashion. Such storage media may comprise non volatile media and or volatile media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Common forms of storage media include for example a floppy disk a flexible disk hard disk solid state drive magnetic tape or any other magnetic data storage medium a CD ROM any other optical data storage medium any physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM NVRAM any other memory chip or cartridge.

Storage media is distinct from but may be used in conjunction with transmission media. Transmission media participates in transferring information between storage media. For example transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infra red data communications.

Various forms of media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk or solid state drive of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infra red transmitter to convert the data to an infra red signal. An infra red detector can receive the data carried in the infra red signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card cable modem satellite modem or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are example forms of transmission media.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution.

In the foregoing specification embodiments of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. The sole and exclusive indicator of the scope of the invention and what is intended by the applicants to be the scope of the invention is the literal and equivalent scope of the set of claims that issue from this application in the specific form in which such claims issue including any subsequent correction.

In the foregoing specification embodiments of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. Thus the sole and exclusive indicator of what is the invention and is intended by the applicants to be the invention is the set of claims that issue from this application in the specific form in which such claims issue including any subsequent correction. Any definitions expressly set forth herein for terms contained in such claims shall govern the meaning of such terms as used in the claims. Hence no limitation element property feature advantage or attribute that is not expressly recited in a claim should limit the scope of such claim in any way. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

