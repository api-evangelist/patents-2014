---

title: Programmable device, hierarchical parallel machines, and methods for providing state information
abstract: Programmable devices, hierarchical parallel machines and methods for providing state information are described. In one such programmable device, programmable elements are provided. The programmable elements are configured to implement one or more finite state machines. The programmable elements are configured to receive an N-digit input and provide a M-digit output as a function of the N-digit input. The M-digit output includes state information from less than all of the programmable elements. Other programmable devices, hierarchical parallel machines and methods are also disclosed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09519860&OS=09519860&RS=09519860
owner: Micron Technology, Inc.
number: 09519860
owner_city: Boise
owner_country: US
publication_date: 20140602
---
This patent application is a divisional of U.S. application Ser. No. 13 037 706 filed Mar. 1 2011 which claims the benefit of priority under 35 U.S.C. Section 119 e to U.S. Provisional Patent Application Ser. No. 61 353 551 filed on Jun. 10 2010 all of which are hereby incorporated by reference herein in their entirety.

One example of a programmable device is a parallel machine. Parallel machines include for example finite state machines FSM engines and field programmable gate arrays FPGAs . A FSM is a representation of state transitions between states and actions. Finite state machines can be expressed in the form of directed flow graphs. They can be used to solve problems in for example engineering pattern recognition biology and artificial intelligence.

The following description and the drawings sufficiently illustrate specific embodiments to enable those skilled in the art to practice them. Other embodiments may incorporate structural logical electrical process and other changes. Portions and features of some embodiments may be included in or substituted for those of other embodiments.

This document describes among other things a hierarchical parallel machine such as a hierarchical finite state machine HFSM engine and related methods. One such hierarchical parallel machine is shown in . Each hierarchical parallel machine includes two or more parallel machines such as two or more finite state machine FSM engines . Each finite state machine engine is a device that receives and reacts to data e.g. a data stream on an input bus and provides e.g. generates an output as a function of the received data.

Each finite state machine engine may be arbitrarily complex. In one embodiment such as is shown in finite state machine engines are cascaded with an output e.g. state of at least one of the finite state machine engines provided e.g. passed in whole or in part to one or more of the finite state machine engines downstream in the cascade. In an example the last finite state machine engine in the cascade generates a result which can be provided on an output bus such as results bus . In one embodiment each of the finite state machine engines can be programmed via a respective program bus such as by for example loading e.g. storing a program e.g. an image onto a finite state machine engine using the program bus .

In some embodiments it may be important to reduce the time needed to process data with the HPRP . The time to process data with the HPRP may be limited at least in part by the amount of data e.g. state information such as a state vector passed between finite state machine engines . In some such embodiments the finite state machine engines are connected in a hierarchical configuration and the interface between finite state machine engines can be designed to approximate real time operation. Among other things this document describes such considerations and suggests a general method for physical implementation of a hierarchical set of parallel machines such as a hierarchical set of FSM engines .

In one example embodiment a Hierarchical Pattern Recognition Processor HPRP is implemented as shown in . A Pattern Recognition Processor is a device that receives data e.g. a sequence of symbols and generates an output that provides some type of notification when a sequence s of interest is recognized e.g. detected . In a simple case a single stream of input symbols is provided to HPRP on an input bus . The HPRP is programmed to detect a specific sequence or specific sequences of input symbols via program bus ses . Results detected sequences are generated and can be provided on results bus . Logical interfaces Program Interface and Data Input of the HPRP are shown in .

In the embodiment shown HPRP might include two or more finite state machine engines programmed as Pattern Recognition Processors PRP . Each PRP is a device that is capable of detecting a sequence s of symbols in a respective data stream such as a data stream on either input bus or input bus . For example each PRP can be capable of matching a respective pattern in a respective data stream. In the illustrated embodiment the second PRP receives as its input an output of the first PRP as provided on output bus and generates a result on results bus . In one embodiment each of the PRPs can be programmed via a respective program bus . An example PRP is described below with reference to also referred to as a content inspection processor . In certain examples the HPRP is implemented using a finite state machine FSM engine or a field programmable gate array FPGA or variations thereof or another implementation of a parallel machine.

The two level e.g. stage hierarchy of hierarchical parallel machines and allows two independent programs to operate based on the same data stream. The two level hierarchy can be similar to visual recognition in the human brain that is modeled as different regions. Under this model the regions are effectively different pattern recognition processors each performing a similar computational function detecting a sequence of symbols in a data stream but using different programs e.g. signatures . By connecting multiple parallel machines together deeper knowledge about the data stream may be obtained.

A first level of the hierarchy such as one implemented by the first FSM engine or first PRP can perform processing directly on a raw data stream for example. That is the first FSM or PRP can generate an output data stream e.g. an indication of a match or matches in the raw data stream as a function of the raw data stream on input bus or input bus respectively. As shown in a second level such as one implemented by the second FSM engine or second PRP processes an output data stream from the first level. For example the second FSM engine receives an output data stream from the first FSM engine provided on output bus and the second FSM engine processes an output data stream of the first FSM engine . Accordingly the second FSM engine does not receive the raw data stream as an input but rather receives an output data stream generated by the first FSM engine . The second FSM engine can be programmed with a first image to detect a sequence s in the output data stream generated by the first FSM engine . The second FSM engine may be coupled to a separate programming interface e.g. by a program bus for receiving a second image.

In an example HPRP can be programmed to implement a pattern recognition function. For example a FSM implemented by HPRP can be configured to recognize one or more data sequences e.g. signatures in a data stream input to the HPRP . When a sequence of interest in the data stream is recognized e.g. matched by the first PRP an output data stream indicating that recognition can be provided on output bus . In an example the pattern recognition can be to recognize a string of symbols e.g. ASCII characters to for example identify malware or other information in network data.

This output data stream e.g. an output word detection state etc. can be fed from the output bus of a first PRP to an input bus of another PRP as shown in . This connection of two PRPs in series provides a means to provide information regarding past events in a compressed word from a first PRP to a second PRP . This provision of information can effectively be a summary of complex events e.g. data stream sequences that were recognized by the first PRP .

As noted above in some embodiments it may be important to reduce the time needed to pass output between levels of PRPs. In some such embodiments the interface between PRPs can be designed to support real time operation of each level of HPRP . This document describes such considerations and suggests a general method for physical implementation of a HPRP for example.

This document describes among other things methods and apparatus for processing data using a hierarchical structure. The hierarchical structure can comprise a plurality of levels e.g. layers where each level processes e.g. performs an analysis on data and provides an output e.g. based on the analysis . The output from lower levels in the hierarchical structure can be provided as inputs to higher levels. In this manner lower levels can perform more basic fundamental analysis while a higher level can perform more complex analysis using the outputs from one or more lower levels. In an example the hierarchical structure performs pattern recognition.

In an example the hierarchical structure is implemented with a plurality of finite state machine engines coupled together in a cascading manner. For example a first and second finite state machine engine can be coupled in series such that the second finite state machine engine receives as an input an output from the first finite state machine engine. Any number of finite state machine engines can be coupled together in this hierarchical structure.

In addition to processing data using a hierarchical structure this document also describes methods and apparatuses for using output from one finite state machine engine to modify the processing performed by another finite state machine engine. Using the finite state machine engine example described above the second finite state machine engine implementing a higher level of processing can provide feedback information to the first finite state machine engine implementing a lower level of processing. The feedback information can be used by the first finite state machine engine to modify e.g. update the processing in a manner similar to learning in a biological brain.

The parallel machine includes a plurality of programmable elements including general purpose elements and special purpose elements . A general purpose element can include one or more inputs and one or more outputs . A general purpose element can be programmed into one of a plurality of states. The state of the general purpose element determines what output s the general purpose elements will provide based on a given input s . That is the state of the general purpose element determines how the programmable element will react e.g. respond to a given input. Data input to the data input port can be provided to the plurality of general purpose elements to cause the general purpose elements to take action thereon. Examples of a general purpose element can include for example a state machine element SME as discussed in detail below a counter and or a configurable logic block among other programmable elements. In an example a SME can be programmed e.g. set to provide a certain output e.g. a high or 1 signal when a given input is received at the data input port . When an input other than the given input is received at the data input port the SME can provide a different output e.g. a low or 0 signal . In an example a configurable logic block can be set to perform a Boolean logic function e.g. AND OR NOR ext. based on input received at the data input port . An example of a counter is discussed later herein. A special purpose element can include memory e.g. RAM logic gates counters look up tables field programmable gate arrays FPGAs and other hardware elements. A special purpose element can interact with the general purpose elements and performing special purpose functions.

The parallel machine can also include a programming interface for loading a program e.g. an image onto the parallel machine . The image can program e.g. set the state of the general purpose elements . That is the image can configure the general purpose elements to react in a certain way to a given input. For example a general purpose element can be set to output a high signal when the character a is received at the data input port . In some examples the parallel machine can use a clock signal for controlling the timing of operation of the general purpose elements . In some embodiments the data received at the data input port can include a fixed set of data received over time or all at once or a stream of data received over time. The data may be received from or generated by any source such as databases sensors networks etc coupled to the parallel machine .

The parallel machine also includes a plurality of programmable switches for selectively coupling together different elements e.g. general purpose element data input port output port programming interface and special purpose elements of the parallel machine . Accordingly the parallel machine comprises a programmable matrix formed among the elements. In an example a programmable switch can selectively couple two or more elements to one another such that an input of a general purpose element the data input port a programming interface or special purpose element can be coupled through one or more programmable switches to an output of a general purpose element the output port a programming interface or special purpose element . Thus the routing of signals between the elements can be controlled by setting the programmable switches . Although illustrates a certain number of conductors e.g. wires between a given element and a programmable switch it should be understood that in other examples a different number of conductors can be used. Also although illustrates each general purpose element individually coupled to a programmable switch in other examples multiple general purpose elements can be coupled as a group e.g. a block as illustrated in to a programmable switch . In an example the data input port the data output port and or the programming interface can be implemented as registers such that writing to the registers provides data to or from the respective elements.

In an example a single parallel machine is implemented on a physical device however in other examples two or more parallel machines can be implemented on a single physical device e.g. physical chip . In an example each of multiple parallel machines can include a distinct data input port a distinct output port a distinct programming interface and a distinct set of general purpose elements . Moreover each set of general purpose elements can react e.g. output a high or low signal to data at their corresponding input data port . For example a first set of general purpose elements corresponding to a first parallel machine can react to the data at a first data input port corresponding to the first parallel machine . A second set of general purpose elements corresponding to a second parallel machine can react to a second data input port corresponding to the second parallel machine . Accordingly each parallel machine includes a set of general purpose elements wherein different sets of general purpose elements can react to different input data. Similarly each parallel machine and each corresponding set of general purpose elements can provide a distinct output. In some examples an output port from first parallel machine can be coupled to an input port of a second parallel machine such that input data for the second parallel machine can include the output data from the first parallel machine .

In an example an image for loading onto the parallel machine comprises a plurality of bits of information for setting the state of the general purpose elements programming the programmable switches and configuring the special purpose elements within the parallel machine . In an example the image can be loaded onto the parallel machine to program the parallel machine to provide a desired output based on certain inputs. The output port can provide outputs from the parallel machine based on the reaction of the general purpose elements to data received at the input port . An output from the output port can include a single bit indicating a match of a given pattern a word comprising a plurality of bits indicating matches and non matches to a plurality of patterns and an output vector corresponding to the state of all or certain general purpose elements and special purpose elements .

Example uses for the parallel machine include pattern recognition e.g. speech recognition image recognition etc. signal processing imaging computer vision cryptography and others. In certain examples the parallel machine can comprise a finite state machine FSM engine a field programmable gate array FPGA and variations thereof. Moreover the parallel machine may be a component in a larger device such as a computer pager cellular phone personal organizer portable audio player network device e.g. router firewall switch or any combination thereof control circuit camera etc.

A parallel machine e.g. a FSM engine PRP or the like can implement a state machine s . A state machine can be represented as a directed graph. shows a simple state machine diagram that represents the sequence of characters found in the word DOG . State is the input state for state machine diagram . State is an intermediate state. In the final state sometimes also called terminal state is identified by the dotted line border around the G state. In the general case when the final state is reached a match condition is indicated through some mechanism. This match condition may be represented by an explicit signal from a parallel machine e.g. FSM engine PRP or it may be encoded as a binary word and stored in a memory register.

There is no theoretical limit to the size of a state machine. In the general case a PRP or FSM engine might implement a separate state machine for each specific sequence of symbols that can be detected by the PRP or FSM engine. One can if desired perform optimizations on the state machines in order to eliminate redundancies common paths such as to combine state machines into a larger implementation or to minimize the size of a particular state machine implementation. Such optimizations can reduce the aggregate size of the state machine implementation s and thus for example a state machine engine implementing the state machine s . Once this optimization is complete a single large state machine may be implemented.

Each state in a state machine has an instantaneous status that indicates whether the state is active. Only active states can react to an input symbol. In one embodiment when an input symbol is received on input bus each active state in the state machine will analyze that symbol to determine if an activation signal should be generated. This activation signal will be used to activate the next state in the sequence. For example a first state that specifies the character b will activate a second state connected to the first state by a transition on the input character b when the first node is active and the character b is received as input data.

In the diagram the input state can be initially activated and can activate a downstream state when the input data matches a transition from the input node . States throughout the diagram can be activated in this manner as the input data is received. An activated final state corresponds to a match of a sequence of interest by the input data. Accordingly activation of a final state indicates that a sequence of interest has been received at the input data. In the context of a finite state machine engine implementing a pattern recognition function activating a final state can indicate that a specific pattern of interest has been detected on the input data.

In an example each intermediate state and final state can correspond to a general purpose element in the finite state machine engine . Each transition can correspond to connections between the general purpose elements . Thus an intermediate state that transitions to e.g. has a transition connecting to another intermediate state or a final state corresponds to a general purpose element that can be coupled to another general purpose element . In some special cases the start state may not necessarily have a corresponding general purpose element .

When a finite state machine engine is programmed to implement a FSM each of the general purpose elements can be in either an active or inactive state. An inactive general purpose element does not react to the data stream at the input interface . An active general purpose element can react to the data stream at the input interface and can activate a downstream general purpose element when the input data stream matches the setting of the general purpose element . When a general purpose element corresponds to a final state the general purpose element can be coupled to the output port to provide an indication of a match to an external device which in some cases could be another finite state machine engine .

An image loaded onto the finite state machine engine via the programming interface can configure the general purpose elements and the connections between the general purpose elements such that a desired FSM is implemented through the activation of downstream states based on responses to the data stream at the input interface . In an example a general purpose element remains active for a single data cycle e.g. a single character a set of characters a single clock cycle and then switches to inactive unless re activated by an upstream general purpose element .

A final state can be considered to store a compressed history of past events. For example the one or more sequences of input data required to activate a final state can be represented by the activation of that final state . In an example the output provided by a final state is binary that is the output indicates whether a corresponding sequence of interest has been matched or not. The ratio of final states to intermediate states in a FSM may be quite small. In other words although there may be a high complexity in the FSM the output of the FSM may be small by comparison.

Whether a FSM engine implements a single combined optimized state machine or implements many independent state machines the concept of a state vector exists. A state vector is a one dimensional vector that has a one to one correspondence between the individual states in the implemented state machine s and the individual digit e.g. bit positions within the vector. That is to say that each state in the state machine s is related to a digit in the state vector. In the case of the state vector is 3 bits wide with one bit indicating the state of each of states and . In the case of the state vector is 74 bits wide. State machines can be arbitrarily complex and therefore in theory there is no limitation placed on the overall size of the machine. Consequently the state vector can be infinitely long.

In order to implement practical state machines in parallel machines however some finite limitation usually is placed on the size of the state machines. This limit is not strictly defined and can be determined based on the characteristics of the parallel machine used to implement the state machines.

Another HFSM is shown in . In the HFSM shown in three finite state machine engines provide information regarding their respective states to one finite state machine engine using all or a portion of all their respective state vector digits. In the example shown each state machine engine is programmed via its respective programming interface PROG . In other embodiments data from each of FSM engines is used to program FSM engine . In some such embodiments FSM engine is designed to adapt to the state information received from FSM engines .

A more complex HFSM is shown in . In the HFSM of multiple FSM engines are connected together with FSM engine providing e.g. feeding state information through bus to FSM engine FSM engine feeding state information through bus to FSM engine and FSM engine feeding state information through bus to FSM engine . This connecting of multiple FSM levels allows each level of the hierarchy to implement different state machines. In some example HFSMs each level of the hierarchy is sensitive to different types of patterns. In these example HFSMs as in HFSM this separation of hierarchical levels allows the HFSM to implement low level recognition that is passed through various levels of the hierarchy to achieve higher level recognition. In one example a result is provided on a results bus of HFSM such as e.g. identification of a particular pattern e.g. a phrase . In other examples the result is a combination of state bits from one or more of FSM engines and .

As shown in one approach for connecting individual FSM engines in a hierarchical manner is to connect the output of one FSM engine to the input of the next higher level FSM engine in the hierarchy. It should be understood that a HFSM could be implemented in which state information from one level is provided e.g. fed forward or back to any other level in the hierarchy. For instance state information from FSM engine might be sent to FSM engine while state information from FSM engine might be fed back to FSM engine . In general terms state information from one or more FSM engines can be provided to one or more e.g. all of the other FSM engines in whatever configuration is deemed necessary.

The example shown in corresponds to a visual identification of written language. As the processing progresses to higher levels of the hierarchy the accumulated knowledge of the data stream grows correspondingly. In the embodiment shown the FSM engine at each level FSM engines and are cascaded to accomplish hierarchical recognition capability. Each successive level of the hierarchy can implement new rules pattern signatures that are applied to the output of the previous level. In this way highly detailed objects can be identified based on the detection of very basic primitive information.

For example the raw data input stream to level one e.g. the first FSM engine can comprise pixel information e.g. whether a given bit is black white or on off for an image. FSM engine can be programmed to recognize e.g. identify primitive patterns formed by the bits. In one example FSM engine is configured to identify when a group of adjacent bits form vertical lines horizontal lines arcs etc. Each of these patterns can be identified by a separate output bit or signal from FSM engine . For example when FSM engine recognizes a vertical line of at least 3 bits a high signal e.g. logical one can be sent on a first bit of an output word to FSM engine . When FSM engine identifies a horizontal line of at least 3 bits a high signal can be sent on a second bit of an output word to FSM engine .

FSM engine meanwhile can be programmed to identify patterns formed by the output from the FSM engine . For example FSM engine can be programmed to identify patterns formed by combinations of the primitive patterns lines arcs etc. identified by FSM engine . FSM engine can be programmed to identify when a horizontal line and a vertical line cross forming the letter t for instance. As mentioned above the HFSM implemented using FSM engine reacts to the output from FSM engine . Thus the combinations of the primitive patterns are identified by identifying patterns in the output bits from FSM engine .

The output from FSM engine is then input into FSM engine which can identify words from combinations of the letters identified by FSM engine . The fourth level FSM engine can then identify phrases formed by the words identified by FSM engine . Accordingly higher levels can be programmed to identify patterns in the lower level outputs. Additionally lower levels can be programmed to identify components that make up the patterns identified in the higher level feedback to lower levels .

The visual identification of letters is used as an example. The hierarchical method and system described herein can however be applied to other data. For example hierarchical processing on data corresponding to sounds can identify syllables from combinations of phonemes at level one and words from combinations of syllables at level two. In other examples the hierarchical processing can be applied to machine data that builds upon itself in a hierarchal manner.

When implementing a HPRP or HFSM such as HFSM one problem that can be encountered is the asymmetric relationship between input data and output data. This asymmetry is exacerbated when the state machine s being implemented becomes sufficiently large. For each input symbol that is processed the state vector of a FSM engine can change responsive to the input symbol. In one embodiment each FSM includes for example up to 2 to the 16th power 64 K states. If each state has a corresponding digit in the state vector the state vector would be 64K bits long. It can be difficult to pass vectors of that length between FSM engines. Ways to reduce this asymmetry between the size of the input data and the size of the output data will be described next.

In one embodiment data is sent between FSM engines on a bus. An N bit wide bus can pass a 64 Kb state vector in 64 Kb N cycles. In other embodiments the state vector is compressed such that only digits in the vector that change in response to an input symbol propagate to the other FSM engines. For instance each bus cycle might include the location of a digit in the state vector that changed in the previous symbol cycle. In this case the output can be referred to as a difference vector.

In yet another embodiment each FSM engine is designed to send only a subset of digits from the state vector to the other FSM engines. In one such embodiment each FSM engine is programmed such that the only state information passed to the other FSM engines is that of final states. In the general case the number of final states is smaller than the total number of states. The ratio of final states to total states in a PRP for example is dependent upon the state machines that are implemented in the PRP. Ratios can be high 1 5 or quite low 1 10 000 for example.

In a practical example where the ratio of final states to total states is 1 10 and the state vector is 64 Kb this implies that an output vector would be 64 Kb 10 or 6 554 bits. In this example every input cycle of the PRP 8 bit symbols would generate a corresponding output vector of 6 554 bits.

For the examples going forward we will use an example where the ASCII character set is the input symbol language. In this case each input symbol is represented by an 8 bit binary word. In alternative embodiments other symbols can be used such as where each input symbol is an N bit binary word.

For instance in one embodiment the output vector sent to the second level PRP in a HPRP such as that depicted in might represent only the final states of the first level PRP . In another example in a HFSM such as that depicted in FSM engine can generate an output vector representing its final states and send the output vector to FSM engine on output bus . In one such example output bus is an eight bit wide bus. Using the 8 6 554 ratio cited from the previous example the number of cycles needed to provide e.g. transfer the 6 554 bits of the output vector would be 6 554 8 or 820 cycles. That is each successive level of the hierarchy would require 820 input cycles to process the output word from the previous level. This effect ripples through the hierarchy linearly so that each successive state will require 820 input cycles to resolve its input word. In this case with the given ratios a six level hierarchy of PRP s would require 4 100 5 820 input cycles to allow the input symbol to ripple through until a result is produced at the highest level. These numbers only serve as an example. If the final state to total state ratio is increased the ripple time will increase. Likewise if the number of levels of the hierarchy is increased the ripple time will increase linearly with each successive level.

Based on the examples used above a delay of several orders of magnitude relative to the input cycle is possible for a HFSM or HPRP to produce a result. Delays of this type may be unacceptable in real time applications. As noted above one can reduce the number of cycles needed to transfer the state information by for instance increasing the size of the bus. One can also decrease the bus cycle time to reduce the time needed to transfer the state information. Further as noted above one can send a difference vector which only identifies the digits of the state vector that changed as a result of the last symbol. Other lossless compression mechanisms can be used as well.

Other methods to reduce this delay are discussed next such as implementing a 1 1 relationship between input and output.

One way to get a 1 1 relationship between input and output in a HFSM such as HFSM is to make the input bus and the output bus equal in size width . The width of output bus can be determined by the HFSM itself. For example the size of output bus could be determined by the number of final states in the state machine engine . Generally speaking a FSM engine is programmed to recognize many different patterns at once. Each of these patterns may be implemented as an individual state machine. In this way a FSM engine may implement a set of state machines all running in parallel.

As shown in each individual state machine may have one or more final states . Although there may be several final states any one of the final states of a particular state machine has the same or a related meaning. Another way of saying this is that a state machine is considered to have a match if ANY of the final states of the state machine is reached. Effectively this means that the final states of a single state machine may be aggregated e.g. OR d together such as by using an OR gate to couple together the outputs of the programmable elements corresponding to the finals states to provide a single output as shown in . In the example shown in state machine ORs together three final states . As can be understood other logic could be used to aggregate the final states .

In one example once the final states of each state machine have been aggregated e.g. OR d the results are grouped e.g. collected in logical groups of N state machines where N is equal to the number of digits in the respective input symbol language. In an example where the input symbol language of a first level comprises 8 bit input words 8 individual state machine outputs could be aggregated to provide one of the input symbols provided to the next level of the hierarchy. In for example only the first level of the hierarchy receives input symbols that correlate to a standard language ASCII or other . In that example then FSM engine might generate an eight bit output vector that is provided to FSM engine on an output bus . Subsequent levels of the hierarchy receive input symbols that have meaning that is determined by the previous level.

Once state machines have been grouped such as in sets of 8 the first level of normalizing the input and output vectors has been completed. Using the numbers from the example used in this disclosure 820 final states could be represented in 103 8 bit words. Each of these 8 bit words encodes the status of the final states for 8 individual state machines . Keep in mind that the total number of final states encoded in this 8 bit output vector may be much greater than 8. This is because the OK ing function performed on final states in the same state machine may OR more than eight states together.

In one embodiment each FSM engine includes an N bit wide input port and an N bit wide output port. In one embodiment state information from each level e.g. in the form of an output vector such as all or a portion of a state vector or a difference vector is distributed through an N bit bus to the next FSM engine. For instance FSM engine distributes state information to FSM engine using the N bit output bus . In one embodiment the same N bit output vector is provided e.g. distributed to each state machine in FSM engine . In another embodiment programmable elements in FSM engine are grouped into groups e.g. blocks and the output port of FSM engine writes a sequence of N bit words to FSM engine and the sequence of words is distributed to the blocks of state machine elements in FSM engine in a pre defined manner such as sequentially . Such an approach allows the distribution of additional state information to FSM engine but requires additional bus cycles to transfer complete state information.

In one embodiment state information for one group of programmable elements is sent to a group of programmable elements in another FSM engine by sending address information including an indication of the FSM engine and the address of the group within the FSM engine. That information could be distributed for example on bus in .

One implementation of a FSM or a PRP has a single stream input that broadcasts an input symbol to all state machines implemented in the PRP. The definition of FSM and PRP may however be extended to implement more than one stream input 16 and 36 respectively . In the example previously cited the total number of independent stream inputs would equal 103. To completely implement for example a HPRP would then require 103 8 bit inputs or an input bus of 820 bits for each PRP .

In one embodiment FSM and PRP are implemented on an array of programmable elements such as state machine elements SMEs . In one example each SME is in a homogenous two dimensional array . This array may be subdivided into individual regions with each region having it s own dedicated stream input 16 and 36 respectively . shows such a two dimensional array of SME elements. is subdivided into an array of SME groups wherein each group of SMEs may correspond to a block in finite state machine engine for example. The entire array might include for example 16 16 SME groups 256 groups total with each group including 128 groups of two SMEs GOTs e.g. where each group includes 16 rows of GOTs such as rows illustrated in .

In some embodiments each row of GOTs contains eight GOTs an additional programmable element s e.g. Boolean logic or a counter and can provide two outputs to the output bus . If all available outputs are used across the FSM and PRP such an array may have for example up to 8192 bits to drive to the next level PRP .

When a HFSM is constructed such as is shown in the two dimensional arrays of SME groups in two different semiconductor devices such as FSM engines and may be connected together. There are various means of connecting two semiconductor devices together. When the I O count gets sufficiently high die to die interconnect may be utilized for example. In one example implementation as is shown in each one of the 256 SME groups in a HPRP could have an 8 bit interface e.g. input bus on the bottom of a die and an 8 bit interface e.g. output bus on the top of the die. When these interfaces are put in predefined locations one level of PRP PRP1 can be stacked directly on top of a lower level PRP PRP0 with the input and output interfaces naturally aligned and connected together using interconnects e.g. through silicon vias such as interconnect .

This alignment effectively creates the concept of a SME column defined by input path output path and interconnects and with each level of the column representing a group of SMEs contained on a same die. Continuing to use the example numbers previously discussed on each PRP level and an SME group can be driven by up to 8 state machines implemented on the previous level. The 8 state machines from the previous level may be arbitrarily complex up to the limit imposed by the SME group . shows an example of a three level HPRP edge view with one of the SME columns highlighted. In each level a grouping of SMEs provides state information from that level e.g. an encoded 8 bit word to the next higher level.

Overall when configured in this way a HPRP can provide substantially instantaneous results with the delay of only one input clock cycle for each level of the PRP hierarchy. The problem posed by the asymmetry of the input and output words is resolved and the entire hierarchy may operate in sync with the stream input .

In certain embodiments state information from one FSM engine is sent to more than one other FSM engine . Such an embodiment is shown in . Describing such an embodiment with reference to the HPRP illustrated in for instance state information from PRP could be sent to PRP . In one such embodiment interconnect and form a bus that transmits state information to any of the blocks in the column. For example interconnects and may comprise one or more through via interconnects and can be provided in each column for passing state information to nonadjacent PRPs. In one such embodiment each PRP in the stack is connected to and receives information from the through vias. In another embodiment inputs of PRP are selectively connected to through vias during the manufacturing process as needed.

In other embodiments state information from one group of SMEs is distributed to adjacent blocks in the same PRP and through those blocks to other PRPs e.g. in the same block column .

In one embodiment state information from one or more PRPs or information derived from that state information is used to reprogram other PRPs in the hierarchy. illustrates an example of a four level hierarchy that uses feedback to reprogram portions of the hierarchy. In general a given PRP e.g. the first finite state machine engine can be reprogrammed based on an output from a higher or lower level finite state machine engine or based on its own output. Thus the first finite state machine engine can change to adapt to changing conditions during run time. In an example the feedback can be used for the lower levels to learn be reprogrammed based on the higher levels. The feedback using the finite state machine engine as an example can be received at the programming interface B and can be in the form of a new or updated program for the finite state machine engine . In an example the updated program can reprogram some or all of finite state machine engine .

The four level hierarchy in is implemented with four finite state machine engines which each have a an input port A A A A a programming interface B B C B and an output port C C C C. The first finite state machine engine implements the first level of the hierarchy and provides an output to the second finite state machine engine which implements the second level of the hierarchy . The third and fourth finite state machine engines likewise implement the third and fourth levels of the hierarchy . In an example the output from the fourth finite state machine engine is sent to an external device as an output of the hierarchy based on analysis of the hierarchy on the input data received by the first finite state machine engine . Accordingly the output from the fourth finite state machine engine corresponds to the collective output for the hierarchy . In other examples the output from other ones of the finite state machine engines or can correspond to the collective output for the hierarchy .

The outputs from the second third and fourth finite state machine engines can each be fed back to the programming interface B B B of the finite state machine engine at the level below. For example the output from the fourth finite state machine engine is fed back into the programming interface B of the third finite state machine engine . The third finite state machine engine therefore can be reprogrammed based on the output from the fourth finite state machine engine . Accordingly the third finite state machine engine can modify its program during runtime. The first and second finite state machine engines can be similarly reprogrammed during runtime based on the outputs from the second and third finite state machine engines respectively.

In an example the feedback from an output from a finite state machine engine is processed e.g. analyzed and compiled to form a program for reprogramming a finite state machine engine . For example the output from the finite state machine engine can be analyzed and compiled by a processing device before being sent to the programming interface B. The processing device can generate the updated program for the finite state machine engine based on the output from the finite state machine engine . The processing device can analyze the output and compile the updated program for the third finite state machine engine . The updated program can then be loaded onto the third finite state machine engine through the programming interface B to reprogram the third finite state machine engine . In an example the updated program may contain only a partial change from the current program. Thus in an example an updated program replaces only a portion of a current program on a finite state machine engine . In another example an updated program replaces all or a large portion of a current program. Likewise the processing devices can analyze and compile feedback in a similar manner based on the outputs from the second and third finite state machine engines . A processing device can be implemented with one or more additional finite state machines engines or can be implemented with a different type of machine e.g. a computer having a von Nuemann architecture .

In some examples the processing devices analyze the output from a higher level prior to compiling the new program. In an example the processing devices analyze the output to determine how to update the lower level program and then compile the new or updated lower level program based on the analysis. Although in the hierarchy the feedback at a given finite state machine engine is received from the level directly above the given finite state machine engine feedback can be from any level finite state machine engine to another finite state machine engine at a higher lower or the same level. For example feedback can be received at a programming input of a finite state machine engine from the output of that same finite state machine engine or from the output of another finite state machine engine at the same higher or lower levels. Additionally a finite state machine engine can receive feedback from multiple different finite state machine engines. The reprogramming of finite state machine engines based on feedback may be disconnected in time from the identification of patterns in the input data e.g. not real time with the processing of the raw data .

A purpose of sending information back down the hierarchy to affect reprogramming of the lower levels can be so that the lower levels may become more efficient at discerning patterns of interest. In some examples the process of sending information to higher levels is avoided when possible recognizing that it takes time to transfer information to higher levels of the hierarchy. In some examples the higher levels can be essentially used to resolve the identification of patterns that are new to the system. This can be similar to the process used that takes place in the neocortex of a biological brain. In an example if a pattern can be fully resolved at the lower levels it should be. The feedback mechanism is one method to transfer learning to the lower levels of the hierarchy. This process of pushing information back down the hierarchy will help preserve the upper levels of the hierarchy for processing new or unfamiliar patterns. Furthermore the entire recognition process can speed up by reducing the amount of data transfer through various levels of the hierarchy.

The feedback can make the lower levels of the hierarchy more acutely sensitive to the data stream at the input. A consequence of this push down of information is that decisions can be made at the lower levels of the hierarchy and can be done so quickly. Accordingly in an example the output from lower level finite state machine engines e.g. the first finite state machine engine can correspond to the collective output from the hierarchy to another device along with the output from the fourth finite state machine engine . The external device can for example monitor the output from each of these finite state machine engines to determine when patterns have been identified by the hierarchy .

In an example the feedback information can include identifying information corresponding to the data stream analyzed. For example the identifying information can include an identifying characteristic of the data format of the data a protocol of the data and or any other type of identifying information. The identifying information may be collected analyzed and used to adapt the analysis method for the input data by for example the processing device . A finite state machine engine may then be programmed with the adapted analysis method. The identifying information can include for example a language of the input data. The finite state machine engine can be initially programmed to determine a language of the input data and may be adapted e.g. reprogrammed during runtime once a language has been identified corresponding to the input. The adapted analysis method for the finite state machine engine can correspond more specifically to analysis methods for the identified language. Finally the finite state machine engine may analyze future input data using the adapted analysis method. The feedback process may be iterative so that additional identifying information may be found in the input data to allow for further adaptation of the analysis method.

Programs also referred to herein as images for loading onto a finite state machine engine can be generated by a compiler as discussed below with respect to . In general compiling can be a computationally intensive process and can be most apparent when compiling large databases of pattern signatures for the first time. In runtime operation finite state machines engines of higher levels can be providing feedback to the lower levels in the form of an incremental program update for the lower level finite state machine engine. Thus the feedback information to the lower level finite state machine engine can be much smaller incremental updates to an original program that are less computationally intensive to compile.

As can be seen from finite state machine engines can be cascaded in almost any manner where the raw data input to the hierarchy as well as an output from a finite state machine engine can be sent to any other finite state machine engine including itself. Moreover the outputs from a given finite state machine engine can be sent to another finite state machine engine as input data and or as feedback for updating the program for a finite state machine engine.

As noted above due to the time for a finite state machine engine to process one bit or word of an input data stream cascading finite state machine engines in series can increase the time to fully process the input data stream through all the finite state machine engines. The lowest level of the hierarchy will often receive the lowest most granular level of input. Accordingly the lower levels should be expected to be more active than the output of high levels. That is each successive level in the hierarchy can assemble higher level objects. In an example a finite state machine engine has a maximum input rate that limits how fast input data can be fed to the finite state machine engine. This input rate can be thought of as a single data cycle. On each successive data cycle the finite state machine engine has the potential to activate many final states. This could cause a finite state machine engine especially at the lowest level of the hierarchy to produce a significant amount of output match data. For example if the input is provided as a stream of bytes to the lowest level finite state machine engine on any given data cycle it may be possible for the finite state machine engine to generate multiple bytes of state information. If one byte of information can generate multiple bytes of state information then the entire hierarchy of finite state machine engines should be synchronized so that information is passed up the hierarchy. The feedback does not need to be synchronized however the faster the feedback is received at a lower lever the faster the lower level can adapt and the more efficient the analysis.

As an example a maximum size output for each level of the hierarchy implemented with a single finite state machine engine can equal 1024 bytes and a depth of the hierarchy can equal 4 levels. The input data stream data rate for a finite state machine engine can equal 128 MB second. With these conditions each level of the hierarchy could be traversed in 7.63 microseconds. With a four level hierarchy the total settling time of the entire stack of finite state machine engines would be 4 times 7.63 microseconds or 30.5 microseconds. With a 30.5 microsecond settling time the implication is that the input data frequency should be limited to 32 KB s.

Notably this is highly dependent on the configuration of the finite state machine engines. Finite state machine engines can be configurable to tradeoff input data rates vs. the state machine size. In addition the input word size to a finite state machine engine can be adjusted if corresponding modifications are made to the compiler that produced the individual images loaded on the finite state machine engines.

In an example the methods to implement one or more FSMs as described with reference to could be implemented with software on a machine having a von Nuemann architecture. Accordingly software instructions could cause a processor to implement a first level analysis FSM on a raw data stream. The output from the first level FSM could then be processed by the processor according to a second level FSM and so on. Furthermore the feedback loop discussed above could be implemented by a processor that analyzes an output from a level of the FSM and uses that to generate a new FSM for one or more of the levels.

The FSM engine includes a plurality of programmable elements including general purpose elements and special purpose elements. The general purpose elements can be programmed to implement many different functions. These general purpose elements include SMEs shown in that are hierarchically organized into rows shown in and blocks shown in . To route signals between the hierarchically organized SMEs a hierarchy of programmable switches is used including inter block switches shown in intra block switches shown in and intra row switches shown in . A SME can correspond to a state of a FSM implemented by the FSM engine . The SMEs can be coupled together by using the programmable switches as described below. Accordingly a FSM can be implemented on the FSM engine by programming the SMEs to correspond to the functions of states and by selectively coupling together the SMEs to correspond to the transitions between states in the FSM.

In an example the input block the output block and or the programming interface can be implemented as registers such that writing to the registers provides data to or from the respective elements. Accordingly bits from the image stored in the registers corresponding to the programming interface can be loaded on the SMEs . Although illustrates a certain number of conductors e.g. wire trace between a block input block output block and an inter block switch it should be understood that in other examples fewer or more conductors can be used.

In an example the row includes a first and second plurality of row interconnection conductors . In an example an input of a GOT can be coupled to one or more row interconnection conductors and an output can be coupled to one row interconnection conductor . In an example a first plurality of the row interconnection conductors can be coupled to each SME of each GOT within the row . A second plurality of the row interconnection conductors can be coupled to one SME of each GOT within the row but cannot be coupled to the other SME of the GOT . In an example a first half of the second plurality of row interconnection conductors can couple to first half of the SMEs within a row one SME from each GOT and a second half of the second plurality of row interconnection conductors can couple to a second half of the SMEs within a row the other SME from each GOT . The limited connectivity between the second plurality of row interconnection conductors and the SMEs is referred to herein as parity . In an example the row can also include a special purpose element such as a counter a programmable Boolean logic element a field programmable gate array FPGA an application specific integrated circuit ASIC a programmable processor e.g. a microprocessor and other elements.

In an example the special purpose element includes a counter also referred to herein as counter . In an example the counter comprises a 12 bit programmable down counter. The 12 bit programmable counter has a counting input a reset input and zero count output. The counting input when asserted decrements the value of the counter by one. The reset input when asserted causes the counter to load an initial value from an associated register. For the 12 bit counter up to a 12 bit number can be loaded in as the initial value. When the value of the counter is decremented to zero 0 the zero count output is asserted. The counter also has at least two modes pulse and hold. When the counter is set to pulse mode the zero count output is asserted during the clock cycle when the counter decrements to zero and at the next clock cycle the zero count output is no longer asserted. When the counter is set to hold mode the zero count output is asserted during the clock cycle when the counter decrements to zero and stays asserted until the counter is reset by the reset input being asserted. In an example the special purpose element includes Boolean logic. In some examples this Boolean logic can be used to extract information from terminal state SMEs in FSM engine . The information extracted can be used to transfer state information to other FSM engines and or to transfer programming information used to reprogram FSM engine or to reprogram another FSM engine .

In an example a state machine element comprises a plurality of memory cells such as those often used in dynamic random access memory DRAM coupled in parallel to a detect line . One such memory cell comprises a memory cell that can be set to a data state such as one that corresponds to either a high or a low value e.g. a 1 or 0 . The output of the memory cell is coupled to the detect line and the input to the memory cell receives signals based on data on the data stream line . In an example an input on the data stream line is decoded to select one of the memory cells . The selected memory cell provides its stored data state as an output onto the detect line . For example the data received at the data input port can be provided to a decoder not shown and the decoder can select one of the data stream lines . In an example the decoder can convert an ACSII character to 1 of 256 bits.

A memory cell therefore outputs a high signal to the detect line when the memory cell is set to a high value and the data on the data stream line corresponds to the memory cell . When the data on the data stream line corresponds to the memory cell and the memory cell is set to a low value the memory cell outputs a low signal to the detect line . The outputs from the memory cells on the detect line are sensed by a detect circuit . In an example the signal on an input line sets the respective detect circuit to either an active or inactive state. When set to the inactive state the detect circuit outputs a low signal on the respective output regardless of the signal on the respective detect line . When set to an active state the detect circuit outputs a high signal on the respective output line when a high signal is detected from one of the memory cells of the respective SME . When in the active state the detect circuit outputs a low signal on the respective output line when the signals from all of the memory cells of the respective SME are low.

In an example an SME includes 256 memory cells and each memory cell is coupled to a different data stream line . Thus an SME can be programmed to output a high signal when a selected one or more of the data stream lines have a high signal thereon. For example the SME can have a first memory cell e.g. bit set high and all other memory cells e.g. bits set low. When the respective detect circuit is in the active state the SME outputs a high signal on the output when the data stream line corresponding to bit has a high signal thereon. In other examples the SME can be set to output a high signal when one of multiple data stream lines have a high signal thereon by setting the appropriate memory cells to a high value.

In an example a memory cell can be set to a high or low value by reading bits from an associated register. Accordingly the SMEs can be programmed by storing an image created by the compiler into the registers and loading the bits in the registers into associated memory cells . In an example the image created by the compiler includes a binary image of high and low e.g. 1 and 0 bits. The image can program the FSM engine to operate as a FSM by cascading the SMEs . For example a first SME can be set to an active state by setting the detect circuit to the active state. The first SME can be set to output a high signal when the data stream line corresponding to bit has a high signal thereon. The second SME can be initially set to an inactive state but can be set to when active output a high signal when the data stream line corresponding to bit has a high signal thereon. The first SME and the second SME can be cascaded by setting the output of the first SME to couple to the input of the second SME . Thus when a high signal is sensed on the data stream line corresponding to bit the first SME outputs a high signal on the output and sets the detect circuit of the second SME to an active state. When a high signal is sensed on the data stream line corresponding to bit the second SME outputs a high signal on the output to activate another SME SME or for output from the FSM engine .

In an example the compiler includes an application programming interface API that allows software developers to create images for implementing FSMs on the FSM engine . The compiler provides methods to convert an input set of regular expressions in the source code into an image that is configured to program the FSM engine . The compiler can be implemented by instructions for a computer having a von Neumann architecture. These instructions can cause a processor on the computer to implement the functions of the compiler. For example the instructions when executed by the processor can cause the processor to perform actions as described in blocks and on source code that is accessible to the processor. An example computer having a von Neumann architecture is shown in and described below.

In an example the source code describes search strings for identifying patterns of symbols within a group of symbols. To describe the search strings the source code can include a plurality of regular expressions regexs . A regex can be a string for describing a symbol search pattern. Regexes are widely used in various computer domains such as programming languages text editors network security and others. In an example the regular expressions supported by the compiler include search criteria for the search of unstructured data. Unstructured data can include data that is free form and has no indexing applied to words within the data. Words can include any combination of bytes printable and non printable within the data. In an example the compiler can support multiple different source code languages for implementing regexes including Perl e.g. Perl compatible regular expressions PCRE PHP Java and .NET languages.

At block the compiler can parse the source code to form an arrangement of relationally connected operators where different types of operators correspond to different functions implemented by the source code e.g. different functions implemented by regexes in the source code . Parsing source code can create a generic representation of the source code. In an example the generic representation comprises an encoded representation of the regexs in the source code in the form of a tree graph known as a syntax tree. The examples described herein refer to the arrangement as a syntax tree also known as an abstract syntax tree in other examples however a concrete syntax tree or other arrangement can be used.

Since as mentioned above the compiler can support multiple languages of source code parsing converts the source code regardless of the language into a non language specific representation e.g. a syntax tree. Thus further processing blocks by the compiler can work from a common input structure regardless of the language of the source code.

As noted above the syntax tree includes a plurality of operators that are relationally connected. A syntax tree can include multiple different types of operators. That is different operators can correspond to different functions implemented by the regexes in the source code.

At block the syntax tree is converted into an automaton. An automaton comprises a software model of a FSM and can accordingly be classified as deterministic or non deterministic. A deterministic automaton has a single path of execution at a given time while a non deterministic automaton has multiple concurrent paths of execution. The automaton comprises a plurality of states. In order to convert the syntax tree into an automaton the operators and relationships between the operators in the syntax tree are converted into states with transitions between the states. In an example the automaton can be converted based partly on the hardware of the FSM engine .

In an example input symbols for the automaton include the symbols of the alphabet the numerals 0 9 and other printable characters. In an example the input symbols are represented by the byte values 0 through 255 inclusive. In an example an automaton can be represented as a directed graph where the nodes of the graph correspond to the set of states. In an example a transition from state p to state q on an input symbol i.e. p is shown by a directed connection from node p to node q. In an example a reversal of an automaton produces a new automaton where each transition p q on some symbol is reversed q p on the same symbol. In a reversal start state becomes a final state and the final states become start states. In an example the language accepted e.g. matched by an automaton is the set of all possible character strings which when input sequentially into the automaton will reach a final state. Each string in the language accepted by the automaton traces a path from the start state to one or more final states.

At block after the automaton is constructed the automaton is optimized to among other things reduce its complexity and size. The automaton can be optimized by combining redundant states.

At block the optimized automaton is converted into a netlist. Converting the automaton into a netlist maps each state of the automaton to a hardware element e.g. SMEs other elements on the FSM engine and determines the connections between the hardware elements.

At block the netlist is placed to select a specific hardware element of the target device e.g. SMEs special purpose elements corresponding to each node of the netlist. In an example placing selects each specific hardware element based on general input and output constraints for of the FSM engine .

At block the placed netlist is routed to determine the settings for the programmable switches e.g. inter block switches intra block switches and intra row switches in order to couple the selected hardware elements together to achieve the connections describe by the netlist. In an example the settings for the programmable switches are determined by determining specific conductors of the FSM engine that will be used to connect the selected hardware elements and the settings for the programmable switches. Routing can take into account more specific limitations of the connections between the hardware elements than placement at block . Accordingly routing may adjust the location of some of the hardware elements as determined by the global placement in order to make appropriate connections given the actual limitations of the conductors on the FSM engine .

Once the netlist is placed and routed the placed and routed netlist can be converted into a plurality of bits for programming of a FSM engine . The plurality of bits are referred to herein as an image.

At block an image is published by the compiler. The image comprises a plurality of bits for programming specific hardware elements and or programmable switches of the FSM engine . In embodiments where the image comprises a plurality of bits e.g. 0 and 1 the image can be referred to as a binary image. The bits can be loaded onto the FSM engine to program the state of SMEs the special purpose elements and the programmable switches such that the programmed FSM engine implements a FSM having the functionality described by the source code. Placement block and routing block can map specific hardware elements at specific locations in the FSM engine to specific states in the automaton. Accordingly the bits in the image can program the specific hardware elements and or programmable switches to implement the desired function s . In an example the image can be published by saving the machine code to a computer readable medium. In another example the image can be published by displaying the image on a display device. In still another example the image can be published by sending the image to another device such as a programming device for loading the image onto the FSM engine . In yet another example the image can be published by loading the image onto a parallel machine e.g. the FSM engine .

In an example an image can be loaded onto the FSM engine by either directly loading the bit values from the image to the SMEs and other hardware elements or by loading the image into one or more registers and then writing the bit values from the registers to the SMEs and other hardware elements . In an example the state of the programmable switches e.g. inter block switches intra block switches and intra row switches . In an example the hardware elements e.g. SMEs other elements programmable switches of the FSM engine are memory mapped such that a programming device and or computer can load the image onto the FSM engine by writing the image to one or more memory addresses.

Method examples described herein can be machine or computer implemented at least in part. Some examples can include a computer readable medium or machine readable medium encoded with instructions operable to configure an electronic device to perform methods as described in the above examples. An implementation of such methods can include code such as microcode assembly language code a higher level language code or the like. Such code can include computer readable instructions for performing various methods. The code may form portions of computer program products. Further the code may be tangibly stored on one or more volatile or non volatile computer readable media during execution or at other times. These computer readable media may include but are not limited to hard disks removable magnetic disks removable optical disks e.g. compact disks and digital video disks magnetic cassettes memory cards or sticks random access memories RAMs read only memories ROMs and the like.

Thus other embodiments can be realized. For example an article of manufacture such as a computer a memory system a magnetic or optical disk some other storage device or any type of electronic device or system can include one or more processors coupled to a computer readable medium such as a memory e.g. removable storage media as well as any memory including an electrical optical or electromagnetic conductor having instructions stored thereon e.g. computer program instructions which when executed by the one or more processors result in performing any of the actions described with respect to the methods above.

The computer can take the form of a computer system having a processor coupled to a number of components directly and or using a bus . Such components can include main memory static or non volatile memory and mass storage . Other components coupled to the processor can include an output device such as a video display an input device such as a keyboard and a cursor control device such as a mouse. A network interface device to couple the processor and other components to a network can also be coupled to the bus . The instructions can further be transmitted or received over the network via the network interface device utilizing any one of a number of well known transfer protocols e.g. HTTP . Any of these elements coupled to the bus can be absent present singly or present in plural numbers depending on the specific embodiment to be realized.

In an example one or more of the processor the memories or the storage device can each include instructions that when executed can cause the computer to perform any one or more of the methods described herein. In alternative embodiments the computer operates as a standalone device or can be connected e.g. networked to other devices. In a networked environment the computer can operate in the capacity of a server or a client device in server client network environment or as a peer device in a peer to peer or distributed network environment. The computer can include a personal computer PC a tablet PC a set top box STB a Personal Digital Assistant PDA a cellular telephone a web appliance a network router switch or bridge or any device capable of executing a set of instructions sequential or otherwise that specify actions to be taken by that device. Further while only a single computer is illustrated the term computer shall also be taken to include any collection of devices that individually or jointly execute a set or multiple sets of instructions to perform any one or more of the methodologies discussed herein.

The computer can also include an output controller for communicating with peripheral devices using one or more communication protocols e.g. universal serial bus USB IEEE 1394 etc. The output controller can for example provide an image to a programming device that is communicatively coupled to the computer . The programming device can be configured to program a parallel machine e.g. parallel machine FSM engine . In other examples the programming device can be integrated with the computer and coupled to the bus or can communicate with the computer via the network interface device or another device.

While the computer readable medium is shown as a single medium the term computer readable medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database or associated caches and servers and or a variety of storage media such as the processor registers memories and the storage device that store the one or more sets of instructions . The term computer readable medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the computer and that cause the computer to perform any one or more of the methodologies of the present invention or that is capable of storing encoding or carrying data structures utilized by or associated with such a set of instructions. The term computer readable medium shall accordingly be taken to include but not be limited to tangible media such as solid state memories optical and magnetic media.

The Abstract is provided to comply with 37 C.F.R. Section 1.72 b requiring an abstract that will allow the reader to ascertain the nature and gist of the technical disclosure. It is submitted with the understanding that it will not be used to limit or interpret the scope or meaning of the claims. The following claims are hereby incorporated into the detailed description with each claim standing on its own as a separate embodiment.

Example 1 includes a programmable device having a plurality of programmable elements wherein the programmable elements are configured to implement one or more finite state machines wherein the plurality of programmable elements are configured to receive a N digit input and provide a M digit output as a function of the N digit input wherein the M digit output includes state information from less than all of the programmable elements.

Example 2 includes a hierarchical parallel machine having a first parallel machine comprising a plurality of programmable elements wherein the programmable elements are configured to implement one or more finite state machines wherein the plurality of programmable elements are configured to receive a N digit input and provide a M digit output as a function of the N digit input wherein the M digit output includes state information from less than all of the programmable elements and a second parallel machine configured to receive and process at least part of the M digit output.

Example 3 includes a programmable device having a plurality of programmable elements wherein the programmable elements are configured to implement one or more finite state machines wherein the plurality of programmable elements are configured to receive a N digit input and provide a M digit output as a function of the N digit input wherein the M digit output is formed by compressing state information from each of the programmable elements.

Example 4 includes a hierarchical parallel machine having a first parallel machine comprising a plurality of programmable elements wherein the programmable elements are configured to implement one or more finite state machines wherein the plurality of programmable elements are configured to receive a N digit input and provide a M digit output as a function of the N digit input wherein the M digit output is formed by compressing state information from each of the programmable elements.

Example 5 includes a method of providing state information from a parallel machine to another device wherein the parallel machine includes a plurality of programmable elements wherein each of the programmable elements is configured to have a corresponding state. The method includes determining state information wherein the state information comprises the state of each of the programmable elements in the parallel machine compressing the state information and providing the compressed state information to the other device

Example 6 includes a hierarchical parallel machine having a first level parallel machine having at least one N digit input and a plurality of N digit outputs wherein each of the N digit outputs corresponds to a respective group of N state machines implemented on the first level parallel machine.

Example 7 includes a parallel machine comprising a plurality of programmable elements configured to implement at least one finite state machine. The parallel making is configured to determine state information wherein the state information comprises the state of each of the programmable elements compress the state information and provide the compressed state information to another device.

In Example 8 the subject matter of any of Examples 1 7 can optionally include wherein the plurality of programmable elements comprises one of two or more groups of programmable elements.

In Example 9 the subject matter of any of Examples 1 8 can optionally include an N digit input interface coupled to the one group of programmable elements and configured to receive the N digit input and a M digit output interface coupled to the one group of programmable elements and configured to provide the M digit output

In Example 10 the subject matter of any of Examples 1 9 can optionally include wherein the one group of programmable elements comprises a block of programmable elements.

In Example 11 the subject matter of any of Examples 1 10 can optionally include wherein the block of programmable elements comprises a plurality of rows of programmable elements wherein each of the rows is coupled to a respective one of a plurality of intra block switches.

In Example 12 the subject matter of any of Examples 1 11 can optionally include wherein the programmable elements in each of the rows comprises a plurality of groups of two state machine elements and another programmable element.

In Example 13 the subject matter of any of Examples 1 12 can optionally include a programmable switch configured to selectively couple the one group of programmable elements to another one of the groups of programmable elements an input port and or an output port.

In Example 14 the subject matter of any of Examples 1 13 can optionally include a register configured to store a program configured to program the plurality of programmable elements and the plurality of programmable switches.

In Example 16 the subject matter of any of Examples 1 15 can optionally include wherein M is an integer multiple of N.

In Example 17 the subject matter of any of Examples 1 16 can optionally include OR logic configured to aggregate output from two or more of the programmable elements used to implement a same one of the finite state machines.

In Example 18 the subject matter of any of Examples 1 17 can optionally include wherein the programmable elements are configured to implement a logical group of N state machines wherein the outputs of the N state machines are aggregated to provide the M digit output.

In Example 19 the subject matter of any of Examples 1 18 can optionally include wherein the logic comprises an OR gate.

In Example 20 the subject matter of any of Examples 1 19 can optionally include wherein the state information included in the M digit output comprises compressed state information.

In Example 21 the subject matter of any of Examples 1 20 can optionally include wherein the plurality of programmable elements comprise state machine elements.

In Example 22 the subject matter of any of Examples 1 21 can optionally include wherein the M digit output comprises a difference vector.

In Example 23 the subject matter of any of Examples 1 22 can optionally include wherein each state in the implemented one or more finite state machines corresponds to a respective digit in a state vector and wherein the difference vector includes only those digits in the state vector that change in response to an input symbol provided to the programmable device.

In Example 24 the subject matter of any of Examples 1 23 can optionally include wherein each state in the implemented one or more finite state machines corresponds to a respective digit in a state vector and wherein the M digit output comprises only a subset of the digits in the state vector.

In Example 25 the subject matter of any of Examples 1 24 can optionally include wherein the subset of the digits comprises those digits corresponding to final states in the one or more finite state machines.

In Example 26 the subject matter of any of Examples 1 25 can optionally include wherein all state machines implemented in the device receive the N digit input.

In Example 27 the subject matter of any of Examples 1 26 can optionally include wherein the plurality of programmable elements comprise one of two or more groups of programmable elements wherein each of the groups has its own dedicated input.

In Example 28 the subject matter of any of Examples 1 27 can optionally include wherein the N digit input is on a bottom of a semiconductor die and wherein the M digit output is on a top of the semiconductor die.

In Example 29 the subject matter of any of Examples 1 28 can optionally include wherein the plurality of programmable elements comprise one of two or more groups of programmable elements and wherein the programmable device is configured to provide state information from one of the groups to another one of the groups in the programmable device.

In Example 30 the subject matter of any of Examples 1 29 can optionally include wherein the second parallel machine is configured to receive and process the whole M digit output.

In Example 31 the subject matter of any of Examples 1 30 can optionally include an input bus coupled to the first parallel machine and configured to provide the N digit input and an output bus coupled between the first parallel machine and the second parallel machine the output bus being configured to provide at least part of the M digit output to the second parallel machine.

In Example 32 the subject matter of any of Examples 1 31 can optionally include wherein the input bus and output bus are equal in size.

In Example 33 the subject matter of any of Examples 1 32 can optionally include wherein the corresponding groups in the first and second parallel machines are coupled by a respective group of interconnects.

In Example 34 the subject matter of any of Examples 1 33 can optionally include wherein the M digit output is provided to each state machine implemented in the second parallel machine.

In Example 35 the subject matter of any of Examples 1 34 can optionally include wherein the second parallel machine comprises a plurality of programmable elements grouped into a plurality of groups wherein the M digit output is provided to a respective one of the groups according to a pre defined manner.

In Example 36 the subject matter of any of Examples 1 35 can optionally include wherein the second parallel machine comprises a plurality of programmable elements configured to send address information to the second parallel machine wherein the address information indicates to which of the groups in the second parallel machine the M digit output is being provided.

In Example 37 the subject matter of any of Examples 1 36 can optionally include wherein the parallel machines are stacked.

In Example 38 the subject matter of any of Examples 1 37 can optionally include wherein the plurality of programmable elements comprise one of two or more groups of programmable elements further comprising logic corresponding to each group wherein the logic corresponding to a respective one of the groups aggregates state information from two or more programmable elements in that group and wherein one or more digits of the M digit output from that group is a function of such logic.

In Example 39 the subject matter of any of Examples 1 38 can optionally include wherein the M digit output is formed by compressing state information from the programmable elements.

In Example 40 the subject matter of any of Examples 1 39 can optionally include logic configured to aggregate output from two or more of the programmable elements used to implement a same one of the finite state machines.

In Example 41 the subject matter of any of Examples 1 40 can optionally include wherein the programmable elements are configured to implement a logical group of N state machines wherein the outputs of the N state machines are aggregated to provide the M digit output.

In Example 42 the subject matter of any of Examples 1 41 can optionally include wherein compressing the state information includes applying a lossless compression algorithm to the state information.

In Example 43 the subject matter of any of Examples 1 42 can optionally include wherein providing the compressed state information to the other device comprises providing the compressed state information to another parallel machine.

In Example 44 the subject matter of any of Examples 1 43 can optionally include wherein providing the compressed state information to the other device comprises providing the compressed state information to system memory.

In Example 45 the subject matter of any of Examples 1 44 can optionally include wherein compressing the state information comprises aggregating final states in a finite state machine implemented on the parallel machine.

In Example 46 the subject matter of any of Examples 1 45 can optionally include a first level parallel machine having at least one N digit input and a plurality of N digit outputs wherein each of the N digit outputs corresponds to a respective group of N state machines implemented on the first level parallel machine.

In Example 47 the subject matter of any of Examples 1 46 can optionally include wherein at least one of the state machines implemented on the first level parallel machine includes a plurality of programmable elements corresponding to a plurality of final states of the at least one state machine wherein the output of the plurality of programmable elements corresponding to the plurality of final states are aggregated together to provide one digit of one of the N digit outputs.

In Example 48 the subject matter of any of Examples 1 47 can optionally include wherein data provided on one of the N digit outputs encodes the status of the final states for the respective group of N state machines implemented on the first level parallel machine.

In Example 49 the subject matter of any of Examples 1 48 can optionally include wherein the first level parallel machine comprises a finite state machine engine.

In Example 50 the subject matter of any of Examples 1 49 can optionally include wherein the finite state machine engine comprises an array of groups of programmable elements and wherein each of the groups of programmable elements is coupled to a respective one of the N digit outputs.

In Example 51 the subject matter of any of Examples 1 50 can optionally include wherein the first level parallel machine has a plurality of N digit input and wherein each of the groups of programmable elements is coupled to a respective one of the N digit inputs of the first level parallel machine.

In Example 52 the subject matter of any of Examples 1 51 can optionally include wherein the second level parallel machine comprises a finite state machine engine.

In Example 53 the subject matter of any of Examples 1 52 can optionally include wherein the finite state machine engine comprises an array of groups of programmable elements and wherein each of the groups of programmable elements is coupled to a respective one of the N digit inputs.

In Example 54 the subject matter of any of Examples 1 53 can optionally include wherein the second level parallel machine has a plurality of N digit outputs and wherein each of the groups of programmable elements is coupled to a respective one of the N digit output of the second level parallel machine.

In Example 55 the subject matter of any of Examples 1 54 can optionally include wherein the first parallel machine comprises a first die and the second parallel machine comprises a second die stacked with the first die.

In Example 56 subject matter of any of Examples 1 55 can optionally include further comprising a third parallel machine and a bus wherein the third parallel machine comprises a third dies stacked with the first die and the second die wherein the second die is between the first die and the third die in the stack and wherein the bus is configured to transfer state information between the first parallel machine and the third parallel machine.

In Example 57 the subject matter of any of Examples 1 56 can optionally include wherein the bus comprises a plurality of interconnects.

In Example 58 the subject matter of any of Examples 1 57 can optionally include wherein the interconnects comprise through via interconnects.

In Example 59 the subject matter of any of Examples 1 58 can optionally include wherein the parallel machines comprise finite state machine engines.

In Example 60 the subject matter of any of Examples 1 59 can optionally include wherein the finite state machine engines comprise pattern recognition processors.

In Example 61 the subject matter of any of Examples 1 60 can optionally include wherein the parallel machines comprise field programmable gate arrays.

In Example 62 the subject matter of any of Examples 1 61 can optionally include wherein the at least one N digit input of the first level parallel machine is configured to receive raw data.

In Example 63 the subject matter of any of Examples 1 62 can optionally include wherein each of the N digit inputs of the second level parallel machine correspond to a respective group of N state machines implemented on the second level parallel machine wherein each group of N state machines implemented on the second level parallel machine is driven by up to N state machines implemented on the first level parallel machine.

In Example 64 the subject matter of any of Examples 1 63 can optionally include wherein the other device comprises a second parallel machine wherein the second parallel machine is configured to receive and process the compressed state information.

In Example 65 the subject matter of any of Examples 1 64 can optionally include wherein the parallel machine being configured to compress the state information comprises the parallel machine being configured to aggregate final states of a finite state machine implemented on the parallel machine.

In Example 66 the subject matter of any of Examples 1 65 can optionally include Boolean logic configured to aggregate the final states.

In Example 67 the subject matter of any of Examples 1 66 can optionally include wherein the parallel machine being configured to compress the state information comprises the parallel machine being configured to output a difference vector wherein the difference vector identifies only those states that have changed in response to an input symbol.

In Example 68 the subject matter of any of Examples 1 67 can optionally include wherein the parallel machine being configured to compress the state information comprises the parallel machine being configured to output an output vector wherein the output vector only provides state information for final states in a finite state machine implemented on the parallel machine.

