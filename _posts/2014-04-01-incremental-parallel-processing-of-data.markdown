---

title: Incremental parallel processing of data
abstract: One example method includes identifying synchronous code including instructions specifying a computing operation to be performed on a set of data; transforming the synchronous code into a pipeline application including one or more pipeline objects; identifying a first input data set on which to execute the pipeline application; executing the pipeline application on a first input data set to produce a first output data set; after executing the pipeline application on the first input data set, identifying a second input data set on which to execute the pipeline application; determining a set of differences between the first input data set and second input data set; and executing the pipeline application on the set of differences to produce a second output data set.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09268597&OS=09268597&RS=09268597
owner: Google Inc.
number: 09268597
owner_city: Mountain View
owner_country: US
publication_date: 20140401
---
Large scale data processing may include parallel processing which generally involves performing some operation over each element of a large data set simultaneously. The various operations may be chained together in a data parallel pipeline to create an efficient mechanism for processing a data set. Production of the data set may involve batch jobs that are run periodically over a set of large evolving inputs. As the inputs are updated the previous output becomes more and more stale so the pipeline is re run on a regular basis.

The present disclosure relates to performing incremental processing of data in a parallel processing system.

In general one innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of identifying synchronous code including instructions specifying a computing operation to be performed on a set of data transforming the synchronous code into a pipeline application including one or more pipeline objects the pipeline application configured to be executed in parallel across a plurality of computing devices each of the one or more pipeline objects configured to receive an input data set and produce an output data set identifying a first input data set on which to execute the pipeline application executing the pipeline application on a first input data set to produce a first output data set the executing the pipeline application including executing each of the one or more pipeline objects in an order in which a previous pipeline object provides its output data set to a next pipeline object as its input data set after executing the pipeline application on the first input data set identifying a second input data set on which to execute the pipeline application determining a set of differences between the first input data set and second input data set and executing the pipeline application on the set of differences to produce a second output data set the executing the pipeline application on the set of differences including executing each of the one or more pipeline objects includes each previous pipeline object in the order providing differences from its previous output data set to the next pipeline object as its input data set and the second output data set including differences from the first output data set. Other embodiments of this aspect include corresponding systems apparatus and computer programs configured to perform the actions of the methods encoded on computer storage devices.

Particular embodiments of the subject matter described in this specification can be implemented so as to realize one or more of the following advantages. Reprocessing a complete input data set each time a pipeline is rerun may be wasteful and for large pipelines the amount of time it takes to run the pipeline limits how frequently it can be run. However by processing the differences between the first and second input data sets the amount of time necessary to process subsequent data sets may be reduced allowing the pipeline to produce updated output data sets more quickly. Further as the designer only writes and maintains one version of synchronous code the pitfalls of maintaining separate batch and incremental systems may be avoided.

The system can automatically derive changes that need to be done to the output given the changes in the input. This reduces or eliminate manual maintenance of the pipeline which in turn also reduces costs. Correctness issues related to maintaining multiple versions of a pipeline may also be alleviated. In addition processing only the changes to the input set may lead to a reduction of compute resources necessary for subsequent executions of the pipeline in cases where the input set has not changed significantly. Lower latency may also be obtained by processing only changes to the input set.

The details of one or more embodiments of the subject matter described in this specification are set forth in the accompanying drawings and the description below. Other features aspects and advantages of the subject matter will become apparent from the description the drawings and the claims.

The present disclosure relates to performing incremental processing of data in a parallel processing system. In some implementations a batch pipeline viewed as an execution plan as series of steps to be applied to some collection of records is transformed into an incremental execution plan that can be executed on a set of differences additions or removals from the original collection to produce a set of differences that can be applied to the previous output collection to produce a collection equivalent to the collection that would have been produced by running the original pipeline on the entire new input. The system in some implementations also detects what the changes to the inputs are and to applies the set of output differences to the final output.

Parallel processing frameworks provide a platform for processing large amounts of data in parallel by multiple computing devices. Users may define pipelines or pipeline applications including steps for processing an input data set to produce an output data set. One common parallel processing framework is the MapReduce framework in which distributed computations are divided into a map step to divide an input set into smaller groups and a reduce step to perform an operation on each of the groups. Such frameworks generally operate in a batch mode such that an entire input data set must be processed by the pipeline each time it is run to produce an output data set even if only a few values in the input data set have been added changed or deleted since the pipeline was last run. This may lead to repeated processing of input and high latency for large input data sets. For certain applications output data that is more up to date than the frequency with which the pipeline can be run may be necessary. In such a case a second system may be constructed to handle such incremental updates. Such an approach often adds complexity and maintenance overhead especially as the original pipeline evolves. Being able to express the computation in a single framework and run the same code in both batch and incremental mode would be advantageous.

In addition the ability to define both modes of operation in synchronous code is also desirable. Synchronous code contains programming instructions presenting a sequential series of steps. This is in contrast to asynchronous code which may be implemented as a finite state machine an event handler or other programming constructs that involve waiting for and responding to input. Generally synchronous code is easier for humans to author and understand than asynchronous code as the operation and program flow of asynchronous code may not be readily identifiable from the code itself.

Accordingly the present disclosure describes a parallel data processing framework that allows for batch and incremental processing operations to be defined in synchronous code. One example method includes identifying the synchronous code and transforming it into a pipeline including pipeline objects. The pipeline may then be executed on a first input data set to produce a first output data set. When the pipeline is run on a second input data set a set of differences between the first input data set and the second input data set is determined. The pipeline is then executed on these differences to produce a second output data set.

By processing the differences between the first and second input data sets the amount of time necessary to process subsequent data sets may be reduced allowing the pipeline to produce updated output data sets more quickly. Further as the designer only writes and maintains one set of synchronous code the pitfalls of maintaining separate batch and incremental systems may be avoided.

Environment includes an optimizer . As shown the optimizer is operable to analyze the synchronous code and produce the pipeline . In some implementations the optimizer may be a software program or set of software programs operable to analyze the synchronous code and produce the corresponding pipeline to perform the data processing actions defined by the synchronous code . The optimizer may also be a software library that may be imported by the author into the synchronous code and may be executed when the synchronous code is compiled and run. In some implementations the optimizer may be a server or set of servers to which the synchronous code may be submitted such as through an Application Programming Interface API over a network via one or more network protocols or through other mechanisms.

In some implementations the optimizer may determine whether to produce a pipeline that operates in batch mode such that the entire input data set is processed each time the pipeline is run or incremental mode such that only differences in the input data set from the last run are processed. In some cases this determination may be made based on input to the optimizer by a user. The determination may also be made automatically by the optimizer such as by analyzing the synchronous code the input data set or based on other analysis. For example the optimizer may examine the size of the input data set and determine that because it contains few items a batch mode pipeline should be produced. In another example the optimizer may examine the size of the input data set and determine that the set contains a large number of items. The optimizer may also determine such as by interaction with a user that the pipeline to be produced is to be run often. In such a case the optimizer may determine that an incremental mode pipeline should be produced.

The synchronous code may include instructions for processing the input data set to produce the output data set . For example the synchronous code may include a series of sequential instructions describing how the input data set is to be processed. The sequential instructions included in the synchronous code may be function calls procedure calls loops conditionals or other programming language instructions. The synchronous code is synchronous in the sense that it presents a sequential series of steps. This is in contrast to asynchronous code which may be implemented as a finite state machine an event handler or other programming constructs that involve waiting for and responding to input. Generally synchronous code is easier for humans to author and understand as the operation and program flow of asynchronous code may not be readily identifiable from the code itself.

In some implementations the synchronous code may include instructions coded according to a programming language such as for example JAVA PYTHON PERL C C C JAVASCRIPT or other programming languages or combinations of processing languages. In some cases synchronous code may be embedded within a larger application such that only a portion of the application s code is optimized by the optimizer .

The optimizer analyzes e.g. transforms synchronous code to produce the pipeline . In some implementations the pipeline is a distributed application operable to perform the operations defined in the synchronous code . In some implementations the optimizer may create the pipeline when the synchronous code is executed. The optimizer may deploy the pipeline across one or more servers and instantiate the pipeline to begin the processing of the input data set . In some implementations the optimizer may communicate with other components within the environment deploy the pipeline for execution.

As shown the pipeline includes one or more pipeline objects . In some implementations the pipeline objects each correspond to an instruction or set of instructions within the synchronous code . The optimizer creates and executes the pipeline objects in response to such instructions in the synchronous code . In some implementations the pipeline objects may be independent software programs that may be run on separate servers in parallel. The pipeline objects may be arranged in an execution order such that the output of one pipeline object e.g. may serve as input to another pipeline object e.g . The operation of the pipeline objects is discussed in greater detail relative to .

In operation the pipeline objects perform various operations or transformations on the input data set to produce the output data set . In some implementations the optimizer generates the pipeline objects based on a mapping of synchronous code instructions to types of pipelines objects. For example in a case where the synchronous code defines a MapReduce operation the pipeline object may be a mapper object generated in response to a map function in the synchronous code the pipeline object may be a shuffler object generated in response to a shuffle function in the synchronous code and the pipeline object may be a reducer object generated in response to a reduce function in the synchronous code . The pipeline objects may also perform other operations such as for example aggregation combination grouping by keys flattening joining counting removing duplicate items and other operations and may be generated in generated in response to corresponding functions in the synchronous code .

Environment also includes an input data set to be processed by the pipeline . In some implementations the input data set may be a database table a text or binary file a data stream a collection of data shards a collection of key value pairs or another type of data set or combination of types of data sets. In some implementations the input data set may be received by the pipeline such as over a network or as standard input to a program. The input data set may also be requested or retrieved by the pipeline on startup or incrementally as execution proceeds.

The environment also includes output data set . In operation the output data set is produced by the pipeline by processing the input data set . The output data set represents the end product of the operation defined by the synchronous code . For example if synchronous code defines an operation in which occurrences of each letter within the input set are to be counted the output data set may include a collection of counts for each letter. In some implementations the output data set may be updated by the pipeline as the operation occurs. In some cases the output data set may be produced at the conclusion of execution of the pipeline . The output data set may be a collection of data such as for example a database table or collection of database tables a text file a set of key value pairs a data stream or other types of data.

The data store may be a database a file system a key value store or other type of data store. The pipeline and the pipeline objects may write to and read from the data store during execution the pipeline . The data store may be a central data store as shown in or may be a distributed story including a plurality of nodes. In some implementations the data store may include storage associated with each server executing the pipeline such as the servers from .

The data store includes a pipeline state . In some implementations the pipeline state may be a representation of the previous execution of the pipeline . The data store may store multiple pipeline states . In some cases each instance of the pipeline may store a different pipeline state . The pipeline state may store representation of the input data set for the last execution of the pipeline . The pipeline may update the pipeline state to indicate changes in the input data set for each execution. For example the pipeline may for each item in the input data set check the pipeline state to determine if the item was processed during the last execution of the pipeline . If the item was not processed in the last execution the pipeline may add the new item to the pipeline state and may begin processing process the item in the current execution. By checking the pipeline state in this manner the pipeline may avoid processing items processed during the previous execution and thus implement an incremental processing mode. The pipeline may also determine items that have been removed from the input data set and remove these items from the pipeline state .

In some implementations the pipeline state may be stored as a set of items in the data store . In a case where the input data set is stored in the same or a similar data store the pipeline may perform a set comparison between the input data set and the pipeline state to determine differences between the two sets. The pipeline may then process these differences to produce the output data set .

In some implementations the pipeline state may include representation of the output data set for the last execution of the pipeline . The pipeline may update this representation of the output data set as new items from the input data set are processed and as deleted items from the input data set are identified. The pipeline may then produce this updated output data set as its output for the current execution. In some cases the pipeline may produce only new output e.g. output generated by new input data instead of the full output data set .

The data store also includes pipeline object states . In some cases each of the pipeline object states corresponds to one of the pipeline objects . The pipeline object states may store state information associated with the individual pipeline objects from the previous execution of the pipeline . The pipeline objects may use this previous state data when operating in incremental mode. For example an aggregator object that produces counts of different items encountered in the input data set may produce incomplete or erroneous results if it is only presented with changes to the input data set during execution. By storing the item counts encountered in the input data set for the previous execution the aggregator may update these counts during execution of the pipeline and produce updated results indicative of the modified input data set . In some implementations the pipeline object states may be stored as key value pairs with a compound key including the item s key found in the input data set and an identifier for the pipeline object associated with the state.

At the synchronous code is transformed into a pipeline application including one or more pipeline objects. In some implementations the transformation involves instantiating new software objects or programs to implement the steps of the synchronous code such as the pipeline object described relative to . In some cases the transformation of the synchronous code may be performed based on the size or other attributes of the input data set. For example the synchronous code may be transformed into a single instance of a pipeline for a small input data set e.g. one that can be processed quickly on a single computing device but may be transformed into multiple distributed pipeline instances on different servers for a large input data set e.g. one that cannot be processed in a reasonable amount of time on a single computing device .

At first input data set on which to execute the pipeline application is identified. In some cases the first input data set is transformed into a first set of key value pairs and stored in a key value store. The first input data set may be a data stream a database table a file or set of files or another type of data set.

At the pipeline application is executed on the first input data set to produce a first output data set. In some cases executing the pipeline application includes processing all items in the first input data set with the pipeline objects included in the pipeline application to produce the first output data set.

At a second input data set on which to execute the pipeline application is identified after executing the pipeline application on the first input data set. In some cases the second input data set may be the first input data set with a number of additional and or deleted items. At a set of differences between the first input data set and the second input data set is determined. In some implementations determining the differences includes transforming the second input data set into a second set of key value pairs comparing the second set of key value pairs to first set of key value pairs and identifying key value pairs that have been added or deleted from the second set of key value pairs relative to the first set of key value pairs. Determining the differences may also include determining a last execution timestamp for the pipeline representing a time at which the pipeline was executed on the first input data set and identifying a set of items in the second input data set including timestamps after the last execution timestamp. At the pipeline application is executed on the set of differences to produce a second output data set.

In some cases the process includes determining a pipeline state in response to executing the pipeline on the first input data set the pipeline state including a representation of the first input data set and the first output data set. The pipeline state may be updated in response to executing the pipeline on the set of differences from the first input data set to generate an updated pipeline state the updated pipeline state including a representation of the second input data set and the second output data set. In some cases a pipeline object state may be determined for each of the one or more pipeline objects in response to executing the pipeline on the first input data set the pipeline object state including a representation of the input data set and the output data set for the pipeline object. The pipeline object state may also be updated in response to executing the pipeline on the set of differences from the first input data set to generate an updated pipeline object state the updated pipeline object state including differences from the input data set and the output data set for the pipeline object

Computing device includes a processor memory a storage device a high speed interface connecting to memory and high speed expansion ports and a low speed interface connecting to low speed bus and storage device . Each of the components and are interconnected using various busses and may be mounted on a common motherboard or in other manners as appropriate. The processor can process instructions for execution within the computing device including instructions stored in the memory or on the storage device to display graphical information for a GUI on an external input output device such as display coupled to high speed interface . In other implementations multiple processors and or multiple buses may be used as appropriate along with multiple memories and types of memory. Also multiple computing devices may be connected with each device providing portions of the necessary operations e.g. as a server bank a group of blade servers or a multi processor system .

The memory stores information within the computing device . In one implementation the memory is a volatile memory unit or units. In another implementation the memory is a non volatile memory unit or units. The memory may also be another form of computer readable medium such as a magnetic or optical disk.

The storage device is capable of providing mass storage for the computing device . In one implementation the storage device may be or contain a computer readable medium such as a floppy disk device a hard disk device an optical disk device or a tape device a flash memory or other similar solid state memory device or an array of devices including devices in a storage area network or other configurations. A computer program product can be tangibly embodied in an information carrier. The computer program product may also contain instructions that when executed perform one or more methods such as those described above. The information carrier is a computer or machine readable medium such as the memory the storage device or memory on processor .

The high speed interface manages bandwidth intensive operations for the computing device while the low speed interface manages lower bandwidth intensive operations. Such allocation of functions is exemplary only. In one implementation the high speed interface is coupled to memory display e.g. through a graphics processor or accelerator and to high speed expansion ports which may accept various expansion cards not shown . In the implementation low speed interface is coupled to storage device and low speed expansion port . The low speed expansion port which may include various communication ports e.g. USB Bluetooth Ethernet wireless Ethernet may be coupled to one or more input output devices such as a keyboard a pointing device a scanner or a networking device such as a switch or router e.g. through a network adapter.

The computing device may be implemented in a number of different forms as shown in the figure. For example it may be implemented as a standard server or multiple times in a group of such servers. It may also be implemented as part of a rack server system . In addition it may be implemented in a personal computer such as a laptop computer . Alternatively components from computing device may be combined with other components in a mobile device not shown such as device . Each of such devices may contain one or more of computing device and an entire system may be made up of multiple computing devices communicating with each other.

Computing device includes a processor memory an input output device such as a display a communication interface and a transceiver among other components. The device may also be provided with a storage device such as a microdrive or other device to provide additional storage. Each of the components and are interconnected using various buses and several of the components may be mounted on a common motherboard or in other manners as appropriate.

The processor can execute instructions within the computing device including instructions stored in the memory . The processor may be implemented as a chipset of chips that include separate and multiple analog and digital processors.

Additionally the processor may be implemented using any of a number of architectures. For example the processor may be a CISC Complex Instruction Set Computers processor a RISC Reduced Instruction Set Computer processor or an MISC Minimal Instruction Set Computer processor. The processor may provide for example for coordination of the other components of the device such as control of user interfaces applications run by device and wireless communication by device .

Processor may communicate with a user through control interface and display interface coupled to a display . The display may be for example a TFT Thin Film Transistor Liquid Crystal Display display or an OLED Organic Light Emitting Diode display or other appropriate display technology. The display interface may comprise appropriate circuitry for driving the display to present graphical and other information to a user. The control interface may receive commands from a user and convert them for submission to the processor . In addition an external interface may be provided in communication with processor so as to enable near area communication of device with other devices. External interface may provide for example for wired communication in some implementations or for wireless communication in other implementations and multiple interfaces may also be used.

The memory stores information within the computing device . The memory can be implemented as one or more of a computer readable medium or media a volatile memory unit or units or a non volatile memory unit or units. Expansion memory may also be provided and connected to device through expansion interface which may include for example a SIMM Single In Line Memory Module card interface. Such expansion memory may provide extra storage space for device or may also store applications or other information for device . Specifically expansion memory may include instructions to carry out or supplement the processes described above and may include secure information also. Thus for example expansion memory may be provided as a security module for device and may be programmed with instructions that permit secure use of device . In addition secure applications may be provided via the SIMM cards along with additional information such as placing identifying information on the SIMM card in a non hackable manner.

The memory may include for example flash memory and or NVRAM memory as discussed below. In one implementation a computer program product is tangibly embodied in an information carrier. The computer program product contains instructions that when executed perform one or more methods such as those described above. The information carrier is a computer or machine readable medium such as the memory expansion memory or memory on processor that may be received for example over transceiver or external interface .

Device may communicate wirelessly through communication interface which may include digital signal processing circuitry where necessary. Communication interface may provide for communications under various modes or protocols such as GSM voice calls SMS EMS or MMS messaging CDMA TDMA PDC WCDMA CDMA2000 or GPRS among others. Such communication may occur for example through radio frequency transceiver . In addition short range communication may occur such as using a Bluetooth WiFi or other such transceiver not shown . In addition GPS Global Positioning System receiver module may provide additional navigation and location related wireless data to device which may be used as appropriate by applications running on device .

Device may also communicate audibly using audio codec which may receive spoken information from a user and convert it to usable digital information. Audio codec may likewise generate audible sound for a user such as through a speaker e.g. in a handset of device . Such sound may include sound from voice telephone calls may include recorded sound e.g. voice messages music files etc. and may also include sound generated by applications operating on device .

The computing device may be implemented in a number of different forms as shown in the figure. For example it may be implemented as a cellular telephone . It may also be implemented as part of a smartphone personal digital assistant or other similar mobile device.

In various implementations operations that are performed in response to or as a consequence of another operation e.g. a determination or an identification are not performed if the prior operation is unsuccessful e.g. if the determination was not performed . Operations that are performed automatically are operations that are performed without user intervention e.g. intervening user input . Features in this document that are described with conditional language may describe implementations that are optional. In some examples transmitting from a first device to a second device includes the first device placing data into a network for receipt by the second device but may not include the second device receiving the data. Conversely receiving from a first device may include receiving the data from a network but may not include the first device transmitting the data.

 Determining by a computing system can include the computing system requesting that another device perform the determination and supply the results to the computing system. Moreover displaying or presenting by a computing system can include the computing system sending data for causing another device to display or present the referenced information.

Embodiments of the subject matter and the operations described in this specification can be implemented in digital electronic circuitry or in computer software firmware or hardware including the structures disclosed in this specification and their structural equivalents or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs i.e. one or more modules of computer program instructions encoded on computer storage medium for execution by or to control the operation of data processing apparatus. Alternatively or in addition the program instructions can be encoded on an artificially generated propagated signal e.g. a machine generated electrical optical or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. A computer storage medium can be or be included in a computer readable storage device a computer readable storage substrate a random or serial access memory array or device or a combination of one or more of them. Moreover while a computer storage medium is not a propagated signal a computer storage medium can be a source or destination of computer program instructions encoded in an artificially generated propagated signal. The computer storage medium can also be or be included in one or more separate physical components or media e.g. multiple CDs disks or other storage devices .

The operations described in this specification can be implemented as operations performed by a data processing apparatus on data stored on one or more computer readable storage devices or received from other sources.

The term data processing apparatus encompasses all kinds of apparatus devices and machines for processing data including by way of example a programmable processor a computer a system on a chip or multiple ones or combinations of the foregoing The apparatus can include special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit . The apparatus can also include in addition to hardware code that creates an execution environment for the computer program in question e.g. code that constitutes processor firmware a protocol stack a database management system an operating system a cross platform runtime environment a virtual machine or a combination of one or more of them. The apparatus and execution environment can realize various different computing model infrastructures such as web services distributed computing and grid computing infrastructures.

A computer program also known as a program software software application script or code can be written in any form of programming language including compiled or interpreted languages declarative or procedural languages and it can be deployed in any form including as a stand alone program or as a module component subroutine object or other unit suitable for use in a computing environment. A computer program may but need not correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data e.g. one or more scripts stored in a markup language document in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code . A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.

The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus can also be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for performing actions in accordance with instructions and one or more memory devices for storing instructions and data. Generally a computer will also include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. However a computer need not have such devices. Moreover a computer can be embedded in another device e.g. a mobile telephone a personal digital assistant PDA a mobile audio or video player a game console a Global Positioning System GPS receiver or a portable storage device e.g. a universal serial bus USB flash drive to name just a few. Devices suitable for storing computer program instructions and data include all forms of non volatile memory media and memory devices including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user embodiments of the subject matter described in this specification can be implemented on a computer having a display device e.g. a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input. In addition a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user for example by sending web pages to a web browser on a user s user device in response to requests received from the web browser.

Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a user computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification or any combination of one or more such back end middleware or front end components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN and a wide area network WAN an inter network e.g. the Internet and peer to peer networks e.g. ad hoc peer to peer networks .

The computing system can include users and servers. A user and server are generally remote from each other and typically interact through a communication network. The relationship of user and server arises by virtue of computer programs running on the respective computers and having a user server relationship to each other. In some embodiments a server transmits data e.g. an HTML page to a user device e.g. for purposes of displaying data to and receiving user input from a user interacting with the user device . Data generated at the user device e.g. a result of the user interaction can be received from the user device at the server.

While this specification contains many specific implementation details these should not be construed as limitations on the scope of any inventions or of what may be claimed but rather as descriptions of features specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover although features may be described above as acting in certain combinations and even initially claimed as such one or more features from a claimed combination can in some cases be excised from the combination and the claimed combination may be directed to a subcombination or variation of a subcombination.

Similarly while operations are depicted in the drawings in a particular order this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order or that all illustrated operations be performed to achieve desirable results. In certain circumstances multitasking and parallel processing may be advantageous. Moreover the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.

Thus particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. In some cases the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition the processes depicted in the accompanying figures do not necessarily require the particular order shown or sequential order to achieve desirable results. In certain implementations multitasking and parallel processing may be advantageous.

