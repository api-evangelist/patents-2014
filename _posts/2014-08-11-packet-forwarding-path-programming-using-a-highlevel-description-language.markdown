---

title: Packet forwarding path programming using a high-level description language
abstract: In general, this disclosure describes a high-level forwarding path description language (FPDL) for describing internal forwarding paths within a network device. The FPDL enables developers to create a template that describes a section of an internal forwarding path within the forwarding plane of a network device. The FPDL provides syntactical elements for specifying the allocation of forwarding path structures as well as enabling the run-time construction of internal forwarding paths to interconnect the forwarding path structures in a manner specific to packet, packet flow, and/or interface properties, for example. In conjunction with late binding techniques, whereby the control plane of the network device provides arguments to template parameters that drive allocation by the packet forwarding engines of forwarding path structures specified by the FPDL, the techniques provide control plane processes a unified interface with which to manage the operation of the packet forwarding engines.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09106581&OS=09106581&RS=09106581
owner: Juniper Networks, Inc.
number: 09106581
owner_city: Sunnyvale
owner_country: US
publication_date: 20140811
---
This application is a continuation of U.S. application Ser. No. 13 194 571 filed Jul. 29 2011 the entire content of which is incorporated herein by reference.

The invention relates to packet based computer networks and more particularly to forwarding packets within computer networks.

A computer network is a collection of interconnected computing devices that can exchange data and share resources. Example network devices include layer two devices that operate within the second layer of the Open Systems Interconnection OSI reference model i.e. the data link layer and layer three devices that operate within the third layer of the OSI reference model i.e. the network layer. Network devices within computer networks often include a control unit that provides control plane functionality for the network device and forwarding components for routing or switching data units. In some cases for example a network device may include a plurality of packet forwarding engines PFEs and a switch fabric that collectively provide a forwarding plane for forwarding network traffic.

The control plane functions provided by the control unit include storing network topologies in the form of a routing information base RIB executing routing protocols to communicate with peer routing devices to maintain and update the RIB and providing a management interface to allow user access and configuration of the network device. The control unit maintains routing information that represents the overall topology of the network and defines routes to destination prefixes within the network.

The control unit derives a forwarding information base FIB that includes a number of forwarding structures generated by the control unit in accordance with the routing information and control information. The control unit installs the forwarding structures within the data plane to programmatically configure the forwarding components. The data and instructions that constitute the forwarding structures define an internal forwarding path for each incoming packet received by the network device. For example to generate a route table lookup forwarding structure the control unit selects routes defined by the network topology and maps packet key information e.g. destination information and other select information from a packet header to one or more specific next hop network devices and ultimately to one or more specific output interfaces of interface cards of the network device. In some cases the control unit may install the forwarding structures into each of the PFEs to update the FIB within each of the PFEs and control traffic forwarding within the data plane. Bifurcating control and data plane functionality allows the FIB in each of PFEs to be updated without degrading packet forwarding performance of the network device.

In general the disclosure specifies techniques for describing internal forwarding paths within a network device using a high level forwarding path description language. The forwarding path description language enables developers to create a template that describes a section of an internal forwarding path within the forwarding plane of a network device. The forwarding path description language provides syntactical elements for creating the template in a form that specifies the allocation of forwarding path structures as well as enables the run time construction of internal forwarding paths to interconnect the forwarding path structures in a manner specific to packet packet flow and or interface properties for example. In conjunction with late binding techniques whereby the control plane of the network device provides arguments to parameters within the template that drive allocation by the packet forwarding engines of forwarding path structures specified by the high level description language the techniques provide control plane processes a unified interface with which to manage the operation of the packet forwarding engines.

The syntactical elements of the forwarding path description language may include specialized variables to reference instantiated forwarding path structures built in constructor functions for particular forwarding path structure types and argument variables to define interfaces for programs that conform to the language. A program lookup statement causes the forwarding component within the data place e.g. a packet forwarding engine to mark and generate a place holder for a forwarding path lookup for a lookup structure that is populated at run time by operation of control plane processes with items bound to actions specified by the program. A program includes one or more code blocks that contain variable declarations statements and conditions for example to define the program logic for instantiation in the internal forwarding path and execution by a PFE hardware engine or other forwarding component. Program code blocks may be internally referenced by the forwarding component and allow developers to specify execution flow for the program in the forwarding component operating environment which provides a limited calling context.

The described techniques may be useful in advanced devices that bifurcate control and forwarding plane functionality. In such devices the control plane determines the operations of the forwarding plane applied to received packets. As a result control plane processes manage the allocation of forwarding path structures and drive the construction of the internal forwarding path in accordance with data structures such as route tables derived by operation of the control plane processes. However the packet forwarding engines translate directives from the control plane to generate the forwarding paths and hardware engines of the packet forwarding engines perform lookups and otherwise execute the forwarding path to apply services to received packets.

The described techniques may provide one or more advantages. For example the syntax of the forwarding path description language which enables compile time and run time configurability of programs and program operation may enable developers that use the language to both manage allocation of forwarding path structures and drive the construction of the forwarding path by control plane processes at a high level. As a result the forwarding path description language allows developers to combine run time lookup data management with already compiled programs written using the language thus providing a single interface with which to construct the forwarding paths. In addition the forwarding components may bind data received from the control plane to programs already instantiated within the forwarding component to add new features to the forwarding path. As a result the techniques may enable separation between compiled programs and lookup data which may mitigate additional compilation of the programs because of the mixed instruction data architecture of modern packet forwarding engines. Pre compile directives provided for by the forwarding path description language allow programs code sections to be conditionally included according to control plane directives which may reduce the number of permutations of a program required for different hardware. The forwarding path description language additionally includes syntactical elements that may enable developers to overcome limitations of conventional high level programming languages with respect to particular characteristics of the underlying packet forwarding engine architecture such as limited provision for a variable infrastructure and limited support for call return program flow.

In one embodiment the invention is directed to a method comprising sending program text for a program that conforms to a general purpose high level forwarding path description language FPDL from a control unit of a network device to a forwarding component of the network device. The method also comprises compiling the program text with the forwarding component to a platform independent intermediate representation and sending program arguments for the program from the control unit to the forwarding component. The method also includes compiling the intermediate representation with the forwarding component using the program arguments to generate a forwarding path block having one or more forwarding structures for execution by the forwarding component to process packets. The method further comprises installing the forwarding path block to an internal packet forwarding path of the forwarding component receiving a packet with the forwarding component and processing the received packet by executing the forwarding path block.

In another embodiment the invention is directed to a method comprising generating program text for a program that conforms to a high level forwarding path description language FPDL syntax and describes an internal packet forwarding path for a network device. The method also comprises defining a lookup primitive for the network device in the program text and generating a lookup statement in the program text that conforms to the FPDL syntax keys the lookup primitive to a packet property and defines one or more actions for execution upon matching a value for the packet property to an item added to the lookup primitive.

In another embodiment the invention is directed a network device comprising a forwarding component comprising an interface card that receives a packet a compiler a programming interface a key engine and an internal packet forwarding path comprising programmable executable microcode that determines processing of the packet. The network device also comprises a control unit comprising a computer readable storage medium that stores a program that conforms to a general purpose high level forwarding path description language FPDL and a forwarding component interface that sends program text for the program to the forwarding component wherein the forwarding component interface sends program arguments for the program to the forwarding component wherein the programming interface receives the program text and program arguments wherein the compiler compiles the program text to a platform independent intermediate representation and then compiles the intermediate representation using the program arguments to generate a forwarding path block having one or more forwarding structures for execution by the forwarding component to process the packet wherein the programming interface installs the forwarding path block to the internal packet forwarding path of the forwarding component and wherein the key engine processes the packet by executing the forwarding path block.

In another embodiment the invention is directed to non transitory computer readable medium containing instructions. The instructions cause one or more programmable processors to send program text for a program that conforms to a high level forwarding path description language FPDL from a control unit of a network device to a forwarding component of the network device. The instructions also cause the programmable processors to send program arguments for the program from the control unit to the forwarding component. The instructions also cause the programmable processors to compile the program text using the program arguments to generate a forwarding path block having one or more forwarding structures for execution by the forwarding component to process packets. The instructions also cause the programmable processors to install the forwarding path block to an internal packet forwarding path of the forwarding component receive a packet with the forwarding component and process the received packet by executing the forwarding path block.

The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features objects and advantages of the invention will be apparent from the description and drawings and from the claims.

In this example network device includes a control unit that provides control plane functionality for the device. Network device also includes a plurality of forwarding components in the form of example packet forwarding engines A N PFEs and a switch fabric that together provide a data plane for forwarding network traffic. PFEs receive and send data packets via interfaces of interface cards A N IFCs each associated with a respective one of PFEs . Each of PFEs and its associated ones of IFCs may reside on a separate line card for network device not shown . Example line cards include flexible programmable integrated circuit PIC concentrators PFCs dense port concentrators DPCs and modular port concentrators MPCs . Each of IFCs may include interfaces for various combinations of layer two L2 technologies including Ethernet Gigabit Ethernet GigE and Synchronous Optical Networking SONET interfaces. In various aspects each of PFEs may comprise more or fewer IFCs. Switch fabric provides a high speed interconnect for forwarding incoming data packets to the selected one of PFEs for output over a network.

Control unit is connected to each of PFEs by internal communication link . Internal communication link may comprise a 100 Mbps Ethernet connection for instance. Daemons A N daemons executed by control unit are user level processes that run network management software execute routing protocols to communicate with peer routing devices maintain and update one or more routing tables and create one or more forwarding tables for installation to PFEs among other functions.

Control unit may include one or more processors not shown in that execute software instructions such as those used to define a software or computer program stored to a computer readable storage medium again not shown in such as non transitory computer readable mediums including a storage device e.g. a disk drive or an optical drive and or a memory such as random access memory RAM including various forms of dynamic RAM DRAM e.g. DDR2 SDRAM or static RAM SRAM Flash memory another form of fixed or removable storage medium that can be used to carry or store desired program code and program data in the form of instructions or data structures and that can be accessed by a processor or any other type of volatile or non volatile memory that stores instructions to cause the one or more processors to perform techniques described herein. Alternatively or in addition control unit may include dedicated hardware such as one or more integrated circuits one or more Application Specific Integrated Circuits ASICs one or more Application Specific Special Processors ASSPs one or more Field Programmable Gate Arrays FPGAs or any combination of one or more of the foregoing examples of dedicated hardware for performing the techniques described herein.

PFEs process packets by performing a series of operations on each packet over respective internal packet forwarding paths as the packets traverse the internal architecture of network device . Operations may be performed for example on each packet by any of a corresponding ingress interface an ingress PFE an egress PFE an egress interface or other components of network device to which the packet is directed prior to egress such as one or more service cards. PFEs each include forwarding structures that when executed examine the contents of each packet or another packet property e.g. incoming interface and on that basis make forwarding decisions apply filters and or perform accounting management traffic analysis and load balancing for example. In one example each of PFEs arranges forwarding structures as next hop data that can be chained together as a series of hops along an internal packet forwarding path for the network device. The result of packet processing determines the manner in which a packet is forwarded or otherwise processed by PFEs from its input interface on one of IFCs to its output interface on one of IFCs .

In many instances the forwarding structures perform lookup operations such as a tree or trie search a table or index search a filter determination and application or a rate limiter determination and application. Lookup operations locate within a lookup data structure e.g. a lookup tree an item that matches packet contents or another property of the packet or packet flow such as the inbound interface of the packet.

Each of programs stored by control unit comprises text that conforms to a high level forwarding path description language syntax that accords with the principles of this disclosure. In other words each of programs is an FPDL program. Each of programs specify using a high level language syntax the features of a section of a packet forwarding path within network device . Programs specify functions to be performed on the packet including fundamental packet forwarding operations such as input packet processing route lookup and output packet processing as well as service functions such as packet filtering or access control statistical sampling traffic policing rate limiting and accounting.

When bound to a set of arguments respective programs define for packet forwarding paths of PFEs a forwarding path block forwarding structure that is a packet forwarding path peer of a firewall next hop or route table. A forwarding path block defined by one programs bound to a set of arguments and instantiated within PFEs as respective forwarding path blocks A N FPBs may itself be composed of multiple other forwarding structures such as lookup operations and policing management counting and filtering functions for example.

Daemons at run time identify individual programs for compilation and instantiation as FPBs in order to apply functions designated by the daemons for the forwarding plane functionality of network device . For example one of daemons may execute the Border Gateway Protocol BGP and receive a message from a BGP peer that causes the daemon to trigger a particular BGP function defined by one of programs . As another example one of daemons may execute a command line interface CLI that receives from a user a command to apply a policing function that is defined by one of programs to rate limit a particular traffic flow at a particular rate. In response daemons invoke FPB interface to select the appropriate ones of programs for installation to PFEs as FPBs . As used herein the term run time refers to any time after network device is deployed within a network environment versus pre compiled and installed within the network device at the time of manufacture. Run time may thus refer to the setup and configuration upon power up of network device as well as full operation for instance.

FPB interface presents an interface to the forwarding components in this example PFEs by which daemons may select one or more of programs provide a set of arguments to bind to the selected programs direct the instantiation of FPBs within PFEs to establish packet forwarding paths and provide lookup data with which to modify lookup data structures referenced in programs . FPB interface may comprise one or more user or kernel level libraries programs toolkits application programming interfaces APIs and may communicate programs arguments and lookup data to PFEs via internal communication link using sockets.

In the illustrated example daemon A invokes FPB interface to install a forwarding path block forwarding structure to FPBs A of PFE A. Daemon A selects one of programs A and provides to FPB interface a set of arguments to bind to the selected program. In response FPB interface sends the selected one of programs to PFE A as FPDL description structure a data structure that includes information needed by PFEs to instantiate the program. For example FPDL description structure for the selected program may specify the program text i.e. the program in textual form the program name and argument variables that define an interface to the program. In some instances FPB interface sends FPDL description data structures for each of programs to PFEs during a configuration setup phase for the PFEs. Although described with respect to PFEs by way of example the techniques herein can be used to configure other types of forwarding components.

In addition FPB interface creates and sends as a distinct structure FPB description structure to PFE A. FPB description structure is a data structure that references FPDL description structure and includes the arguments provided by daemon A for binding to the selected one of programs described by FPDL description structure . FPB interface assigns a unique system wide identifier to each FPB description structure. FPB description structure includes the information required for a particular instance of the selected one of programs described by FPDL description structure . Other FPB description structures may also reference FPDL description structure and yet include different information for a different instance of the selected one of programs .

Each of FPDL description structure and FPB description structure may comprise tables structs classes or other data structure types to carry the requisite information. FPB interface may send FPDL description structure and FPB description structure to PFE A in separate messages or in a combined message.

PFE A receives FPDL description structure and locally compiles the included program text to intermediate code representation or pseudo code that includes placeholders for argument variables that may be bound e.g. parameterized with argument values specified by various FPB description structures. PFE A also receives FPB description structure responsively loads the intermediate code to the forwarding hardware and binds or links the argument values specified therein to the corresponding argument variable placeholders in the loaded intermediate code to create and install a new forwarding path block in FPBs A. In this manner PFE A creates a new forwarding path structure in the packet forwarding path. In some aspects PFE A binds an argument value of FPB description structure to an argument variable placeholder of FPDL description structure by writing the argument value to the memory location for the argument variable placeholder. The argument value may represent another memory location a forwarding path reference that specifies another forwarding path structure or another type of reference that facilitates packet forwarding path construction.

Subsequently PFE A may receive additional FPB description structures that correspond to FPB description structure and have updated argument values. PFE A rebinds these updated argument values to argument variables of the new forwarding path block created for FPB description structure to modify the program flow from and or within the new forwarding path block. That is PFE A changes the argument set for a program already instantiated as a forwarding path block. Moreover PFE A may receive additional FPB description structures that also reference FPDL description structure yet are not associated with FPB description structure . The additional FPB description structures in this case in other words direct PFE A to create a separate instance of the referenced program as a separate forwarding path block. As a result the techniques allow numerous instances of the same program to be used with different argument sets without prompting a recompilation of the program by PFEs . As a result daemons by invoking FPB interface may more easily and flexibly modify the forwarding paths of PFEs .

Daemons operate over and interact with kernel which provides a run time operating environment for user level processes. Kernel may comprise for example a UNIX operating system derivative such as Linux or Berkeley Software Distribution BSD . Kernel offers libraries and drivers by which daemons may interact with the underlying system. PFE interface of kernel comprises a kernel level library by which daemons FPB interface FPDL interface and other user level processes or user level libraries may interact with PFEs . PFE interface may include for example a sockets library for communicating with PFEs over dedicated network links

Hardware environment of control unit comprises microprocessor that executes program instructions loaded into a main memory not shown in from storage also not shown in in order to execute the software stack including both kernel and user space of control unit . Microprocessor may comprise one or more general or special purpose processors such as a digital signal processor DSP an application specific integrated circuit ASIC a field programmable gate array FPGA or any other equivalent logic device. Accordingly the terms processor or controller as used herein may refer to any one or more of the foregoing structures or any other structure operable to perform techniques described herein.

RPD executes one or more interior and or exterior routing protocols to exchange routing information with other network devices and store received routing information in routing information base RIB . RIB may include information defining a topology of a network including one or more routing tables and or link state databases. RPD resolves the topology defined by routing information in RIB to select or determine one or more active routes through the network and then installs these routes to forwarding information base FIB . Typically RPD generates FIB in the form of a radix or other lookup tree to map packet information e.g. header information having destination information and or a label stack to next hops and ultimately to interface ports of interface cards associated with respective PFEs .

Command line interface daemon CLI provides a shell by which an administrator or other management entity may modify the configuration of network device using text based commands. Simple Network Management Protocol daemon SNMP comprises an SNMP agent that receives SNMP commands from a management entity to set and retrieve configuration and management information for network device . Using CLI and SNMP management entities may enable disable and configure services install routes enable disable and configure rate limiters and configure interfaces for example. As described in detail below RPD CLI and SNMP configure data plane B to implement configured services add modify delete routes and otherwise modify packet forwarding paths by installing forwarding structures to PFEs using forwarding path block interface FPB interface .

FPB interface allows daemons to drive the installation and configuration of forwarding path description language programs FPDL programs in packet forwarding paths. In particular FPB interface includes an application programming interface by which daemons may request one of FPDL programs bind the requested program to arguments and send the arguments and the requested program to PFEs for compilation instantiation and installation by PFEs to ASICs as forwarding path blocks FPBs . FPDL interface manages FPDL programs and FPDL description structures. FPDL interface includes an application programming interface accessible by FPB interface and by which FPB interface may direct FPDL interface to send one of FPDL programs to one of PFEs within an FPDL description structure.

PFEs implement data plane B also known as a forwarding plane functionality to handle packet processing from ingress interfaces on which packets are received to egress interfaces to which packets are sent. Data plane B determines data packet forwarding through network device applies services rate limits packet flows filters packets and otherwise processes the packets using forwarding structures and lookup data installed by control plane A to data plane B. While illustrates only PFE A in detail each of PFEs comprises similar components that perform substantially similar functionality.

PFE bind actions to be performed on packets received by the PFEs to identification of one or more properties of the packets. That is upon identifying certain packet properties PFEs perform the action bound to the properties. Packet properties may include packet metadata such as a particular packet s ingress interface or egress interface as determined by the PFEs as well as information carried by the packet and packet header such as packet header fields destination route prefixes layer four L4 or Transport Layer protocol destination ports and the packet payload. Actions bound to packet characteristics may include count discard forward to a specified next hop or interface filter sample rate limit and Quality of Service QoS marking differential services DiffServ load balance intrusion detection and prevention L2 class of service CoS and L2 or L2 Virtual Private Network L2VPN switching.

PFE A includes ASIC based packet processors ASICs that process packets to identify packet properties and perform actions bound to the properties. ASICs include one or more programmable application specific integrated circuits having key engines A M key engines that execute microcode or microinstructions to control and apply fixed hardware components of ASICs to process packet keys. A packet key includes packet fields and other parameters that determine a flow of packet processing for the packet along an internal forwarding path. Each of key engines includes one or more key buffers to store packet field data for corresponding packets that the key engine is currently processing. Key buffers may also provide limited writable memory to which elements of the internal forwarding path may write to pass messages accessible by future elements. Internal forwarding path forwarding path comprises programmable executable microcode and fixed hardware components that determine the packet processing actions and other operations performed by key engines . Forwarding path may include for example executable instructions programmable logic and application specific logic that perform lookups rate limit packet flows and manipulate packet keys among other functions. Internal forwarding paths of network device may include combinations of respective forwarding paths of PFEs . In other words forwarding path of PFE A may include only a part of the overall internal forwarding path of network device .

Primitives of forwarding path include data structures having entries or items that correspond to packet key values and bind the values to actions to be performed by key engines executing forwarding path . In this respect primitives represent a tightly coupled combination of executable instructions that correspond to bound actions and of data for possible packet key values. A tree lookup one of primitives may perform a longest match prefix lookup in a routing table or search a list of prefixes in a filter program. A table lookup one of primitives may determine whether another one of primitives should be performed by key engines . For example key engine A may perform a table lookup of packet properties to determine that key engines A should further perform a tree lookup to identify an outbound interface for the packet. PFE A may store primitives and FPBs in computer readable storage media such as static random access memory SRAM . While illustrated within ASICs primitives may be stored in memory external to ASICs onboard PFE A.

In some aspects actions of forwarding path use a next hop data structure to initiate processing. At the end of each processing step by one of key engines such as execution of one of primitives or of one of FPBs the result is a next hop that may specify additional processing or the termination of processing for instance. In addition next hops may specify one or more functions to be executed by key engines . Example next hop functions include policing i.e. rate limiting counting and sampling. Next hops thus form the primary data structure that can be used to initiate a lookup or an FPB chain lookups and FPBs to allow for multiple lookup and other operations to be performed on a single packet and terminate a lookup or an FPB . Key engines may be associated with respective result or lookup buffers that store results for executing next hops. For example key engine A may execute a lookup specified by a next hop and store the result of the lookup to the associated result buffer. The contents of a result buffer may affect the actions of the next hop in the next hop chain. Additional information regarding next hops and next hop chaining is available in PLATFORM INDEPENDENT CONTROL PLANE AND LOWER LEVEL DERIVATION OF FORWARDING STRUCTURES U.S. application Ser. No. 12 266 298 filed Nov. 6 2008 which is incorporated herein by reference in its entirety.

PFE microprocessor manages ASICs and executes FPB PFE interface to provide an interface to control unit . PFE microprocessor may execute a microkernel to provide an operating environment for interfaces. FPB PFE interface is a programming interface receives FPDL and FPB description structures from PFE interface of control unit . As described above an FPB description structure binds arguments to FPDL program parameters identified in a FPDL description structure that includes one of FDPL programs .

FPB PFE interface receives FPDL programs in textual form in FPDL description structure. That is the programs as received by the PFEs conform to the high level forwarding path description language and may not comprise data executable by a processor such as one of key engines . Compiler of PFE A compiles FPDL programs identified in FPDL description structures using the arguments provided in FPB description structures to generate microcode that constitutes a forwarding path block forwarding structure. In this way compiler creates executable instances of the FPDL programs referenced in corresponding FPDL description structures and FPB description structures. Because each of PFEs includes an instance of compiler the compiler represents a distributed compiler for network device that may provide PFE specific compilation targeted to the particular chip set represented by ASICs .

The arguments provided in FPB description structures may specify for example conditional compilation for portions of a specified one of FPDL programs as well as next hops of forwarding path including next hops that initiate FPBs and primitives . FPB PFE interface installs compiled forwarding path blocks to forwarding path as FPBs for execution by key engines . By providing updated arguments for FPB description structures via FPB interface daemons can alter the operation of instantiated FPBs by for example changing the next hops for the forwarding path blocks. In this way daemons may modify the operation of forwarding path without necessitating a recompile by compiler of FPDL programs.

Some instantiated FPBs specify one or more lookups operations using primitives . For example one of FPBs may specify a lookup operation using a tree one of primitives . These FPBs lookups specify the actions to be performed for items bound to the actions in the primitives. In other words each item of primitives is bound to an action performed by key engines for packets having keys that match the item. Instantiated FPBs determine the actions to be performed. In some instances the action to be performed may include executing a next hop external to a particular one of FPBs and modifiable using FPB interface .

FPB interface of control unit provides an interface by which daemons may add to modify or delete items of primitives to modify packet processing by forwarding path of packets having keys that match the items. For example RPD may invoke FPB interface to add to a lookup tree one of primitives identified within one of FPBs an item that binds a destination prefix to an action that includes a statement that references a next hop structure which may be populated with a reference to another one of FPBs . As another example CLI may invoke FPB interface to add to a lookup table one of primitives identified within one of FPBs an item that binds an inbound interface to an action that directs key engines to discard packets that arrive on the inbound interface when executing the FPB.

Some instantiated FPBs specify one or more rate limiters that includes one or more policer stages that each bind an action to a particular flow rate. When a packet flow exceeds the flow rate for a particular policer stage of a rate limiter key engines execute the corresponding bound action. FPB interface also provides interface to set rate limiter stage flow rates or to bind an action to a rate limiter stage. For example SNMP may invoke FPB interface to obtain a reference to a rate limiter of a particular one of FPBs . SNMP may then use the reference to set a flow rate for a second stage of the rate limiter to a particular bandwidth. As another example SNMP may use the reference to bind the second stage to an action identified in the one of FPDL programs from which compiler compiled the FPB that directs key engines to load balance traffic that exceeds the flow rate for the second stage. Some instantiated FPBs specify one or more counters that may be instantiated within forwarding path and manipulated by key engines during the execution of actions bound to packet key values or flow rate values for example. Primitives such as lookup tables and lookup tree along with rate limiters and counters are hereinafter collectively referred to as forwarding path elements. However forwarding path elements may include additional types of structures to carry out data plane B functionality listed above.

Daemons using FPB interface can in the described manner manage lookup and rate limiter operations by referencing high level constructs of FPDL programs . In this way the described techniques may simplify programming of forwarding path .

Example program text A illustrates forwarding path description language constructs that when bound to received program arguments compiled and instantiated as FPBs in forwarding path of PFEs direct packet processing by key engines of PFEs . The forwarding path description language supports definition elements including scalars such as integers and Booleans structure definitions type definitions e.g. typedef and bitfields. Program A includes global arguments global instantiation variables inst. vars. and a set of one or more blocks A N blocks . Each of programs A has a unique name to enable the program to be referenced by FPB interface to create FPB description structures and instantiate the program. In some instances the forwarding path description language identifies a program variable using type program.

Global arguments set forth argument variables that indicate to compiler that the variable should be initialized externally via parameters supplied in an FPB description structure when the program is instantiated. In this way global arguments together with block local arguments define an external interface to the program. As a result FPDL interface extracts the names of program argument variables to program interface information A during pre processing. Global arguments have block global scope within program A and may therefore be referenced within any of blocks . In some instances the forwarding path description language identifies arguments using variable type arg making arg a valid storage class for the language. To declare a scalar that is an argument variable for example program A may include the text arg uint32 m int where int32 specifies an unsigned 32 bit integer. Once initialized in compiler compiling program A with externally supplied parameters compiler uses argument variables in a read only manner to build an instance of the program.

Global instantiation variables direct compiler to instantiate a specified forwarding path element and allow that element to be referenced throughout blocks of program A. Example instantiation variable types include counter table tree and rate limiter. To declare a counter for example program A may include the text counter c . Once initialized in compiler compiling program A compiler uses instantiation variables in a read only manner to build an instance of the program.

Blocks represent elemental code containers of the forwarding path description language. Each of blocks may contain variable declarations e.g. arguments and instantiation variables statements functions and conditionals that determine the instantiated forwarding path elements for a forwarding path block instance of a program as well as the operations of key engines with respect to the forwarding path elements and program flow. Blocks consolidate forwarding path description language code into easily readable sections and because each block is named allow the blocks to be referred to from within program A and also via a reference obtained using FPB interface external to program A.

By default the first block A listed in program A is the default entry block for the program i.e. the first block executed by key engines upon initiation . Execution of compiled blocks by key engines may jump from a first one of blocks to a second one of blocks only when the first block includes an explicit instruction to begin executing the second block. In this way blocks are similar to functions because they may be invoked and because they consolidate forwarding path description language code into sections. However blocks are not equivalent to functions because blocks do not return to an invoking block unless the invoked block includes an explicit instruction to return to the invoking block. In this way blocks have the properties of a labeled instruction that may be invoked by directing the thread to execute the labeled instruction i.e. the first instruction within the block . To declare a block for example program A may include the text block blockA block code .

Block local argument variables set forth argument variables that indicate to compiler that the variable should be initialized externally via parameters supplied in an FPB description structure when the program is instantiated. Block local instantiation variables direct compiler to instantiate a specified forwarding path element. Block local argument variables and instantiation variables may be referenced only within block A. In other words block local variables do not have scope outside of the blocks in which they are declared.

The forwarding path description language may also provide syntax enabling assignments parameterized functions and compiler directives. Assignments may conform to standard C language syntax. Instantiation variables may not in general be assigned to because the variable only exists during instantiation. Instantiation variables may however be assigned to using instantiation constructor functions for the variables. For example block A may include the assignment instruction table foo table table max MAX ENTRIES that directs compiler to instantiate the new table according to the instantiation constructor table .

The forwarding path description language parameterizes functions using name value pairs that provide values for named parameters and that can be listed in the function call in any order. Some functions may not be parameterized. Parameters may be mandatory or optional. Unsupplied values for optional parameters may cause compiler to use an internal default value for the parameter. A parameter value may be an array of scalars or strings for example. For instance block A may include the assignment instruction bar foo bar bar parameter2 value1 parameter1 entry1 entry2 . This example instruction invokes the bar function using value1 for parameter2 and an array of values for parameter1.

Compiler directives of the forwarding path description language modify compilation of compiler according to provided parameters. For example a compiler directive may indicate that program A is only available to run on any of a set of one or more ASIC architecture types listed in the directive. As a result compiler may decline to compile program A when compiler executes on one of PFEs that includes an ASIC chipset architecture type that is not listed in the compiler directive.

As described in further detail below program flow within programs is block based. That is due to the limited invocation context for key engines key engine execution threads pass among labeled code blocks rather than among procedures. Functions represent native i.e. built in accessor functions that enable instantiation variables e.g. counters rate limiters and primitives to be created and assigned according to function parameters. For example as described above block A may include the assignment instruction table foo table table max MAX ENTRIES that directs compiler to instantiate the new empty table according to the accessor function table of functions . Similar instantiation constructor may be presented by the FPDL for other forwarding path elements such as trees counters and rate limiters for example. In some instances the instantiation constructor for tables may present a required parameter to define a number of entries for the table and the instantiation constructor for rate limiters may present a required parameter to define a number of policer stages for the rate limiter.

Each of functions presents an optional scope parameter that allows developers using the FPDL to manage the instantiation scope of the corresponding forwarding path element across separate instances of programs installed to forwarding path . For example program A may define a lookup table one of instantiation variables as global. As a result each one of FPBs that is an instance of program A uses the same instance of the lookup table when executed by key engines . In other words each instance of the lookup table is global and accessible by all instances of the program. As another example a program A may define a local counter within a bound action also defined within program A. Each one of FPBs that is an instance of program A is associated with a separate instance of the local counter. In other words each local counter is local to an instance of the program and not accessible to other instances of the program. The scope of a forwarding path element defined in one of functions for the element refers to the scope of the element among forwarding path block instances of a program i.e. whether the element is shared whereas block local and block global scope refers to a scope of variables within one of programs .

Key engines execute statements set forth within programs such as program A. Compiler generates and installs microcode for each of statements . In this sense statements instantiated in FPBs define aspects of forwarding path logic for forwarding path . Statements includes statements that control program flow such as if condition else statements for evaluating conditions using comparisons for instance. The following is an if else statement that conforms to an example FPDL 

In the above example key engines read an iif mismatch field of a result buffer populated by executing a previous next hop for instance. If the field value is true the key engines execute a vpls sa learn block that updates a VPLS L2 table for the network device with the source L2 address of the packet being processed. If the field value is false the VPLS L2 table has already learned the L2 address and the key engines increment a counter to age the VPLS L2 table entry for the source address.

Other example statements that control program flow for FPDL programs include goto which references one of blocks and causes key engines to jump execution to the referenced block. A goto statement of statements in block A may reference block A to facilitate recursive execution. A call statement of statements invokes one of blocks without parameters and without receiving a return value. A return statement of statements in one of blocks returns an execution thread to another one of blocks that invoked the block with a call statement. In order the return the return statement must be present. The call statement may be stacked among multiple blocks .

An exit statement of statements causes packet forwarding engines to execute code that is external to one of FPBs instances of programs . The exit statement may reference a next hop reference another one of FPBs or other forwarding path reference type. A discard statement of statements causes packet forwarding engines to terminate packet processing for the packet currently being processed.

A lookup statement of statements directs lookup functionality of forwarding path by associating one or more possible actions with a lookup result for one of primitives that is predicated upon a key value. In one example of a lookup statement an item statement defines a template for items that may be instantiated within one of primitives and bound to the one more actions defined by one or more action statements of the lookup statement. The action statements define per action operations executed when a lookup operation identifies the matching item and performs the bound action. In addition the item statement may include one or more instantiation variables and statements that apply to each item instantiated from the item statement template. These define per item operations. A default statement within a lookup statement defines a default action for a lookup operation. When the lookup operation is unable to determine a matching item key engines execute the operations defined by the default statement. If no default is specified key engines may discard the packet being processed.

Daemons may use FPB interface to add items to one of primitives and bind these items to actions named in the action statements for the to statement that references the primitive. FPB PFE interface instantiates added items by adding any forwarding path elements and microcode required by the item statement template for the lookup statement that references the primitive. Compiler translates a lookup statement of statements into a forwarding hardware lookup executable by key engines .

Rate limiters of forwarding path may be based on a series of cascaded stages. A rate limiter statement of statements directs rate limiting functionality of forwarding path by associating one or more possible actions with a rate limiter stage e.g. a policer that triggers when traffic flow exceeds the allowed bandwidth for the stage. When a rate limiter stage triggers key engines execute the action bound to the rate limiter stage. Daemons may use FPB interface to set allowable bandwidths for each rate limiter stage and bind each rate limiter stage to an action defined within a rate limiter statement of statements in programs .

An increment statement of statements increments a counter defined as one of instantiation variables within programs . The counter may be supplied to the statement as a parameter. The following is an increment statement that conforms to an example FPDL increment counter discard counter . A sample statement of statements directs keys engines to sample the packet currently being processed. The sample class may be specified as a parameter which may be supplied as one of arguments . Sampling refers to a process of forwarding a copy of a packet to an external system such as control unit for processing. A packet that is designated to be sampled is processed normally according to forwarding path but data plane B creates a copy of the packet or portion of the packet and forwards the copy to control plane for further processing. The following is a sample statement that conforms to an example FPDL sample class myclass .

The statements packet read and packet write of statements access packet header fields in the key buffers of key engines for reading from and writing to header field values respectively. The packet read statement is a function that returns the value of field name specified for the function and may thus be used for comparison evaluation as in the following example 

In the above example an FPB instance of one of programs that includes these statements directs key engines read the IPv4 protocol field of the packet header being processed from the associated key buffer for the key engine and determine whether the field has a value equal to the constant defined for ICMP. If the packet is an Internet Control Message Protocol ICMP packet packet engines process the packet as an ICMP packet which may include trapping the packet to control plane A.

The statements result read and result write of statements access fields of the result buffer associated with the executing one of key engines to enable data passing between next hops within and external to FPBs . The result read statement is a function that returns the value of field name specified for the function and may thus be used for comparison evaluation as in the following example 

In the above example packet engines read their associated result buffers to determine whether the packet currently being processed does not match the expected inbound interface as determined by the operation of a previous next hop in the next hop chain that also includes one of FPBs instantiated from a program that defines the above example code.

Conditionals may affect both execution by key engines and compilation instantiation by compiler . Key engines evaluate conditionals defined in programs and direct the execution thread according to the outcome. The following example that conforms to an example FPDL program redirects IPv4 fragments based on a key buffer field 

In addition compiler evaluates conditionals in programs that are dependent upon argument variables and compiles the programs according to arguments supplied by FPB interface . The following example that conforms to an example FPDL program causes compiler to instantiate based on the supplied argument only partial logic defined by the program 

The example program code provided above and throughout this disclosure is merely exemplary. Other program code grammars capable of facilitating the described techniques are also contemplated. In one example program code including the various blocks arguments instantiation and other variables functions statements conditions and arguments may conform to the following language definition which for illustrative purposes is in Backus Naur Form BNF 

FPB interface sends FPB description structures and FPDL interface sends FPDL description structures to PFEs for compilation by compiler in accordance with the respective arguments founds within the FPB description structures. FPB PFE interface installs the compiled instance of the corresponding program to forwarding path as one of FPBs .

Multiple FPB description structures may reference a single one of FPDL description structures . In the illustrated example FPB description structures B C reference FPDL description structure B. As a result control unit may install multiple different instances of the single FPDL program reference by FPDL description structure B with each instance exhibiting different behavior according to the particular parameters of FPB description structures B C. In addition FPDL interface need only send one copy of each of FPDL description structures to each of the PFEs for compilation. These instances may be reused by compiler to support multiple FPB description structures that reference the instances.

In some aspects compiler compiles FPDL program text received in FPDL description structures to platform independent intermediate code object or representation that retains placeholders for arguments received by compiler in FPB description structures . When compiler receives a new or updated one of FPB description structures the compiler combines the intermediate code and the respective arguments the FPB description structure to generate a new instance of the FPB for installation by FPB PFE interface to FPBs .

Block includes increment statement lookup statement and exit statement . During packet processing key engines execute block to first execute increment statement to increment counter which counts every packet handled by program .

Lookup statement defines a lookup template by which FPB interface may bind forwarding path actions to lookup items in primitive . Items refer to individual entries within a lookup primitive that corresponds to a possible value for a field or other property of a packet key. An action is a section of code executable by key engines when an item to which the action is bound is matched during a lookup operation. Daemons may add modify and delete item entries and item action bindings using FPB interface .

The example lookup statement defines an item template that specifies a counter and an increment statement that when compiled and executed increments counter . As a result each item for primitive is associated with a counter that key engines increment when the item matches the packet being processed. Lookup statement also defines action and default action . FPB interface binds each item entry added to primitive to either action or default action . In various examples lookup statement may define any number of actions. Default action provides default code that packet engines execute for packet key values that do not match any of the items added to the primitive defined by primitive . In addition FPB interface may bind added item entries to default action . Actions and default action include respective increment statements that when compiled and executed increment respective counters . As a result program tracks the number of packets processed according to each of the actions. In addition default action includes discard statement that when compiled and executed directs key engines to discard the packet currently being processed.

Key engines execute lookup statement by keying key defined in lookup statement to the primitive identified by primitive . Lookup statement thus expresses a complex forwarding path lookup using a simple syntax provided by the forwarding path definition language. After executing the lookup statement exit statement directs key engines to proceed to the forwarding path reference provided by FPB interface for argument variable .

In the above example nextfpr represents argument test table is a table that represents primitive and test items represents counter . Key of lookup statement is parameterized using an iif field of the packet key and the lookup primitive is for lookup statement test itable. Counters test items test accepts and test discards represent counters and respectively. Lookup operation defines action named test accept and default action named default .

In operation daemons bind actions to items using FPB interface by referring to action names and to primitive names. For example FPB interface may define methods fpb table fpb table find by name fpb fpb char table name and void fpb table add fpb table table int index char action name . Daemons may invoke FPB interface with the names defined in FPDL program test in the above example. For example RPD may obtain a table pointer value table t to primitive by executing table t fpb table find by name fpb1 test table and may subsequently add items to table t and bind the items to actions by executing fpb table add. For example RPD may add an item for packet property value 10 and bind the item to action by executing fpb table add table t 10 test accept . FPB interface may define similar interface methods for lookup tree primitives and for rate limiters. As a result daemons executing in the control plane of a network device can control lookups in the forwarding path without requiring programs in the data plane to be recompiled and without requiring new programs to be deployed to the data plane.

RPD invokes FPB interface to create FPB description structure A referenced by FPB table identifier entry A to include arguments A for the program referenced by FPDL description structure A. FPB interface sends FPB description structure A to PFE A which compiles the referenced program and arguments A to FPB and installs FPB to forwarding path . Arguments A include a value for the argument variable nextfpr . In addition RPD invokes FPB interface to add items A D to primitive and bind the items to one of actions A B actions defined for the lookup operation.

During execution packet engines enter FPB at next hop which includes microcode to cause the packet engines increment counter . Next hop chains to the lookup operation for primitive here illustrated as a table . Primitive includes item entries A B and C for respective packet property values e.g. key values and . The lookup operation directs execution threads of packet engines to the respective item structure A D items for the matching packet property value. In the illustrated example items are each an instance of item template of and are each implemented as next hops. For example packet property value 10 directs packet engines to item B for packet property value 10 specified by item entry B. The next hop of item B causes the packet engines to increment counter B for the item. In this way every one of items has an associated counter that counts packets that match the packet property value corresponding to the item.

Each of items is bound by operation of FPB interface to one of actions . For example item B is bound to action A. Action B represents an instantiation of default action defined in program of and directs packet engines to increment counter the discard counter and to discard the packet being processed. Action A represents an instantiation of action defined by program of and directs packet engines to increment counter according to the next hop. Completion of action A directs packet engines to proceed to the forwarding path reference e.g. a next hop location defined by the value for argument variable nextfpr .

Functions that conform to a forwarding path description language as described herein present an optional scope parameter that allows developers using the FPDL to manage the instantiation scope of the corresponding forwarding path element across separate instances of programs installed to forwarding path . A globally scoped variable is shared among all instance of programs while new instances locally scoped variables are created for each instance of programs. In the case of globally scoped variables the PFE FPB interface creates the instance of the variable when installing the first instance of a program. PFE FPB interface configures subsequent instances of the program to use the previously allocated instance of the variable. In instances where every variable for a program is a local variable PFE FPB interface instantiates every instance of the program as a complete copy of all variables. In other words the program defines a template that may be reproduced and installed to forwarding path .

In the illustrated example a counter that instantiates counter is parameterized using a global scope value to indicate that the counter is a global counter shared among various instances of program including FPBs . In one example program instantiates counter according to the following instruction counter foo counter counter scope global . Next hops of each of FPBs indirectly reference shown as dashed lines counter to increment the counter during packet processing. In various examples any of the illustrated variables may be declared global to cause FPBs to share the instance of such variables including primitive counters counter and counter of respective FPBs . A globally scoped primitive may enable daemons to instantiate FPBs to share a single lookup table for example simplifying management of the lookup table and ensuring consistency across FPBs . Items added to primitive however are still bound in this example to only one of FPB . As a result execution threads of packet engines may jump between FPBs . For example packet engine A may begin executing FPB A lookup one of items instantiated within FPB B and thus transfer the execution thread to the next hop for the identified item within FPB B.

Packet flows arrive at stage A which determines whether the packet flow bandwidth exceeds the rate parameter value for stage A. If so packet engines execute action A here implemented as a next hop bound to stage A by operation of FPB interface . If not stage B determines whether the packet flow bandwidth exceeds the rate parameter value for stage B. If so packet engines execute action B here implemented as a next hop bound to stage B by operation of FPB interface . If not packet engines execute default action here implemented as a next hop . Each of stages may each represent a hardware policer within an ASIC of a packet forwarding engine.

The method fpb create creates and returns a reference to a new forwarding path block given a program name a reference name for the one of PFEs on which to create the forwarding path block and a set of arguments. fpb get fpr returns a forwarding path reference that may be embedded within other forwarding path blocks as a value for an argument variable for example. In this way daemons may chain together multiple forwarding path blocks within forwarding path .

Once daemons create an FPB description structure FPB interface sends the FPB description structure to PFE FPB interface and directs FPDL interface to send the FPDL description structure for the referenced program to PFE FPB interface . Compiler compiles the referenced program according to the set of arguments within the received FPB description structure to generate a new forwarding path block . PFE FPB interface then installs the new forwarding path block to forwarding path as one of FPBs .

Forwarding path having been modified packet engines execute the forwarding path to process packets accordingly. Packet engines process packets having property value that match the added item using the action of the forwarding path block that is bound to the item in the primitive .

The techniques described in this disclosure may be implemented at least in part in hardware software firmware or any combination thereof. For example various aspects of the described techniques may be implemented within one or more processors including one or more microprocessors digital signal processors DSPs application specific integrated circuits ASICs field programmable gate arrays FPGAs or any other equivalent integrated or discrete logic circuitry as well as any combinations of such components. The term processor or processing circuitry may generally refer to any of the foregoing logic circuitry alone or in combination with other logic circuitry or any other equivalent circuitry. A control unit comprising hardware may also perform one or more of the techniques of this disclosure.

Such hardware software and firmware may be implemented within the same device or within separate devices to support the various operations and functions described in this disclosure. In addition any of the described units modules or components may be implemented together or separately as discrete but interoperable logic devices. Depiction of different features as modules or units is intended to highlight different functional aspects and does not necessarily imply that such modules or units must be realized by separate hardware or software components. Rather functionality associated with one or more modules or units may be performed by separate hardware or software components or integrated within common or separate hardware or software components.

The techniques described in this disclosure may also be embodied or encoded in a computer readable medium such as a non transitory computer readable medium or computer readable storage medium containing instructions. Instructions embedded or encoded in a computer readable medium may cause a programmable processor or other processor to perform the method e.g. when the instructions are executed. Computer readable storage media may include random access memory RAM read only memory ROM programmable read only memory PROM erasable programmable read only memory EPROM electronically erasable programmable read only memory EEPROM flash memory a hard disk a CD ROM a floppy disk a cassette magnetic media optical media or other computer readable storage media. It should be understood that the term computer readable storage media refers to physical storage media and not signals or carrier waves although the term computer readable media may include transient media such as signals in addition to physical storage media.

Various embodiments of the invention have been described. These and other embodiments are within the scope of the following claims.

