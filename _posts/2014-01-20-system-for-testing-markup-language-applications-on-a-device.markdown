---

title: System for testing markup language applications on a device
abstract: A system is described for testing markup language-based applications, such as a web page, executing on an external computing device. A development device executes development tool modules which may include a proxy module and a driver module. The proxy module enables communication between one or more modules which execute on the development device and one or more embedded test tools on the computing device. The driver module provides a command line interface to facilitate automated testing, and generates commands appropriate to the use of the embedded test tools and may use the proxy module to communicate with the computing device. Using the proxy module, the driver module, or both, a developer is able to test and interact with a markup language application executing on the computing device with a variety of development modules.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09367415&OS=09367415&RS=09367415
owner: Google Inc.
number: 09367415
owner_city: Mountain View
owner_country: US
publication_date: 20140120
---
With the growing popularity of computing devices there is an increasing demand for applications or apps to run on such devices. These devices may include smartphones tablet computers televisions set top boxes wearable devices in vehicle computer systems home entertainment systems embedded devices and so forth. To satisfy this demand programmers are constantly building testing and maintaining applications. Testing of these applications is useful for quality assurance to find and correct errors.

Certain implementations and embodiments will now be described more fully below with reference to the accompanying figures in which various aspects are shown. However various aspects may be implemented in many different forms and should not be construed as limited to the implementations set forth herein. Like numbers refer to like elements throughout.

U.S. patent application Ser. No. 13 619 867 filed on Sep. 14 2012 titled Remote Control of a Mobile Device to Manish Lachwani et al. is incorporated by reference into this disclosure.

U.S. patent application Ser. No. 13 680 671 filed on Nov. 19 2012 titled Configurable Network Virtualization to Manish Lachwani et al. is incorporated by reference into this disclosure.

U.S. patent application Ser. No. 13 631 919 filed on Sep. 29 2012 titled Application Validation Through Object Level Hierarchy Analysis to Manish Lachwani et al. is incorporated by reference into this disclosure.

U.S. patent application Ser. No. 13 655 667 filed on Oct. 19 2012 titled Application Auditing Through Object Level Code Inspection to Manish Lachwani et al. is incorporated by reference into this disclosure.

U.S. patent application Ser. No. 13 721 632 filed on Dec. 20 2012 titled System For Testing Markup Language Applications to Manish Lachwani et al. is incorporated by reference into this disclosure.

U.S. patent application Ser. No. 13 741 989 filed on Jan. 15 2013 titled Application Testing System With Application Programming Interface to Manish Lachwani et al. is incorporated by reference into this disclosure.

U.S. patent application Ser. No. 13 862 240 filed on Apr. 12 2013 titled Test Automation API For Host Devices to Manish Lachwani et al. is incorporated by reference into this disclosure.

U.S. patent application Ser. No. 13 868 560 filed on Apr. 23 2013 titled Test Script Generation to Manish Lachwani et al. is incorporated by reference into this disclosure.

U.S. patent application Ser. No. 13 962 662 filed on Aug. 8 2013 titled Application Testing System to Manish Lachwani et al. is incorporated by reference into this disclosure.

U.S. patent application Ser. No. 14 050 071 filed on Oct. 9 2013 titled Performance Data Collection to Manish Lachwani et al. is incorporated by reference into this disclosure.

A wide variety of applications or apps are developed for execution on computing devices including smartphones tablet computers televisions set top boxes wearable devices in vehicle computer systems home entertainment systems and so forth. Some of these devices are mobile devices in that they are portable from one location to another.

There is an increasing demand for software developers to build applications or apps to run on such devices. Software developers build test and maintain applications using a variety of development tools. Testing provides many benefits including finding and correcting errors improving performance and so forth. Testing may include observing processor usage observing memory allocation programmatic debugging determining usability validating functionality and so forth.

Different types of applications may be available for use on the computing devices. These include native applications markup language applications hybrid applications and browser based applications. Native applications are those which are written and compiled for execution on the particular device. For example native applications may be written in a programming language such as C or Objective C and compiled into native code such as a binary executable for use on the device. Markup language applications include one or more instructions in a markup language which may be rendered by a layout engine and one or more instructions in a scripting language which may be interpreted by a scripting language engine during execution. For example a hypertext markup language HTML version 5 or higher markup language application may include HTML cascading style sheets CSS and JavaScript. In some implementations the markup language application may have multiple instances of the UIWebView class references. Hybrid applications include native code and markup language application portions. Browser based applications are processed within a web browser application and are limited in execution. The browser based applications may have one or more UIWebView instances.

Markup language applications confer several advantages including in particular ease of deployment across different devices with no adjustment or minimal adjustment. For example a markup language application for a smartphone from one manufacturer may also be executed on an in vehicle system. In comparison a native application may need to be re coded recompiled and so forth to operate on different platforms. The platforms may be distinguished by different processors operating systems or combinations thereof. In some implementations the markup language application may be provided as one or more web pages. For example the markup language application may comprise the set of HTML5 CSS JavaScript and so forth which may be accessible by way of a network address. The network address may comprise a uniform resource locator URL uniform resource identifier URI internet protocol address and so forth.

Traditional testing systems have lacked the ability to provide development tools for testing for markup language applications executing on computing devices. Software developers developers have had to rely on cumbersome methods for testing including insertion of debug code use of simulators and so forth. The insertion of debug code such as found in a software development kit SDK or manual breakpoints requires ongoing editing and adjustment of the code and may result in incorrect or missed information. Likewise the simulators lack the full fidelity provided by execution on the actual computing device.

Furthermore developers may wish to use a particular tool with which they are more familiar or which includes additional functionality but which the computing device which will be executing the application to be tested may not natively support the particular tool. For example a developer may prefer the set of features and interface associated with the Chrome Development Tools also known as DevTools as promulgated by Google Inc. of Mountain View Calif. Traditionally the developer has been unable to use these Chrome DevTools to debug a markup language application which is executing on a computing device which is executing the iOS operating system from Apple Corp. of Cupertino Calif. Instead the developer would need to use those tools specifically provided by Apple Corp. such as the Safari Inspector to debug a markup language application executing on the iOS operating system. As a result developers may be frustrated in their development efforts.

This disclosure describes embodiments of systems and methods for testing markup language applications executing on an actual computing device a simulation of a computing device or both. A development device such as a desktop computer may execute one or more development tools such as debuggers memory debuggers and so forth. These development tools may be used to test markup language applications which are either local to the development device or which are remote such as those executing on the computing device. In one implementation the development tools may include the Safari Inspector as developed by Apple Corp. of Cupertino Calif. Chrome Developer Tools as developed by Google Inc. of Mountain View Calif. and so forth.

A proxy module is configured to provide communication between the development tools of the development device and embedded test tools which are present on the computing device. The proxy module allows for the use of the development tools to interact with an application under test and the modules which support execution thereof. These embedded test tools may be incorporated into other modules such as a layout engine module. The layout engine module is configured to execute an application or portion thereof which uses a markup language such as hypertext markup language HTML version 5 or higher. In one implementation the layout engine module may comprise WebKit as promulgated by Apple Corp. or others through an open source development model.

In some implementations the proxy module may be configured to provide an interface with one or more ports which is WebSocket compatible. For example the proxy module may provide a first set of one or more WebSockets which are available to communicate with the developer tools and a second set of one or more WebSockets which are available to communicate with services or modules executing on the computing device. In some implementations the WebSocket protocol may be compliant with the Internet Engineering Task Force IETF Request For Comments RFC 6455 also known as RFC 6455.

In some implementations a developer may choose to use development tools which may be otherwise incompatible with the layout engine module or the embedded test tools. For example a developer may choose to use the Google Chrome DevTools to debug a web site which is rendered in the Mobile Safari browser executing on the computing device running the Apple iOS operating system. In this example the Google Chrome DevTools use the Google Inc. remote debugging protocol however the WebKit portion of the layout engine module may be unable to process inputs made using the remote debugging protocol.

A driver module may be employed to accept one or more commands in a first form and output one or more commands in a second form. Continuing the earlier example the driver module may accept remote debugging protocol inputs from DevTools command line inputs and so forth and provide outputs which are compatible with WebKit . The driver module may be configured to accept manual inputs scripted input programmatically generated inputs and so forth. For example the driver module may be configured to accept as input commands included in test script data. In some implementations the driver module may use WebSockets to exchange information with other modules such as the developer tools proxy module and so forth.

With the proxy module and the driver module developers may use a wide variety of tools to develop applications which incorporate markup language. As described above a developer may use the Chrome DevTools to debug a web page as rendered by the Apple Mobile Safari browser executing on the iOS operating system.

The techniques and modules described above may be performed using a computing device which is in the secured configuration such as a default operating system which has not been jailbroken . In this secured configuration access to the operating system on the computing device file system and so forth may be restricted.

By eliminating the need for insertion of debugging code and the associated effort involved overall productivity and effectiveness of the software development effort is improved. For example by using the proxy module the developer may debug a markup language application on the computing device using existing on board previously loaded embedded test tools such as the Apple Safari web inspector com.apple.webinspectord . Finally the use of the actual computing device during testing provides the highest fidelity testing available which is representative of the end user experience which may improve quality of the application as released to the end user.

A development device is depicted. The development device is configured to execute at least in part one or more development tool modules . The development tool module provides applications for testing debugging runtime editing of the application being tested and so forth. The development tool module may include the Safari Inspector as developed by Apple Corp. the GNU debugger gdb as maintained by the GDB Steering Committee Google Developer Tools DevTools as promulgated by Google Inc. and so forth. The development tool modules are discussed in more detail elsewhere in this application.

The development device may be used to test one or more local applications under test . This local application under test includes a markup language application . The development tool module may be configured to provide testing of the local application under test . This testing may include the development tool module providing one or more commands to a local layout engine module not depicted here . The local layout engine module is configured to execute or interpret the markup language application and return output data . The output data may include crash dumps register values memory information timing data hardware resource usage data and so forth.

In one implementation the layout engine module may comprise WebKit as promulgated by Apple Corp. and others. In this implementation the commands may be debugging commands compatible with the WebKit layout engine and internal components such as the WebCore JSCore and so forth. For example commands may be deemed compatible when such commands are operable to be processed by a module to change state change operation and so forth.

In this illustration the development tool module is providing commands to the markup language application which is local to the development device . The development tool module may receive the output data resulting from the execution of the markup language application by the local layout engine module.

The development tool module may provide session data . The session data may be stored in a JavaScript Object Notation JSON format. The session data may include data based at least in part on the commands the output data and so forth. The session data may be saved for later analysis sent to another device and so forth. In some implementations the development tool module may be configured to replay previously stored session data . The development device is described in more detail elsewhere in this application such as in regard to .

As described above testing using a particular computing device platform provides valuable information which is useful to the software developer and others. One or more computing devices may be coupled to the development device . This coupling enables the development tool module of the development device to test a markup language application on the computing device . Because of the coupling and testing facilities made available through the development tool module debug code or other testing instructions may be omitted from a remote application under test .

The computing device may include a native application the markup language application a hybrid application a browser based application or a combination thereof.

The native application is written and compiled for execution on the particular computing device platform. For example native applications may be written in a programming language such as C or Objective C and compiled into native code such as a binary executable for use on the device having a particular processor and operating system.

In comparison markup language applications include one or more instructions in a markup language which is rendered and a scripting language which is interpreted by a scripting language engine during execution. For example a hypertext markup language HTML version 5 or higher markup language application may include HTML and cascading style sheets CSS as the markup language and JavaScript as the scripting language. In some implementations the markup language application may have multiple instances of the UIWebView class references.

The hybrid applications include native code as well as markup language application portions. For example portions of native code may be used to interact with platform specific hardware such as a graphics processing unit while portions of markup language provide business logic and user interface elements.

The browser based applications are processed within a web browser application and may be limited in their execution by the constraints of the web browser. The browser based applications may include rendering of a particular web page or group of web pages such as expressed at least in part by a markup language such as HTML5. The browser based application is executed within a particular sandbox and executes within the web browser. The browser based applications may have only a single UIWebView instance. Browser based applications may be further constrained in that they may share caches and other resources with the web browser and also occupy the same sandbox as the web browser. Sandboxing and distinctions between the different applications are discussed elsewhere in this application such as in regard to .

The computing device may include one or more of the remote applications under test . These applications are remote or external in that they are executing on a different device from the development device and the development tool module . The remote applications under test may include the markup language application the hybrid application or both.

The remote applications under test may use a layout engine module during execution. In one implementation the layout engine module may comprise WebKit as promulgated by Apple Corp. and others. In this implementation the commands may comprise WebKit commands.

The layout engine module may include one or more libraries scripting language engines embedded test tools and so forth. The libraries may comprise previously stored program instructions which may be called by applications during execution. These libraries may include those involved in layout rendering document object model DOM creation graphics libraries and so forth. In one implementation the graphics libraries may include WebGL as promulgated by the Khronos Group of Beaverton Oreg.

The scripting language engines are configured to interpret and execute the scripting language portion of the markup language application or the hybrid application . In the WebKit implementation the scripting language engine may comprise the JavaScript Core. Other scripting language engines may also be present. For example the Nitro JS engine provided by Apple Corp. the Carakan JavaScript engine provided by Opera Software of Oslo Norway and so forth may be available on the computing device for use. These may be regularly available on the computing device or may be specifically loaded onto the computing device for testing purposes.

The layout engine module may include one or more of the embedded test tools . The embedded test tools are functionalities in the layout engine module which may be used for testing. The embedded test tools may include facilities for runtime editing providing memory allocation information platform resource usage information and so forth. The embedded test tools are configured to interact with the scripting language engine or other portions of the layout engine module . For example in one implementation the embedded test tools may comprise the Mobile Safari web inspector such as implemented by the com.apple.webinspectord service executing on a computing device which uses the Apple iOS operating system. The embedded test tools may generate the output data . The embedded test tools may be used in conjunction with the development tool module s executing on the development device to provide various testing capabilities to the software developer.

Communication between the development tool module on the development device and the layout engine module may be provided in some implementations by a communication module and an unpack module . The communication module is configured to send and receive information to a device external to the computing device such as the development device . The communication module may use various physical transports to exchange information including universal serial bus USB Institute of Electrical and Electronics Engineers IEEE 1394 Firewire wired Ethernet wireless such as Wi Fi or Bluetooth and so forth. Transmission control protocol TCP user datagram protocol UDP or other transport layer protocols may be used in conjunction with the physical transports to exchange information between the development device and the computing device . In one implementation the physical transport may comprise USB and data may be sent using hypertext transport protocol HTTP over TCP HTTP TCP WebSockets and so forth.

In one implementation the communication module may comprise a lightweight HTTP server. This server is configured to send and receive data and is considered lightweight in that it executes with relatively small resource overhead and has a more limited feature set than that provided by a typical web server application such as Apache HTTP server. For example the communication module may omit functions such as support for HTTP Secure HTTPS .

In another implementation the communication module may be configured to provide TCP over USB. For example the communication module may implement the usbmuxd daemon.

The communication module may receive packed commands from the development tool of the development device . The commands may be packetized or otherwise manipulated for transport between the development tool module on the development device and the computing device forming the packed commands . The communication module passes the received packed commands to the unpack module .

The unpack module is configured to process the packed commands and provide unpacked commands to the layout engine module . The processing may include removing transport associated information such as headers routing information and so forth. For example the unpack module may remove TCP headers and reassemble payloads across multiple packets to form the commands . In some implementations the unpacked commands may be in extensible markup language procedure call XPC format.

The unpack module provides the unpacked commands to the layout engine module for processing. The unpacked commands are compatible with the embedded test tools and other aspects of the layout engine module and an associated framework. Just as the development tool module may send commands associated with the local application under test the development tool module may send commands associated with the remote application under test . The layout engine module may be configured to operate such that commands are provided and responses such as the output data are generated.

The development tool modules may include one or more developer modules a proxy module and a driver module . The developer modules may include code editor modules debug modules automated test modules or other modules . The developer modules may be configured to generate one or more commands . For example generation may include creation of a command replay of a previously stored command and so forth. The code editor modules may include tools for the developer to change the markup language expressions in the markup language application perform runtime editing and so forth. The debug modules may provide for step by step execution crash analysis and so forth. The automated test modules may allow for creation editing and playback of test script data which may be used to automate at least a portion of a testing regimen. Other modules may provide other testing functionality. For example a fuzzing module may be configured to generate inputs which may be applied to the markup language application or another application under test. In one implementation the developer modules may include one or more of the applications libraries executables application programming interfaces APIs and so forth present in the Google DevTools as promulgated by Google Inc. In some implementations the developer modules may generate commands which are compliant with at least a portion of the remote debugging protocol as promulgated by Google Inc.

The proxy module is configured to provide a communication proxy between the development tool modules or the driver module and modules executing on the computing device . For example the proxy module may provide for communication between a Chrome DevTool on the development device and the web inspector daemon com.apple.webinspectord executing on the computing device . The proxy module may encapsulate pack or otherwise process the commands or other data for transfer. For example in one implementation the proxy module may generate packed commands from the commands provided by one or more of the developer modules .

The proxy module may be configured to provide communications interfaces or ports. For example the proxy module may provide a first set of one or more WebSockets which are available to communicate with the developer modules and the driver module and a second set of one or more WebSockets which are available to communicate with services or modules executing on the computing device . In some implementations the WebSocket protocol may be compliant with the Internet Engineering Task Force RFC 6455.

The proxy module may maintain multiple sessions or WebSocket ports for a single computing device . For example in one implementation a separate WebSocket port may be provided for each tab within a browser application executing on the computing device .

The driver module is configured to receive commands in a first form and convert those commands to a second form. For example the driver module may receive commands in a first form which is compatible with the remote debugging protocol and provide commands which are compatible with the WebKit of the layout engine module . Continuing the example the command may designate a URL to open and render within a web browser.

In some implementations the driver module may be implemented using the Ruby programming language as developed by Yukihiro Matsumoto and described at www.ruby lang.org. The driver module may be used to provide a command line interface CLI . The command line interface may accept commands manually such as when the developer types them into the CLI or may accept commands which have been previously written such as from test script data.

Using the techniques described a single development device may perform testing using one or more computing devices . For example the single development device may be connected to and performing testing using four computing devices and . The testing may be automated allowing for long duration and more comprehensive tests across multiple devices compared to testing on a single computing device at a time.

The modules in this disclosure may be described as separate modules for ease of illustration and not by way of limitation. For example the communication module and the unpack module are described in this disclosure as separate modules. In some implementations at least a portion of the functionality of these modules may be combined into a single module or incorporated into another module. The computing device is described in more detail elsewhere in this application such as in regard to .

Some operating systems executing on the computing devices may provide for sandboxes or sandboxing. The sandbox comprises an environment with access controls applied to executing processes. These access controls may be provided to limit or control interactions between the executing applications and with other devices or applications. Sandboxing may be used to mitigate the effects of malicious or improperly coded applications. In some implementations the sandboxes may be implemented as separate virtual machines within which the application may execute. Some operating systems such as the iOS operating system by Apple Corp. provide for sandboxing applications.

In this illustration four sandboxes are depicted with a different application in each. However it is understood that in some implementations sandboxing may be omitted and the various applications may execute in a common environment.

The sandbox contains the native application . As described above the native application is written and compiled for execution on the particular computing device platform. The native application comprises native code and may also include one or more data files . The native code comprises a binary executable for use on a particular platform. For example the native application may be written in a programming language such as Objective C and compiled into native code . The data files may include application cache proxy server caches user preferences user data and so forth. For example in one implementation the data files may include a cache used by a web browser application.

The sandbox contains the markup language application . The markup language application includes one or more instructions expressed in a markup language . The markup language may use one or more tags to specify particular rendering of content. For example the markup language may comprise instructions compliant with hypertext markup language HTML version 5 or higher . The markup language may also include cascading style sheets CSS . While the examples in this disclosure use HTML5 or later the systems and methods described may also be applied to other markup languages.

The markup language application may also include instructions expressed in a scripting language . The scripting language is configured for processing by an interpreter during execution. For example the scripting language may comprise JavaScript and the interpreter may comprise the JavaScript Core in WebKit . While the examples in this disclosure use JavaScript the systems and methods described may also be applied to other scripting languages.

In some implementations the markup language application may have multiple instances of the UIWebView class references. These UIWebView instances enable presentation of content expressed using a markup language such as HTML5 with CSS and a scripting language such as JavaScript. For example as depicted here the markup language application may have UIWebView instances .

The markup language application may also have one or more data files . As described above the data files may include property list PLIST files caches user preferences user data icons cookies databases temporary files temporary directories and so forth. In some implementations a portion or all of the data files may be stored on a remote device such as a backend server accessible via the Internet. Software developers may thus minimize or eliminate the data which is stored locally on the computing device . This may be done to reduce local storage requirements improve security of the data and so forth. For example upon loss or compromise of the computing device the backend server may terminate access safeguarding the data. Use of the backend server may also minimize or eliminate the complexity associated with encrypting contents in the data files to further safeguard data. The implementation of the markup language application as a front end and the use of the backend server allows for easier purging of data associated with the application when the application is exited or terminated.

The development tool module may be configured to access information about the data files and present that information to the developer for testing debugging inspection and so forth of the local store associated with the remote application under test .

For example consider an example markup language application executing in the sandbox of the computing device which is executing the iOS operating system. In this example the data files such as which are associated with remote applications under test may be stored on the computing device at a directory location var mobile Applications device specific where device specific indicates a value which may vary from one computing device to another. The files may be analyzed debugged or tested using various tools of the development tool module as appropriate to the file types. For example where the .db files indicated above such as EAsyncstore.db use SQLite as developed by D. Richard Hipp and others the sqlite3 utility be used to execute commands against the database.

As described above the data files may also include session cookies. A command may be used to retrieve these session cookies.

The development tool module may also include the plutil as provided with the Mac OS from Apple Corp. to interact with session PLIST files user data PLIST files and so forth.

By using the development tool module the developer may assess the data files which are locally stored on the computing device by the remote application under test . For example the above information about the data files may be presented within the Safari Inspector.

In some implementations the data files may be cleared prior to during or after testing. For example a command may be issued by a developer module . The command may be configured to clear a browser cache prior to testing page load times. In some implementations other caches such as a cache used by a proxy server may be cleared.

To clear the cache or provide other actions on data in the file system of the computing device the file system of the computing device may be mounted by the development device . Once mounted files such as cache files may be deleted.

In the implementation described below a Filesystem in Userspace FUSE kernel module may be loaded on a computing device which is executing the MacOS from Apple Corp. In one implementation MacFUSE may be used. MacFUSE may be obtained from http code.google.com p macfuse or other locations. The following example illustrates the use of MacFUSE however other FUSE implementations may also be used such as OSXFuse.

The MacFUSE application may be installed and the command run mountAppDirectory may be executed. The MACFuse application attempts to connect with the Apple File Connection AFC or AFC2 using lockdownd. The iOS operating system module of the computing device provides the AFC AFC2 service.

The document sharing service com.apple.mobile.house arrest which is available on iOS may then be started. The house arrest makes an app container of the markup language application which is undergoing testing available for sharing. Using the AFC AFC2 connection the directory is accessible using MACFuse. Once accessible file operations such as cache files associated with the browser application module may be deleted.

The sandbox depicts the hybrid application . As described above the hybrid application includes native code as well as markup language scripting language or both. For example portions of native code may be used to interact with platform specific hardware such as a graphics processing unit GPU or satellite navigation receiver while portions of markup language provide business logic and user interface elements such as controlling display of mapping information. Similar to the markup language application multiple instances of the UIWebView and class references may be present. The hybrid application may also have one or more associated data files .

The sandbox depicts the browser based applications . Browser based applications are processed within a web browser application and are limited in their execution by this constraint. The browser based application may include a web page or collection of web pages. In one implementation the web browser application may be the Safari browser also known as Mobile Safari by Apple Corp. and executing in the iOS operating system while in another implementation the web browser application may be the Chrome browser by Google Inc. and executing in the iOS operating system the Android operating system and so forth. The web browser application may access one or more of the markup language or scripting language for rendering and execution. The browser based application may have only a single UIWebView instance.

The web browser application s native code the rendered markup language the executed scripting language the corresponding single UIWebView instance and the data files share the same sandbox . As a result there is a potential for unwanted or undesired interactions. For example the scripting language may improperly invoke a function in the native code and generate an error or malicious condition.

Among the types of applications the markup language application provides a useful blend of benefits. Cross platform development and maintenance is less than that of native applications . Hybrid applications leverage platform specific native code with the cross platform capabilities of the markup language and the scripting language . The markup language application readily supports multiple UIWebView instances allowing for rich application experiences compared to browser based applications . Compared to the browser based applications the markup language application and the hybrid application may experience improved security by operating in a separate sandbox omitting the web browser application and so forth.

The development device may include one or more input output I O interface s to allow the development device to communicate with other devices. For example the I O interface s may be configured to provide a universal serial bus USB connection compliant with the standards promulgated by the USB Implementers Forum Inc. of Beaverton Oreg. to couple to the computing device .

The I O interface s may couple to one or more I O devices . The I O device s may include user input devices such as one or more of a keyboard a mouse a pen a game controller a voice input device a touch input device a gestural input device and so forth. The I O device s may include output devices such as one or more of a display a printer audio speakers haptic output devices and so forth. In some embodiments the I O device s may be physically incorporated with the development device or be externally placed.

The development device may also include one or more network interfaces to enable communications between the development device and other networked devices. Such network interface s may include one or more network interface controllers NICs or other types of transceiver devices configured to send and receive communications over the network s . For example the network interface s may be configured to provide a wired network connection wireless Wi Fi connection compliant with one or more IEEE 802.11 standards such as 802.11g or 802.11n and so forth. The development device may also include one or more busses or other internal communications hardware or software that allow for the transfer of data between the various modules and components of the development device .

The development device includes one or more memories . The memory comprises one or more computer readable storage media CRSM . The CRSM may be any one or more of an electronic storage medium a magnetic storage medium an optical storage medium a quantum storage medium a mechanical computer storage medium and so forth. The memory provides storage of computer readable instructions data structures program modules and other data for the operation of the development device .

The memory may include at least one operating system OS module . The OS module is configured to manage hardware resources such as the I O interface s and network interface s and to provide various services to applications or modules executing on the processor s . In some implementations the OS module may comprise one or more operating systems configured for execution on the development device . For example the OS module may implement one or more of Mac OS from Apple Corp. of Cupertino Calif. Windows from Microsoft Corp. of Redmond Wash. Linux and its derivatives from various sources FreeBSD UNIX or other operating systems.

The memory may include a user interface module the development tool module a local application under test one or more of the developer modules or other module s . For example the memory may store at least a portion of the development tool module and developer modules such as the Safari Inspector from Apple Corp. the Chrome DevTools and so forth.

The memory also includes a datastore to store information for operations of the development device . The datastore may comprise a database array structured list tree executable code markup language or other data structure. In some implementations the datastore may store remote application under test connection data . For example the connection data such as USB port device identifier address and so forth may be stored. Test script data may be stored which defines particular tests or functions be executed by the development tool module against an application under test. The test script data may comprise a series of instructions or commands configured to initiate or otherwise perform the tests or functions to exercise the application under test. In one example the test script data may comprise one or more commands configured to clear a browser cache initiate a debugging session enable a web inspector specify a network address open a web page at the network address and so forth.

In some implementations the test script data may be provided as described in U.S. patent application Ser. No. 13 868 560 filed on Apr. 23 2013 titled Test Script Generation to Manish Lachwani et al. which has been incorporated by reference into this disclosure.

The session data may be stored in the datastore . As described elsewhere in this disclosure in some implementations the session data may be stored in a JSON format.

Other data may also be stored such as software developer preferences configuration settings for the development tool module and so forth.

The computing device may include one or more input output I O interface s to allow the computing device to communicate with other devices. For example the I O interface s may be configured to provide a universal serial bus USB connection to couple to the development device .

The I O interface s may couple to one or more I O devices . The I O device s may include user input devices such as one or more of a keyboard a mouse a pen a game controller a voice input device a touch input device a gestural input device or other devices. The I O device s may include output devices such as one or more of a display a printer audio speakers haptic output devices and so forth. In some embodiments the I O device s may be physically incorporated with the computing device or be externally placed.

The computing device may also include one or more network interfaces to enable communications between the computing device and other networked devices such as those depicted in . Such network interface s may include one or more network interface controllers NICs or other types of transceiver devices configured to send and receive communications over the network s . For example the network interface s may be configured to provide a Wi Fi connection compliant with one or more IEEE 802.11 standards such as 802.11g or 802.11n. The computing device may also include one or more busses or other internal communications hardware or software that allow for the transfer of data between the various modules and components of the computing device .

The computing device includes one or more memories . The memory comprises one or more CRSM as described above. The memory provides storage of computer readable instructions data structures program modules and other data for the operation of the computing device .

The memory may include at least one operating system OS module . The OS module is configured to manage hardware resources such as the I O interface s and network interface s and to provide various services to applications or modules executing on the processor s . In some implementations the OS module may comprise one or more mobile operating systems configured for execution on mobile computing devices. For example the OS module may implement one or more of iOS from Apple Corp. of Cupertino Calif. Windows Mobile from Microsoft Corp. of Redmond Wash. Android from Google Inc. of Mountain View Calif. and its derivatives from various sources Palm OS from Palm Computing Inc. of Sunnyvale Calif. and its derivatives from various sources BlackBerry OS from Research In Motion Ltd. of Waterloo Ontario Canada or other operating systems such as VxWorks from Wind River Systems of Alameda Calif. In cases where the OS module implements a version of iOS any version of iOS may be supported including iOS 1.x 2.x 3.x 4.x 4.x 6.x 7.x or higher versions including any version of iOS for the iPhone iPad iPod Touch or any other compatible derivative or related device. In cases where the OS module implements a version of Android any version of Android may be supported including but not limited to versions 2.3.x Gingerbread 4.0.x Ice Cream Sandwich 4.1.x Jelly Bean and so forth. As described above with regard to in some implementations the OS module may be configured to sandbox applications .

The memory may include a browser application module . This browser application module may be implemented as a native application compiled for execution on the particular platform of the computing device . For example where the platform comprises an Apple Corp. device running the iOS operating system the browser application module may comprise the Safari mobile browser.

The memory may also include the layout engine module as described above. In some implementations the layout engine module may comprise the WebKit framework and associated libraries scripting language engine and embedded test tools . The browser application module or other applications on the computing device may utilize at least a portion of the layout engine module during operation. For example the Safari mobile browser may use the JavaScript core in WebKit for execution of the scripting language which comprises JavaScript.

The layout engine module may be initialized prior to testing. The initialization may be configured to activate the embedded test tools . For example where the layout engine module comprises WebKit the WebKit listener may be placed into an inspection mode configured to receive commands from the Safari Inspector. In another example the web inspector process com.apple.webinspectord may be loaded. In this example the lockdownd process present in iOS may be used to start com.apple.webinspectord.

In some implementations where information about how to initialize or otherwise activate the embedded test tools is not readily available the layout engine module or other applications may be analyzed as described in U.S. patent application Ser. No. 13 631 919 filed on Sep. 29 2012 titled Application Validation Through Object Level Hierarchy Analysis and in U.S. patent application Ser. No. 13 655 667 filed on Oct. 19 2012 titled Application Auditing Through Object Level Code Inspection both of which are incorporated by reference into this disclosure.

The testing described herein may further be facilitated using the systems and methods described in U.S. patent application Ser. No. 13 619 867 filed on Sep. 14 2012 titled Remote Control of a Mobile Device which is incorporated by reference into this disclosure.

The communication module and the unpack module are also stored in the memory . As described above the communication module is configured to send and receive information to a device external to the computing device such as the development device . In one implementation the communication module may comprise a lightweight HTTP server. In another implementation the communication module may comprise the Apple Corp. usbmuxd process which provides data transport over the USB connection.

As also described above the unpack module is configured to process the packed commands and provide unpacked commands to the layout engine module . The unpacked commands are compatible with the embedded test tools and other aspects of the layout engine module and an associated framework. In some implementations the commands may be provided by the developer modules directly or may be provided by the driver module .

The memory may include native applications markup language applications hybrid applications browser based applications and so forth. As described above the remote applications under test may include one or more of the markup language application the portion of the hybrid application which is non native code or the portion of the browser based application which uses a markup language.

Other modules may also be stored in the memory such as digital rights management modules speech recognition modules and so forth.

The memory also includes a datastore to store information for operations of the computing device . The datastore may comprise a database array structured list tree or other data structure. The datastore may store the packed command data unpacked command data the output data or both. Other data may also be stored such as user preferences configuration settings and so forth.

The techniques described in this disclosure may use one or more services applications or processes which are provided by the OS module in a secured configuration such as a non jailbroken device as shipped from a manufacturer. For example the development tool module may be used to gather session data associated with the remote application under test such as the markup language application . This may occur without the use of root or super user privileges.

However in other cases one or more modifications may be made to the computing device . For example the OS module may be rooted or jailbroken prior to installation of the communication module the unpack module and so forth. Rooting or jailbreaking may include bypassing one or more security constraints imposed by the OS module and may provide unrestricted or minimally restricted access to the file system portions of the OS module processes executing on the computing device and so forth. For example root or super user privileges may be available on a jailbroken device as compared to a non jailbroken in which root or super user privileges are unavailable or strictly curtailed.

The option to specify network address of a web page to test may be used to test performance of a particular web page. For example the user may specify a URL with a web page to load and render in the browser application .

The option to enable video capture may be used to capture video output as presented on the display of the computing device during a run of the test. For example the developer may select this option such that when a failure in execution of the markup language application is determined the failure may be observed.

The option to use an automated test script may allow for automated testing. Automated testing allows one or more tests to be run one or more times without human intervention during the testing. The automated testing may use the test script data described above. The automated tests may be manually created or automatically generated.

The option to test on all available connected computing devices may allow for the use of a plurality of computing devices which are connected to the development device . For example the testing may be performed on twenty computing devices attached to the development device .

The option to send session data after completion may be used to send the session data to another developer module development device external server and so forth. For example the session data may be sent to a build server following completion of testing.

The option to collect timeline data may be used to collect information about what actions by the markup language application occur at what times in what sequence and for how long. For example the Chrome DevTools provide a JavaScript Console which includes timeline functionality.

The option to collect network event data may be used to acquire data about information which is sent to and from one or more of the network interfaces by the markup language application . For example the Chrome DevTools provide network event capture and analysis capabilities.

The option to retrieve device console logs may be used to access console logs generated on the computing device . For example the console logs may provide information about kernel failures application crashes and so forth.

The option to retrieve app crash reports may be used to access crash reports from the computing device . The crash reports may be generated by the OS module the layout engine module and so forth.

The option to generate page load characteristics may be used to acquire information or calculate from previously acquired session data information about load times of the markup language application . For example this may include determining time to load a document object model DOM time to load the entire page and so forth. In some implementation selection of this option may result in commands being sent to the computing device to clear a browser cache or other previously stored files associated with the markup language application being tested.

In some implementations selection of one option may result in selection or deselection of another option. For example selection of the option to generate page load characteristics may result in deselection of the option to collect timeline data as this may result in significant overhead on the computing device distorting the resulting page load times.

Other options and tests may be available as well. These may include but are not limited to retrieving DOM debugger and script parsing output retrieving information about processor bound threads heap size utilization rendering time paint time measuring hardware statistics such as memory processor disk network and so forth.

By allowing the developer to collect and access this information particularly in an automated fashion on real browser applications executing on actual computing devices the development process is improved. The impact of changes in the code of the markup language application may be determined and debugged which may result in improved markup language applications .

Other options may be provided as well. For example the developer may specify use of particular audio libraries for use in audio processing.

The output data is depicted in a graphical user interface however in other implementations the information may be presented as a character user interface or may be stored for processing by another application. For example the output data may be stored for processing by an analytical application such as Splunk by Splunk Inc. of San Francisco Calif. Nagios as promulgated by Nagios Enterprises LLC of Saint Paul Minn.

The user interface may include one or more indications of options which have been selected. For example these may include the options discussed above with respect to .

A runtime editing code view is presented. In this view the software developer may see a portion of the code such as the markup language the scripting language or both at a particular point in execution. For example the runtime editing code view may present a portion of the code where an error has occurred. The runtime editing code view may also allow the software developer to make changes to the code for subsequent testing.

Memory allocation and leak detection data may be depicted. This information may include information such as memory allocated to particular processes. For example the software developer may use this information to determine that the markup language application has a particular process which has been allocated memory for use but is not released after use or is inaccessible.

Timeline data may be presented. The timeline data may present information about which elements have been accessed the duration of that access and so forth. Network bandwidth data may also be presented. The network bandwidth data provides information about a quantity of data transferred with respect to a particular element and the duration of that transfer.

A control to play video capture of a particular test may be provided. For example the user interface may provide a control to playback the video capture of the test session.

CPU usage data or other information about hardware resource usage on the computing device may also be presented. In this illustration various threads of the remote application under test and their associated usage of processor resources may be presented to the software developer.

Page load information may be provided in the user interface . For example in this illustration details about a particular SEND request and a maximum amount of memory used during page load is presented.

In some implementations the user interface may also provide information indicating the operating system executing on the computing device . For example the tests were run on a computing device executing iOS 7.0.4.

The test results and functions depicted are provided for illustration and not by way of limitation. In some implementations additional tests may be added some tests may be omitted and so forth.

Block provides a first set of one or more ports. The first set of one or more ports are accessible to the developer modules the driver module or both. The proxy module may be configured to receive the one or more commands at the first set of one or more ports.

Block establishes communication with one or more external computing devices coupled to the development device . In one implementation this may include initiating a connection via a USB using the Mobile Device framework as promulgated by Apple Corp. with the external computing device executing a version of the iOS operating system version 7.0 or higher as promulgated by Apple Corp.

As described the external computing device may be configured to execute the layout engine module within an operating system having a secured configuration. For example where the computing device is executing the iOS operating system the OS module may not be jailbroken .

Block provides a second set of one or more ports. The second set of one or more ports are accessible to one or more of the modules which may execute on the computing device . For example the second set of one or more ports may be accessible to the layout engine module which is executable on the external computing device . As described in this disclosure the layout engine module may comprise one or more portions of WebKit the com.apple.webinspectord daemon or a combination thereof. Communication may be established with the external computing device using the second set of one or more ports.

The first set of ports the second set of ports or both may be compliant with the WebSocket protocol as promulgated by the Internet Engineering Task Force Request For Comments RFC 6455. In one implementation such as where the driver module is implemented using the Ruby programming language the faye WebSocket implementation may be used. Faye is promulgated by James Coglan at faye.jcoglan.com.

Block transfers data such as the commands the output data and so forth between the first set of one or more ports and the second set of one or more ports. For example the command received by the first set of ports from the debugger module may be passed via a WebSocket connection of the first set of one or more ports and transferred to the second set of one or more ports for delivery to the layout engine module . In another example data such as the output data may be received from the external computing device using the second set of one or more ports. For example output data generated at least in part by the layout engine module may be transferred by the proxy module and received by one or more of the developer modules .

In one implementation the one or more commands may be generated by one or more of the developer modules . The one or more commands may be configured to control at least a portion of the execution of the remote application under test which is configured to execute on the computing device . For example the automated test module may generate commands which are configured to set one or more parameters for testing such a network address indicative of a location from which to retrieve a list of portion of the remote application under test . Continuing the example the network address may comprise a URL which is associated with the remote application under test comprising one or more webpages. The one or more commands may be provided to the external computing device using the second set of one or more ports. For example the one or more commands may be sent to the com.apple.webinspectord service executing on the external computing device within the iOS operating system.

In some implementation the developer module may use the proxy module the driver module or both for automated testing. In this implementation the developer module may access an automated test script such as the automated test script data . Once accessed the developer module may generate or replay the one or more commands based on the automated test script. For example the automated test module may access the test script data and begin executing the script.

As described elsewhere in this disclosure the proxy module may receive commands from the driver module . For example as described elsewhere in this disclosure the driver module may convert the commands from a first form to a second form. The proxy module may then pass those commands which are now in the second form to the computing device .

In one implementation the commands may be compliant with at least a portion of remote debugging protocol as promulgated by Google Inc. of Mountain View Calif. The external computing device may execute the iOS operating system version 7.0 or higher as promulgated by Apple Corp. of Cupertino Calif. In this implementation the proxy module serves to connect the developer modules which use the remote debugging protocol and one or more modules executing in the iOS operating system such as the com.apple.webinspectord WebKit and so forth.

As described elsewhere in this disclosure such as with regard to the commands may be converted from a first form to a second form. In one implementation prior to providing the commands the driver module may convert the one or more commands provided to the external computing device to one or more expressions configured to control operation of a WebKit layout engine module .

Other commands may also be transferred by the proxy module . In one implementation at least a portion of the one or more commands may be configured to clear a browser cache or other cache associated with the layout engine module . In this implementation as described elsewhere in this application MacFUSE may be used to access the app container of the remote application under test to delete files such as those stored within the cache.

Block receives one or more commands expressed in a first form. While in the first form the command may be inoperable to control the layout engine module of one or more of the computing device . For example the first form of the command may be unrecognized by the layout engine module .

Block converts the command from the first form to a second form wherein the layout engine is controllable by the second form. For example the conversion may change a remote debugging protocol command to a WebKit call.

Block provides the second form of the command to the layout engine module on the computing device . For example the driver module may use the proxy module to send the second form of the command to the layout engine .

In one implementation the second form of the command may be received at a first set of one or more WebSocket ports. Communication may be established with the computing device at a second set of one or more WebSocket ports. The second form of the command may be sent to the layout engine module using the second set of one or more WebSocket ports. The driver module provides the capability for the developer modules which may not otherwise be compatible to operate the layout engine module or other services or modules provided by the computing device .

Block executes a proxy module . As described in this disclosure in one implementation the proxy module may provide a first set of WebSockets and a second set of WebSockets and allow transfer of data between the first and second sets.

Block executes one or more developer modules . The developer modules may be configured to operate in remote application under test which executes on the computing device .

Block establishes a connection between the developer module and the remote application under test using the proxy module . For example the debug module may establish a WebSockets connection with the first set of WebSockets provided by the proxy module .

Block starts video capture on the computing device . For example a video capture application executing on the computing device may be executed. The video capture may be implemented as described in U.S. patent application Ser. No. 13 619 867 filed on Sep. 14 2012 titled Remote Control of a Mobile Device to Manish Lachwani et al. which has been incorporated by reference into this disclosure.

Block sends one or more commands from the developer module to the remote application under test using the proxy module . As described above in some implementations the driver module may be used to convert at least a portion of the commands from a first form to a second form wherein the second form is operable with regard to the remote application under test or one or more modules executing on the computing device .

Block stops video capture on the computing device. For example the video capture application may be terminated or suspended.

Block receives output data from the computing device . For example the layout engine module may provide output data from the com.apple.webinspectord daemon.

Block generates session data based at least in part on the output data . For example the session data may comprise a JSON file.

For illustration and not by way of limitation the following examples of illustrative code are provided.

Code Sample 1 Proxy module establishes communication with computing device and sets up web inspector.

Those having ordinary skill in the art will readily recognize that certain steps or operations illustrated in the figures above may be eliminated combined or performed in an alternate order. Any steps or operations may be performed serially or in parallel. Moreover the methods described above may be implemented as one or more software programs for a computer system and may be encoded in a computer readable storage medium as instructions executable on one or more processors.

Embodiments may be provided as a computer program product including a non transitory computer readable storage medium having stored thereon instructions in compressed or uncompressed form that may be used to program a computer or other electronic device to perform processes or methods described herein. The computer readable storage medium may be one or more of an electronic storage medium a magnetic storage medium an optical storage medium a quantum storage medium and so forth. For example the computer readable storage media may include but is not limited to hard drives floppy diskettes optical disks read only memories ROMs random access memories RAMs erasable programmable ROMs EPROMs electrically erasable programmable ROMs EEPROMs flash memory magnetic or optical cards solid state memory devices or other types of physical media suitable for storing electronic instructions. Further embodiments may also be provided as a computer program product including a transitory machine readable signal in compressed or uncompressed form . Examples of machine readable signals whether modulated using a carrier or unmodulated include but are not limited to signals that a computer system or machine hosting or running a computer program can be configured to access including signals transferred by one or more networks. For example the transitory machine readable signal may comprise transmission of software by the Internet.

Separate instances of these programs can be executed on or distributed across any number of separate computer systems. Thus although certain steps have been described as being performed by certain devices software programs processes or entities this need not be the case and a variety of alternative implementations will be understood by those having ordinary skill in the art.

Additionally those having ordinary skill in the art readily recognize that the techniques described above can be utilized in a variety of devices environments and situations. Although the present disclosure is written with respect to specific embodiments and implementations various changes and modifications may be suggested to one skilled in the art. It is intended that the present disclosure encompass such changes and modifications that fall within the scope of the appended claims.

