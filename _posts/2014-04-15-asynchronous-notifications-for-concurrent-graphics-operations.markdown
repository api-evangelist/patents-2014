---

title: Asynchronous notifications for concurrent graphics operations
abstract: A method and an apparatus for notifying a display driver to update a display with a graphics frame including multiple graphics data rendered separately by multiple graphics processing units (GPUs) substantially concurrently are described. Graphics commands may be received to dispatch to each GPU for rendering corresponding graphics data. The display driver may be notified when each graphics data has been completely rendered respectively by the corresponding GPU.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08988442&OS=08988442&RS=08988442
owner: Apple Inc.
number: 08988442
owner_city: Cupertino
owner_country: US
publication_date: 20140415
---
This application is a continuation of co pending U.S. application Ser. No. 13 668 169 filed on Nov. 2 2012 which is a continuation of U.S. application Ser. No. 11 811 337 filed on Jun. 7 2007 now issued as U.S. Pat. No. 8 310 491.

The present invention relates generally to graphics processing. More particularly this invention relates to asynchronous notifications for graphics operations.

As more and more media processors are coupled through a common memory system to share graphics content for performing graphics operations separately it is becoming more and more expensive to allow one media processor such as a graphics processing unit GPU to consume the result produced by another media processor. Usually these media processors may be capable of handling 2D 3D Video and or display command streams driven by API application programming interface calls from a graphics application. A host processor such as a central processing unit CPU is typically required to explicitly synchronize these graphics operations by stopping one media processor and starting another one when switching between APIs. Such synchronization is usually very costly and prevents simultaneous parallel execution of a separate media processors.

In particular a media processor may be driven by a system on a chip requiring a host processor included in the chip to respond to an interrupt signifying the completion of individual hardware graphics operations such as a single copy operation or a single solid color fill operation. However responding to a single interrupt per operation can be expensive. Furthermore interrupts may prevent simultaneous execution of media processors and a host processor. Consequently the overall performance is degraded with lower parallelism.

On the other hand multiple media processors and a display device coupled with a common memory system may require synchronization. For example more than one component of a graphics content may arrive asynchronously from separate media processors to be displayed in a display device for a single application. Executing a graphics command to display the graphics content may depend on when each component is properly rendered and ready to display. Apparently it is necessary to ensure maximum parallelism among multiple media processors to allow rendering different components for the same graphics content in a synchronous manner.

Additionally parallel operations between a host processor and coupled media processors may be limited by a bottleneck introduced when deleting commonly shared graphics resources. Typically media processor drivers ensure the media processors are idle prior to deleting graphics resources such as allocated memories memory management unit MMU entries the textures etc. that might otherwise be in use by pending graphics operations. This however prevents parallel operations by the host processor and media processors.

Furthermore graphics rendering operations such as scaling may be limited by a fixed number of fractional precision in media processor hardware for arithmetic representations. Often the bit precision of the scale factor is limited to optimize mathematical operations inside the media processor hardware to allow a multiplication instead of a division which may be more expensive. For example a scale factor may be inversely represented through a limited bit precision fixed point arithmetic. As a result a limiting factor is introduced that certain scale factors cannot be represented accurately.

An embodiment of the present invention includes a method and apparatus that notify a display driver to update a display with a graphics frame including multiple graphics data rendered separately by multiple graphics processing units GPUs substantially concurrently. Graphics commands may be received to dispatch to each GPU for rendering corresponding graphics data. The display driver may be notified when each graphics data has been completely rendered respectively by the corresponding GPU.

In an alternative embodiment a display is updated with a graphics frame including multiple graphics data after receiving a plurality of synchronization messages. The graphics frame may include multiple graphics data associated with separate GPUs. A separate synchronization message may be received from each graphics driver associated with a GPU to indicate the graphics data corresponding to the GPU has been completely processed. Multiple GPUs may process corresponding graphics data substantially concurrently.

In another alternative embodiment a display is updated with a graphics frame when synchronization commands for a plurality of segments of the graphics data associated with the graphics frame have been received. A swap command may be received from a graphics API to identify a plurality of graphics commands for rending the plurality of segments of graphics data by a plurality of GPUs substantially concurrently. A synchronization command may be received from each GPU to indicate the respective GPU has completed processing the corresponding segment of graphics data associated with the GPU. Updating the display may be suspended until all of the synchronization commands are received. A synchronization command may be examined to determined whether it is the last one representing the last segment of the graphics data processed by the GPUs.

Other features of the present invention will be apparent from the accompanying drawings and from the detailed description that follows.

A method and an apparatus for processing graphics commands in graphics processors are described herein. In the following description numerous specific details are set forth to provide thorough explanation of embodiments of the present invention. It will be apparent however to one skilled in the art that embodiments of the present invention may be practiced without these specific details. In other instances well known components structures and techniques have not been shown in detail in order not to obscure the understanding of this description.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment.

The processes depicted in the figures that follow are performed by processing logic that comprises hardware e.g. circuitry dedicated logic etc. software such as is run on a general purpose computer system or a dedicated machine or a combination of both. Although the processes are described below in terms of some sequential operations it should be appreciated that some of the operations described may be performed in different order. Moreover some operations may be performed in parallel rather than sequentially.

According to one embodiment graphics driver fetches graphics commands from a command stream buffer not shown that receives the graphics commands from applications . In response to the received graphics commands the graphic driver may determine the resources required by the graphics commands and their relationships such as graphics resources dependencies. The graphics driver may send multiple graphics commands to a GPU if there is no resource conflict among the graphics commands otherwise the graphics driver may send one command at a time to a GPU dependent upon the availability of hardware resources of the GPU. For example graphics driver may send multiple 2D commands to a GPU. However graphics driver can only send one 3D command at a time or alternatively any 2D commands would not be sent until a previously sent 3D command has been executed.

In addition graphics driver further includes a resource management functionality to keep track what graphics commands have been sent to a GPU and how many of those commands have been executed by the GPU. The graphics driver further keep track of the graphics resources e.g. memory used by the commands. In one embodiment the graphics resources used by a graphics command would not be freed or released until the graphics command has been executed by the GPU.

Further the graphics driver and or graphics APIs may communicate with display controller or display driver for example via an interrupt. In one embodiment each of the GPUs processes the graphics data concurrently and asynchronously. For example multiple GPUs may process multiple components of a video frame concurrently. However the video frame would not be displayed or updated e.g. refresh until all of the components have been processed by the GPUs. The communications between the graphics APIs and graphics driver with the display controller would allow the display controller to synchronize for example via a swap command or a swap ID all of the processed components before display the video frame in the display .

According to certain embodiments of the invention graphics commands may be serialized to allow one or more media processors to process graphics data in an optimal and efficient manner. Each media processor may be a dedicated hardware chip to for example process graphics data according to a stream of graphics commands. A driver for a media processor may serialize graphics commands for the media processor to execute. In one embodiment a stream of graphics commands may be generated from multiple graphics applications via one or more graphics APIs Application Programming Interface . The stream of graphics commands received in a media processor may include multiple types of graphics commands such as 2D graphics commands or 3D graphics commands. In one embodiment serializing the stream of graphics commands may allow the media processor to execute graphics commands of the same type in an order in which these graphics commands have been received without requiring synchronization interrupts. In another embodiment serializing graphics commands may prevent one graphics API from running while another is constructing a new graphics command stream. Multiple media processors may execute serialized graphics command streams substantially concurrently with minimum synchronization interrupts from an associated host processor.

Referring back to in one embodiment a graphics API may generate one or more graphics commands through a graphics command generator. For example a graphics API module may generate 2D or 3D graphics commands through a 2D 3D command generator module for simple yet efficient graphics rendering functionalities such as 2D blit copy scaling filter or 3D primitive operations. APIs in an OpenGL embedded system API module may implement OpenGL functionalities to generate GL graphics commands through a GL command generator module . GL graphics commands may be associated with OpenGL functionalities based on an OpenGL state machine. In one embodiment a notification command generator module may be coupled with the graphics API module and an OpenGL embedded system API module to generate notification commands. Graphics operations across different graphics processing units may be synchronized through notification commands generated according to parameters associated with graphics API calls. In one embodiment an application may call APIs in a frame buffer API module for displaying a processed frame by generating a swap command through a swap master command generator . A swap command may include dependency conditions on graphics resources and graphics operations to display an associated frame buffer. In one embodiment a swap command may be associated with a swap id and a plurality of associated notification ids. A swap master command generator may forward a swap command to a display driver module associated with a graphics display device . The display driver module may receive notification messages from other graphics drivers such as graphics driver module to determine a condition to display a graphics frame according to swap ids and a notification ids extracted from the received notification messages.

According to one embodiment 2D 3D GL and notification graphics commands may be stored in a command stream buffer . One or more graphics commands may be arranged in the command stream buffer according to a sequence of graphics API calls from applications. A command stream buffer may be associated with a graphics processing unit through a graphics driver module . For example a graphics API may request for a command stream buffer. In response to the request the associated graphics driver allocates a segment of memory or buffer and passes the handle or pointer back to the graphics API such that the graphics API can store the graphics commands received from an application in the allocated command stream buffer. A graphics command generator may be coupled with more than one command stream buffer associated with more than one graphics processing units. In one embodiment the graphics processing unit may be a media or graphics processor separate from the host processor hosting the command stream buffer . The graphics driver module may retrieve graphics commands from the command stream buffer in an FIFO First In First Out order as stored in the command stream buffer . In one embodiment a graphics driver module may schedule processing a retrieved graphics command according to a header data such as header data in extracted from the retrieved graphics command. A graphics driver module may forward hardware graphics commands based on graphics instructions extracted from a graphics command such as graphics instructions in to be executed in a graphics processing unit . In one embodiment the graphics driver module may attach additional data known privately to a kernel or hardware specific but not available for an application to the hardware graphics commands forwarded to the graphics processing unit . In one embodiment the graphics driver module may process a graphics notification command by sending a notification message to a display driver module .

A command fetching module in the graphics driver module may retrieve graphics commands from the command stream buffer according to an order the graphics commands have been stored such as FIFO. In one embodiment the command fetching module may retrieve the next graphics command from the command stream buffer according to a status of the associated graphics processing unit and or dependency conditions identified from previously received graphics commands. The status of a graphics processing unit may include an indication on the availability of associated hardware resources such as a hardware FIFO buffer for receiving processing instructions. In one embodiment the status of a graphics processing unit may be obtained based on values of predetermined memory locations such as a status register associated with the graphics processing unit. The command fetching module may proceed fetching the next graphics command as instructed by a dependency checking module .

A dependency checking module may extract header data from a retrieved graphics command to determine if an associated graphics resource has been allocated in a memory coupled to the graphics processing unit . In one embodiment a memory for allocating graphics resources may be coupled to both the graphics processing unit and the host processor hosting the graphics driver module . The dependency checking module may notify a memory management module to allocate required graphics resources. In one embodiment the dependency checking module may compare the graphics instructions carried by the retrieved graphics command with graphics instructions from previously retrieved graphics commands to determine if a dependency condition exists for the current graphics command. In one embodiment forwarding graphics instructions of a 2D graphics command to a graphics processing unit may depend on when graphics instructions of a previous 3D graphics command are completely executed in the same graphics processing unit.

A command dispatching module may forward hardware graphics commands based on graphics instructions from a retrieved graphics command to the graphics processing unit . In one embodiment the command dispatching module may send the graphics processing unit with additional kernel level data associated with the hardware graphics commands such as interrupt addresses or callback addresses. The command dispatching module may send notification messages to a graphics display driver module for a retrieved graphics notification command. In one embodiment a notification message may inform the graphics display driver module readiness of one condition for displaying a frame buffer. The command dispatching module may not initiate sending commands or messages if corresponding dependency conditions are not satisfied according to a dependency checking module . In other embodiments a command dispatching module may generate a synchronization instruction appended to hardware graphics commands for a processing unit to notify a graphics driver module the completion of executing the hardware graphics commands. The notification may signify that a hardware buffer for an IO port of a graphics processing unit is emptied.

In one embodiment a graphics processing unit may include IO ports coupled to graphics core logics such as for example a 2D graphics processing module and a 3D graphics processing module . IO ports may buffer hardware graphics commands received. The size of a hardware buffer associated with IO ports may limit the maximum number of hardware graphics commands allowed at a time. In one embodiment a 2D graphics processing module and a 3D graphics processing module may be based on separate hardware components for a graphics processing unit . IO ports may forward 2D and 3D graphics instructions received from hardware graphics commands to 2D graphics processing module and 3D graphics processing module respectively. In one embodiment a 2D graphics processing module and a 3D graphics processing module may not operate at the same time in a graphics processing unit . In another embodiment a 2D graphics processing module may process multiple 2D graphics instructions from one or more 2D graphics commands at one time e.g. a batch . In other embodiments a 3D graphics processing module may not process 3D graphics instructions from another 3D graphics command before finishing processing 3D graphics instructions for a current 3D graphics command e.g. one graphics command at a time .

At block in one embodiment process may extract header data from a currently retrieved graphics command. A header data in a graphics command such as header data of may include information on graphics resources to be processed according to graphics instructions in a graphics command such as read surfaces write surfaces or other graphics objects. Additionally header data may include marking data such as ids for messages and resources associated with the graphics command. A graphics resource such as a surface or a texture may be identified by a graphics id. Notification ids may be sent between graphics drivers for separate graphics processing units and or display processing units for synchronizing graphics processing and display. Notification ids may be associated with graphics notification commands. Separate notification ids may be grouped together based on a swap id for displaying a graphics buffer where a swap ID may be associated with an image or a frame to be displayed in a display.

At block in one embodiment process may determine if there are dependency conditions associated with a currently retrieved graphics command. When dependency conditions are satisfied or removed process may proceed to send hardware graphics commands or notification messages associated with a graphics command. Dependency conditions for a retrieved graphic command may be determined based on header data included in the retrieved graphic command and or previous retrieved graphics commands. For example if it is determined that a current command depends on a previous command e.g. graphics resource dependency the current command will be held off until the previous command has been processed by the hardware. Otherwise both current and previous commands may be sent down to the hardware for executions. In a particular embodiment when a first command is a 3D graphics command and a second command received subsequently is a 2D graphics command the second command will not be sent to the hardware until the first command has been processed by the hardware. In another particular embodiment if both first and second commands are 2D graphics commands both the first and second commands may be sent to the hardware as a batch for execution where the hardware may buffer both commands during the execution. Other configurations may exist dependent upon a specific design of a graphics processing unit.

At block process may determine if a currently retrieved graphics command depends on previously retrieved graphics commands. A command dependency condition may exist for a currently retrieved graphics command depending on a previously retrieved graphics command being completely processed . In one embodiment sending a current command to a graphics processing unit or another graphics driver module may require a graphics processing unit to complete processing previously retrieved graphics commands. For example a currently retrieved graphics command may have a dependency on a previous retrieved 3D graphics command. A currently retrieved 3D graphics command may have a dependency condition on a previously retrieved 2D graphics command. A currently retrieved graphics command may have a dependency on a previously retrieved OpenGL graphics command. At block process may determine a capacity dependency condition 513 on an associated graphics processing unit if there are graphics instructions included in a currently retrieved graphics command to send to the graphics processing unit. In one embodiment a capacity dependency condition may be associated with available processing capacity of a graphics processing unit. A status of processing capacity may be related to number of empty slots of a hardware buffer for an IO port in a graphics processing unit such as IO port of . At block process may collect all dependency conditions identified. In one embodiment a currently retrieved 2D graphics command may not have a command dependency condition on a previously retrieved 2D graphics command.

Referring back to if there are dependency conditions in one embodiment process may remove the dependency conditions or wait for an indicators indicating the dependency conditions have been satisfied at block . For a resource dependency condition process may send a request to a memory management module to make an associated graphics resource resident to satisfy the condition. A graphics resource may be resident if it is allocated in a physical memory coupled to a graphics processing unit. In one embodiment a resident graphics resource is mapped to a virtual device space associated with a graphics processing unit. Process may wait for an indictor indicating an associated graphics processing unit has completed processing graphics instructions for a dependent graphics command. In one embodiment the indicator may be based on an interrupt message such as a hardware interrupt from a graphics processing unit to a host processor performing process . Process may retrieve processing statuses from predetermined memory locations such as specific registers associated with a graphics processing unit to determine whether a capacity dependency condition is satisfied. In one embodiment a graphic processing unit may indicate the status e.g. usage of a buffer within a graphics processing unit by for example raising a flag value in a register when an associated hardware buffer such as a hardware graphics command buffer for IO port of is full or almost full. The graphics processing unit may reset the flag value once hardware graphics commands received in the associated hardware buffer have been executed. In one embodiment process may be notified when a capacity condition is satisfied. In another embodiment process may continue to check e.g. polling an indicator such as a register flag value to determine if a capacity condition has been satisfied.

At block when the determined dependency conditions are satisfied or removed process may proceed to send hardware graphics commands based on a currently retrieved graphics command to an associated graphics processing unit. In one embodiment process may send a notification message to another graphics driver according to a header data extracted from a currently retrieved graphics command. Process may retrieve next graphics command from a graphics command buffer at block and continue at block to process the next graphics command. In one embodiment a stream of 2D graphics commands may be continuously retrieved from a command buffer to be forwarded to a graphics processing unit subject to the capacity of a graphics processing unit if associated graphics resources are resident.

In one embodiment a single notification such as an interrupt may be generated for a batch of multiple graphics commands to reduce an expensive processing overhead requiring one interrupt per graphics command. Tracking which graphics commands have been submitted to determine when these graphics commands are completed may provide information to guide memory management system to free graphics resource no longer in use. Additionally whether a graphics processing unit is idle may be determined to track which graphics resources can be freed or released when they are no longer in use.

A hardware command queue may be coupled to a graphics processor in a graphics processing unit such as graphics processing unit of . A hardware command queue may be associated with an IO port of a graphics processing unit such as IO port of . A graphics processor may send a notification message to a notification handler module of a graphics driver module . In one embodiment a notification message may be generated via an interrupt such as a hardware interrupt from the graphics processor to a host processor hosting the graphics driver module . A physical memory may be coupled to a graphics processor and a host processor. In one embodiment a physical memory includes a status register storing values indicating operating statuses of a graphics processing unit associated with the graphics processor . Operating statuses may include whether a graphics processing unit is busy or idle.

In one embodiment a graphics resource status data may provide a store for status information about a graphics resource such as time stamps and flags . Time stamps may store values indicating whether a corresponding graphics resource is currently being operated on. Flags may indicate if there are outstanding requests made against a corresponding graphics resource such as a request to delete from a process initiated by a user. A graphics resource status data may be updated by a graphics driver module . In one embodiment time stamps of a graphics resource may be updated by a graphics driver module when submitting hardware graphics commands for a corresponding graphics command associated with the graphics resource. In other embodiments time stamps of a graphics resource may be updated by a graphics driver module when a graphics processor has completed processing graphics instructions corresponding to the graphics command associated with a graphics resource. A graphics resource handler module may manage graphics resources such as allocating mapping and deleting corresponding memory space. In one embodiment a graphics driver module may update a graphics resource status data via a graphics resource handler module .

In another embodiment process may generate a hardware synchronization command when a hardware command queue is full such as hardware command queue of associated with a graphics processing unit. Process may determine whether a hardware command queue is full via a status register associated with a graphics process unit such as status register of . In one embodiment a batch of hardware graphics commands may be determined based on when a hardware command queue is full.

At block according to one embodiment process may submit a batch of hardware graphics commands followed by a hardware synchronization command to a graphics processing unit for execution or processing. In one embodiment process may submit a batch of hardware graphics commands together with the hardware synchronization command to a graphics processing unit in one single transaction. At block in one embodiment process may proceed to generate a next batch of hardware graphic commands from subsequent graphics commands in a command stream buffer such as the command stream buffer at block . At block process may generate a next hardware synchronization command for the next batch of hardware graphics commands.

In one embodiment at block process may receive a single notification message subsequent to complete execution of a batch of hardware graphics commands in a graphics processing unit. In another embodiment process may receive a single notification message when a hardware command queue associated with a graphics processing unit is emptied. A notification message may be generated based on a hardware interrupt caused by a graphics processing unit when finishing executing the batch of graphics commands. In one embodiment a graphics processing unit may execute a hardware synchronization command to perform a hardware interrupt to a host processor for sending a notification message. Process may be performed in a host processor. At block process may determine the next batch of hardware graphics commands are ready to be submitted to a graphics processing unit based on a received notification message. In one embodiment the received notification message may signify that a graphics processing unit is idle after finishing executing pending hardware graphics commands. Process may submit a next batch of hardware graphics commands and a next generated hardware synchronization command to the graphics processing unit for execution at block .

At block in one embodiment process may receive a notification message after the hardware graphics commands corresponding to a retrieved graphics command have been executed in a graphics processing unit. Process may determine an association between a notification message and a retrieved graphics command. In one embodiment process may track submitted graphics command to determine the association. At block process may update a graphics resource status associated with a graphics resource subsequent to receiving a notification message. In one embodiment process may increment the value of a complete counter in a graphics resource status by one at block . At block process may determine if a graphic resource can be freed or released based on an associated graphics resource status. In one embodiment process may compare the values of a submit counter and a complete counter included in a graphics resource status to determine whether all graphics commands sent to the hardware have been executed or completed. Process may determine an associated graphics resource can be released when the values of the submit counter and the complete counter are equal in the associated graphics resource status. When the values of the submit counter and complete counter are equal that means all of the commands that have been sent to the hardware have been executed by the hardware. As a result all graphics resources associated with those commands are no longer in use and these graphics resources can be released for use by other subsequent commands.

At time instance Time a batch of hardware graphics commands are submitted to the hardware command buffer including 2D b 2D a and 2D a corresponding to a stream of 2D graphics commands 2Db 2Da and 2Da from the command buffer. Additionally a hardware synchronization command Syn is submitted to the hardware command buffer following the last hardware graphics command 2D b in the batch. The graphics resource status for graphics resource a associated with two graphics commands 2Das is updated by incrementing its submit count CountS by 2 to be of a value 2 according to the submission. The graphics resource status for graphics resource b associated with one graphics command 2Db is updated by incrementing its submit count CountS by 1 to be of a value 8 according to the submission.

At time instance Time the graphics processing unit have executed the batch of hardware graphics commands and the hardware synchronization command from the hardware command buffer. Executing the hardware synchronization command Syn has resulted in a notification message signifying a completion of processing the stream of 2D graphics commands 2Db 2Da and 2Da for updating associated graphics resource statuses. In one embodiment the graphics resource status for graphics resource a associated with two graphics commands 2Das is updated by incrementing its complete count CountC by 2 to be of a value 2 according to the notification. The graphics resource status for graphics resource b associated with one graphics command 2Db is updated by incrementing its complete count CountC by 1 to be of a value 8 according to the notification.

At time instance Time a next batch of hardware graphics command is submitted to the hardware command buffer including a single hardware graphic command 3D c corresponding to one 3D graphics command 3Dc from the command buffer. Additionally a newly generated hardware synchronization command Syn is submitted to the hardware command buffer following hardware graphics command 3D c. The graphics resource status for graphics resource c associated with the graphics command 3Dc is updated by incrementing its submit count CountS by 1 to be of a value 1 according to the submission.

As described above referring back to when a stream of graphics commands is received and stored in the command stream buffer graphics driver may stamp each graphics command received at the command stream buffer for example by incrementing a submit counter to represent a number of graphics commands that have been received. Alternatively the submit counter is updated when the graphics commands have been enqued for submission to the graphics processing unit. In addition the graphics driver may further maintain graphics resources usage required by these graphics commands using graphics resource handler module .

Once the graphics commands have been sent to the hardware graphics driver still maintains the command stream buffer that stores the graphics commands that have been sent to the hardware and stamped by the graphics driver . Subsequently a notification is received by the graphics driver from the hardware for example via an interrupt via a host processor indicating that the hardware has completed executing the graphics commands. In response to the notification the graphics driver may update the complete counter to indicate the number of graphics commands that have been executed. In addition the graphics driver revisits the graphics commands stored in the command stream buffer where these graphics commands by now have been executed by the hardware. For each of those graphics commands that have been executed the graphics resources associated with those commands may be released using the information maintained by graphics resource handler module . In this way the graphics resources would not be released until the associated graphics commands have been processed. This is typically useful when an application or a graphics API requests for releasing certain graphics resources while the associated graphics commands are still being processed by the hardware which will be described in details further below.

In one embodiment requests to swap graphics data to one or more display devices may be constructed to ensure segments of graphics data are ready for display prior to swapping the graphics data. Each segment of graphics data may be rendered by separate media processors running substantially concurrently and or asynchronously. A synchronization point may be provided to ensure all segments of the graphics data are displayed simultaneously in a graphics display e.g. refresh . Content completion notifications that arrive asynchronously to a swap request may allow maximum parallelism among media processors and or display devices which operate asynchronously in parallel for display the graphics data.

As described above a video frame may include multiple components which may require different graphics resources and processed by different graphics rendering engines or processing units. In one embodiment each component may be processed by a different graphics processing unit. Thus multiple graphics processing units may process multiple components of a video frame substantially concurrently and asynchronously. The output of the graphics processing units are stored in graphics memory . However the processing speeds of different graphics processing units may be different dependent upon the specific graphics commands and or graphics resources. As a result the output data generated from different graphics processing units may arrive at the graphics memory at different time. According to one embodiment of the invention a synchronization signal such as a swap ID is transmitted to the display controller to allow the display controller to collect all of the output data of all components of a video frame based on the synchronization signal such as a swap ID from all graphics processing units before display the video frame having all of the components ready in a display. In this embodiment a swap ID is used to identify a particular video frame and each graphics components of the video frame include certain information linked with the swap ID. When display controller is notified by each of the graphics processing units indicating that a respective component of the video frame identified by the swap ID has been completed the display controller can examine each component based on the swap ID to determine whether all components are ready to be displayed. If so the video frame is displayed by the display controller otherwise the display controller may wait until all of the components of the video frame have been completed.

At block process may generate a swap command via a swap API call to display a graphics data in a display device. The swap command may include a swap ID and one or more notification IDs in association with one or more notification commands at block . In one embodiment a swap command may be associated with a graphics display unit such as the display device of . Process may forward a generated swap command to a display driver module such as the display driver module of according to an associated graphics display unit at block .

At block according to one embodiment process may wait for a notification message caused by a graphics processing unit executing a hardware synchronization command. In one embodiment a notification message may be caused by a hardware interrupt according to a hardware synchronization command. Subsequently at block process may generate a driver notification message including a swap ID and a notification ID associated with a notification command. In one embodiment a notification command may be associated with a target graphics driver such as display driver module of . Process may send a driver notification message to a target graphics driver associated with the notification at block .

Graphics commands G G and notification command N may be sent to the driver for a graphics processing unit graphics gpu to draw GUI graphics data during time period . Graphics gpu may be the 2D 3D graphics processing unit of . Graphics command R and notification command N may be sent to the driver for a graphics processing unit special GPU to perform rotation operation on a video frame during time period . In one embodiment special GPU may be a 2D special effect graphics processing unit of .

Notification commands N and N may be associated with two of the notification IDs associated with swap command S . In one embodiment the driver for special GPU may send a driver notification messages corresponding to notification commands N subsequent to completing the rotation operation . The driver for graphics GPU may send a driver notification message corresponding to notification command N subsequent to completing drawing GUI graphics data according to graphics commands G and G at . In one embodiment LCD driver may determine a graphics data e.g. in a frame buffer is ready to display at because each notification ID associated with the swap ID for swap command S has a corresponding driver notification message received. The graphics data may include the GUI components drawn during time period and a video frame rated during time period . When receiving video synchronization signal Vsync at time instance LCD driver may display the corresponding graphics data. In one embodiment LCD driver may not display a graphics data corresponding to the swap ID of swap command S when receiving Vsync signal at time instance because the driver notification command associated with notification command N has not been received.

In one embodiment graphics command S may be a swap command associated with a display driver such as TV display driver . Swap command S may be associated with at least two notification IDs. TV display driver may receive swap command S to wait for at least two driver notification messages associated with the notification IDs included in the swap command S during time period . Graphics commands G and notification command N may be sent to the driver for graphics GPU to draw GUI graphics data during time period . Graphics command Z and notification command N may be sent to a driver for special GPU to perform zooming operation on a video frame during time period . Notification commands N and N may be associated with two of the notification IDs associated with swap command S . In one embodiment TV display driver may determine a graphics data is ready to display at after receiving both driver notification messages associated with notification IDs of notification commands N and N . TV display driver may display a graphics data corresponding to swap command when receiving the next video synchronization signal Vsync at after .

In one embodiment asynchronous deletion operations may be performed based on detecting if graphics processing units are idle or not to allow a host processor to immediately return to take on additional tasks after making a deleting request. Graphics processing units may be ensured to be idle when graphics resources are deleted while allowing parallel operations between the graphics processing units and a coupled host processor.

A graphics driver module may include a resource management module for managing graphics resources allocated according to graphics commands retrieved from a command stream buffer . A resource management module may notify a memory management module to allocate required graphics resourced associated with a graphics command. In one embodiment a graphics resource may be associated with a graphics resource data including time stamps and flags using certain techniques described above. Time stamps for a graphics resource may include a complete counter and submit counter as in . Flags may include a Delete flag and a Finish flag. Flags may be set according to management requests received from the graphics API and command module . In one embodiment the graphics driver module may include a delete pool coupled with the resource management module . The delete pool may be a data structure identifying one or more pointers corresponding to one or more graphics resources to be released from allocated memories. In one embodiment a delete pool may be updated by a resource management module .

According to certain embodiments the submit counter and complete counter may be used to identify which of the graphics commands have been sent to the hardware and which of the graphics commands have been completed by the hardware. The finish flag and delete flag may be used to indicate whether a specific graphics command has been completed and whether the graphics resources associated with the commands can be released or deleted. This typically useful when a request is received from an application or a graphics API registering a notification when certain graphics commands have been completed e.g. finished and or requesting certain graphics resources can be released e.g. delete .

For example according to certain embodiments when a request is received from an application or a graphics API for registering a notification call back when a specific graphics command has been completed the graphics driver may check based on the finish flag of the requested command to determine whether the command has been completed. If the finish flag has been set which indicates that the associated command has been completed the graphics driver may immediately return the request indicating that the command has been completed.

However if the finish flag has not be set which indicates that the command has not been completed or finished by the hardware the graphics driver may delay returning the request for example by marking the request as pending . Subsequently when the graphics driver receives a notification from the hardware indicating that the previous command or previous batch of commands have been completed the graphics driver will walk through for example in the command stream buffer those commands that have been sent to the hardware and mark those commands as finished by setting the corresponding finish mark. Thereafter a maintenance routine or a garbage collection routine maintained by the graphics driver may clean up the pending request for finish notifications by checking the finish flag of the commands and return the pending requests to indicate the caller e.g. application or graphics API that the requested command has been finished. 

In another scenarios according to one embodiment when an application or a graphics API sends down a request for deleting or releasing certain graphics resources the graphics driver may check whether the requested resources can be deleted or released using the graphics resource status data. If there is no graphics command pending to be finished that is associated with the requested graphics resources the requested resources can be immediately deleted or released. However if there is at least one graphics command associated with the requested graphics resources and is still pending e.g. the corresponding finish flag has not been set the requested graphics resources cannot be deleted or released. In this situation the graphics driver may delay returning the request by marking the request as pending and set the delete flag of the requesting graphics resources to indicate that the associated graphics resources have been requested to be deleted or released.

Subsequently when the graphics driver receives a notification from the hardware indicating that a previous command or a previous batch of commands has been completed. The graphics driver marks those commands as finished by setting the corresponding finished flag. In addition graphics driver may check whether there are any outstanding graphics resources that require to be cleaned up by examining the delete pool . For each graphics resource that has been marked in a delete flag if the associated graphics command or commands have been executed indicated via the corresponding finish flag the marked graphics resources are deleted or released. Other configurations apparent to those with ordinary skills in the art may exist.

At block in one embodiment process may determine if there are graphics processing units busy processing graphics data after determining there are no associated outstanding graphics commands. In one embodiment one or more graphics processing units may be coupled with a graphics memory storing the graphics resource to be deleted such as the graphics memory of . Memory management operations on a graphics memory such as memory mapping allocation releasing etc. may not be performed when a coupled graphics processing unit is busy. For example a physical memory that has been mapped as a virtual memory or a linear memory cannot be released or deleted e.g. unmapped while the hardware is accessing the memory otherwise the system may crash. In one embodiment process may retrieve operating status from a status register which indicates whether an associated graphics processing unit is currently busy or not. Process may proceed to delete the graphics resource at block if no graphics processing units are busy. Otherwise at block process may update a delete pool in a graphics driver module such as delete pool of to include the graphics resource for deletion by the updated delete pool. In one embodiment process may add a pointer pointing to the graphics resource to the delete pool at block . If process identifies outstanding graphics commands associated with the graphics resource at block in one embodiment process may proceed at block to set a Delete flag associated with the graphics resource such as in flags of . A Delete flag when set may indicate a request has been made to delete a corresponding graphics resource. Subsequently at block process may return from the management request to the calling application.

At block in one embodiment process may set a Finish flag associated with a graphics resource associated with a management request received at block if the management request is to wait for finishing processing the graphics resource instead of deleting the graphic resource as determined at block . A Finish flag when set may signify a request has been made for a process such as process to be notified when all outstanding graphics commands associated with a graphics resource have been processed. In one embodiment a Finish flag associated with a graphics resource may include an identification of a process waiting to be notified. At block process may wait for a wake up notification message when all outstanding graphics commands associated with a graphics resource have been processed. In one embodiment the wake up notification message may be based on hardware interrupts generated from graphics processing units finishing processing outstanding graphics commands associated with the graphics resource. A graphics processing unit may notify a host processor which performs process when a hardware interrupt occurs. When waken up process may return from the management request to the calling application at block .

At block process may update time stamps associated with a graphics resource such as time stamps of . In one embodiment process may update a complete counter in the time stamps of a graphics resource such as CountC of according to the number of corresponding graphics commands associated with the graphics resource based on the notification message. At block process may retrieve a value of a Finish flag such as from Flags of the graphics resource status data of associated with the graphics resource to determine whether the Finish flag is set or not. If the Finish flag is set in one embodiment process may determine if there are outstanding graphics commands associated with the graphics resource at block . In one embodiment process may compare the values of a complete counter and a submit counter associated with the graphics resource to make the determination. If there are still outstanding graphics commands associated with the graphics resource process may proceed without performing further delete operations for the graphics resource. In one embodiment process may make the determination based on whether the values in a complete counter and a submit counter associated with a graphics resource are not equal.

In one embodiment if there are no more outstanding graphics commands for a graphics resource for example when both the associated complete counter and submit counter have the same value process may send a wake up notification message to a graphics application waiting for finishing graphics operations on the graphics resource at block . One or more graphics processing units may perform graphics operations on a command graphics resource. In one embodiment the status data associated with the graphics resource such as graphics resource status data of may store pointer information for graphics applications waiting to receive wake up notification messages.

Subsequent to checking the Finish flag in one embodiment process may retrieve a value of a Delete flag associated with the graphics resource such as from Flags of the graphics resource status data of to determine whether the Delete flag is set or not at block . If the Delete flag is set in one embodiment process may determine if there are outstanding graphics commands associated with a graphics resource at block similar to block . A Delete flag associated with a graphics resource may be set when a request from an application has been made to delete the graphics resource. If there are no outstanding graphics commands associated with the graphics resource found at block process may proceed to delete the graphics resource at block . In one embodiment graphics processing units may be idle when process deletes a graphics resource at block . In another embodiment process may check operating status of graphics processing units at block to delete a graphics resource when graphics processing units are idle. After each graphics resource associated with the notification message received at block has been processed for deletion at block process may delete graphics resources associated with a delete pool such as Delete pool of to clean up the delete pool. In one embodiment process may synchronize with graphics processing units to delete graphics resources at block during when graphics processing units are idle.

In one embodiment a two pass scaling approach utilizing a graphics operation memory and an extra scaling operation may provide an actual scaling effect more desirable than a single scaling operation based on a desired scaling factor which is not representable because of limited bit precision in a graphics scaling unit. A larger number of discrete values may be explored when scaling up with an up scale factor greater than 1 to arrive at an effective scale factor closer to the desired scale factor than a single scaling operation based on a limited representation of the desired scale factor in the graphics scaling unit.

A graphics scaling unit may generate a scaled graphics data from an input graphics data . A graphics memory such as graphics memory of may be coupled with a graphics scaling unit to store input graphics data and or output graphics data . A graphics operating memory may be a dedicated memory for a graphics scaling unit . In one embodiment a graphics operating memory may be customizable with different sizes memory capacities . A graphics scaling unit may include a scale factor storage having a fixed point representation with a predetermined fixed number of precisions to store a desired scale factor. A graphics scaling engine in a graphics scaling unit may perform scaling operations on an input graphic data according to the desired scale factor .

At block in one embodiment process may determine an up scale factor and a down scale factor which can be precisely represented under the limited number of fractional precisions in the graphics scaling unit to better represent the desired scale factor at block which may not be precisely represented based on the same number of fractional precisions in the graphics scaling unit. In one embodiment process may compare a difference between the desired scale factor and a value by multiplying the up scale factor and the down scale factor against a scaling error determined at block . Process may determine an up scale factor and a down scale factor such that the difference of block is smaller than the scaling error. In another embodiment process may determine a maximum memory requirement based on an up scale factor a down scale factor and a size of the source texture. Process may determine an up scale factor and a down scale factor such that the maximum memory requirement does not exceed the size of the graphics operating memory.

In one embodiment process may employ a binary search scheme among on a plurality of possible up scale factors precisely represented according to a limited fractional precision of arithmetic representation. Process may determine based on each selected up scale factor among all possible numbers precisely represented under the same limited fractional precision of arithmetic representation a corresponding down scale factor such that multiplication of the selected up scale factor and the corresponding down scale factor has a value closest to the desired scale factor of block . In one embodiment process may select an up scale factor such that a combined scale factor with the corresponding down scale factor most closely or more precisely representing the desired scale factor among the plurality of possible up scale factors searched.

An up scale factor may be applied in a first pass graphics scaling operation. The corresponding down scale factor may be applied in a second pass graphics scaling operation. A combined scale factor may be based on multiplying an up scale factor and its corresponding down scale factor. In one embodiment process may perform a binary search subject to a constraint that the maximum operating memory requirement based on an up scale factor a corresponding down scale factor and a size of the source texture does not exceed the size of a graphics operating memory associated with the graphics scaling unit. In one embodiment process may determine a size requirement for a graphics operating memory based on a maximum scaling error required to scale a source texture according to a limited fractional precision of arithmetic representations for an up scale factor and the corresponding down scale factor.

In one embodiment at block process may generate a first graphics command to scale the source texture to a temporary texture according to an up scale factor. A temporary texture and a source texture may be stored in a graphics memory coupled to a graphics scaling unit such as graphics memory of . Subsequently at block process may generate a second graphics command to scale a temporary texture to a destination texture according to a down scale factor. In one embodiment at block process may send a first graphics command and a second graphics command to a command stream buffer such as command stream buffer associated with a graphics scaling unit for performing the scaling operations.

In a single pass scaling a desired scale factor 0.8 which is binary represented with infinite fractional precisions as 0.1100110011001100 . . . has an actual value of 0.78125 with 5 binary fractional precisions with a binary representation as 0.11001 . Thus the single pass scaling for desired scale factor 0.8 may have a scaling error of 0.01875. An up scale factor 0.5 for a first pass scaling may be precisely represented with 5 fractional precisions as 0.10000 for binary representation. Thus the actual up scale factor with a binary representation are the same as the up scale factor . A down scale factor 1.59375 may be selected by representing a desired down scale factor 1.6 for the second pass scaling based on 5 binary fractional precision representation 1.10011 . The desired down scale factor 1.6 may be binary represented with infinite fractional precisions as 1.1001100110011001 . . . . The actual combined scale factor based on the up scale factor and a down scale factor may be obtained as 0.796875 which corresponds to a smaller scaling error of 0.003125 than 0.01875.

This digital interface may include a graphical user interface which is similar to that shown on a typical computer such as for example a Macintosh computer when running OS X operating system software. The system also includes a communication interface e.g. wired or wireless communication interface such as for example one or more wireless transceivers to communicate with another system or device. A wireless transceiver may be a WiFi transceiver an infrared IR transceiver a Bluetooth transceiver and or a wireless cellular telephony transceiver. It will be appreciated that additional components not shown may also be part of the system in certain embodiments and in certain embodiments fewer components than shown in may also be used in a data processing system.

The data processing system also includes one or more input devices which are provided to allow a user to provide input to the system. These input devices may be a keypad or a keyboard or a touch panel or a multi touch panel. Alternatively input devices may include a voice interactive interface that can receive and interact with a voice command. The data processing system also includes an optional input output device which may be a connector for a dock. It will be appreciated that one or more buses not shown may be used to interconnect the various components as is well known in the art. The data processing system shown in may be a handheld computer or a personal digital assistant PDA or a cellular telephone with PDA like functionality or a handheld computer which includes a cellular telephone or a media player such as an iPod or devices which combine aspects or functions of these devices such as a media player combined with a PDA and a cellular telephone in one device. In other embodiments the data processing system may be a network computer or an embedded processing device within another device or other types of data processing systems which have fewer components or perhaps more components than that shown in .

At least certain embodiments of the inventions may be part of a digital media player such as a portable music and or video media player which may include a media processing system to present the media a storage device to store the media and may further include a radio frequency RF transceiver e.g. an RF transceiver for a cellular telephone coupled with an antenna system and the media processing system. In certain embodiments media stored on a remote storage device may be transmitted to the media player through the RF transceiver. The media may be for example one or more of music or other audio still pictures or motion pictures.

The portable media player may include a media selection device such as a click wheel input device on an iPod or iPod Nano media player from Apple Computer Inc. of Cupertino Calif. a touch screen input device pushbutton device movable pointing input device or other input device. The media selection device may be used to select the media stored on the storage device and or the remote storage device. The portable media player may in at least certain embodiments include a display device which is coupled to the media processing system to display titles or other indicators of media being selected through the input device and being presented either through a speaker or earphone s or on the display device or on both display device and a speaker or earphone s . Examples of a portable media player are described in published U.S. patent application numbers 2003 0095096 and 2004 0224638 both of which are incorporated herein by reference. Other configurations may exist.

Portions of what was described above may be implemented with logic circuitry such as a dedicated logic circuit or with a microcontroller or other form of processing core that executes program code instructions. Thus processes taught by the discussion above may be performed with program code such as machine executable instructions that cause a machine that executes these instructions to perform certain functions. In this context a machine may be a machine that converts intermediate form or abstract instructions into processor specific instructions e.g. an abstract execution environment such as a virtual machine e.g. a Java Virtual Machine an interpreter a Common Language Runtime a high level language virtual machine etc. and or electronic circuitry disposed on a semiconductor chip e.g. logic circuitry implemented with transistors designed to execute instructions such as a general purpose processor and or a special purpose processor. Processes taught by the discussion above may also be performed by in the alternative to a machine or in combination with a machine electronic circuitry designed to perform the processes or a portion thereof without the execution of program code.

An article of manufacture may be used to store program code. An article of manufacture that stores program code may be embodied as but is not limited to one or more memories e.g. one or more flash memories random access memories static dynamic or other optical disks CD ROMs DVD ROMs EPROMs EEPROMs magnetic or optical cards or other type of machine readable media suitable for storing electronic instructions. Program code may also be downloaded from a remote computer e.g. a server to a requesting computer e.g. a client by way of data signals embodied in a propagation medium e.g. via a communication link e.g. a network connection .

The preceding detailed descriptions are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the tools used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be kept in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The present invention also relates to an apparatus for performing the operations described herein. This apparatus may be specially constructed for the required purpose or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a computer system bus.

The processes and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct a more specialized apparatus to perform the operations described. The required structure for a variety of these systems will be evident from the description below. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

The foregoing discussion merely describes some exemplary embodiments of the present invention. One skilled in the art will readily recognize from such discussion the accompanying drawings and the claims that various modifications can be made without departing from the spirit and scope of the invention.

