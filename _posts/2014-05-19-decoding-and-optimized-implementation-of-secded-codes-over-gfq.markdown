---

title: Decoding and optimized implementation of SECDED codes over GF(q)
abstract: A plurality of columns for a check matrix that implements a distance d linear error correcting code are populated by providing a set of vectors from which to populate the columns, and applying to the set of vectors a filter operation that reduces the set by eliminating therefrom all vectors that would, if used to populate the columns, prevent the check matrix from satisfying a column-wise linear independence requirement associated with check matrices of distance d linear codes. One of the vectors from the reduced set may then be selected to populate one of the columns. The filtering and selecting repeats iteratively until either all of the columns are populated or the number of currently unpopulated columns exceeds the number of vectors in the reduced set. Columns for the check matrix may be processed to reduce the amount of logic needed to implement the check matrix in circuit logic.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08892985&OS=08892985&RS=08892985
owner: Micron Technology, Inc.
number: 08892985
owner_city: Boise
owner_country: US
publication_date: 20140519
---
This application is a divisional application of U.S. Non Provisional Application No. 14 029 379 Design Decoding and Optimized Implementation of SECDED Codes over GF q by H. Lee Ward et al. filed Sep. 17 2013 allowed Feb. 6 2014 which is a divisional application of U.S. Non Provisional Application No. 13 116 976 Design Decoding and Optimized Implementation of SECDED Codes over GF q by H. Lee Ward et al. filed May 26 2011 now U.S. Pat. No. 8 566 684 issued Oct. 22 2013 both of which are incorporated herein by reference.

This invention was developed under Contract DE AC04 94AL85000 between Sandia Corporation and the U.S. Department of Energy. The U.S. Government has certain rights in this invention.

The present work relates generally to linear block codes and more particularly to single error correcting double error detecting SECDED codes over GF q .

SECDED codes play a pivotal role in data transfer communication applications. One example is data storage applications. Advances in memory technology have provided the capability of storing increasingly large amounts of data in individual memory packages or modules . This makes it possible to store retrieve from a single memory module data that previously was stored retrieved by accessing multiple modules providing improvements in performance power consumption and scalability. When accessing a single module it is advantageous to address effectively errors that have a single cause. For example if several I O terminals of a module provide respective I O paths a failed transmitter driving one of the terminals may be used multiple times per memory access. The bits transferred via any given terminal in a single burst may be considered to be a data symbol. If the terminal transfers data in 4 bit bursts for example then the symbol size is four bits. A sixteen byte transfer might be accomplished by transferring a 4 bit burst i.e. one symbol on each of 32 terminals of the memory module. Within knowable limits a SECDED code that appends four parity check symbols of four bits each is capable of correcting any error in a single data symbol and detecting errors in two data symbols . Thus errors repeatedly caused by a single failed transmitter associated with a single terminal may be corrected.

The aforementioned example SECDED code has a Hamming distance of at least four in terms of symbols. This is a specific example of a linear n k d code over a general alphabet GF q with n 36 data parity check symbols k 32 data symbols code distance d 4 and symbol alphabet size q 16 2with 4 bits symbol that is a 36 32 4 code.

One approach to construct an n k d code is a random search of parity check matrices in GF q . Considering the aforementioned example of a 36 32 4 code there are 15 36 different single symbol errors while the syndrome from the four symbol parity has 65536 possibilities. It thus appears that a random search would likely yield a code. Nevertheless testing as many as 15 2H matrices obtained via random search has failed to yield a 36 32 4 code.

Another approach is to construct a 35 32 3 code and extend it with a single parity check to a 36 32 4 code. Since GCD 35 16 1 construction of a BCH code with n 35 and d 3 may be considered. BCH codes provide a minimum distance guarantee that is determined by the generator polynomial. However investigation of BCH codes with n 35 and q 16 reveals that the most efficient BCH codes with d 3 are 35 31 3 codes which cannot be extended to a 36 32 4 code.

Another approach is the use of an existing bound such as the Gilbert Varshamov GV bound that indicates feasible codes. However for the code distance d 4 the GV bound indicates that only k 27.5 is achievable.

Another approach is constructing a 36 32 4 code as four simultaneous 36 32 4 codes or two simultaneous 36 32 4 codes. However a 36 32 4 code does not exist because it violates the Hamming bound. Although a linear 36 32 4 code would not violate the Hamming bound it has been found that 36 32 4 codes do not exist.

It is desirable in view of the foregoing to provide for the construction of distance d linear codes more efficiently than by random searching.

The present work provides for non deterministically generating the parity check matrix for a linear n k d code over a general alphabet GF q . The search space is organized as a tree and the search can terminate in one of two states one if it has taken an unsuccessful path and run out of search space another if it has found a suitable parity check matrix. Also provided is a simple decoder for linear SECDED codes with an efficient parallel implementation. The present work further provides for generating from an input parity check matrix another parity check matrix whose corresponding code has the same distance as that of the input matrix is a subcode of the input matrix and requires the minimum number of logical AND gates among all subcodes that encode the same set of symbols.

In the retrieval path the parity check symbols at are exclusive ORed XORed at with the parity check symbols that were stored and are now retrieved with the data symbols. The result of the XOR operation at is the syndrome which is decoded by a syndrome decoder . The syndrome decoder which uses information from entries in the matrix H produces information which may be used by an error corrector together with the retrieved data symbols to correct single symbol errors and output correspondingly corrected data. The syndrome decoder also produces information which indicates detection of errors in two and often more symbols.

The above described operations performed by the check symbol generator the syndrome decoder and the error corrector are generally known in the art. Thus in some embodiments these components operate in accordance with conventional techniques. However with respect to the parity check matrix H used by the check symbol generator and the syndrome decoder the present work provides improved techniques for non deterministically generating this matrix H for a linear SECDED code. The present work exploits the known relationship between the code distance of a linear code and the requirement that there must be linear independence of the column vectors of the parity check matrix for the code. More specifically if H is the parity check matrix of a linear code C then the code C has distance d if and only if any non trivial linear combination of d 1 column vectors of H is not zero. Column vectors may also be referred to herein simply as columns or vectors. A parity check matrix H is described in standard form as where A is a matrix describing the parity checks I is the identity matrix concatenated with A to form H k is the number of data symbols transferred and r is the number of parity check symbols generated for the k data symbols. The aforementioned property that no non trivial linear combination of d 1 column vectors of H results in zero is referred to herein as d 1 linear independence and the columns of H are said to be d 1 linearly independent. 

Considering the aforementioned example using 4 bit symbols this provides sixteen 2 available values for a symbol. That is the size of the symbol alphabet referred to herein as q is q 16. As shown generally in the present work provides an A matrix generator that receives as input the aforementioned parameters q d r and k and produces a matrix A in such a manner that A and thus H exhibits the aforementioned d 1 linear independence property. The parameters d and r are related as d r 1 to avoid violation of the singleton bound. The check symbol generator of uses information from the symbol entries in the matrix H to generate the check symbols and the syndrome decoder uses information from the symbol entries in matrix H to decode the syndrome.

The iterative filter is shown in more detail in . The filter includes a first linear combination filter a second linear combination filter and a concatenation buffer coupled for bidirectional communication with the second linear combination filter . The first linear combination filter is an initializing filter that performs an initial vector elimination operation with respect to P to produce an initial subset of P namely P. The second linear combination filter performs iterative filtering operations beginning with the initial Presult produced by the first linear combination filter . For each iteration i that it performs i 0 1 2 . . . the filter selects from P the current subset of P a column vector for A and applies the aforementioned vector elimination processing to Pto produce from Pa set Pfor the next iteration i 1. The vector selected from P when i 0 is stored in the column 0 COL 0 entry of the concatenation buffer the vector selected from P when i 1 is stored in the column 1 COL 1 entry and so on. The concatenation buffer is used in this fashion to construct the A matrix by successive concatenation of its columns.

Noting that a column vector is d 1 linearly dependent with columns of I if and only if that vector has at least d 2 zeros some embodiments form the set Pby simply eliminating from P all vectors that contain at least d 2 zeros. Consider for example the aforementioned scenario where each element of each column vector contains four bits. Each column vector wherein all four bits of at least d 2 elements are zero is eliminated from P and the result is P.

At if the iteration index i k 1 then all columns of A have been populated and the matrix is complete. Otherwise another vector is selected from Pat . The test shown at is applied to the selected vector. The test is whether the selected vector is of the form

Thereafter a test is performed at to determine whether Pcontains enough vectors to populate the currently unpopulated columns of A. In the test P denotes the number of vectors in P and q is the size of the symbol alphabet. For each vector x that is yet to be concatenated to A at at least the q 1 non zero multiples of that vector will be eliminated at so the maximum number of vectors still available for concatenation to A is bounded by P q 1. There are at this point i 1 columns already populated in A with k i 1 columns remaining to be populated. The test determines whether the maximum number of available vectors is less than the number of unpopulated columns of A. If not then the iteration index is updated at and operations return to to begin the next iteration. Otherwise the test determines that there are not enough vectors in Pto complete the construction of A so the current attempt to generate A fails.

The operations shown in constitute only expository examples of how Pmay be formed from P. Various embodiments use various techniques. For example in some embodiments the technique used to form Pfrom Pis tailored to the size of the code and the data processing resources available. Some embodiments use a hash table to represent all qavailable vectors with each vector indexing an entry in the table. The entries are in binary format and are all initially set to the same binary value e.g. 1 . Elimination of a vector is represented by setting the corresponding entry to the other binary value e.g. 0 . For a given vector x all vectors having the form specified at in are computed and these computed vectors are used to index the hash table in parallel and write Os to the corresponding entries thereby forming P. The next vector x is selected from only those vectors whose corresponding table entry is 1.

In contrast to the above described techniques of the present work conventional approaches use a random code search when attempting to find an n k d code that is not a member of the currently known block codes or their modifications. The smaller the ratio of the total number of check matrices for n k d codes to the total number of k r matrices the less likely is the success of a random search technique. The present work provides a more systematic search for check matrices and is significantly more efficient than a random search in finding n k d codes if these codes are rare. Although the time needed to verify the d 1 linear independence of a column increases with successive iterations in the present work the number of acceptable columns decreases with successive iterations. This makes it progressively more likely to choose columns that are acceptable as the time needed to verify column acceptability progressively increases. Also because candidate columns may be identified as not acceptable while the matrix is being built the present work determines relatively early if a matrix under construction will not work.

As an example a random brute force search using fifteen 2.27 GHz 8 GByte processors for two weeks has failed to produce a linear 36 32 4 code. Relaxing the check symbol requirement to r 5 or the distance requirement to d 3 has been found to enable random brute force searching to produce the respectively associated 37 32 4 and 36 32 3 codes in about an hour. In contrast the techniques of the present work have produced a linear 36 32 4 code in under a minute using a single processor. A linear 68 64 4 code has also been produced according to the present work.

In some embodiments the syndrome decoder in implements a simple decoding technique for linear SECDED codes that allows for a parallel implementation. The decoding technique which may be generalized for use with larger distance codes is based on the fact that the syndrome resulting from also designated as s is a linear combination of columns of H. That is if h i i 1 . . . n are the columns of H where n k r and e e . . . e is the error vector then

Some embodiments achieve improved computational efficiency by assuming that H is in standard form H AI and that errors in the parity check symbols will not be corrected. As shown at in decoding under these assumptions is performed as follows 

Given s h GF q evaluating whether the condition h i s is satisfied is equivalent to satisfying the following conditions where i and j are symbol indices of the syndrome s and the column h i h 0s 0 j and 0 require For purposes of evaluating the foregoing conditions the multiplicative inverses of the possible non zero symbol values in H e.g. h and h may be pre computed. For example in the aforementioned case of 4 bit symbols each symbol value of each column may be represented as a single hexadecimal digit. The respective multiplicative inverses for the hexadecimal digits 1 2 . . . E F are 1 9 E D B 7 6 F 2 C 5 A 4 3 8.

Applying the conditions defined above to the symbols of an example column vector h 4 F 0 3 in a four row r 4 H matrix it can be seen that the h i s condition is satisfied for a given syndrome s if s 0 and 4 8 3 where s s sand sare the syndrome symbols. In some embodiments pre computed multiplicative inverses are stored and the syndrome decoder of multiplies the appropriate multiplicative inverse values by the appropriate syndrome symbols in parallel to facilitate determining e.g. at in in whether the h i s condition is satisfied. diagrammatically illustrates a corresponding portion of the syndrome decoder according to example embodiments of the present work. The appropriate multiplicative inverses are provided in parallel from storage based on the column content of the H matrix. Parallel multiplication logic multiplies the appropriate stored inverses and the appropriate syndrome symbols in parallel producing parallel results that are compared at to determine whether the are equal in support of the determination as to whether the h i s condition is satisfied.

For a systematic k r k d linear code with parity check matrix in standard form H I and input x x. . . x the check symbol generator computes the parity check symbols as follows

Some embodiments produce a check matrix Hhaving r rows and k r columns and then use that matrix to produce another check matrix tilde over H having r rows and k r columns. The columns of tilde over H have the same degree of linear independence as the columns of H i.e. both matrices have the same code distance . It may be assumed without loss of generality that the matrix His in standard form. The matrix tilde over H is also in standard form. It is known in the art to form a matrix such as tilde over H by selecting its k r columns from the k r columns of a matrix such as H. However example embodiments of the present work suitably process the columns of Hto permit the columns of tilde over H to be selected such that tilde over H has the lowest weight among all k r sub matrices that could be chosen from Hand have the same code distance as H.

As shown in in some embodiments the first k columns of tilde over H are determined based on Has follows 

In some embodiments the matrix H used in the processing of is produced by an A matrix generator see in that is similar to the A matrix generator of and generates the A matrix columns in the manner described relative to . However the A matrix generator produces A with kcolumns and implements a corresponding concatenation buffer of width k not explicitly shown in thereby permitting formation of the desired matrix H. As also shown in data processing logic produces tilde over H from H for example in the manner described relative to . The matrix tilde over H may then be used by the check symbol generator and syndrome decoder of .

Although example embodiments of the present work are described above in detail this does not limit the scope of the present work which can be practiced in a variety of embodiments.

